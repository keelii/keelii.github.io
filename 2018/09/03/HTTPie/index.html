<!DOCTYPE html>   
<html class="no-js" lang="zh-CN">
<head>
    <meta charset="utf-8">
    <title>HTTPie 官方文档中文翻译版</title>
    <meta name="description" content="__ you don&#39;t know yet">
    <meta name="keywords" content="">
    <meta name="author" content="keelii">
    <meta name="generator" content="Hugo 0.49.2" />

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    

    <link rel="canonical" href="https://keelii.com/2018/09/03/HTTPie/">
    <link href="https://keelii.com/favicon.ico" rel="icon">
    <link href="https://keelii.com/atom.xml" rel="alternate" type="application/rss+xml" title="Something">

    
    <link href="/stylesheets/screen.css" rel="stylesheet" type="text/css">
    <link href="//cdn.bootcss.com/highlight.js/9.7.0/styles/solarized-dark.min.css" rel="stylesheet" type="text/css">

    
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-79264835-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-79264835-1');
    </script>

</head>
<body>

<header role="banner">
    <hgroup>
        <h1><a href="https://keelii.com/">Something</a></h1>
        <h2>__ you don&#39;t know yet</h2>
    </hgroup>
</header>


<nav role="navigation">
    <ul class="subscription" data-subscription="rss">
        <li>
            
        </li>
    </ul>

    <form action="https://www.google.com/search" method="get">
        <fieldset role="search">
            <input type="hidden" name="sitesearch" value="https://keelii.com/">
            <input class="search" type="text" name="q" results="0" placeholder="Search" />
        </fieldset>
    </form>

    <ul class="main-navigation">
        
        <li><a href="https://keelii.com/">Blog</a> </li>
        
        <li><a href="https://keelii.com/archives">Archives</a> </li>
        
        <li><a href="https://keelii.com/about">About</a> </li>
        
    </ul>
</nav>


<div id="main">
    <div id="content">
        <div style="padding-top:0;">
            <article class="hentry" role="article">
                <header>
                    <h1 class="entry-title">HTTPie 官方文档中文翻译版</h1>
                    <p class="meta">
                        <time class="entry-date" datetime="2018-09-03 19:10:27">
                            <span class="date">2018-9-3</span>
                            <span class="time">19:10 PM</span>
                        </time>
                    </p>
                </header>

                <div class="entry-content">

<p>HTTPie 是一个命令行 HTTP 客户端。目标是让 CLI 与 Web services 的交互尽可能的更友
好。它提供了一个简单的 <code>http</code> 命令，可以让我们用简单自然的表述发送任意 HTTP 请求
，并且可以输出带代码高亮的结果。HTTPie 可以使用在测试、调试以及通用的与 HTTP 交
互场景</p>

<h2 id="主要功能特性">主要功能特性</h2>

<ul>
<li>自然而且简单的命令语句</li>
<li>格式化且高亮显示输出内容</li>
<li>内置 JSON 支持</li>
<li>表单和文件上传</li>
<li>支持 HTTPS, 代理和授权验证</li>
<li>支持多样化的请求数据格式</li>
<li>自定义 headers 头</li>
<li>持久 sessions 存储</li>
<li>类似 <code>wget</code> 的下载模式</li>
<li>兼容 Python 2.6, 2.7 以及 3.x</li>
<li>支持 Linux, macOS 和 Windows 操作系统</li>
<li>插件支持</li>
<li>详细的文档说明</li>
<li>完善的测试用例覆盖</li>
</ul>

<h2 id="安装">安装</h2>

<h3 id="macos">macOS</h3>

<p>在 macOS 系统中推荐使用 <a href="brew.sh">Homebrew</a> 来安装:</p>

<pre><code class="language-bash">brew install httpie
</code></pre>

<p>当然 MacPorts 也是可以的:</p>

<pre><code class="language-bash">port install httpie
</code></pre>

<h3 id="linux">Linux</h3>

<p>大多数的 Linux 构建版都提供了包管理组件，可以使用他们来安装：</p>

<pre><code class="language-bash"># 基于 Debian Linux 的构建版，比如 Ubuntu
apt-get install httpie

# 基于 RPM Linux 的构建版
yum install httpie

# Arch Linux 系统
pacman -S httpie
</code></pre>

<h3 id="windows-及其它">Windows 及其它</h3>

<p>使用 <a href="https://pip.pypa.io/en/latest/installing/">pip</a> 是一种通用的（可以使用在
Windows, MacOS, Linux &hellip;）并且提供最新版本安装包的安装方法</p>

<pre><code class="language-bash"># 确保使用了最新版本的 pip 和 setuptools:
pip install --upgrade pip setuptools

pip install --upgrade httpie
</code></pre>

<h3 id="开发版">开发版</h3>

<p>最新的开发版本可以直接通过 github 安装</p>

<pre><code class="language-bash"># Homebrew
brew install httpie --HEAD

# pip
pip install --upgrade https://github.com/jkbrzt/httpie/archive/master.tar.gz
</code></pre>

<h3 id="python-版本">Python 版本</h3>

<p>虽然兼容 Python 2.6, 2.7 版本的，但是如果可以的话还是建议使用最新版的 Python 3.x
来安装 HTTPie。这将保证一些比较新的功能（比如：<a href="#服务器名称指示
-sni-server-name-indication">SNI</a> ）可以开箱即用。Python 3 在 Homebrew 0.9.4 版本以上
已经成为了默认的 Python 版本。可以使用 <code>http --debug</code> 来查看 HTTPie 使用的
python 版本</p>

<h2 id="使用">使用</h2>

<p>最简单的使用：</p>

<pre><code class="language-bash">http httpie.org
</code></pre>

<p>使用语法：</p>

<pre><code class="language-bash">http [flags] [METHOD] URL [ITEM [ITEM]]
</code></pre>

<p>也可以使用 <code>http --help</code> 来查看更多使用方法：</p>

<h3 id="例子">例子</h3>

<p>自定义 HTTP 方法，HTTP 头和 JSON 数据：</p>

<pre><code class="language-bash">http PUT example.org X-API-Token:123 name=John
</code></pre>

<p>表单提交：</p>

<pre><code class="language-bash">http -f POST example.org hello=World
</code></pre>

<p>使用一个输出参数 <code>-v</code> 来查看请求信息（默认不显示请求信息）：</p>

<pre><code class="language-bash">http -v example.org
</code></pre>

<p>使用 <a href="http://developer.github.com/v3/issues/comments/#create-a-comment">Github
API</a> 向 issue
发送一条评论（需要授权验证参数）：</p>

<pre><code class="language-bash">http -a USERNAME POST https://api.github.com/repos/jkbrzt/httpie/issues/83/comments body='HTTPie is awesome! :heart:'
</code></pre>

<p>通过命令行的输入重定向上传文件：</p>

<pre><code class="language-bash">http example.org &lt; file.json
</code></pre>

<p>使用 <code>wget</code> 风格下载文件：</p>

<pre><code class="language-bash">http --download example.org/file
</code></pre>

<p>使用命令会话对同一 host 进行请求之间的持久通信：</p>

<pre><code class="language-bash">http --session=logged-in -a username:password httpbin.org/get API-Key:123
http --session=logged-in httpbin.org/headers
</code></pre>

<p>自定义请求 host 头：</p>

<pre><code class="language-bash">http localhost:8000 Host:example.com
</code></pre>

<h2 id="http-方法">HTTP 方法</h2>

<p>HTTP 方法的名称在 URL 参数之前：</p>

<pre><code class="language-bash">http DELETE example.org/todos/7
</code></pre>

<p>这看起来就像是原生的 HTTP 请求发送的文本一样：</p>

<pre><code class="language-http">DELETE /todos/7 HTTP/1.1
</code></pre>

<h2 id="请求-url">请求 URL</h2>

<p>HTTPie 唯一必传的一个参数是请求 URL，默认的方案不出意料的是 <code>http://</code>，可以在请
求的时候缺省 - <code>http example.org</code> 是没问题的</p>

<h3 id="querystring-参数">Querystring 参数</h3>

<p>如果需要在命令行手动构建 URLs，你可能会觉得使用 <code>param==value</code> 添加参数的方式是
比较方便的，这样你就不需要担心命令行中转义链接字符串 <code>&amp;</code> 的问题，当然参数中的特
殊字符也将被自动转义（除非已经转义过）。用下面的命令搜索 <code>HTTPie logo</code> 可以在
google 图片上结果：</p>

<pre><code class="language-bash">http www.google.com search=='HTTPie logo' tbm==isch

GET /?search=HTTPie+logo&amp;tbm=isch HTTP/1.1
</code></pre>

<h3 id="localhost-的-url-缩写">localhost 的 URL 缩写</h3>

<p>另外，类似 <code>curl</code> 的 localhost 缩写也是支持的。这表示你可以使用 <code>:3000</code> 来代替
<code>http://localhost:3000</code>, 如果不传入端口号，<code>80</code> 将会默认被使用</p>

<pre><code class="language-bash">http :/foo

GET /foo HTTP/1.1
Host: localhost
</code></pre>

<pre><code class="language-bash">http :3000/bar

GET /bar HTTP/1.1
Host: localhost:3000
</code></pre>

<pre><code class="language-bash">http :

GET / HTTP/1.1
Host: localhost
</code></pre>

<h3 id="自定义默认的方案">自定义默认的方案</h3>

<p>你可以使用 <code>--default-scheme &lt;URL_SCHEME&gt;</code> 参数来指定非 HTTP 的其它协义</p>

<pre><code class="language-bash">alias https='http --default-scheme=https'
</code></pre>

<h2 id="请求项">请求项</h2>

<p>不同的请求项类型提供一种便捷的方法来指定 HTTP 头、简单的 JSON
、表单数据、文件、URL 参数</p>

<p>URL 参数后面紧随的是 <code>键/值</code> 对参数都会被拼装成请求发送。不同类型的 <code>键/值</code> 对分
割符号分别是：<code>:</code>, <code>=</code>, <code>:=</code>, <code>@</code>, <code>=@</code>, <code>:=@</code>。用 <code>@</code> 分割的参数表示文件路径</p>

<table>
<thead>
<tr>
<th align="right">项类型(item type)</th>
<th align="left">描述(Description)</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">HTTP 头参数<br/> <code>Name:Value</code></td>
<td align="left">任意的 HTTP 头，比如：<code>X-API-Token:123</code></td>
</tr>

<tr>
<td align="right">URL 参数<br/> <code>name==value</code></td>
<td align="left">通过分割符 <code>==</code> 表示一个查询字符串的 <code>键/值</code> 对</td>
</tr>

<tr>
<td align="right">数据域<br/> <code>field=value</code>,<br/> <code>field=@file.txt</code></td>
<td align="left">请求一个默认会被序列化成 JSON 的数据域，或者表单类型 form-encoded<code>(--form, -f)</code></td>
</tr>

<tr>
<td align="right">纯 JSON 域<br/> <code>field:=json</code>,<br/> <code>field:=@file.json</code></td>
<td align="left">当需要指定一个或者多数域参数类型 <code>boolean</code>, <code>number</code> .. 时非常有用， 比如：meals:=&rsquo;[&ldquo;ham&rdquo;,&ldquo;spam&rdquo;]&rsquo; or pies:=<a href="注意引号">1,2,3</a>.</td>
</tr>

<tr>
<td align="right">Form 表单文件域</td>
<td align="left">仅当传入参数 <code>--form, -f</code> 时有效，比如 <code>screenshot@~/Pictures/img.png</code> 文件内容将会被序列化成 <code>multipart/form-data</code> 发送</td>
</tr>
</tbody>
</table>

<p>数据域不是唯一的指定请求数据的方式，<a href="#重定向输入">重定向输入</a>也可以</p>

<h3 id="字符转义规则">字符转义规则</h3>

<p>可以使用 <code>\</code> 来转义不应该被用于分割符的情况。比如 <code>foo\==bar</code> 会被转义成一个数据
键值对（foo= 和 bar）而不是 URL 参数</p>

<p>通常情况需要使用引号包围值，比如 <code>foo='bar baz'</code></p>

<p>如果有一个域的名字或者 header 以减号开头，你需要把这些参数放在一个特殊符号 <code>--</code>
<strong>后面</strong> ，这样做是为了和 <code>--arguments</code> 区分开</p>

<pre><code class="language-bash">http httpbin.org/post  --  -name-starting-with-dash=foo -Unusual-Header:bar

POST /post HTTP/1.1
-Unusual-Header: bar
Content-Type: application/json

{
    &quot;-name-starting-with-dash&quot;: &quot;value&quot;
}
</code></pre>

<h2 id="json">JSON</h2>

<p>JSON 是现代 web services 通用规范，HTTPie 也默认遵循了它的 <strong>不严格的数据类型</strong></p>

<pre><code class="language-bash">http PUT example.org name=John email=john@example.org

PUT / HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Content-Type: application/json
Host: example.org

{
    &quot;name&quot;: &quot;John&quot;,
    &quot;email&quot;: &quot;john@example.org&quot;
}
</code></pre>

<h3 id="默认行为">默认行为</h3>

<p>如果你的命令包含了一些请求项数据，它们将默认被序列化成 JSON 对象。HTTPie 会默认
自动添加下面两个 header 头，当然这两个头也可以重新传入</p>

<table>
<thead>
<tr>
<th align="right">Content-Type</th>
<th align="left"><code>application/json</code></th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">Accept</td>
<td align="left"><code>application/json, */*</code></td>
</tr>
</tbody>
</table>

<h3 id="明确的-json">明确的 JSON</h3>

<p>你可以使用命令行参数 <code>--json, -j</code> 明确地设置 <code>Accept</code> 为 <code>application/json</code> 而无
需在意发送的数据是什么（这是个快捷方式，也可以使用普通的 header 注解：<code>http url
Accept:'application/json, */*'</code>），另外，HTTPie 会试着检测 JSON 响应，即使
<code>Content-Type</code> 是不正常的 <code>text/plain</code> 或者未知类型</p>

<h3 id="非字符串的-json-域">非字符串的 JSON 域</h3>

<p>非字符串类型的 JSON 域使用 <code>:=</code> 分割，这可以允许你嵌入原生纯 JSON 到结果对象，文
本和原生的纯 JSNO 文件也可以使用 <code>=@</code> 和 <code>:=G</code> 嵌入</p>

<pre><code class="language-bash">http PUT api.example.com/person/1 \
    name=John \
    age:=29 married:=false hobbies:='[&quot;http&quot;, &quot;pies&quot;]' \  # Raw JSON
    description=@about-john.txt \   # Embed text file
    bookmarks:=@bookmarks.json      # Embed JSON file

PUT /person/1 HTTP/1.1
Accept: application/json, */*
Content-Type: application/json
Host: api.example.com

{
    &quot;age&quot;: 29,
    &quot;hobbies&quot;: [
        &quot;http&quot;,
        &quot;pies&quot;
    ],
    &quot;description&quot;: &quot;John is a nice guy who likes pies.&quot;,
    &quot;married&quot;: false,
    &quot;name&quot;: &quot;John&quot;,
    &quot;bookmarks&quot;: {
        &quot;HTTPie&quot;: &quot;http://httpie.org&quot;,
    }
}
</code></pre>

<p>不过请注意，当发送复杂数据的时候，这个例子使用的语法会显得很笨重。在这种情况下 <a href="#重定向输入">
重定向输入</a> 将会更合适：</p>

<pre><code class="language-bash">http POST api.example.com/person/1 &lt; person.json
</code></pre>

<h2 id="表单">表单</h2>

<p>提交表单和发送 JSON 请求很相似，通常情况下唯一的不同是添加额外的 <code>--form, -f</code> 参
数，这将确保数据域和 <code>Content-Type</code> 被设置成 <code>application/x-www-form-urlencoded;
charset=utf-8</code></p>

<h3 id="普通的表单">普通的表单</h3>

<pre><code class="language-bash">http --form POST api.example.org/person/1 name='John Smith'

POST /person/1 HTTP/1.1
Content-Type: application/x-www-form-urlencoded; charset=utf-8

name=John+Smith
</code></pre>

<h3 id="文件上传表单">文件上传表单</h3>

<p>如果有一个文件域，序列化方式和 content type 会是 <code>multipart/form-data</code>：</p>

<pre><code class="language-bash">http -f POST example.com/jobs name='John Smith' cv@~/Documents/cv.pdf
</code></pre>

<p>上面的请求和下面的 HTML 表单发送请求是一样的：</p>

<pre><code class="language-html">&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;http://example.com/jobs&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;
    &lt;input type=&quot;file&quot; name=&quot;cv&quot; /&gt;
&lt;/form&gt;
</code></pre>

<p>注意 <code>@</code> 用来模拟文件上传域，而 <code>=@</code>
是把文件内容以文本的方式嵌入到数据域的值里面</p>

<h2 id="http-头">HTTP 头</h2>

<p>可以使用 <code>Header:Value</code> 注解的形式来添加自定义头信息</p>

<pre><code class="language-bash">http example.org  User-Agent:Bacon/1.0  'Cookie:valued-visitor=yes;foo=bar'  \
    X-Foo:Bar  Referer:http://httpie.org/

GET / HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Cookie: valued-visitor=yes;foo=bar
Host: example.org
Referer: http://httpie.org/
User-Agent: Bacon/1.0
X-Foo: Bar
</code></pre>

<h3 id="默认的请求头">默认的请求头</h3>

<p>有几个默认的请求头是 HTTPie 设置的</p>

<pre><code class="language-http">GET / HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
User-Agent: HTTPie/&lt;version&gt;
Host: &lt;taken-from-URL&gt;
</code></pre>

<h3 id="空头和重新设置默认头">空头和重新设置默认头</h3>

<p>可以使用 <code>Header:</code> 来取消上面的几个默认头信息</p>

<pre><code class="language-bash">http httpbin.org/headers Accept: User-Agent:
</code></pre>

<p>请求中的 <code>Accept</code> 和 <code>User-Agent</code> 头都会被移除</p>

<p>使用 <code>Header;</code> 表示添加一个为空的头信息，注意须使用引号</p>

<pre><code class="language-bash">http -v httpbin.org/headers 'Host;'

GET /headers HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host:
User-Agent: HTTPie/0.9.9
...
</code></pre>

<h2 id="授权验证">授权验证</h2>

<p>目前支持的验证方案有基础和摘要两种（查看更多 <a href="#授权插件">授权插件</a>），有两种标识
来控制验证：</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>--auth, -a</code></td>
<td>把 <code>用户名:密码</code> 做为键值对参数传入，如果只指定用户名可以使用 <code>-a 用户名</code>，密码在接下来的提示符中输入，空密码使用 <code>username:</code>，<code>username:password@hostname</code> 格式的 URL 语法也是支持的，证书通过 <code>-a</code> 参数传入且具有更高的优先级</td>
</tr>

<tr>
<td><code>--auth-type, -A</code></td>
<td>指定指定身份验证机制。<code>basic</code>(默认) 和 <code>digest</code> 两种</td>
</tr>
</tbody>
</table>

<h3 id="basic-授权">Basic 授权</h3>

<pre><code class="language-bash">http -a username:password example.org
</code></pre>

<h3 id="digest-授权">Digest 授权</h3>

<pre><code class="language-bash">http -A digest -a username:password example.org
</code></pre>

<h3 id="密码提示">密码提示</h3>

<pre><code class="language-bash">http -a username example.org&lt;Paste&gt;
</code></pre>

<h3 id="netrc">.netrc</h3>

<p>从你的 <code>~/.netrc</code> 文件授权也可以</p>

<pre><code class="language-bash">cat ~/.netrc
machine httpbin.org
login httpie
password test

http httpbin.org/basic-auth/httpie/test
HTTP/1.1 200 OK
[...]
</code></pre>

<h3 id="授权插件">授权插件</h3>

<p>授权机制可以使用安装插件的方式来实现，可以在 Python Package 上面找到更多相关插件</p>

<ul>
<li><a href="https://github.com/pd/httpie-api-auth">httpie-api-auth</a>: ApiAuth</li>
<li><a href="https://github.com/httpie/httpie-aws-auth">httpie-aws-auth</a>: AWS / Amazon S3</li>
<li><a href="https://github.com/akamai-open/httpie-edgegrid">httpie-edgegrid</a>: EdgeGrid</li>
<li><a href="https://github.com/guardian/httpie-hmac-auth">httpie-hmac-auth</a>: HMAC</li>
<li><a href="https://github.com/teracyhq/httpie-jwt-auth">httpie-jwt-auth</a>: JWTAuth (JSON Web Tokens)</li>
<li><a href="https://github.com/ndzou/httpie-negotiate">httpie-negotiate</a>: SPNEGO (GSS Negotiate)</li>
<li><a href="https://github.com/httpie/httpie-ntlm">httpie-ntlm</a>: NTLM (NT LAN Manager)</li>
<li><a href="https://github.com/httpie/httpie-oauth">httpie-oauth</a>: OAuth</li>
<li><a href="https://github.com/mozilla-services/requests-hawk">requests-hawk</a>: Hawk</li>
</ul>

<h2 id="http-重定向">HTTP 重定向</h2>

<p>HTTP 重定向默认不会自动跳转，请求发出后命令行只会显示 <strong>第一次</strong> 收到的响应</p>

<pre><code class="language-bash">http httpbin.org/redirect/3
</code></pre>

<h3 id="按-header-头中的-location-字段值跳转">按 header 头中的 location 字段值跳转</h3>

<p>指定 <code>--follow, -F</code> 参数让 HTTPie 自动跟随 <code>30x</code> 响应头中的 <code>location</code>
字段值进行跳转，并且显示最终的响应内容</p>

<pre><code class="language-bash">http --follow httpbin.org/redirect/3
</code></pre>

<h3 id="显示中间的跳转响应">显示中间的跳转响应</h3>

<p>如果你也想看到更多的跳转信息，可以指定 <code>--all</code> 参数</p>

<pre><code class="language-bash">http --follow --all httpbin.org/redirect/3
</code></pre>

<h3 id="限制重定向最大次数">限制重定向最大次数</h3>

<p>改变默认最大 <code>30</code> 次重定向值可以使用 <code>--max-redirects=&lt;limit&gt;</code> 参数</p>

<pre><code class="language-bash">http --follow --all --max-redirects=5 httpbin.org/redirect/3
</code></pre>

<h2 id="代理">代理</h2>

<p>你可以通过添加参数 <code>--proxy</code> 来指定各自协义（为了防止跨协义的重定向，协义被包含
在了参数值中）的代理服务器</p>

<pre><code class="language-bash">http --proxy=http:http://10.10.1.10:3128 --proxy=https:https://10.10.1.10:1080 example.org
</code></pre>

<p>添加 basic 授权</p>

<pre><code class="language-bash">http --proxy=http:http://user:pass@10.10.1.10:3128 example.org
</code></pre>

<h3 id="环境变量">环境变量</h3>

<p>也可以通过设置 <code>HTTP_PROXY</code> 和 <code>HTTPS_PROXY</code> 环境变量来配置代理，底层的 request
库也将使用这些代理配置，如果你想指定某些 host 不使用代理，可以通过添加
<code>NO_PROXY</code> 参数来实现</p>

<p>在你的 <code>~/.bash_profile</code> 文件中（zsh 则在 <code>~/.zshrc</code> 中）</p>

<pre><code class="language-bash">export HTTP_PROXY=http://10.10.1.10:3128
export HTTPS_PROXY=https://10.10.1.10:1080
export NO_PROXY=localhost,example.com
</code></pre>

<h3 id="socks">Socks</h3>

<p>要启用 socks 代理支持请使用 pip 安装 <code>requests[socks]</code> 库</p>

<pre><code class="language-bash">pip install -U requests[socks]
</code></pre>

<p>用法与其它类型的代理相同：</p>

<pre><code class="language-bash">http --proxy=http:socks5://user:pass@host:port --proxy=https:socks5://user:pass@host:port example.org
</code></pre>

<h2 id="https">HTTPS</h2>

<h3 id="服务器-ssl-证书验证">服务器 SSL 证书验证</h3>

<p>使用参数 <code>--verify=no</code> 可以跳过主机 SSL 验证（默认：<code>yes</code>）</p>

<pre><code class="language-bash">http --verify=no https://example.org
</code></pre>

<h3 id="自定义-ca-包">自定义 CA 包</h3>

<p>使用 <code>--verify=&lt;CA_BUNDLE_PATH&gt;</code> 指定 CA 认证包路径</p>

<pre><code class="language-bash">http --cert=client.pem https://example.org
</code></pre>

<h3 id="客户端-ssl-证书">客户端 SSL 证书</h3>

<p>使用客户端 SSL 证书进行 SSL 通信，可以用 <code>--cert</code> 参数指定证书文件路径</p>

<pre><code class="language-bash">http --cert=client.pem https://example.org
</code></pre>

<p>如果证书中不包含私钥，可以通过 <code>--cert-key</code> 参数指定密钥文件路径</p>

<pre><code class="language-bash">http --cert=client.crt --cert-key=client.key https://example.org
</code></pre>

<h3 id="ssl-版本">SSL 版本</h3>

<p>参数 <code>--ssl=&lt;PROTOCOL&gt;</code> 用来指定你想使用的 SSL 协义版本，默认是 <code>SSL v2.3</code>。这将
会协商服务端和你安装的 OpenSSL 支持的最高 SSL 协议版本。可用的版本有： <code>ssl2.3</code>,
<code>ssl3</code>, <code>tls1</code>, <code>tls1.1</code>, <code>tls1.2</code> （实际上可用的协义可能有很多种，这由你安装
的 OpenSSL 决定）</p>

<pre><code class="language-bash"># 指定容易受到攻击的 SSL v3 协义与老服务器进行通信
http --ssl=ssl3 https://vulnerable.example.org
</code></pre>

<h3 id="服务器名称指示-sni-server-name-indication">服务器名称指示 SNI(Server Name Indication)</h3>

<p>如果你的 HTTPie 版本（可以使用 <code>http --debug</code> 查看版本）小于 2.7.9，又需要使用
SNI 与服务器会话。那么你需要安装额外的依赖</p>

<pre><code class="language-bash">pip install --upgrade requests[security]
</code></pre>

<p>使用下面的命令测试 SNI 支持</p>

<pre><code class="language-bash">http https://sni.velox.ch
</code></pre>

<h2 id="输出参数">输出参数</h2>

<p>HTTPie 默认只输出最终响应信息并且打印（header, body同样），你可以通过下面一些参
数控制打印内容：</p>

<table>
<thead>
<tr>
<th align="right">命令行参数</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">&ndash;headers, -h</td>
<td align="left">仅打印响应头</td>
</tr>

<tr>
<td align="right">&ndash;body, -b</td>
<td align="left">仅打印响应体</td>
</tr>

<tr>
<td align="right">&ndash;verbose, -v</td>
<td align="left">打印所有的 HTTP 请求来回内容，这将默认开启 <code>--all</code> 参数</td>
</tr>
</tbody>
</table>

<p>使用 <code>--verbose</code> 参数来调试请求或生成文档时是非常有用的</p>

<pre><code class="language-bash">http --verbose PUT httpbin.org/put hello=world
</code></pre>

<pre><code class="language-http">PUT /put HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Content-Type: application/json
Host: httpbin.org
User-Agent: HTTPie/0.2.7dev

{
    &quot;hello&quot;: &quot;world&quot;
}


HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 477
Content-Type: application/json
Date: Sun, 05 Aug 2012 00:25:23 GMT
Server: gunicorn/0.13.4

{
    […]
}
</code></pre>

<h3 id="哪部分的-http-请求内容应该打印出来">哪部分的 HTTP 请求内容应该打印出来</h3>

<p>所有的 HTTP 输出选项都属于更强大的 <code>--print, -p</code> 参数的快捷方式。<code>--print, -p</code>
接受一个字符串，字符串的每个字母都表示下面的 HTTP 某一部分</p>

<table>
<thead>
<tr>
<th align="right">字符</th>
<th align="left">代表</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right"><code>H</code></td>
<td align="left">请求头</td>
</tr>

<tr>
<td align="right"><code>B</code></td>
<td align="left">请求体</td>
</tr>

<tr>
<td align="right"><code>h</code></td>
<td align="left">响应头</td>
</tr>

<tr>
<td align="right"><code>b</code></td>
<td align="left">响应体</td>
</tr>
</tbody>
</table>

<p>打印请求头和响应头：</p>

<pre><code class="language-bash">http --print=Hh PUT httpbin.org/put hello=world
</code></pre>

<h3 id="查看中间的请求-响应">查看中间的请求/响应</h3>

<p>使用 <code>--all</code> 参数可以查看 HTTP 通信中的所有信息，中间的 HTTP 通信包括跟随重定向
（使用参数<code>--follow</code>）和使用 HTTP 摘要授权时第一次未授权的请求（使用参数
<code>--auth=diggest</code>）</p>

<pre><code class="language-bash"># 包括最终响应之前的所有响应信息
http --all --follow httpbin.org/redirect/3
</code></pre>

<p>中间请求/响应默认会使用 <code>--print, -p</code> 参数指定的值格式化，可以使用
<code>--history-print, -P</code> 指定， 参数和 <code>--print, -p</code> 是一样的。但是这只实用于 <strong>中
间请求</strong></p>

<pre><code class="language-bash"># 中间请求/响应信息使用 H 格式化，最终请求/响应信息使用 Hh 格式化:
http -A digest -a foo:bar --all -p Hh -P H httpbin.org/digest-auth/auth/foo/bar
</code></pre>

<h3 id="条件化的-body-内容下载">条件化的 body 内容下载</h3>

<p>做为一个优化项，响应体在仅作为输出一部分时才会被下载，这和 <code>HEAD</code> 类型的请求类似
（除了 HEAD 可以使用在任何 HTTP 请求中）</p>

<p>比如有一个 API 更新后会返回整个资源，但是你只对更新后响应头中的状态码感兴趣：</p>

<pre><code class="language-bash">http --headers PATCH example.org/Really-Huge-Resource name='New Name'
</code></pre>

<p>由于我们在上面设置了只打印头信息，当响应头接收完成的时候服务器连接就会被关闭，
带宽和时间不会浪费在下载响应体，你可以不必在意。响应头总是会被下载的无论它是不是
输出部分</p>

<h2 id="重定向输入">重定向输入</h2>

<p>直接从 <code>stdin</code> （标准输入）管道传入请求数据是大部分人认为比较好的方法。 这些数据
被缓冲而且不需要更多的操作就可以做为请求体被使用，使用管道有下面几个好用的方法：</p>

<p>从一个文件重新定向</p>

<pre><code class="language-bash">http PUT example.com/person/1 X-API-Token:123 &lt; person.json
</code></pre>

<p>或者从其它程序的输出</p>

<pre><code class="language-bash">grep '401 Unauthorized' /var/log/httpd/error_log | http POST example.org/intruders
</code></pre>

<p>当然也可以使用 <code>echo</code> 命令来传简单数据</p>

<pre><code class="language-bash">echo '{&quot;name&quot;: &quot;John&quot;}' | http PATCH example.com/person/1 X-API-Token:123
</code></pre>

<p>甚至可以使用 web services</p>

<pre><code class="language-bash">http GET https://api.github.com/repos/jkbrzt/httpie | http POST httpbin.org/post
</code></pre>

<p>也可以使用 <code>cat</code> 命令来输入多行文本</p>

<pre><code class="language-bash">cat | http POST example.com
&lt;paste&gt;
^D
</code></pre>

<pre><code class="language-bash">cat | http POST example.com/todos Content-Type:text/plain
- buy milk
- call parents
^D
</code></pre>

<p>在 macOS 中可以使用 <code>pbpaste</code> 命令把剪贴板中的内容做为数据发送</p>

<pre><code class="language-bash">pbpaste | http PUT example.com
</code></pre>

<p>通过 <code>stdin</code> 传递数据的方式 <strong>不能</strong> 和指定数据域的方式混合使用</p>

<pre><code class="language-bash">echo 'data' | http POST example.org more=data   # 不可以
</code></pre>

<h3 id="从一个文件中取请求数据">从一个文件中取请求数据</h3>

<p>指定文件路径（<code>@/path/to/file</code>）方式可以替代上面使用 <code>stdin</code> 的方式</p>

<p>这个方法有个优点，<code>Content-Type</code> 可以根据提供的文件扩展名自动设置成对应的。比如
下面的请求会被设置头 <code>Content-Type: application/xml</code></p>

<pre><code class="language-bash">http PUT httpbin.org/put @/data/file.xml
</code></pre>

<h2 id="命令行输出">命令行输出</h2>

<p>HTTPie 默认会做一些事情，目的是为了让命令行输出内容有更高的可读性</p>

<h3 id="颜色和格式化">颜色和格式化</h3>

<p>语法高亮会应用在 HTTP 请求的 headers 和 body 里面。如果你不喜欢默认的配色方案，
可以使用 <code>--style</code> 参数自定义（使用<code>http --help</code>命令查看更多选项）</p>

<p>还有下面几个格式化规则会被使用：</p>

<ul>
<li>HTTP 头会按名称排序</li>
<li>JSON 数据会有缩进，并且按 key 名排序，unicode 序列会被转换成实际字符</li>
</ul>

<p>下面这些参数可以用在处理输出结果中：</p>

<table>
<thead>
<tr>
<th align="left">命令行参数</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">&ndash;pretty=all</td>
<td align="left">应用颜色和格式化，默认</td>
</tr>

<tr>
<td align="left">&ndash;pretty=colors</td>
<td align="left">仅应用颜色</td>
</tr>

<tr>
<td align="left">&ndash;pretty=format</td>
<td align="left">仅应用格式化</td>
</tr>

<tr>
<td align="left">&ndash;pretty=none</td>
<td align="left">不使用颜色和格式化，重定向时默认使用</td>
</tr>
</tbody>
</table>

<h3 id="二进制数据">二进制数据</h3>

<p>二进制数据在命令行中会被禁止，这会使处理响应返回的二进制数据变得更安全，重定向时
也禁止二进制数据，但是会被装饰输出。一旦当我们知道响应体是二进制数据时，连接会关
闭</p>

<pre><code class="language-bash">http example.org/Movie.mov
</code></pre>

<p>你几乎可以立即看见下面的提示：</p>

<pre><code class="language-bash">HTTP/1.1 200 OK
Accept-Ranges: bytes
Content-Encoding: gzip
Content-Type: video/quicktime
Transfer-Encoding: chunked

+-----------------------------------------+
| NOTE: binary data not shown in terminal |
+-----------------------------------------+
</code></pre>

<h2 id="重定向输出">重定向输出</h2>

<p>与命令行输出相比，重定向输出使用了不同的默认值，不同之处在于：</p>

<ul>
<li>格式化和种颜色默认不会使用（除非<code>--pretty</code>被指定）</li>
<li>只输出响应体（除非指定了输出参数）</li>
<li>二进制结果不会被禁止</li>
</ul>

<p>原因是为了把 HTTPie 的结果直接 piping 到其它程序，并且使下载文件不需要额外的参数
标识。多数情况下输出重定向时只有响应体有意义</p>

<p>下载一个文件：</p>

<pre><code class="language-bash">http example.org/Movie.mov &gt; Movie.mov
</code></pre>

<p>下载 Octocat 图片，使用 ImageMagick 修改大小，上传到其它地方：</p>

<pre><code class="language-bash">http octodex.github.com/images/original.jpg | convert - -resize 25% -  | http example.org/Octocats
</code></pre>

<p>强制使用格式化与颜色，在 <code>less</code> 的分页中显示请求和响应</p>

<pre><code class="language-bash">http --pretty=all --verbose example.org | less -R
</code></pre>

<p><code>-R</code> 标识告诉 <code>less</code> 命令解析 HTTPie 输出中的颜色序列</p>

<p>你可以使用下面的 bash 函数代码建立一个调用 HTTPie
分页格式化且高亮输出的快捷方式：</p>

<pre><code class="language-bash">function httpless {
    # `httpless example.org'
    http --pretty=all --print=hb &quot;$@&quot; | less -R;
}
</code></pre>

<h2 id="下载模式">下载模式</h2>

<p>HTTPie 具有下载模式，这和 <code>wget</code> 命令类似</p>

<p>使用 <code>--download, -d</code> 标识启用，响应头会打印到命令行，下载响应体的进度条也会显示</p>

<pre><code class="language-bash">http --download https://github.com/jkbrzt/httpie/archive/master.tar.gz
</code></pre>

<pre><code class="language-http">HTTP/1.1 200 OK
Content-Disposition: attachment; filename=httpie-master.tar.gz
Content-Length: 257336
Content-Type: application/x-gzip

Downloading 251.30 kB to &quot;httpie-master.tar.gz&quot;
Done. 251.30 kB in 2.73862s (91.76 kB/s)
</code></pre>

<h3 id="下载文件的文件名">下载文件的文件名</h3>

<p>如果没有指定参数 <code>--output, -o</code>，文件名将由 <code>Content-Disposition</code> 决定，或者通过
URL 及其 <code>Content-Type</code>，如果名字已占用，HTTPie 会添加唯一后缀</p>

<h3 id="下载的同时-piping">下载的同时 piping</h3>

<p>即使响应头和进度状态显示在命令行中，你仍然可以将响应重定向到其它的程序</p>

<pre><code class="language-bash">http -d https://github.com/jkbrzt/httpie/archive/master.tar.gz |  tar zxf -
</code></pre>

<h3 id="恢复下载">恢复下载</h3>

<p>如果指定 <code>--output, -o</code>，你可以 <code>--continue, -c</code>
恢复部分下载。不过仅当服务器支持 <code>Range</code> 请求而且响应返回 <code>206 Partial Content</code>
才可以，如果服务器不支持这个功能，那就只会下载整个文件</p>

<pre><code class="language-bash">http -dco file.zip example.org/file
</code></pre>

<h3 id="其它注意事项">其它注意事项</h3>

<ul>
<li><code>--download</code> 仅更改响应正文的处理方式</li>
<li>仍然可以使用自定义 header 头、使用 session 会话，<code>--verbose, -v</code> 等</li>
<li><code>--download</code> 意味着启用 <code>--follow</code></li>
<li>如果文件没有被完全下载完，HTTPie 将会返回错误状态码 <code>1</code> 并退出</li>
<li><code>Accept-Encoding</code> 不能和 <code>--download</code> 一起使用</li>
</ul>

<h2 id="流式响应">流式响应</h2>

<p>响应体会被以块的形式下载和打印，这使程序在不使用大量内存情况下进行流式传输和下载
，然而如果使用颜色和格式化参数，<strong>整个</strong> 响应体会被缓冲，然后立即处理</p>

<h3 id="禁用缓冲">禁用缓冲</h3>

<p>可以使用 <code>--stream, -S</code> 进行下面的操作：</p>

<ul>
<li>输出内容以更小的块更新，不需要任何缓冲，这使得 HTTPie 表现的像 <code>tail -f</code> 命令
一样</li>
<li>即使输出被美化，流也会启用：它将应用于响应的每一行并立即更新。这样就可以为持续
时间长的请求提供一个漂亮的输出，例如一个 Twitter 的流 API</li>
</ul>

<h3 id="示例">示例</h3>

<p>修饰过的流响应</p>

<pre><code class="language-bash">http --stream -f -a YOUR-TWITTER-NAME https://stream.twitter.com/1/statuses/filter.json track='Justin Bieber'
</code></pre>

<p>像 <code>tail -f</code> 一样小块的流输出</p>

<pre><code class="language-bash">http --stream -f -a YOUR-TWITTER-NAME https://stream.twitter.com/1/statuses/filter.json track=Apple \
| while read tweet; do echo &quot;$tweet&quot; | http POST example.org/tweets ; done
</code></pre>

<h2 id="会话">会话</h2>

<p>默认情况下，同一个 host 每个 HTTPie 发出的请求完全独立</p>

<p>然而，HTTPie 支持使用 <code>--session=SESSION_NAME_OR_PATH</code> 参数进行持久会话。在同一
个 host 的会话中，自定义 header(除了以<code>Content-</code> 和 <code>If-</code> 开头)、authorization、
cookies(手动指定或者服务器发送) 会持续保存</p>

<pre><code class="language-bash"># 创建一个新会话
http --session=/tmp/session.json example.org API-Token:123

# 复制用已存在的会话 API-Token 会自动设置
http --session=/tmp/session.json example.org
</code></pre>

<p>所有的会话数据都会被存储成纯文本，这表示会话文件可以使用编辑器手动添加或者修改——
其实就是 JSON 数据</p>

<h3 id="具名会话">具名会话</h3>

<p>每个 host 都可以建一个或者多个会话，比如：下面的命令将为 host 是 <code>example.org</code>
的请求建一个名为 <code>name1</code> 的会话：</p>

<pre><code class="language-bash">http --session=user1 -a user1:password example.org X-Foo:Bar
</code></pre>

<p>从现在起，你就通过名字来选择会话，当你选择使用一个会话时，之前用过的授权、HTTP
头都会被自动添加：</p>

<pre><code class="language-bash">http --session=user1 example.org
</code></pre>

<p>创建或者重用不同的会话，只需要指定不同的名字即可：</p>

<pre><code class="language-bash">http --session=user2 -a user2:password example.org X-Bar:Foo
</code></pre>

<p>具名会话将被以 JSON 的数据格式存储在 <code>~/.httpie/sessions/&lt;host&gt;/&lt;name&gt;.json</code>
下面（windows下则是 <code>%APPDATA%\httpie\sessions\&lt;host&gt;\&lt;name&gt;.json</code>）</p>

<h3 id="匿名会话">匿名会话</h3>

<p>不同与具名会话，你也可以直接使用一个文件路径来指定会话文件的存储地址，这也可以在
不同的 host 间复用会话：</p>

<pre><code class="language-bash">http --session=/tmp/session.json example.org
http --session=/tmp/session.json admin.example.org
http --session=~/.httpie/sessions/another.example.org/test.json example.org
http --session-read-only=/tmp/session.json example.org
</code></pre>

<h3 id="只读会话">只读会话</h3>

<p>如果复用一个会话又不想更新会话信息，可以通过指定
<code>--session-read-only=SESSION_NAME_OR_PATH</code> 来实现</p>

<h2 id="配置">配置</h2>

<p>HTTPie 使用了一个简单的 JSON 配置文件</p>

<h3 id="配置文件路径">配置文件路径</h3>

<p>默认的配置文件路径在 <code>~/.httpie/config.json</code> （window 在
<code>%APPDATA%\httpie\config.json</code>），配置文件的路径也可以通过修改环境变量
<code>HTTPIE_CONFIG_DIR</code> 来更改，可以使用 <code>http --debug</code> 命令查看当前配置文件路径</p>

<h3 id="可配置的参数">可配置的参数</h3>

<p>JSON 配置文件包含以下的键：</p>

<p><code>default_options</code></p>

<p>参数默认值数组（默认为空），数组里面的参数会被应用于每次 HTTPie 的调用</p>

<p>比如说，你可以使用这个选项改变默认的样式和输出参数：<code>&quot;default_options&quot;:
[&quot;--style=fruity&quot;, &quot;--body&quot;]</code> ，另外一个常用的默认参数是 <code>&quot;--session=default&quot;</code>，
这会让 HTTPie 总是使用会话（名称为default）。也可以使用 <code>--form</code> 改变默认 <strong>不严
格的</strong> JSON 类型为 form 类型</p>

<p><code>__meta__</code></p>

<p>HTTPie 自动存储了一些它自己的元数据，不要动它</p>

<h3 id="取消之前指定的参数">取消之前指定的参数</h3>

<p>配置文件中的参数和其它任何指定参数的方法，都可以使用 <code>--no-OPTION</code> 参数来取消，
比如：<code>--no-style</code> 或者 <code>--no-session</code></p>

<h2 id="脚本">脚本</h2>

<p>当你在 shell 脚本中使用 HTTPie 的时候，<code>--check-status</code> 标识会比较好用。这个标识
将告知 HTTPie 如果响应状态码是 <code>3xx</code>, <code>4xx</code>, <code>5xx</code> 时程序将退出并显示对应的错误
码 <code>3</code>（除非 <code>--follow</code> 参数被指定）, <code>4</code>, <code>5</code></p>

<pre><code class="language-bash">#!/bin/bash

if http --check-status --ignore-stdin --timeout=2.5 HEAD example.org/health &amp;&gt; /dev/null; then
    echo 'OK!'
else
    case $? in
        2) echo 'Request timed out!' ;;
        3) echo 'Unexpected HTTP 3xx Redirection!' ;;
        4) echo 'HTTP 4xx Client Error!' ;;
        5) echo 'HTTP 5xx Server Error!' ;;
        6) echo 'Exceeded --max-redirects=&lt;n&gt; redirects!' ;;
        *) echo 'Other Error!' ;;
    esac
fi
</code></pre>

<h2 id="最佳实践">最佳实践</h2>

<p>在非交互式调用的情况下通常不希望使用 <code>stdin</code> 的默认行为，可以使用
<code>--ignore-stdin</code> 参数来禁止它</p>

<p>如果没有这个选项，HTTPie 可能会挂起，这是一个常见的问题。发生的场景可能是——例如
从定时任务中调用HTTPie时，<code>stdin</code> 未连接到终端。因此，重定向输入的规则适用，即
HTTPie 开始读取它，希望请求体将被传递。由于没有数据也没有 EOF，它会被卡住。因此
，除非你将一些数据传递给 HTTPie，否则应在脚本中使用此标志</p>

<p>当然使用 <code>--timeout</code> 参数手动设置（默认 30 秒）延迟时间是个比较好的做法</p>

<h2 id="元信息">元信息</h2>

<h3 id="接口设计">接口设计</h3>

<p>命令行参数的设计与通过网络发送 HTTP 请求的过程密切相关。这使得 HTTPie 的命令更容
易记忆和阅读。有时你甚至可以把原生的 HTTP 请求串连到一行就很自然的形成了 HTTPie
的命令行参数。例如 对比下面这个原生 HTTP 请求：</p>

<pre><code class="language-bash">POST /collection HTTP/1.1
X-API-Key: 123
User-Agent: Bacon/1.0
Content-Type: application/x-www-form-urlencoded

name=value&amp;name2=value2
</code></pre>

<p>和使用 HTTPie 命令发送同样的参数：</p>

<pre><code class="language-bash">http -f POST example.org/collection \
  X-API-Key:123 \
  User-Agent:Bacon/1.0 \
  name=value \
  name2=value2
</code></pre>

<p>注意他们两者的顺序和参数都非常相似，并且只有一小部分命令用于控制 HTTPie（<code>-f</code> 表
示让 HTTPie 发送一个 from 请求），并且不直接对应于请求的任何部分</p>

<p>两种模式：<code>--pretty=all</code>（命令行中默认）、<code>--pretty=none</code>（重定向输出时默认），
对交互式使用和脚本调用都比较友好，HTTPie 在这过程中作为通用的 HTTP 客户端</p>

<p>由于 HTTPie 还在频繁的开发中，现有的一些命令行参数在最终版 <code>1.0</code> 发布之前可能会
有一些微小的调整。这些调整都会在<a href="#变更日志">变更日志</a> 里面记录</p>

<h3 id="用户支持">用户支持</h3>

<p>你可以通过下面的一些途径找到帮助支持</p>

<ul>
<li><a href="https://github.com/jkbr/httpie/issues">GitHub issues</a></li>
<li><a href="https://gitter.im/jkbrzt/httpie">Our Gitter chat room</a></li>
<li><a href="https://stackoverflow.com/">StackOverflow</a></li>
<li>Twitter <a href="https://twitter.com/clihttp">@clihttp</a>，也可以直接 <a href="https://twitter.com/jkbrzt">@jkbrzt</a></li>
</ul>

<h3 id="相关项目">相关项目</h3>

<h4 id="依赖">依赖</h4>

<p>HTTPie 底层使用了两个特别棒的库：</p>

<p><a href="http://python-requests.org/">Requests</a> — Python HTTP 库
<a href="http://pygments.org/">Pygments</a> — Python 代码高亮</p>

<h4 id="httpie-的朋友">HTTPie 的朋友</h4>

<p>HTTPie 可以和下面两个好友愉快地玩耍：</p>

<p><a href="https://stedolan.github.io/jq/">jq</a>
<a href="https://github.com/eliangcs/http-prompt">http-prompt</a></p>

<h3 id="贡献">贡献</h3>

<p><a href="https://github.com/jakubroztocil/httpie/blob/master/CONTRIBUTING.rst">CONTRIBUTING.rst</a></p>

<h3 id="变更日志">变更日志</h3>

<p><a href="https://github.com/jkbrzt/httpie/blob/master/CHANGELOG.rst">CHANGELOG</a></p>

<h3 id="插图">插图</h3>

<p><a href="https://github.com/claudiatd/httpie-artwork">claudiatd/httpie-artwork</a></p>

<h3 id="许可证">许可证</h3>

<p>BSD-3-Clause: <a href="https://github.com/jkbrzt/httpie/blob/master/LICENSE">LICENSE</a></p>

<h3 id="作者">作者</h3>

<p><a href="http://roztocil.co/">Jakub Roztocil</a> (<a href="https://twitter.com/jkbrzt">@jkbrzt</a>)
创造了 HTTPie，还有一些 <a href="https://github.com/jkbrzt/httpie/contributors">优秀的人</a> 也贡献力量</p>
</div>
                <footer>
                    <p class="meta">
                        <span class="byline author vcard">Posted</span>
                        
                        <span class="span">on</span>
                        <span class="categories">
                            
                            
                            <a class="category 0|1" href="https://keelii.com/categories/shell">shell</a>
                            
                        </span>
                        
                    </p>
                    <p class="meta">
                        <span class="span">Last modified •</span>
                        <time class="entry-date" datetime="2018-09-25 09:33:33">
                            <span class="date">2018-9-25</span>
                            <span class="time">09:33 AM</span>
                        </time>
                    </p>
                    <p class="meta">
                        
                        <span class="basic-alignment left">
                            &laquo; <a href="https://keelii.com/2018/08/26/vim-plugin-ultisnips-advanced-tips/" title="Previous Post: VIM 代码片段插件 ultisnips 使用教程">VIM 代码片段插件 ultisnips 使用教程</a>
                        </span>
                        

                        
                        <span class="basic-alignment right">
                            <a href="https://keelii.com/2018/09/24/socket-programming-in-python/" title="Nextious Post: [译]Python 中的 Socket 编程（指南）">[译]Python 中的 Socket 编程（指南）</a> &raquo;
                        </span>
                        
                    </p>
                </footer>
            </article>
            <section>
    <h1>Comments</h1>
    <div id="disqus_thread"></div>
    <script>
    (function() {
    var d = document, s = d.createElement('script');
    s.src = '//keelii-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


        </div>

        <aside class="sidebar">
    
        
<section id="side-toc" class="side-toc odd" style="width: 100%;">
    <h2>Table  of contents</h2>
    <nav id="TableOfContents">
<ul>
<li><a href="#主要功能特性">主要功能特性</a></li>
<li><a href="#安装">安装</a>
<ul>
<li><a href="#macos">macOS</a></li>
<li><a href="#linux">Linux</a></li>
<li><a href="#windows-及其它">Windows 及其它</a></li>
<li><a href="#开发版">开发版</a></li>
<li><a href="#python-版本">Python 版本</a></li>
</ul></li>
<li><a href="#使用">使用</a>
<ul>
<li><a href="#例子">例子</a></li>
</ul></li>
<li><a href="#http-方法">HTTP 方法</a></li>
<li><a href="#请求-url">请求 URL</a>
<ul>
<li><a href="#querystring-参数">Querystring 参数</a></li>
<li><a href="#localhost-的-url-缩写">localhost 的 URL 缩写</a></li>
<li><a href="#自定义默认的方案">自定义默认的方案</a></li>
</ul></li>
<li><a href="#请求项">请求项</a>
<ul>
<li><a href="#字符转义规则">字符转义规则</a></li>
</ul></li>
<li><a href="#json">JSON</a>
<ul>
<li><a href="#默认行为">默认行为</a></li>
<li><a href="#明确的-json">明确的 JSON</a></li>
<li><a href="#非字符串的-json-域">非字符串的 JSON 域</a></li>
</ul></li>
<li><a href="#表单">表单</a>
<ul>
<li><a href="#普通的表单">普通的表单</a></li>
<li><a href="#文件上传表单">文件上传表单</a></li>
</ul></li>
<li><a href="#http-头">HTTP 头</a>
<ul>
<li><a href="#默认的请求头">默认的请求头</a></li>
<li><a href="#空头和重新设置默认头">空头和重新设置默认头</a></li>
</ul></li>
<li><a href="#授权验证">授权验证</a>
<ul>
<li><a href="#basic-授权">Basic 授权</a></li>
<li><a href="#digest-授权">Digest 授权</a></li>
<li><a href="#密码提示">密码提示</a></li>
<li><a href="#netrc">.netrc</a></li>
<li><a href="#授权插件">授权插件</a></li>
</ul></li>
<li><a href="#http-重定向">HTTP 重定向</a>
<ul>
<li><a href="#按-header-头中的-location-字段值跳转">按 header 头中的 location 字段值跳转</a></li>
<li><a href="#显示中间的跳转响应">显示中间的跳转响应</a></li>
<li><a href="#限制重定向最大次数">限制重定向最大次数</a></li>
</ul></li>
<li><a href="#代理">代理</a>
<ul>
<li><a href="#环境变量">环境变量</a></li>
<li><a href="#socks">Socks</a></li>
</ul></li>
<li><a href="#https">HTTPS</a>
<ul>
<li><a href="#服务器-ssl-证书验证">服务器 SSL 证书验证</a></li>
<li><a href="#自定义-ca-包">自定义 CA 包</a></li>
<li><a href="#客户端-ssl-证书">客户端 SSL 证书</a></li>
<li><a href="#ssl-版本">SSL 版本</a></li>
<li><a href="#服务器名称指示-sni-server-name-indication">服务器名称指示 SNI(Server Name Indication)</a></li>
</ul></li>
<li><a href="#输出参数">输出参数</a>
<ul>
<li><a href="#哪部分的-http-请求内容应该打印出来">哪部分的 HTTP 请求内容应该打印出来</a></li>
<li><a href="#查看中间的请求-响应">查看中间的请求/响应</a></li>
<li><a href="#条件化的-body-内容下载">条件化的 body 内容下载</a></li>
</ul></li>
<li><a href="#重定向输入">重定向输入</a>
<ul>
<li><a href="#从一个文件中取请求数据">从一个文件中取请求数据</a></li>
</ul></li>
<li><a href="#命令行输出">命令行输出</a>
<ul>
<li><a href="#颜色和格式化">颜色和格式化</a></li>
<li><a href="#二进制数据">二进制数据</a></li>
</ul></li>
<li><a href="#重定向输出">重定向输出</a></li>
<li><a href="#下载模式">下载模式</a>
<ul>
<li><a href="#下载文件的文件名">下载文件的文件名</a></li>
<li><a href="#下载的同时-piping">下载的同时 piping</a></li>
<li><a href="#恢复下载">恢复下载</a></li>
<li><a href="#其它注意事项">其它注意事项</a></li>
</ul></li>
<li><a href="#流式响应">流式响应</a>
<ul>
<li><a href="#禁用缓冲">禁用缓冲</a></li>
<li><a href="#示例">示例</a></li>
</ul></li>
<li><a href="#会话">会话</a>
<ul>
<li><a href="#具名会话">具名会话</a></li>
<li><a href="#匿名会话">匿名会话</a></li>
<li><a href="#只读会话">只读会话</a></li>
</ul></li>
<li><a href="#配置">配置</a>
<ul>
<li><a href="#配置文件路径">配置文件路径</a></li>
<li><a href="#可配置的参数">可配置的参数</a></li>
<li><a href="#取消之前指定的参数">取消之前指定的参数</a></li>
</ul></li>
<li><a href="#脚本">脚本</a></li>
<li><a href="#最佳实践">最佳实践</a></li>
<li><a href="#元信息">元信息</a>
<ul>
<li><a href="#接口设计">接口设计</a></li>
<li><a href="#用户支持">用户支持</a></li>
<li><a href="#相关项目">相关项目</a>
<ul>
<li><a href="#依赖">依赖</a></li>
<li><a href="#httpie-的朋友">HTTPie 的朋友</a></li>
</ul></li>
<li><a href="#贡献">贡献</a></li>
<li><a href="#变更日志">变更日志</a></li>
<li><a href="#插图">插图</a></li>
<li><a href="#许可证">许可证</a></li>
<li><a href="#作者">作者</a></li>
</ul></li>
</ul>
</nav>
</section>



    
</aside>

    </div>
</div>

<footer role="contentinfo">
    <p>
        Copyright &copy; 2018 - keelii -
        <span class="credit">Powered by <a href="http://gohugo.io/">Hugo</a></span>,
        <span class="credit">Theme Copied from <a href="http://octopress.org/">Octopress</a></span>
    </p>
</footer>


<script src="//cdn.bootcss.com/zepto/1.2.0/zepto.min.js"></script>
<script src="/javascripts/octopress.js"></script>



<script src="/javascripts/highlight.pack.js"></script>
<script src="/javascripts/post.js"></script>
<script>
if (typeof hljs !=="undefined") hljs.initHighlightingOnLoad()
</script>



<script>
!function(e){function t(e){for(var t=location.href,n=t.split("").reverse(),r=e.split(""),i=[],s=0,o=16;o>s;s++)i.push(r[s]+(n[s]||""));return i.join("")}var n=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.so\.com)/gi,r=e.location.href;if(r&&!n.test(r)&&window.navigator.appName){var i="//s.360.cn/so/zz.gif",o="0cbb5a2bef902d89e9dc9bb5f742b91c",u=t(o),a=new Image;r&&(i+="?url="+encodeURIComponent(r)),o&&(i+="&sid="+o),u&&(i+="&token="+u),o&&(a.src=i)}}(window);
</script>

<!--
# There are some hotkeys for better experience #

[s] for search input
[t] for scroll to top
[h] for prev article
[l] for next article
[j] for scroll page up 300px
[k] for scroll page down 300px
[G] for scroll page bottom
-->

</body>
</html>
