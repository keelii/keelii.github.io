<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Archives on Something</title>
    <link>https://keelii.com/archives/</link>
    <description>Recent content in Archives on Something</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 24 Sep 2018 19:10:27 +0000</lastBuildDate>
    
        <atom:link href="https://keelii.com/archives/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[译]Python 中的 Socket 编程（指南）</title>
      <link>https://keelii.com/2018/09/24/socket-programming-in-python/</link>
      <pubDate>Mon, 24 Sep 2018 19:10:27 +0000</pubDate>
      
      <guid>https://keelii.com/2018/09/24/socket-programming-in-python/</guid>
      <description>

&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;

&lt;p&gt;本书翻译自 &lt;a href=&#34;https://realpython.com/&#34;&gt;realpython&lt;/a&gt; 网站上的文章教程 &lt;a href=&#34;https://realpython.com/python-sockets/&#34;&gt;Socket Programming in Python (Guide)&lt;/a&gt;，由于原文比较长，所以整理成了 &lt;a href=&#34;https://legacy.gitbook.com/book/keelii/socket-programming-in-python-cn/details&#34;&gt;Gitbook&lt;/a&gt; 方便阅读&lt;/p&gt;

&lt;h2 id=&#34;原作者&#34;&gt;原作者&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Nathan Jennings 是 Real Python 教程团队的一员，他在很早之前就使用 C 语言开始了自己的编程生涯，但是最终发现了 Python，从 Web 应用和网络数据收集到网络安全，他喜欢任何 Pythonic 的东西
—— realpython&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;译者注&#34;&gt;译者注&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://keelii.com/&#34;&gt;译者&lt;/a&gt; 是一名前端工程师，平常会写很多的 JavaScript。但是当我使用 JavaScript 很长一段时间后，会对一些 &lt;em&gt;语言无关&lt;/em&gt; 的编程概念感兴趣，比如：网络/socket 编程、异步/并发、线/进程通信等。然而恰好这些内容在 JavasScript 领域很少见&lt;/p&gt;

&lt;p&gt;因为一直从事 Web 开发，所以我认为理解了网络通信及其 socket 编程就理解了 Web 开发的某些本质。过程中我发现 Python 社区有很多我喜欢的内容，并且很多都是高质量的公开发布且开源的。&lt;/p&gt;

&lt;p&gt;最近我发现了这篇文章，系统地从底层网络通信讲到了应用层协议及其 C/S 架构的应用程序，由浅入深。虽然代码、API 使用了 Python，但是底层原因都是相通的。非常值得一读，推荐给大家&lt;/p&gt;

&lt;p&gt;另外，由于本人水平所限，翻译的内容难免出现偏差，如果你在阅读的过程中发现问题，请毫不忧虑的提醒我或者开新 &lt;a href=&#34;https://github.com/keelii/socket-programming-in-python-cn/pulls&#34;&gt;PR&lt;/a&gt;。或者有什么不理解的地方也可以开 &lt;a href=&#34;https://github.com/keelii/socket-programming-in-python-cn/issues&#34;&gt;issue&lt;/a&gt; 讨论&lt;/p&gt;

&lt;h2 id=&#34;授权&#34;&gt;授权&lt;/h2&gt;

&lt;p&gt;本文（翻译版）通过了 realpython 官方授权，原文版权归其所有，任何转载请联系他们&lt;/p&gt;

&lt;h2 id=&#34;开始&#34;&gt;开始&lt;/h2&gt;

&lt;p&gt;网络中的 Socket 和 Socket API 是用来跨网络的消息传送的，它提供了 &lt;a href=&#34;https://en.wikipedia.org/wiki/Inter-process_communication&#34;&gt;进程间通信(IPC)&lt;/a&gt; 的一种形式。网络可以是逻辑的、本地的电脑网络，或者是可以物理连接到外网的网络，并且可以连接到其它网络。英特网就是一个明显的例子，就是那个你通过 ISP 连接到的网络&lt;/p&gt;

&lt;p&gt;本篇教程有三个不同的迭代阶段，来展示如何使用 Python 构建一个 Socket 服务器和客户端&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;我们将以一个简单的 Socket 服务器和客户端程序来开始本教程&lt;/li&gt;
&lt;li&gt;当你看完 API 了解例子是怎么运行起来以后，我们将会看到一个具有同时处理多个连接能力的例子的改进版&lt;/li&gt;
&lt;li&gt;最后，我们将会开发出一个更加完善且具有完整的自定义头信息和内容的 Socket 应用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;教程结束后，你将学会如何使用 Python 中的 &lt;a href=&#34;https://docs.python.org/3/library/socket.html&#34;&gt;socket 模块&lt;/a&gt; 来写一个自己的客户端/服务器应用。以及向你展示如何在你的应用中使用自定义类在不同的端之间发送消息和数据&lt;/p&gt;

&lt;p&gt;所有的例子程序都使用 Python 3.6 编写，你可以在 Github 上找到 &lt;a href=&#34;https://github.com/realpython/materials/tree/master/python-sockets-tutorial&#34;&gt;源代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;网络和 Socket 是个很大的话题。网上已经有了关于它们的字面解释，如果你还不是很了解 Socket 和网络。当你你读到那些解释的时候会感到不知所措，这是非常正常的。因为我也是这样过来的&lt;/p&gt;

&lt;p&gt;尽管如此也不要气馁。 我已经为你写了这个教程。 就像学习 Python 一样，我们可以一次学习一点。用你的浏览器保存本页面到书签，以便你学习下一部分时能找到&lt;/p&gt;

&lt;p&gt;让我们开始吧！&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;Socket 有一段很长的历史，最初是在 &lt;a href=&#34;https://en.wikipedia.org/wiki/Network_socket#History&#34;&gt;1971 年被用于 ARPANET&lt;/a&gt;，随后就成了 1983 年发布的 Berkeley Software Distribution (BSD) 操作系统的 API，并且被命名为 &lt;a href=&#34;https://en.wikipedia.org/wiki/Berkeley_sockets&#34;&gt;Berkeleysocket&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当互联网在 20 世纪 90 年代随万维网兴起时，网络编程也火了起来。Web 服务和浏览器并不是唯一使用新的连接网络和 Socket 的应用程序。各种类型不同规模的客户端/服务器应用都广泛地使用着它们&lt;/p&gt;

&lt;p&gt;时至今日，尽管 Socket API 使用的底层协议已经进化了很多年，也出现了许多新的协议，但是底层的 API 仍然保持不变&lt;/p&gt;

&lt;p&gt;Socket 应用最常见的类型就是 &lt;strong&gt;客户端/服务器&lt;/strong&gt; 应用，服务器用来等待客户端的链接。我们教程中涉及到的就是这类应用。更明确地说，我们将看到用于 &lt;a href=&#34;https://en.wikipedia.org/wiki/Berkeley_sockets&#34;&gt;InternetSocket&lt;/a&gt; 的 Socket API，有时称为 Berkeley 或 BSD Socket。当然也有 &lt;a href=&#34;https://en.wikipedia.org/wiki/Unix_domain_socket&#34;&gt;Unix domain sockets&lt;/a&gt; —— 一种用于 &lt;strong&gt;同一主机&lt;/strong&gt; 进程间的通信&lt;/p&gt;

&lt;h2 id=&#34;socket-api-概览&#34;&gt;Socket API 概览&lt;/h2&gt;

&lt;p&gt;Python 的 socket 模块提供了使用 Berkeley sockets API 的接口。这将会在我们这个教程里使用和讨论到&lt;/p&gt;

&lt;p&gt;主要的用到的 Socket API 函数和方法有下面这些：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connect_ex()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Python 提供了和 C 语言一致且方便的 API。我们将在下面一节中用到它们&lt;/p&gt;

&lt;p&gt;作为标准库的一部分，Python 也有一些类可以让我们方便的调用这些底层 Socket 函数。尽管这个教程中并没有涉及这部分内容，你也可以通过&lt;a href=&#34;https://docs.python.org/3/library/socketserver.html&#34;&gt;socketserver 模块&lt;/a&gt; 中找到文档。当然还有很多实现了高层网络协议（比如：HTTP, SMTP）的的模块，可以在下面的链接中查到 &lt;a href=&#34;https://docs.python.org/3/library/internet.html&#34;&gt;Internet Protocols and Support&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tcp-sockets&#34;&gt;TCP Sockets&lt;/h2&gt;

&lt;p&gt;就如你马上要看到的，我们将使用 &lt;code&gt;socket.socket()&lt;/code&gt; 创建一个类型为 &lt;code&gt;socket.SOCK_STREAM&lt;/code&gt; 的 socket 对象，默认将使用 &lt;a href=&#34;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&#34;&gt;Transmission Control Protocol(TCP) 协议&lt;/a&gt;，这基本上就是你想使用的默认值&lt;/p&gt;

&lt;p&gt;为什么应该使用 TCP 协议？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可靠的&lt;/strong&gt;：网络传输中丢失的数据包会被检测到并重新发送&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有序传送&lt;/strong&gt;：数据按发送者写入的顺序被读取&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相反，使用 &lt;code&gt;socket.SOCK_DGRAM&lt;/code&gt; 创建的 &lt;a href=&#34;https://en.wikipedia.org/wiki/User_Datagram_Protocol&#34;&gt;用户数据报协议(UDP)&lt;/a&gt; Socket 是 &lt;strong&gt;不可靠&lt;/strong&gt; 的，而且数据的读取写发送可以是 &lt;strong&gt;无序的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为什么这个很重要？网络总是会尽最大的努力去传输完整数据（往往不尽人意）。没法保证你的数据一定被送到目的地或者一定能接收到别人发送给你的数据&lt;/p&gt;

&lt;p&gt;网络设备（比如：路由器、交换机）都有带宽限制，或者系统本身的极限。它们也有 CPU、内存、总线和接口包缓冲区，就像我们的客户端和服务器。TCP 消除了你对于丢包、乱序以及其它网络通信中通常出现的问题的顾虑&lt;/p&gt;

&lt;p&gt;下面的示意图中，我们将看到 Socket API 的调用顺序和 TCP 的数据流：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://files.realpython.com/media/sockets-tcp-flow.1da426797e37.jpg&#34; alt=&#34;TCP Socket 流&#34; /&gt;&lt;/p&gt;

&lt;p&gt;左边表示服务器，右边则是客户端&lt;/p&gt;

&lt;p&gt;左上方开始，注意服务器创建「监听」Socket 的 API 调用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;「监听」Socket 做的事情就像它的名字一样。它会监听客户端的连接，当一个客户端连接进来的时候，服务器将调用 &lt;code&gt;accept()&lt;/code&gt; 来「接受」或者「完成」此连接&lt;/p&gt;

&lt;p&gt;客户端调用 &lt;code&gt;connect()&lt;/code&gt; 方法来建立与服务器的链接，并开始三次握手。握手很重要是因为它保证了网络的通信的双方可以到达，也就是说客户端可以正常连接到服务器，反之亦然&lt;/p&gt;

&lt;p&gt;上图中间部分往返部分表示客户端和服务器的数据交换过程，调用了 &lt;code&gt;send()&lt;/code&gt; 和 &lt;code&gt;recv()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;下面部分，客户端和服务器调用 &lt;code&gt;close()&lt;/code&gt; 方法来关闭各自的 socket&lt;/p&gt;

&lt;h2 id=&#34;打印客户端和服务端&#34;&gt;打印客户端和服务端&lt;/h2&gt;

&lt;p&gt;你现在已经了解了基本的 socket API 以及客户端和服务器是如何通信的，让我们来创建一个客户端和服务器。我们将会以一个简单的实现开始。服务器将打印客户端发送回来的内容&lt;/p&gt;

&lt;h3 id=&#34;打印程序服务端&#34;&gt;打印程序服务端&lt;/h3&gt;

&lt;p&gt;下面就是服务器代码，&lt;code&gt;echo-server.py&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python3

import socket

HOST = &#39;127.0.0.1&#39;  # 标准的回环地址 (localhost)
PORT = 65432        # 监听的端口 (非系统级的端口: 大于 1023)

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    conn, addr = s.accept()
    with conn:
        print(&#39;Connected by&#39;, addr)
        while True:
            data = conn.recv(1024)
            if not data:
                break
            conn.sendall(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：上面的代码你可能还没法完全理解，但是不用担心。这几行代码做了很多事情，这
只是一个起点，帮你看见这个简单的服务器是如何运行的
教程后面有引用部分，里面有很多额外的引用资源链接，这个教程中我将把链接放在那儿&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;让我们一起来看一下 API 调用以及发生了什么&lt;/p&gt;

&lt;p&gt;&lt;code&gt;socket.socket()&lt;/code&gt; 创建了一个 socket 对象，并且支持 &lt;a href=&#34;https://docs.python.org/3/reference/datamodel.html#context-managers&#34;&gt;context manager type&lt;/a&gt;，你可以使用 &lt;a href=&#34;https://docs.python.org/3/reference/compound_stmts.html#with&#34;&gt;with 语句&lt;/a&gt;，这样你就不用再手动调用 &lt;code&gt;s.close()&lt;/code&gt; 来关闭 socket 了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    pass  # Use the socket object without calling s.close().
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用 &lt;code&gt;socket()&lt;/code&gt; 时传入的 socket 地址族参数 &lt;code&gt;socket.AF_INET&lt;/code&gt; 表示因特网 IPv4 &lt;a href=&#34;https://realpython.com/python-sockets/#socket-address-families&#34;&gt;地址族&lt;/a&gt;，&lt;code&gt;SOCK_STREAM&lt;/code&gt; 表示使用 TCP 的 socket 类型，协议将被用来在网络中传输消息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bind()&lt;/code&gt; 用来关联 socket 到指定的网络接口（IP 地址）和端口号：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;HOST = &#39;127.0.0.1&#39;
PORT = 65432

# ...

s.bind((HOST, PORT))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bind()&lt;/code&gt; 方法的入参取决于 socket 的地址族，在这个例子中我们使用了 &lt;code&gt;socket.AF_INET&lt;/code&gt; (IPv4)，它将返回两个元素的元组：(host, port)&lt;/p&gt;

&lt;p&gt;host 可以是主机名称、IP 地址、空字符串，如果使用 IP 地址，host 就应该是 IPv4 格式的字符串，&lt;code&gt;127.0.0.1&lt;/code&gt; 是标准的 IPv4 回环地址，只有主机上的进程可以连接到服务器，如果你传了空字符串，服务器将接受本机所有可用的 IPv4 地址&lt;/p&gt;

&lt;p&gt;端口号应该是 1-65535 之间的整数（0是保留的），这个整数就是用来接受客户端链接的 TCP 端口号，如果端口号小于 1024，有的操作系统会要求管理员权限&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;bind()&lt;/code&gt; 传参为主机名称的时候需要注意：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你在 host 部分 &lt;strong&gt;主机名称&lt;/strong&gt; 作为 IPv4/v6 socket 的地址，程序可能会产生非确
定性的行为，因为 Python 会使用 DNS 解析后的 &lt;strong&gt;第一个&lt;/strong&gt; 地址，根据 DNS 解析的结
果或者 host 配置 socket 地址将会以不同方式解析为实际的 IPv4/v6 地址。如果想得
到确定的结果传入的 host 参数建议使用数字格式的地址 &lt;a href=&#34;https://docs.python.org/3/library/socket.html&#34;&gt;引用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我稍后将在 &lt;a href=&#34;#使用主机名&#34;&gt;使用主机名&lt;/a&gt; 部分讨论这个问题，但是现在也值得一提。目前来说你只需要知道当使用主机名时，你将会因为 DNS 解析的原因得到不同的结果&lt;/p&gt;

&lt;p&gt;可能是任何地址。比如第一次运行程序时是 10.1.2.3，第二次是 192.168.0.1，第三次是 172.16.7.8 等等&lt;/p&gt;

&lt;p&gt;继续看上面的服务器代码示例，&lt;code&gt;listen()&lt;/code&gt; 方法调用使服务器可以接受连接请求，这使它成为一个「监听中」的 socket&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;s.listen()
conn, addr = s.accept()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;listen()&lt;/code&gt; 方法有一个 &lt;code&gt;backlog&lt;/code&gt; 参数。它指定在拒绝新的连接之前系统将允许使用的 &lt;em&gt;未接受的连接&lt;/em&gt; 数量。从 Python 3.5 开始，这是可选参数。如果不指定，Python 将取一个默认值&lt;/p&gt;

&lt;p&gt;如果你的服务器需要同时接收很多连接请求，增加 backlog 参数的值可以加大等待链接请求队列的长度，最大长度取决于操作系统。比如在 Linux 下，参考 &lt;a href=&#34;https://serverfault.com/questions/518862/will-increasing-net-core-somaxconn-make-a-difference/519152&#34;&gt;/proc/sys/net/core/somaxconn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;accept()&lt;/code&gt; 方法阻塞并等待传入连接。当一个客户端连接时，它将返回一个新的 socket 对象，对象中有表示当前连接的 conn 和一个由主机、端口号组成的 IPv4/v6 连接的元组，更多关于元组值的内容可以查看 &lt;a href=&#34;#socket 地址族&#34;&gt;socket 地址族&lt;/a&gt; 一节中的详情&lt;/p&gt;

&lt;p&gt;这里必须要明白我们通过调用 &lt;code&gt;accept()&lt;/code&gt; 方法拥有了一个新的 socket 对象。这非常重要，因为你将用这个 socket 对象和客户端进行通信。和监听一个 socket 不同的是后者只用来授受新的连接请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;conn, addr = s.accept()
with conn:
    print(&#39;Connected by&#39;, addr)
    while True:
        data = conn.recv(1024)
        if not data:
            break
        conn.sendall(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从 &lt;code&gt;accept()&lt;/code&gt; 获取客户端 socket 连接对象 conn 后，使用一个无限 while 循环来阻塞调用 &lt;code&gt;conn.recv()&lt;/code&gt;，无论客户端传过来什么数据都会使用 &lt;code&gt;conn.sendall()&lt;/code&gt; 打印出来&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;conn.recv()&lt;/code&gt; 方法返回一个空 byte 对象（&lt;code&gt;b&#39;&#39;&lt;/code&gt;），然后客户端关闭连接，循环结束，with 语句和 conn 一起使用时，通信结束的时候会自动关闭 socket 链接&lt;/p&gt;

&lt;h3 id=&#34;打印程序客户端&#34;&gt;打印程序客户端&lt;/h3&gt;

&lt;p&gt;现在我们来看下客户端的程序，&lt;code&gt;echo-client.py&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python3

import socket

HOST = &#39;127.0.0.1&#39;  # 服务器的主机名或者 IP 地址
PORT = 65432        # 服务器使用的端口

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    s.sendall(b&#39;Hello, world&#39;)
    data = s.recv(1024)

print(&#39;Received&#39;, repr(data))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与服务器程序相比，客户端程序简单很多。它创建了一个 socket 对象，连接到服务器并且调用 &lt;code&gt;s.sendall()&lt;/code&gt; 方法发送消息，然后再调用 &lt;code&gt;s.recv()&lt;/code&gt; 方法读取服务器返回的内容并打印出来&lt;/p&gt;

&lt;h3 id=&#34;运行打印程序的客户端和服务端&#34;&gt;运行打印程序的客户端和服务端&lt;/h3&gt;

&lt;p&gt;让我们运行打印程序的客户端和服务端，观察他们的表现，看看发生了什么事情&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你在运行示例代码时遇到了问题，可以阅读 &lt;a href=&#34;https://dbader.org/blog/how-to-make-command-line-commands-with-python&#34;&gt;如何使用 Python 开发命令行命令&lt;/a&gt;，如果
你使用的是 windows 操作系统，请查看 &lt;a href=&#34;https://docs.python.org/3.6/faq/windows.html&#34;&gt;Python Windows FAQ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;打开命令行程序，进入你的代码所在的目录，运行打印程序的服务端：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./echo-server.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你的命令行将被挂起，因为程序有一个阻塞调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;conn, addr = s.accept()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它将等待客户端的连接，现在再打开一个命令行窗口运行打印程序的客户端：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./echo-client.py
Received b&#39;Hello, world&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在服务端的窗口你将看见：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./echo-server.py
Connected by (&#39;127.0.0.1&#39;, 64623)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的输出中，服务端打印出了 &lt;code&gt;s.accept()&lt;/code&gt; 返回的 addr 元组，这就是客户端的 IP 地址和 TCP 端口号。示例中的端口号是 64623 这很可能是和你机器上运行的结果不同&lt;/p&gt;

&lt;h3 id=&#34;查看-socket-状态&#34;&gt;查看 socket 状态&lt;/h3&gt;

&lt;p&gt;想查找你主机上 socket 的当前状态，可以使用 &lt;code&gt;netstat&lt;/code&gt; 命令。这个命令在 macOS, Window, Linux 系统上默认可用&lt;/p&gt;

&lt;p&gt;下面这个就是启动服务后 netstat 命令的输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ netstat -an
Active Internet connections (including servers)
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4       0      0  127.0.0.1.65432        *.*                    LISTEN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意本地地址是 127.0.0.1.65432，如果 &lt;code&gt;echo-server.py&lt;/code&gt; 文件中 &lt;code&gt;HOST&lt;/code&gt; 设置成空字符串 &lt;code&gt;&#39;&#39;&lt;/code&gt; 的话，netstat 命令将显示如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ netstat -an
Active Internet connections (including servers)
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4       0      0  *.65432                *.*                    LISTEN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本地地址是 &lt;code&gt;*.65432&lt;/code&gt;，这表示所有主机支持的 IP 地址族都可以接受传入连接，在我们的例子里面调用 &lt;code&gt;socket()&lt;/code&gt; 时传入的参数 &lt;code&gt;socket.AF_INET&lt;/code&gt; 表示使用了 IPv4 的 TCP socket，你可以在输出结果中的 &lt;code&gt;Proto&lt;/code&gt; 列中看到(tcp4)&lt;/p&gt;

&lt;p&gt;上面的输出是我截取的只显示了咱们的打印程序服务端进程，你可能会看到更多输出，具体取决于你运行的系统。需要注意的是 Proto, Local Address 和 state 列。分别表示 TCP socket 类型、本地地址端口、当前状态&lt;/p&gt;

&lt;p&gt;另外一个查看这些信息的方法是使用 &lt;code&gt;lsof&lt;/code&gt; 命令，这个命令在 macOS 上是默认安装的，Linux 上需要你手动安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lsof -i -n
COMMAND     PID   USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
Python    67982 nathan    3u  IPv4 0xecf272      0t0  TCP *:65432 (LISTEN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isof 命令使用 &lt;code&gt;-i&lt;/code&gt; 参数可以查看打开的 socket 连接的 COMMAND, PID(process id) 和 USER(user id)，上面的输出就是打印程序服务端&lt;/p&gt;

&lt;p&gt;&lt;code&gt;netstat&lt;/code&gt; 和 &lt;code&gt;isof&lt;/code&gt; 命令有许多可用的参数，这取决于你使用的操作系统。可以使用 man page 来查看他们的使用文档，这些文档绝对值得花一点时间去了解，你将受益匪浅，macOS 和 Linux 中使用命令 &lt;code&gt;man netstat&lt;/code&gt; 或者 &lt;code&gt;man lsof&lt;/code&gt; 命令，windows 下使用 &lt;code&gt;netstat /?&lt;/code&gt; 来查看帮助文档&lt;/p&gt;

&lt;p&gt;一个通常会犯的错误是在没有监听 socket 端口的情况下尝试连接：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./echo-client.py
Traceback (most recent call last):
  File &amp;quot;./echo-client.py&amp;quot;, line 9, in &amp;lt;module&amp;gt;
    s.connect((HOST, PORT))
ConnectionRefusedError: [Errno 61] Connection refused
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可能是端口号出错、服务端没启动或者有防火墙阻止了连接，这些原因可能很难记住，或许你也会碰到 &lt;code&gt;Connection timed out&lt;/code&gt; 的错误，记得给你的防火墙添加允许我们使用的端口规则&lt;/p&gt;

&lt;p&gt;引用部分有一些常见的 &lt;a href=&#34;#错误&#34;&gt;错误&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;通信的流程分解&#34;&gt;通信的流程分解&lt;/h2&gt;

&lt;p&gt;让我们再仔细的观察下客户端是如何与服务端进行通信的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://files.realpython.com/media/sockets-loopback-interface.44fa30c53c70.jpg&#34; alt=&#34;host&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当使用回环地址时，数据将不会接触到外部网络，上图中，回环地址包含在了 host 里面。这就是回环地址的本质，连接数据传输是从本地到主机，这就是为什么你会听到有回环地址或者 &lt;code&gt;127.0.0.1&lt;/code&gt;、&lt;code&gt;::1&lt;/code&gt; 的 IP 地址和表示本地主机&lt;/p&gt;

&lt;p&gt;应用程序使用回环地址来与主机上的其它进程通信，这使得它与外部网络安全隔离。由于它是内部的，只能从主机内访问，所以它不会被暴露出去&lt;/p&gt;

&lt;p&gt;如果你的应用程序服务器使用自己的专用数据库（非公用的），则可以配置服务器仅监听回环地址，这样的话网络上的其它主机就无法连接到你的数据库&lt;/p&gt;

&lt;p&gt;如果你的应用程序中使用的 IP 地址不是 127.0.0.1 或者 ::1，那就可能会绑定到连接到外部网络的以太网上。这就是你通往 localhost 王国之外的其他主机的大门&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://files.realpython.com/media/sockets-ethernet-interface.aac312541af5.jpg&#34; alt=&#34;external network&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里需要小心，并且可能让你感到难受甚至怀疑全世界。在你探索 localhost 的安全限制之前，确认读过 &lt;a href=&#34;#使用主机名&#34;&gt;使用主机名&lt;/a&gt; 一节。 一个安全注意事项是 &lt;strong&gt;不要使用主机名，要使用
IP 地址&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;处理多个连接&#34;&gt;处理多个连接&lt;/h2&gt;

&lt;p&gt;打印程序的服务端肯定有它自己的一些局限。这个程序只能服务于一个客户端然后结束。打印程序的客户端也有它自己的局限，但是还有一个问题，如果客户端调用了下面的方法&lt;code&gt;s.recv()&lt;/code&gt; 方法将返回 &lt;code&gt;b&#39;Hello, world&#39;&lt;/code&gt; 中的一个字节 &lt;code&gt;b&#39;H&#39;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data = s.recv(1024)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1024 是缓冲区数据大小限制最大值参数 &lt;code&gt;bufsize&lt;/code&gt;，并不是说 &lt;code&gt;recv()&lt;/code&gt; 方法只返回 1024个字节的内容&lt;/p&gt;

&lt;p&gt;&lt;code&gt;send()&lt;/code&gt; 方法也是这个原理，它返回发送内容的字节数，结果可能小于传入的发送内容，你得处理这处情况，按需多次调用 &lt;code&gt;send()&lt;/code&gt; 方法来发送完整的数据&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;应用程序负责检查是否已发送所有数据；如果仅传输了一些数据，则应用程序需要尝试传
递剩余数据 &lt;a href=&#34;https://docs.python.org/3/library/socket.html#socket.socket.send&#34;&gt;引用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以使用 &lt;code&gt;sendall()&lt;/code&gt; 方法来回避这个过程&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;和 send() 方法不一样的是，&lt;code&gt;sendall()&lt;/code&gt; 方法会一直发送字节，只到所有的数据传输完成
或者中途出现错误。成功的话会返回 None &lt;a href=&#34;https://docs.python.org/3/library/socket.html#socket.socket.sendall&#34;&gt;引用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;到目前为止，我们有两个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何同时处理多个连接请求&lt;/li&gt;
&lt;li&gt;我们需要一直调用 &lt;code&gt;send()&lt;/code&gt; 或者 &lt;code&gt;recv()&lt;/code&gt; 直到所有数据传输完成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;应该怎么做呢，有很多方式可以实现并发。最近，有一个非常流程的库叫做 &lt;a href=&#34;https://docs.python.org/3/library/asyncio.html&#34;&gt;Asynchronous I/O&lt;/a&gt; 可以实现，asyncio 库在 Python 3.4 后默认添加到了标准库里面。传统的方法是使用线程&lt;/p&gt;

&lt;p&gt;并发的问题是很难做到正确，有许多细微之处需要考虑和防范。可能其中一个细节的问题都会导致整个程序崩溃&lt;/p&gt;

&lt;p&gt;我说这些并不是想吓跑你或者让你远离学习和使用并发编程。如果你想让程序支持大规模使用，使用多处理器、多核是很有必要的。然而在这个教程中我们将使用比线程更传统的方法使得逻辑更容易推理。我们将使用一个非常古老的系统调用：&lt;code&gt;select()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;select()&lt;/code&gt; 允许你检查多个 socket 的 I/O 完成情况，所以你可以使用它来检测哪个 socket I/O 是就绪状态从而执行读取或写入操作，但是这是 Python，总会有更多其它的选择，我们将使用标准库中的&lt;a href=&#34;https://docs.python.org/3/library/selectors.html&#34;&gt;selectors&lt;/a&gt; 模块，所以我们使用了最有效的实现，不用在意你使用的操作系统：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个模块提供了高层且高效的 I/O 多路复用，基于原始的 &lt;code&gt;select&lt;/code&gt; 模块构建，推荐用
户使用这个模块，除非他们需要精确到操作系统层面的使用控制 &lt;a href=&#34;https://docs.python.org/3/library/selectors.html&#34;&gt;引用
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;尽管如此，使用 &lt;code&gt;select()&lt;/code&gt; 也无法并发执行。这取决于您的工作负载，这种实现仍然会很快。这也取决于你的应用程序对连接所做的具体事情或者它需要支持的客户端数量&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/library/asyncio.html&#34;&gt;asyncio&lt;/a&gt; 使用单线程来处理多任务，使用事件循环来管理任务。通过使用 &lt;code&gt;select()&lt;/code&gt;，我们可以创建自己的事件循环，更简单且同步化。当使用多线程时，即使要处理并发的情况，我们也不得不面临使用 CPython 或者 PyPy 中的「全局解析器锁 GIL」，这有效地限制了我们可以并行完成的工作量&lt;/p&gt;

&lt;p&gt;说这些是为了解析为什么使用 &lt;code&gt;select()&lt;/code&gt; 可能是个更好的选择，不要觉得你必须使用 asyncio、线程或最新的异步库。通常，在网络应用程序中，你的应用程序就是 I/O 绑定：它可以在本地网络上，网络另一端的端，磁盘上等待&lt;/p&gt;

&lt;p&gt;如果你从客户端收到启动 CPU 绑定工作的请求，查看 &lt;a href=&#34;https://docs.python.org/3/library/concurrent.futures.html&#34;&gt;concurrent.futures&lt;/a&gt;模块，它包含一个 ProcessPoolExecutor 类，用来异步执行进程池中的调用&lt;/p&gt;

&lt;p&gt;如果你使用多进程，你的 Python 代码将被操作系统并行地在不同处理器或者核心上调度运行，并且没有全局解析器锁。你可以通过
Python 大会上的演讲 &lt;a href=&#34;https://www.youtube.com/watch?v=0kXaLh8Fz3k&#34;&gt;John Reese - Thinking Outside the GIL with AsyncIO and Multiprocessing - PyCon 2018&lt;/a&gt; 来了解更多的想法&lt;/p&gt;

&lt;p&gt;在下一节中，我们将介绍解决这些问题的服务器和客户端的示例。他们使用 &lt;code&gt;select()&lt;/code&gt; 来同时处理多连接请求，按需多次调用 &lt;code&gt;send()&lt;/code&gt; 和 &lt;code&gt;recv()&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;多连接的客户端和服务端&#34;&gt;多连接的客户端和服务端&lt;/h2&gt;

&lt;p&gt;下面两节中，我们将使用 selectors 模块中的 selector 对象来创建一个可以同时处理多个请求的客户端和服务端&lt;/p&gt;

&lt;h3 id=&#34;多连接的服务端&#34;&gt;多连接的服务端&lt;/h3&gt;

&lt;p&gt;首页，我们来看眼多连接服务端程序的代码，&lt;code&gt;multiconn-server.py&lt;/code&gt;。这是开始建立监听 socket 部分&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import selectors
sel = selectors.DefaultSelector()
# ...
lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
lsock.bind((host, port))
lsock.listen()
print(&#39;listening on&#39;, (host, port))
lsock.setblocking(False)
sel.register(lsock, selectors.EVENT_READ, data=None)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个程序和之前打印程序服务端最大的不同是使用了 &lt;code&gt;lsock.setblocking(False)&lt;/code&gt; 配置 socket 为非阻塞模式，这个 socket 的调用将不在是阻塞的。当它和 &lt;code&gt;sel.select()&lt;/code&gt; 一起使用的时候（下面会提到），我们就可以等待 socket 就绪事件，然后执行读写操作&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sel.register()&lt;/code&gt; 使用 &lt;code&gt;sel.select()&lt;/code&gt; 为你感兴趣的事件注册 socket 监控，对于监听 socket，我们希望使用 &lt;code&gt;selectors.EVENT_READ&lt;/code&gt; 读取到事件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;data&lt;/code&gt; 用来存储任何你 socket 中想存的数据，当 &lt;code&gt;select()&lt;/code&gt; 返回的时候它也会返回。我们将使用 &lt;code&gt;data&lt;/code&gt; 来跟踪 socket 上发送或者接收的东西&lt;/p&gt;

&lt;p&gt;下面就是事件循环：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import selectors
sel = selectors.DefaultSelector()

# ...

while True:
    events = sel.select(timeout=None)
    for key, mask in events:
        if key.data is None:
            accept_wrapper(key.fileobj)
        else:
            service_connection(key, mask)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sel.select(timeout=None)&lt;/code&gt; 调用会阻塞直到 socket I/O 就绪。它返回一个(key, events) 元组，每个 socket 一个。key 就是一个包含 &lt;code&gt;fileobj&lt;/code&gt; 属性的具名元组。&lt;code&gt;key.fileobj&lt;/code&gt; 是一个 socket 对象，&lt;code&gt;mask&lt;/code&gt; 表示一个操作就绪的事件掩码&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;key.data&lt;/code&gt; 为空，我们就可以知道它来自于监听 socket，我们需要调用 &lt;code&gt;accept()&lt;/code&gt; 方法来授受连接请求。我们将使用一个 &lt;code&gt;accept()&lt;/code&gt; 包装函数来获取新的 socket 对象并注册到 &lt;code&gt;selector&lt;/code&gt; 上，我们马上就会看到&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;key.data&lt;/code&gt; 不为空，我们就可以知道它是一个被接受的客户端 socket，我们需要为它服务，接着 &lt;code&gt;service_connection()&lt;/code&gt; 会传入 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;mask&lt;/code&gt; 参数并调用，这包含了所有我们需要在 socket 上操作的东西&lt;/p&gt;

&lt;p&gt;让我们一起来看看 &lt;code&gt;accept_wrapper()&lt;/code&gt; 方法做了什么：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def accept_wrapper(sock):
    conn, addr = sock.accept()  # Should be ready to read
    print(&#39;accepted connection from&#39;, addr)
    conn.setblocking(False)
    data = types.SimpleNamespace(addr=addr, inb=b&#39;&#39;, outb=b&#39;&#39;)
    events = selectors.EVENT_READ | selectors.EVENT_WRITE
    sel.register(conn, events, data=data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于监听 socket 被注册到了 &lt;code&gt;selectors.EVENT_READ&lt;/code&gt; 上，它现在就能被读取，我们调用 &lt;code&gt;sock.accept()&lt;/code&gt; 后立即再立即调 &lt;code&gt;conn.setblocking(False)&lt;/code&gt; 来让 socket 进入非阻塞模式&lt;/p&gt;

&lt;p&gt;请记住，这是这个版本服务器程序的主要目标，因为我们不希望它被阻塞。如果被阻塞，那么整个服务器在返回前都处于挂起状态。这意味着其它 socket 处于等待状态，这是一种 &lt;strong&gt;非常严重的&lt;/strong&gt; 谁都不想见到的服务被挂起的状态&lt;/p&gt;

&lt;p&gt;接着我们使用了 &lt;code&gt;types.SimpleNamespace&lt;/code&gt; 类创建了一个对象用来保存我们想要的 socket 和数据，由于我们得知道客户端连接什么时候可以写入或者读取，下面两个事件都会被用到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;events = selectors.EVENT_READ | selectors.EVENT_WRITE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事件掩码、socket 和数据对象都会被传入 &lt;code&gt;sel.register()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;现在让我们来看下，当客户端 socket 就绪的时候连接请求是如何使用 &lt;code&gt;service_connection()&lt;/code&gt; 来处理的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def service_connection(key, mask):
    sock = key.fileobj
    data = key.data
    if mask &amp;amp; selectors.EVENT_READ:
        recv_data = sock.recv(1024)  # Should be ready to read
        if recv_data:
            data.outb += recv_data
        else:
            print(&#39;closing connection to&#39;, data.addr)
            sel.unregister(sock)
            sock.close()
    if mask &amp;amp; selectors.EVENT_WRITE:
        if data.outb:
            print(&#39;echoing&#39;, repr(data.outb), &#39;to&#39;, data.addr)
            sent = sock.send(data.outb)  # Should be ready to write
            data.outb = data.outb[sent:]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是多连接服务端的核心部分，&lt;code&gt;key&lt;/code&gt; 就是从调用 &lt;code&gt;select()&lt;/code&gt; 方法返回的一个具名元组，它包含了 socket 对象「fileobj」和数据对象。&lt;code&gt;mask&lt;/code&gt; 包含了就绪的事件&lt;/p&gt;

&lt;p&gt;如果 socket 就绪而且可以被读取，&lt;code&gt;mask &amp;amp; selectors.EVENT_READ&lt;/code&gt; 就为真，&lt;code&gt;sock.recv()&lt;/code&gt; 会被调用。所有读取到的数据都会被追加到 &lt;code&gt;data.outb&lt;/code&gt; 里面。随后被发送出去&lt;/p&gt;

&lt;p&gt;注意 &lt;code&gt;else:&lt;/code&gt; 语句，如果没有收到任何数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if recv_data:
    data.outb += recv_data
else:
    print(&#39;closing connection to&#39;, data.addr)
    sel.unregister(sock)
    sock.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这表示客户端关闭了它的 socket 连接，这时服务端也应该关闭自己的连接。不过别忘了先调用 &lt;code&gt;sel.unregister()&lt;/code&gt; 来撤销 &lt;code&gt;select()&lt;/code&gt; 的监控&lt;/p&gt;

&lt;p&gt;当 socket 就绪而且可以被读取的时候，对于正常的 socket 应该一直是这种状态，任何接收并被 &lt;code&gt;data.outb&lt;/code&gt; 存储的数据都将使用 &lt;code&gt;sock.send()&lt;/code&gt; 方法打印出来。发送出去的字节随后就会被从缓冲中删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data.outb = data.outb[sent:]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;多连接的客户端&#34;&gt;多连接的客户端&lt;/h3&gt;

&lt;p&gt;现在让我们一起来看看多连接的客户端程序，&lt;code&gt;multiconn-client.py&lt;/code&gt;，它和服务端很相似，不一样的是它没有监听连接请求，它以调用 &lt;code&gt;start_connections()&lt;/code&gt; 开始初始化连接：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;messages = [b&#39;Message 1 from client.&#39;, b&#39;Message 2 from client.&#39;]


def start_connections(host, port, num_conns):
    server_addr = (host, port)
    for i in range(0, num_conns):
        connid = i + 1
        print(&#39;starting connection&#39;, connid, &#39;to&#39;, server_addr)
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setblocking(False)
        sock.connect_ex(server_addr)
        events = selectors.EVENT_READ | selectors.EVENT_WRITE
        data = types.SimpleNamespace(connid=connid,
                                     msg_total=sum(len(m) for m in messages),
                                     recv_total=0,
                                     messages=list(messages),
                                     outb=b&#39;&#39;)
        sel.register(sock, events, data=data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;num_conns&lt;/code&gt; 参数是从命令行读取的，表示为服务器建立多少个链接。就像服务端程序一样，每个 socket 都设置成了非阻塞模式&lt;/p&gt;

&lt;p&gt;由于 &lt;code&gt;connect()&lt;/code&gt; 方法会立即触发一个 &lt;code&gt;BlockingIOError&lt;/code&gt; 异常，所以我们使用 &lt;code&gt;connect_ex()&lt;/code&gt; 方法取代它。&lt;code&gt;connect_ex()&lt;/code&gt; 会返回一个错误指示 &lt;code&gt;errno.EINPROGRESS&lt;/code&gt;，不像 &lt;code&gt;connect()&lt;/code&gt; 方法直接在进程中返回异常。一旦连接结束，socket 就可以进行读写并且通过 &lt;code&gt;select()&lt;/code&gt; 方法返回&lt;/p&gt;

&lt;p&gt;socket 建立完成后，我们将使用 &lt;code&gt;types.SimpleNamespace&lt;/code&gt; 类创建想会传送的数据。由于每个连接请求都会调用 &lt;code&gt;socket.send()&lt;/code&gt;，发送到服务端的消息得使用 &lt;code&gt;list(messages)&lt;/code&gt; 方法转换成列表结构。所有你想了解的东西，包括客户端将要发送的、已发送的、已接收的消息以及消息的总字节数都存储在 &lt;code&gt;data&lt;/code&gt; 对象中&lt;/p&gt;

&lt;p&gt;让我们再来看看 &lt;code&gt;service_connection()&lt;/code&gt;。基本上和服务端一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;def service_connection(key, mask):
    sock = key.fileobj
    data = key.data
    if mask &amp;amp; selectors.EVENT_READ:
        recv_data = sock.recv(1024)  # Should be ready to read
        if recv_data:
            print(&#39;received&#39;, repr(recv_data), &#39;from connection&#39;, data.connid)
            data.recv_total += len(recv_data)
        if not recv_data or data.recv_total == data.msg_total:
            print(&#39;closing connection&#39;, data.connid)
            sel.unregister(sock)
            sock.close()
    if mask &amp;amp; selectors.EVENT_WRITE:
        if not data.outb and data.messages:
            data.outb = data.messages.pop(0)
        if data.outb:
            print(&#39;sending&#39;, repr(data.outb), &#39;to connection&#39;, data.connid)
            sent = sock.send(data.outb)  # Should be ready to write
            data.outb = data.outb[sent:]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有一个不同的地方，客户端会跟踪从服务器接收的字节数，根据结果来决定是否关闭 socket 连接，服务端检测到客户端关闭则会同样的关闭服务端的连接&lt;/p&gt;

&lt;h3 id=&#34;运行多连接的客户端和服务端&#34;&gt;运行多连接的客户端和服务端&lt;/h3&gt;

&lt;p&gt;现在让我们把 &lt;code&gt;multiconn-server.py&lt;/code&gt; 和 &lt;code&gt;multiconn-client.py&lt;/code&gt; 两个程序跑起来。他们都使用了命令行参数，如果不指定参数可以看到参数调用的方法：&lt;/p&gt;

&lt;p&gt;服务端程序，传入主机和端口号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./multiconn-server.py
usage: ./multiconn-server.py &amp;lt;host&amp;gt; &amp;lt;port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端程序，传入启动服务端程序时同样的主机和端口号以及连接数量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./multiconn-client.py
usage: ./multiconn-client.py &amp;lt;host&amp;gt; &amp;lt;port&amp;gt; &amp;lt;num_connections&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面就是服务端程序运行起来在 65432 端口上监听回环地址的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./multiconn-server.py 127.0.0.1 65432
listening on (&#39;127.0.0.1&#39;, 65432)
accepted connection from (&#39;127.0.0.1&#39;, 61354)
accepted connection from (&#39;127.0.0.1&#39;, 61355)
echoing b&#39;Message 1 from client.Message 2 from client.&#39; to (&#39;127.0.0.1&#39;, 61354)
echoing b&#39;Message 1 from client.Message 2 from client.&#39; to (&#39;127.0.0.1&#39;, 61355)
closing connection to (&#39;127.0.0.1&#39;, 61354)
closing connection to (&#39;127.0.0.1&#39;, 61355)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是客户端，它创建了两个连接请求到上面的服务端：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./multiconn-client.py 127.0.0.1 65432 2
starting connection 1 to (&#39;127.0.0.1&#39;, 65432)
starting connection 2 to (&#39;127.0.0.1&#39;, 65432)
sending b&#39;Message 1 from client.&#39; to connection 1
sending b&#39;Message 2 from client.&#39; to connection 1
sending b&#39;Message 1 from client.&#39; to connection 2
sending b&#39;Message 2 from client.&#39; to connection 2
received b&#39;Message 1 from client.Message 2 from client.&#39; from connection 1
closing connection 1
received b&#39;Message 1 from client.Message 2 from client.&#39; from connection 2
closing connection 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;应用程序客户端和服务端&#34;&gt;应用程序客户端和服务端&lt;/h2&gt;

&lt;p&gt;多连接的客户端和服务端程序版本与最早的原始版本相比肯定有了很大的改善，但是让我们再进一步地解决上面「多连接」版本中的不足，然后完成最终版的实现：客户端/服务器应用程序&lt;/p&gt;

&lt;p&gt;我们希望有个客户端和服务端在不影响其它连接的情况下做好错误处理，显然，如果没有发生异常，我们的客户端和服务端不能崩溃的一团糟。这也是到现在为止我们还没讨论的东西，我故意没有引入错误处理机制因为这样可以使之前的程序容易理解&lt;/p&gt;

&lt;p&gt;现在你对基本的 API，非阻塞 socket、select() 等概念已经有所了解了。我们可以继续添加一些错误处理同时讨论下「&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%88%BF%E9%96%93%E8%A3%8F%E7%9A%84%E5%A4%A7%E8%B1%A1&#34;&gt;房间里面的大象&lt;/a&gt;」的问题，我把一些东西隐藏在了幕后。你应该还记得，我在介绍中讨论到的自定义类&lt;/p&gt;

&lt;p&gt;首先，让我们先解决错误：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;所有的错误都会触发异常，像无效参数类型和内存不足的常见异常可以被抛出；从 Python
3.3 开始，与 socket 或地址语义相关的错误会引发 OSError 或其子类之一的异常 &lt;a href=&#34;https://docs.python.org/3/library/socket.html&#34;&gt;引用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们需要捕获 &lt;code&gt;OSError&lt;/code&gt; 异常。另外一个我没提及的的问题是延迟，你将在文档的很多地方看见关于延迟的讨论，延迟会发生而且属于「正常」错误。主机或者路由器重启、交换机端口出错、电缆出问题或者被拔出，你应该在你的代码中处理好各种各样的错误&lt;/p&gt;

&lt;p&gt;刚才说的「房间里面的大象」问题是怎么回事呢。就像 &lt;code&gt;socket.SOCK_STREAM&lt;/code&gt; 这个参数的字面意思一样，当使用 TCP 连接时，你会从一个连续的字节流读取的数据，好比从磁盘上读取数据，不同的是你是从网络读取字节流&lt;/p&gt;

&lt;p&gt;然而，和使用 &lt;code&gt;f.seek()&lt;/code&gt; 读文件不同，换句话说，没法定位 socket 的数据流的位置，如果可以像文件一样定位数据流的位置（使用下标），那你就可以随意的读取你想要的数据&lt;/p&gt;

&lt;p&gt;当字节流入你的 socket 时，会需要有不同的网络缓冲区，如果想读取他们就必须先保存到其它地方，使用 &lt;code&gt;recv()&lt;/code&gt; 方法持续的从 socket 上读取可用的字节流&lt;/p&gt;

&lt;p&gt;相当于你从 socket 中读取的是一块一块的数据，你必须使用 &lt;code&gt;recv()&lt;/code&gt; 方法不断的从缓冲区中读取数据，直到你的应用确定读取到了足够的数据&lt;/p&gt;

&lt;p&gt;什么时候算「足够」这取决于你的定义，就 TCP socket 而言，它只通过网络发送或接收原始字节。它并不了解这些原始字节的含义&lt;/p&gt;

&lt;p&gt;这可以让我们定义一个应用层协议，什么是应用层协议？简单来说，你的应用会发送或者接收消息，这些消息其实就是你的应用程序的协议&lt;/p&gt;

&lt;p&gt;换句话说，这些消息的长度、格式可以定义应用程序的语义和行为，这和我们之前说的从socket 中读取字节部分内容相关，当你使用 &lt;code&gt;recv()&lt;/code&gt; 来读取字节的时候，你需要知道读的字节数，并且决定什么时候算读取完成&lt;/p&gt;

&lt;p&gt;这些都是怎么完成的呢？一个方法是只读取固定长度的消息，如果它们的长度总是一样的话，这样做很容易。当你收到固定长度字节消息的时候，就能确定它是个完整的消息&lt;/p&gt;

&lt;p&gt;然而，如果你使用定长模式来发送比较短的消息会比较低效，因为你还得处理填充剩余的部分，此外，你还得处理数据不适合放在一个定长消息里面的情况&lt;/p&gt;

&lt;p&gt;在这个教程里面，我们将使用一个通用的方案，很多协议都会用到它，包括 HTTP。我们将在每条消息前面追加一个头信息，头信息中包括消息的长度和其它我们需要的字段。这样做的话我们只需要追踪头信息，当我们读到头信息时，就可以查到消息的长度并且读出所有字节然后消费它&lt;/p&gt;

&lt;p&gt;我们将通过使用一个自定义类来实现接收文本/二进制数据。你可以在此基础上做出改进或者通过继承这个类来扩展你的应用程序。重要的是你将看到一个例子实现它的过程&lt;/p&gt;

&lt;p&gt;我将会提到一些关于 socket 和字节相关的东西，就像之前讨论过的。当你通过 socket 来发送或者接收数据时，其实你发送或者接收到的是原始字节&lt;/p&gt;

&lt;p&gt;如果你收到数据并且想让它在一个多字节解释的上下文中使用，比如说 4-byte 的整形，你需要考虑它可能是一种不是你机器 CPU 本机的格式。客户端或者服务器的另外一头可能是另外一种使用了不同的字节序列的 CPU，这样的话，你就得把它们转换成你主机的本地字节序列来使用&lt;/p&gt;

&lt;p&gt;上面所说的字节顺序就是 CPU 的 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F&#34;&gt;字节序&lt;/a&gt;，在引用部分的字节序 一节可以查看更多。我们将会利用 Unicode 字符集的优点来规避这个问题，并使用UTF-8 的方式编码，由于 UTF-8 使用了 8字节 编码方式，所以就不会有字节序列的问题&lt;/p&gt;

&lt;p&gt;你可以查看 Python 关于编码与 Unicode 的 &lt;a href=&#34;https://docs.python.org/3/library/codecs.html#encodings-and-unicode&#34;&gt;文档&lt;/a&gt;，注意我们只会编码消息的头部。我们将使用严格的类型，发送的消息编码格式会在头信息中定义。这将让我们可以传输我们觉得有用的任意类型/格式数据&lt;/p&gt;

&lt;p&gt;你可以通过调用 &lt;code&gt;sys.byteorder&lt;/code&gt; 来决定你的机器的字节序列，比如在我的英特尔笔记本上，运行下面的代码就可以：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python3 -c &#39;import sys; print(repr(sys.byteorder))&#39;
&#39;little&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我把这段代码跑在可以模拟大字节序 CPU「PowerPC」的虚拟机上的话，应该是下面的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python3 -c &#39;import sys; print(repr(sys.byteorder))&#39;
&#39;big&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们的例子程序中，应用层的协议定义了使用 UTF-8 方式编码的 Unicode 字符。对于真正传输消息来说，如果需要的话你还是得手动交换字节序列&lt;/p&gt;

&lt;p&gt;这取决于你的应用，是否需要它来处理不同终端间的多字节二进制数据，你可以通过添加额外的头信息来让你的客户端或者服务端支持二进制，像 HTTP 一样，把头信息做为参数传进去&lt;/p&gt;

&lt;p&gt;不用担心自己还没搞懂上面的东西，下面一节我们看到是如果实现的&lt;/p&gt;

&lt;h3 id=&#34;应用的协议头&#34;&gt;应用的协议头&lt;/h3&gt;

&lt;p&gt;让我们来定义一个完整的协议头：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可变长度的文本&lt;/li&gt;
&lt;li&gt;基于 UTF-8 编码的 Unicode 字符集&lt;/li&gt;
&lt;li&gt;使用 JSON 序列化的一个 Python 字典&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中必须具有的头应该有以下几个：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;byteorder&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;机器的字节序列（uses sys.byteorder），应用程序可能用不上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;content-length&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内容的字节长度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;content-type&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内容的类型，比如 text/json 或者 binary/my-binary-type&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;content-encoding&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内容的编码类型，比如 utf-8 编码的 Unicode 文本，二进制数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这些头信息告诉接收者消息数据，这样的话你就可以通过提供给接收者足够的信息让他接收到数据的时候正确的解码的方式向它发送任何数据，由于头信息是字典格式，你可以随意向头信息中添加键值对&lt;/p&gt;

&lt;h3 id=&#34;发送应用程序消息&#34;&gt;发送应用程序消息&lt;/h3&gt;

&lt;p&gt;不过还有一个问题，由于我们使用了变长的头信息，虽然方便扩展但是当你使用 &lt;code&gt;recv()&lt;/code&gt; 方法读取消息的时候怎么知道头信息的长度呢&lt;/p&gt;

&lt;p&gt;我们前面讲到过使用 &lt;code&gt;recv()&lt;/code&gt; 接收数据和如何确定是否接收完成，我说过定长的头可能会很低效，的确如此。但是我们将使用一个比较小的 2 字节定长的头信息前缀来表示头信息的长度&lt;/p&gt;

&lt;p&gt;你可以认为这是一种混合的发送消息的实现方法，我们通过发送头信息长度来引导接收者，方便他们解析消息体&lt;/p&gt;

&lt;p&gt;为了给你更好地解释消息格式，让我们来看看消息的全貌：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://files.realpython.com/media/sockets-app-message.2e131b0751e3.jpg&#34; alt=&#34;message&#34; /&gt;&lt;/p&gt;

&lt;p&gt;消息以 2字节的固定长度的头开始，这两个字节是整型的网络字节序列，表示下面的变长 JSON 头信息的长度，当我们从 &lt;code&gt;recv()&lt;/code&gt; 方法读取到 2 个字节时就知道它表示的是头信息长度的整形数字，然后在解码 JSON 头之前读取这么多的字节&lt;/p&gt;

&lt;p&gt;JSON 头包含了头信息的字典。其中一个就是 &lt;code&gt;content-length&lt;/code&gt;，这表示消息内容的数量（不是JSON头），当我们使用 &lt;code&gt;recv()&lt;/code&gt; 方法读取到了 &lt;code&gt;content-length&lt;/code&gt; 个字节的数据时，就表示接收完成并且读取到了完整的消息&lt;/p&gt;

&lt;h3 id=&#34;应用程序类&#34;&gt;应用程序类&lt;/h3&gt;

&lt;p&gt;最后让我们来看下成果，我们使用了一个消息类。来看看它是如何在 socket 发生读写事件时与 &lt;code&gt;select()&lt;/code&gt; 配合使用的&lt;/p&gt;

&lt;p&gt;对于这个示例应用程序而言，我必须想出客户端和服务器将使用什么类型的消息，从这一点来讲这远远超过了最早时候我们写的那个玩具一样的打印程序&lt;/p&gt;

&lt;p&gt;为了保证程序简单而且仍然能够演示出它是如何在一个真正的程序中工作的，我创建了一个应用程序协议用来实现基本的搜索功能。客户端发送一个搜索请求，服务器做一次匹配的查找，如果客户端的请求没法被识别成搜索请求，服务器就会假定这个是二进制请求，对应的返回二进制响应&lt;/p&gt;

&lt;p&gt;跟着下面一节，运行示例、用代码做实验后你将会知道他是如何工作的，然后你就可以以这个消息类为起点把他修改成适合自己使用的&lt;/p&gt;

&lt;p&gt;就像我们之前讨论的，你将在下面看到，处理 socket 时需要保存状态。通过使用类，我们可以将所有的状态、数据和代码打包到一个地方。当连接开始或者接受的时候消息类就会为每个 socket 创建一个实例&lt;/p&gt;

&lt;p&gt;类中的很多包装方法、工具方法在客户端和服务端上都是差不多的。它们以下划线开头，就像 &lt;code&gt;Message._json_encode()&lt;/code&gt; 一样，这些方法通过类使用起来很简单。这使得它们在其它方法中调用时更短，而且符合 &lt;a href=&#34;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&#34;&gt;DRY&lt;/a&gt; 原则&lt;/p&gt;

&lt;p&gt;消息类的服务端程序本质上和客户端一样。不同的是客户端初始化连接并发送请求消息，随后要处理服务端返回的内容。而服务端则是等待连接请求，处理客户端的请求消息，随后发送响应消息&lt;/p&gt;

&lt;p&gt;看起来就像这样：&lt;/p&gt;

&lt;p&gt;步骤 | 端     | 动作/消息内容
:-   | :-     | :-
1    | 客户端 | 发送带有请求内容的消息
2    | 服务端 | 接收并处理请求消息
3    | 服务端 | 发送有响应内容的消息
4    | 客户端 | 接收并处理响应消息&lt;/p&gt;

&lt;p&gt;下面是代码的结构：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;应用程序&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;文件&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;代码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;服务端&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;app-server.py&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;服务端主程序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;服务端&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;libserver.py&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;服务端消息类&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;客户端&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;app-client.py&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;客户端主程序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;客户端&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;libclient.py&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;客户端消息类&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;消息入口点&#34;&gt;消息入口点&lt;/h3&gt;

&lt;p&gt;我想通过首先提到它的设计方面来讨论 Message 类的工作方式，不过这对我来说并不是立马就能解释清楚的，只有在重构它至少五次之后我才能达到它目前的状态。为什么呢？因为要管理状态&lt;/p&gt;

&lt;p&gt;当消息对象创建的时候，它就被一个使用 &lt;code&gt;selector.register()&lt;/code&gt; 事件监控起来的 socket 关联起来了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;message = libserver.Message(sel, conn, addr)
sel.register(conn, selectors.EVENT_READ, data=message)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意，这一节中的一些代码来自服务端主程序与消息类，但是这部分内容的讨论在客户端
也是一样的，我将在他们之间存在不同点的时候来解释客户端的版本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当 socket 上的事件就绪的时候，它就会被 &lt;code&gt;selector.select()&lt;/code&gt; 方法返回。对过 key 对象的 data 属性获取到 message 的引用，然后在消息用调用一个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;while True:
    events = sel.select(timeout=None)
    for key, mask in events:
        # ...
        message = key.data
        message.process_events(mask)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;观察上面的事件循环，可以看见 &lt;code&gt;sel.select()&lt;/code&gt; 位于「司机位置」，它是阻塞的，在循环的上面等待。当 socket 上的读写事件就绪时，它就会为其服务。这表示间接的它也要负责调用 &lt;code&gt;process_events()&lt;/code&gt; 方法。这就是我说 &lt;code&gt;process_events()&lt;/code&gt; 方法是入口的原因&lt;/p&gt;

&lt;p&gt;让我们来看下 &lt;code&gt;process_events()&lt;/code&gt; 方法做了什么&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def process_events(self, mask):
    if mask &amp;amp; selectors.EVENT_READ:
        self.read()
    if mask &amp;amp; selectors.EVENT_WRITE:
        self.write()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做很好，因为 &lt;code&gt;process_events()&lt;/code&gt; 方法很简洁，它只可以做两件事情：调用 &lt;code&gt;read()&lt;/code&gt; 和 &lt;code&gt;write()&lt;/code&gt; 方法&lt;/p&gt;

&lt;p&gt;这又把我们带回了状态管理的问题。在几次重构后，我决定如果别的方法依赖于状态变量里面的某个确定值，那么它们就只应该从 &lt;code&gt;read()&lt;/code&gt; 和 &lt;code&gt;write()&lt;/code&gt; 方法中调用，这将使处理socket 事件的逻辑尽量的简单&lt;/p&gt;

&lt;p&gt;可能说起来很简单，但是经历了前面几次类的迭代：混合了一些方法，检查当前状态、依赖于其它值、在 &lt;code&gt;read()&lt;/code&gt; 或者 &lt;code&gt;write()&lt;/code&gt; 方法外面调用处理数据的方法，最后这证明了这样管理起来很复杂&lt;/p&gt;

&lt;p&gt;当然，你肯定需要把类按你自己的需求修改使它能够符合你的预期，但是我建议你尽可能把状态检查、依赖状态的调用的逻辑放在 &lt;code&gt;read()&lt;/code&gt; 和 &lt;code&gt;write()&lt;/code&gt; 方法里面&lt;/p&gt;

&lt;p&gt;让我们来看看 &lt;code&gt;read()&lt;/code&gt; 方法，这是服务端版本，但是客户端也是一样的。不同之处在于方法名称，一个（客户端）是 &lt;code&gt;process_response()&lt;/code&gt; 另一个（服务端）是 &lt;code&gt;process_request()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def read(self):
    self._read()

    if self._jsonheader_len is None:
        self.process_protoheader()

    if self._jsonheader_len is not None:
        if self.jsonheader is None:
            self.process_jsonheader()

    if self.jsonheader:
        if self.request is None:
            self.process_request()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;_read()&lt;/code&gt; 方法首页被调用，然后调用 &lt;code&gt;socket.recv()&lt;/code&gt; 从 socket 读取数据并存入到接收缓冲区&lt;/p&gt;

&lt;p&gt;记住，当调用 &lt;code&gt;socket.recv()&lt;/code&gt; 方法时，组成消息的所有数据并没有一次性全部到达。&lt;code&gt;socket.recv()&lt;/code&gt; 方法可能需要调用很多次，这就是为什么在调用相关方法处理数据前每次都要检查状态&lt;/p&gt;

&lt;p&gt;当一个方法开始处理消息时，首页要检查的就是接受缓冲区保存了足够的多读取的数据，如果确定，它们将继续处理各自的数据，然后把数据存到其它流程可能会用到的变量上，并且清空自己的缓冲区。由于一个消息有三个组件，所以会有三个状态检查和处理方法的调用：&lt;/p&gt;

&lt;p&gt;Message Component   | Method                | Output
&amp;ndash;                  | &amp;ndash;                    | &amp;ndash;
Fixed-length header | process_protoheader() | self._jsonheader_len
JSON header         | process_jsonheader()  | self.jsonheader
Content             | process_request()     | self.request&lt;/p&gt;

&lt;p&gt;接下来，让我们一起看看 &lt;code&gt;write()&lt;/code&gt; 方法，这是服务端的版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def write(self):
    if self.request:
        if not self.response_created:
            self.create_response()

    self._write()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;write()&lt;/code&gt; 方法会首先检测是否有请求，如果有而且响应还没被创建的话 &lt;code&gt;create_response()&lt;/code&gt; 方法就会被调用，它会设置状态变量 &lt;code&gt;response_created&lt;/code&gt;，然后为发送缓冲区写入响应&lt;/p&gt;

&lt;p&gt;如果发送缓冲区有数据，&lt;code&gt;write()&lt;/code&gt; 方法会调用 &lt;code&gt;socket.send()&lt;/code&gt; 方法&lt;/p&gt;

&lt;p&gt;记住，当 &lt;code&gt;socket.send()&lt;/code&gt; 被调用时，所有发送缓冲区的数据可能还没进入到发送队列，socket 的网络缓冲区可能满了，&lt;code&gt;socket.send()&lt;/code&gt; 可能需要重新调用，这就是为什么需要检查状态的原因，&lt;code&gt;create_response()&lt;/code&gt; 应该只被调用一次，但是 &lt;code&gt;_write()&lt;/code&gt; 方法需要调用多次&lt;/p&gt;

&lt;p&gt;客户端的 &lt;code&gt;write()&lt;/code&gt; 版大体与服务端一致：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def write(self):
    if not self._request_queued:
        self.queue_request()

    self._write()

    if self._request_queued:
        if not self._send_buffer:
            # Set selector to listen for read events, we&#39;re done writing.
            self._set_selector_events_mask(&#39;r&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为客户端首页初始化了一个连接请求到服务端，状态变量&lt;code&gt;_request_queued&lt;/code&gt;被检查。如果请求还没加入到队列，就调用 &lt;code&gt;queue_request()&lt;/code&gt; 方法创建一个请求写入到发送缓冲区中，同时也会使用变量 &lt;code&gt;_request_queued&lt;/code&gt; 记录状态值防止多次调用&lt;/p&gt;

&lt;p&gt;就像服务端一样，如果发送缓冲区有数据 &lt;code&gt;_write()&lt;/code&gt; 方法会调用 &lt;code&gt;socket.send()&lt;/code&gt; 方法&lt;/p&gt;

&lt;p&gt;需要注意客户端版本的 &lt;code&gt;write()&lt;/code&gt; 方法与服务端不同之处在于最后的请求是否加入到队列中的检查，这个我们将在客户端主程序中详细解释，原因是要告诉 &lt;code&gt;selector.select()&lt;/code&gt;停止监控 socket 的写入事件而且我们只对读取事件感兴趣，没有办法通知套接字是可写的&lt;/p&gt;

&lt;p&gt;我将在这一节中留下一个悬念，这一节的主要目的是解释 &lt;code&gt;selector.select()&lt;/code&gt; 方法是如何通过 &lt;code&gt;process_events()&lt;/code&gt; 方法调用消息类以及它是如何工作的&lt;/p&gt;

&lt;p&gt;这一点很重要，因为 &lt;code&gt;process_events()&lt;/code&gt; 方法在连接的生命周期中将被调用很多次，因此，要确保那些只能被调用一次的方法正常工作，这些方法中要么需要检查自己的状态变量，要么需要检查调用者的方法中的状态变量&lt;/p&gt;

&lt;h3 id=&#34;服务端主程序&#34;&gt;服务端主程序&lt;/h3&gt;

&lt;p&gt;在服务端主程序 &lt;code&gt;app-server.py&lt;/code&gt; 中，主机、端口参数是通过命令行传递给程序的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./app-server.py
usage: ./app-server.py &amp;lt;host&amp;gt; &amp;lt;port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如需求监听本地回环地址上面的 65432 端口，需要执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./app-server.py 127.0.0.1 65432
listening on (&#39;127.0.0.1&#39;, 65432)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;host&amp;gt;&lt;/code&gt; 参数为空的话就可以监听主机上的所有 IP 地址&lt;/p&gt;

&lt;p&gt;创建完 socket 后，一个传入参数 &lt;code&gt;socket.SO_REUSEADDR&lt;/code&gt; 的方法 &lt;code&gt;to
socket.setsockopt()&lt;/code&gt; 将被调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Avoid bind() exception: OSError: [Errno 48] Address already in use
lsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置这个参数是为了避免 &lt;code&gt;端口被占用&lt;/code&gt; 的错误发生，如果当前程序使用的端口和之前的程序使用的一样，你就会发现连接处于 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态&lt;/p&gt;

&lt;p&gt;比如说，如果服务器主动关闭连接，服务器会保持为大概两分钟的 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态，具体时长取决于你的操作系统。如果你想在两分钟内再开启一个服务，你将得到一个&lt;code&gt;OSError&lt;/code&gt; 表示 &lt;code&gt;端口被战胜&lt;/code&gt;，这样做是为了确保一些在途的数据包正确的被处理&lt;/p&gt;

&lt;p&gt;事件循环会捕捉所有错误，以保证服务器正常运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;while True:
    events = sel.select(timeout=None)
    for key, mask in events:
        if key.data is None:
            accept_wrapper(key.fileobj)
        else:
            message = key.data
            try:
                message.process_events(mask)
            except Exception:
                print(&#39;main: error: exception for&#39;,
                      f&#39;{message.addr}:\n{traceback.format_exc()}&#39;)
                message.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当服务器接受到一个客户端连接时，消息对象就会被创建：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;def accept_wrapper(sock):
    conn, addr = sock.accept()  # Should be ready to read
    print(&#39;accepted connection from&#39;, addr)
    conn.setblocking(False)
    message = libserver.Message(sel, conn, addr)
    sel.register(conn, selectors.EVENT_READ, data=message)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;消息对象会通过 &lt;code&gt;sel.register()&lt;/code&gt; 方法关联到 socket 上，而且它初始化就被设置成了只监控读事件。当请求被读取时，我们将通过监听到的写事件修改它&lt;/p&gt;

&lt;p&gt;在服务器端采用这种方法的一个优点是，大多数情况下，当 socket 正常并且没有网络问题时，它始终是可写的&lt;/p&gt;

&lt;p&gt;如果我们告诉 &lt;code&gt;sel.register()&lt;/code&gt; 方法监控 &lt;code&gt;EVENT_WRITE&lt;/code&gt; 写入事件，事件循环将会立即唤醒并通知我们这种情况，然而此时 socket 并不用唤醒调用 &lt;code&gt;send()&lt;/code&gt; 方法。由于请求还没被处理，所以不需要发回响应。这将消耗并浪费宝贵的 CPU 周期&lt;/p&gt;

&lt;h3 id=&#34;服务端消息类&#34;&gt;服务端消息类&lt;/h3&gt;

&lt;p&gt;在消息切入点一节中，当通过 &lt;code&gt;process_events()&lt;/code&gt; 知道 socket 事件就绪时我们可以看到消息对象是如何发出动作的。现在让我们来看看当数据在 socket 上被读取是会发生些什么，以及为服务器就绪的消息的组件片段发生了什么&lt;/p&gt;

&lt;p&gt;&lt;code&gt;libserver.py&lt;/code&gt; 文件中的服务端消息类，可以在 Github 上找到 &lt;a href=&#34;https://github.com/realpython/materials/tree/master/python-sockets-tutorial&#34;&gt;源代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这些方法按照消息处理顺序出现在类中&lt;/p&gt;

&lt;p&gt;当服务器读取到至少两个字节时，定长头的逻辑就可以开始了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def process_protoheader(self):
    hdrlen = 2
    if len(self._recv_buffer) &amp;gt;= hdrlen:
        self._jsonheader_len = struct.unpack(&#39;&amp;gt;H&#39;,
                                             self._recv_buffer[:hdrlen])[0]
        self._recv_buffer = self._recv_buffer[hdrlen:]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网络字节序列中的定长整型两字节包含了 JSON 头的长度，&lt;code&gt;struct.unpack()&lt;/code&gt; 方法用来读取并解码，然后保存在 &lt;code&gt;self._jsonheader_len&lt;/code&gt; 中，当这部分消息被处理完成后，就要调用 &lt;code&gt;process_protoheader()&lt;/code&gt; 方法来删除接收缓冲区中处理过的消息&lt;/p&gt;

&lt;p&gt;就像上面的定长头的逻辑一样，当接收缓冲区有足够的 JSON 头数据时，它也需要被处理：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def process_jsonheader(self):
    hdrlen = self._jsonheader_len
    if len(self._recv_buffer) &amp;gt;= hdrlen:
        self.jsonheader = self._json_decode(self._recv_buffer[:hdrlen],
                                            &#39;utf-8&#39;)
        self._recv_buffer = self._recv_buffer[hdrlen:]
        for reqhdr in (&#39;byteorder&#39;, &#39;content-length&#39;, &#39;content-type&#39;,
                       &#39;content-encoding&#39;):
            if reqhdr not in self.jsonheader:
                raise ValueError(f&#39;Missing required header &amp;quot;{reqhdr}&amp;quot;.&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;self._json_decode()&lt;/code&gt; 方法用来解码并反序列化 JSON 头成一个字典。由于我们定义的 JSON 头是 utf-8 格式的，所以解码方法调用时我们写死了这个参数，结果将被存放在 &lt;code&gt;self.jsonheader&lt;/code&gt; 中，&lt;code&gt;process_jsonheader&lt;/code&gt; 方法做完他应该做的事情后，同样需要删除接收缓冲区中处理过的消息&lt;/p&gt;

&lt;p&gt;接下来就是真正的消息内容，当接收缓冲区有 JSON 头中定义的 &lt;code&gt;content-length&lt;/code&gt; 值的数量个字节时，请求就应该被处理了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def process_request(self):
    content_len = self.jsonheader[&#39;content-length&#39;]
    if not len(self._recv_buffer) &amp;gt;= content_len:
        return
    data = self._recv_buffer[:content_len]
    self._recv_buffer = self._recv_buffer[content_len:]
    if self.jsonheader[&#39;content-type&#39;] == &#39;text/json&#39;:
        encoding = self.jsonheader[&#39;content-encoding&#39;]
        self.request = self._json_decode(data, encoding)
        print(&#39;received request&#39;, repr(self.request), &#39;from&#39;, self.addr)
    else:
        # Binary or unknown content-type
        self.request = data
        print(f&#39;received {self.jsonheader[&amp;quot;content-type&amp;quot;]} request from&#39;,
              self.addr)
    # Set selector to listen for write events, we&#39;re done reading.
    self._set_selector_events_mask(&#39;w&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把消息保存到 &lt;code&gt;data&lt;/code&gt; 变量中后，&lt;code&gt;process_request()&lt;/code&gt; 又会删除接收缓冲区中处理过的数据。接着，如果 content type 是 JSON 的话，它将解码并反序列化数据。否则（在我们的例子中）数据将被视 做二进制数据并打印出来&lt;/p&gt;

&lt;p&gt;最后 &lt;code&gt;process_request()&lt;/code&gt; 方法会修改 selector 为只监控写入事件。在服务端的程序 &lt;code&gt;app-server.py&lt;/code&gt; 中，socket 初始化被设置成仅监控读事件。现在请求已经被全部处理完了，我们对读取事件就不感兴趣了&lt;/p&gt;

&lt;p&gt;现在就可以创建一个响应写入到 socket 中。当 socket 可写时 &lt;code&gt;create_response()&lt;/code&gt; 将被从 &lt;code&gt;write()&lt;/code&gt; 方法中调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def create_response(self):
    if self.jsonheader[&#39;content-type&#39;] == &#39;text/json&#39;:
        response = self._create_response_json_content()
    else:
        # Binary or unknown content-type
        response = self._create_response_binary_content()
    message = self._create_message(**response)
    self.response_created = True
    self._send_buffer += message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;响应会根据不同的 content type 的不同而调用不同的方法创建。在这个例子中，当 &lt;code&gt;action == &#39;search&#39;&lt;/code&gt; 的时候会执行一个简单的字典查找。你可以在这个地方添加你自己的处理方法并调用&lt;/p&gt;

&lt;p&gt;一个不好处理的问题是响应写入完成时如何关闭连接，我会在 &lt;code&gt;_write()&lt;/code&gt; 方法中调用 &lt;code&gt;close()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def _write(self):
    if self._send_buffer:
        print(&#39;sending&#39;, repr(self._send_buffer), &#39;to&#39;, self.addr)
        try:
            # Should be ready to write
            sent = self.sock.send(self._send_buffer)
        except BlockingIOError:
            # Resource temporarily unavailable (errno EWOULDBLOCK)
            pass
        else:
            self._send_buffer = self._send_buffer[sent:]
            # Close when the buffer is drained. The response has been sent.
            if sent and not self._send_buffer:
                self.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然&lt;code&gt;close()&lt;/code&gt; 方法的调用有点隐蔽，但是我认为这是一种权衡。因为消息类一个连接只处理一条消息。写入响应后，服务器无需执行任何操作。它的任务就完成了&lt;/p&gt;

&lt;h3 id=&#34;客户端主程序&#34;&gt;客户端主程序&lt;/h3&gt;

&lt;p&gt;客户端主程序 &lt;code&gt;app-client.py&lt;/code&gt; 中，参数从命令行中读取，用来创建请求并连接到服务端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./app-client.py
usage: ./app-client.py &amp;lt;host&amp;gt; &amp;lt;port&amp;gt; &amp;lt;action&amp;gt; &amp;lt;value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来个示例演示一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./app-client.py 127.0.0.1 65432 search needle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当从命令行参数创建完一个字典来表示请求后，主机、端口、请求字典一起被传给 &lt;code&gt;start_connection()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def start_connection(host, port, request):
    addr = (host, port)
    print(&#39;starting connection to&#39;, addr)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setblocking(False)
    sock.connect_ex(addr)
    events = selectors.EVENT_READ | selectors.EVENT_WRITE
    message = libclient.Message(sel, sock, addr, request)
    sel.register(sock, events, data=message)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对服务器的 socket 连接被创建，消息对象被传入请求字典并创建&lt;/p&gt;

&lt;p&gt;和服务端一样，消息对象在 &lt;code&gt;sel.register()&lt;/code&gt; 方法中被关联到 socket 上。然而，客户端不同的是，socket 初始化的时候会监控读写事件，一旦请求被写入，我们将会修改为只监控读取事件&lt;/p&gt;

&lt;p&gt;这种实现和服务端一样有好处：不浪费 CPU 生命周期。请求发送完成后，我们就不关注写入事件了，所以不用保持状态等待处理&lt;/p&gt;

&lt;h3 id=&#34;客户端消息类&#34;&gt;客户端消息类&lt;/h3&gt;

&lt;p&gt;在 &lt;a href=&#34;#消息入口点&#34;&gt;消息入口点&lt;/a&gt; 一节中，我们看到过，当 socket 使用准备就绪时，消息对象是如何调用具体动作的。现在让我们来看看 socket 上的数据是如何被读写的，以及消息准备好被加工的时候发生了什么&lt;/p&gt;

&lt;p&gt;客户端消息类在 &lt;code&gt;libclient.py&lt;/code&gt; 文件中，可以在 Github 上找到 &lt;a href=&#34;https://github.com/realpython/materials/tree/master/python-sockets-tutorial&#34;&gt;源代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这些方法按照消息处理顺序出现在类中&lt;/p&gt;

&lt;p&gt;客户端的第一个任务就是让请求入队列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def queue_request(self):
    content = self.request[&#39;content&#39;]
    content_type = self.request[&#39;type&#39;]
    content_encoding = self.request[&#39;encoding&#39;]
    if content_type == &#39;text/json&#39;:
        req = {
            &#39;content_bytes&#39;: self._json_encode(content, content_encoding),
            &#39;content_type&#39;: content_type,
            &#39;content_encoding&#39;: content_encoding
        }
    else:
        req = {
            &#39;content_bytes&#39;: content,
            &#39;content_type&#39;: content_type,
            &#39;content_encoding&#39;: content_encoding
        }
    message = self._create_message(**req)
    self._send_buffer += message
    self._request_queued = True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用来创建请求的字典，取决于客户端程序 &lt;code&gt;app-client.py&lt;/code&gt; 中传入的命令行参数，当消息对象创建的时候，请求字典被当做参数传入&lt;/p&gt;

&lt;p&gt;请求消息被创建并追加到发送缓冲区中，消息将被 &lt;code&gt;_write()&lt;/code&gt; 方法发送，状态参数 &lt;code&gt;self._request_queued&lt;/code&gt; 被设置，这使 &lt;code&gt;queue_request()&lt;/code&gt; 方法不会被重复调用&lt;/p&gt;

&lt;p&gt;请求发送完成后，客户端就等待服务器的响应&lt;/p&gt;

&lt;p&gt;客户端读取和处理消息的方法和服务端一致，由于响应数据是从 socket 上读取的，所以处理 header 的方法会被调用：&lt;code&gt;process_protoheader()&lt;/code&gt; 和 &lt;code&gt;process_jsonheader()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最终处理方法名字的不同在于处理一个响应，而不是创建：&lt;code&gt;process_response()&lt;/code&gt;,&lt;code&gt;_process_response_json_content()&lt;/code&gt; 和 &lt;code&gt;_process_response_binary_content()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最后，但肯定不是最不重要的 —— 最终的 &lt;code&gt;process_response()&lt;/code&gt; 调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def process_response(self):
    # ...
    # Close when response has been processed
    self.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;消息类的包装&#34;&gt;消息类的包装&lt;/h3&gt;

&lt;p&gt;我将通过提及一些方法的重要注意点来结束消息类的讨论&lt;/p&gt;

&lt;p&gt;主程序中任意的类触发异常都由 &lt;code&gt;except&lt;/code&gt; 字句来处理：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;try:
    message.process_events(mask)
except Exception:
    print(&#39;main: error: exception for&#39;,
          f&#39;{message.addr}:\n{traceback.format_exc()}&#39;)
    message.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意最后一行的方法 &lt;code&gt;message.close()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这一行很重要的原因有很多，不仅仅是保证 socket 被关闭，而且通过调用 &lt;code&gt;message.close()&lt;/code&gt; 方法删除使用 &lt;code&gt;select()&lt;/code&gt; 监控的 socket，这是类中的一段非常简洁的代码，它能减小复杂度。如果一个异常发生或者我们自己主动抛出，我们很清楚 &lt;code&gt;close()&lt;/code&gt; 方法将处理善后&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Message._read()&lt;/code&gt; 和 &lt;code&gt;Message._write()&lt;/code&gt; 方法都包含一些有趣的东西：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def _read(self):
    try:
        # Should be ready to read
        data = self.sock.recv(4096)
    except BlockingIOError:
        # Resource temporarily unavailable (errno EWOULDBLOCK)
        pass
    else:
        if data:
            self._recv_buffer += data
        else:
            raise RuntimeError(&#39;Peer closed.&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 except 行：&lt;code&gt;except BlockingIOError&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_write()&lt;/code&gt; 方法也有，这几行很重要是因为它们捕获临时错误并通过使用 &lt;code&gt;pass&lt;/code&gt; 跳过。临时错误是 socket 阻塞的时候发生的，比如等待网络响应或者连接的其它端&lt;/p&gt;

&lt;p&gt;通过使用 &lt;code&gt;pass&lt;/code&gt; 跳过异常，&lt;code&gt;select()&lt;/code&gt; 方法将再次调用，我们将有机会重新读写数据&lt;/p&gt;

&lt;h3 id=&#34;运行应用程序的客户端和服务端&#34;&gt;运行应用程序的客户端和服务端&lt;/h3&gt;

&lt;p&gt;经过所有这些艰苦的工作后，让我们把程序运行起来并找到一些乐趣！&lt;/p&gt;

&lt;p&gt;在这个救命中，我们将传一个空的字符串做为 &lt;code&gt;host&lt;/code&gt; 参数的值，用来监听服务器端的所有IP 地址。这样的话我就可以从其它网络上的虚拟机运行客户端程序，我将模拟一个 PowerPC 的机器&lt;/p&gt;

&lt;p&gt;首页，把服务端程序运行进来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ ./app-server.py &#39;&#39; 65432
listening on (&#39;&#39;, 65432)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在让我们运行客户端，传入搜索内容，看看是否能看他（墨菲斯-黑客帝国中的角色）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ ./app-client.py 10.0.1.1 65432 search morpheus
starting connection to (&#39;10.0.1.1&#39;, 65432)
sending b&#39;\x00d{&amp;quot;byteorder&amp;quot;: &amp;quot;big&amp;quot;, &amp;quot;content-type&amp;quot;: &amp;quot;text/json&amp;quot;, &amp;quot;content-encoding&amp;quot;: &amp;quot;utf-8&amp;quot;, &amp;quot;content-length&amp;quot;: 41}{&amp;quot;action&amp;quot;: &amp;quot;search&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;morpheus&amp;quot;}&#39; to (&#39;10.0.1.1&#39;, 65432)
received response {&#39;result&#39;: &#39;Follow the white rabbit. 🐰&#39;} from (&#39;10.0.1.1&#39;, 65432)
got result: Follow the white rabbit. 🐰
closing connection to (&#39;10.0.1.1&#39;, 65432)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我的命令行 shell 使用了 utf-8 编码，所以上面的输出可以是 emojis&lt;/p&gt;

&lt;p&gt;再试试看能不能搜索到小狗：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ ./app-client.py 10.0.1.1 65432 search 🐶
starting connection to (&#39;10.0.1.1&#39;, 65432)
sending b&#39;\x00d{&amp;quot;byteorder&amp;quot;: &amp;quot;big&amp;quot;, &amp;quot;content-type&amp;quot;: &amp;quot;text/json&amp;quot;, &amp;quot;content-encoding&amp;quot;: &amp;quot;utf-8&amp;quot;, &amp;quot;content-length&amp;quot;: 37}{&amp;quot;action&amp;quot;: &amp;quot;search&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;\xf0\x9f\x90\xb6&amp;quot;}&#39; to (&#39;10.0.1.1&#39;, 65432)
received response {&#39;result&#39;: &#39;🐾 Playing ball! 🏐&#39;} from (&#39;10.0.1.1&#39;, 65432)
got result: 🐾 Playing ball! 🏐
closing connection to (&#39;10.0.1.1&#39;, 65432)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意请求发送行的 byte string，很容易看出来你发送的小狗 emoji 表情被打印成了十六进制的字符串 &lt;code&gt;\xf0\x9f\x90\xb6&lt;/code&gt;，我可以使用 emoji 表情来搜索是因为我的命令行支持utf-8 格式的编码&lt;/p&gt;

&lt;p&gt;这个示例中我们发送给网络原始的 bytes，这些 bytes 需要被接受者正确的解释。这就是为什么之前需要给消息附加头信息并且包含编码类型字段的原因&lt;/p&gt;

&lt;p&gt;下面这个是服务器对应上面两个客户端连接的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;accepted connection from (&#39;10.0.2.2&#39;, 55340)
received request {&#39;action&#39;: &#39;search&#39;, &#39;value&#39;: &#39;morpheus&#39;} from (&#39;10.0.2.2&#39;, 55340)
sending b&#39;\x00g{&amp;quot;byteorder&amp;quot;: &amp;quot;little&amp;quot;, &amp;quot;content-type&amp;quot;: &amp;quot;text/json&amp;quot;, &amp;quot;content-encoding&amp;quot;: &amp;quot;utf-8&amp;quot;, &amp;quot;content-length&amp;quot;: 43}{&amp;quot;result&amp;quot;: &amp;quot;Follow the white rabbit. \xf0\x9f\x90\xb0&amp;quot;}&#39; to (&#39;10.0.2.2&#39;, 55340)
closing connection to (&#39;10.0.2.2&#39;, 55340)

accepted connection from (&#39;10.0.2.2&#39;, 55338)
received request {&#39;action&#39;: &#39;search&#39;, &#39;value&#39;: &#39;🐶&#39;} from (&#39;10.0.2.2&#39;, 55338)
sending b&#39;\x00g{&amp;quot;byteorder&amp;quot;: &amp;quot;little&amp;quot;, &amp;quot;content-type&amp;quot;: &amp;quot;text/json&amp;quot;, &amp;quot;content-encoding&amp;quot;: &amp;quot;utf-8&amp;quot;, &amp;quot;content-length&amp;quot;: 37}{&amp;quot;result&amp;quot;: &amp;quot;\xf0\x9f\x90\xbe Playing ball! \xf0\x9f\x8f\x90&amp;quot;}&#39; to (&#39;10.0.2.2&#39;, 55338)
closing connection to (&#39;10.0.2.2&#39;, 55338)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意发送行中写到客户端的 bytes，这就是服务端的响应消息&lt;/p&gt;

&lt;p&gt;如果 action 参数不是搜索，你也可以试试给服务器发送二进制请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./app-client.py 10.0.1.1 65432 binary 😃
starting connection to (&#39;10.0.1.1&#39;, 65432)
sending b&#39;\x00|{&amp;quot;byteorder&amp;quot;: &amp;quot;big&amp;quot;, &amp;quot;content-type&amp;quot;: &amp;quot;binary/custom-client-binary-type&amp;quot;, &amp;quot;content-encoding&amp;quot;: &amp;quot;binary&amp;quot;, &amp;quot;content-length&amp;quot;: 10}binary\xf0\x9f\x98\x83&#39; to (&#39;10.0.1.1&#39;, 65432)
received binary/custom-server-binary-type response from (&#39;10.0.1.1&#39;, 65432)
got response: b&#39;First 10 bytes of request: binary\xf0\x9f\x98\x83&#39;
closing connection to (&#39;10.0.1.1&#39;, 65432)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于请求的 content-type 不是 &lt;code&gt;text/json&lt;/code&gt;，服务器会把内容当成二进制类型并且不会解码 JSON，它只会打印 content-type 和返回的前 10 个 bytes 给客户端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./app-server.py &#39;&#39; 65432
listening on (&#39;&#39;, 65432)
accepted connection from (&#39;10.0.2.2&#39;, 55320)
received binary/custom-client-binary-type request from (&#39;10.0.2.2&#39;, 55320)
sending b&#39;\x00\x7f{&amp;quot;byteorder&amp;quot;: &amp;quot;little&amp;quot;, &amp;quot;content-type&amp;quot;: &amp;quot;binary/custom-server-binary-type&amp;quot;, &amp;quot;content-encoding&amp;quot;: &amp;quot;binary&amp;quot;, &amp;quot;content-length&amp;quot;: 37}First 10 bytes of request: binary\xf0\x9f\x98\x83&#39; to (&#39;10.0.2.2&#39;, 55320)
closing connection to (&#39;10.0.2.2&#39;, 55320)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;故障排除&#34;&gt;故障排除&lt;/h2&gt;

&lt;p&gt;某些东西运行不了是很常见的，你可能不知道应该怎么做，不用担心，所有人都会遇到这种问题，希望你借助本教程、调试器和万能的搜索引擎解决问题并且继续下去&lt;/p&gt;

&lt;p&gt;如果还是解决不了，你的第一站应该是 python 的 &lt;a href=&#34;https://docs.python.org/3/library/socket.html&#34;&gt;socket&lt;/a&gt; 模块文档，确保你读过文档中每个我们使用到的方法、函数。同样的可以从引用一节中找到一些办法，尤其是错误一节中的内容&lt;/p&gt;

&lt;p&gt;有的时候问题并不是由你的源代码引起的，源代码可能是正确的。有可能是不同的主机、客户端和服务器。也可能是网络原因，比如路由器、防火墙或者是其它网络设备扮演了中间人的角色&lt;/p&gt;

&lt;p&gt;对于这些类型的问题，额外的一些工具是必要的。下面这些工具或者集可能会帮到你或者至少提供一些线索&lt;/p&gt;

&lt;h3 id=&#34;pin&#34;&gt;pin&lt;/h3&gt;

&lt;p&gt;ping 命令通过发送一个 &lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol&#34;&gt;ICMP&lt;/a&gt; 报文来检测主机是否连接到了网络，它直接与操作系统上的 TCP/IP 协议栈通信，所以它在主机上是独立于任何应用程序运行的&lt;/p&gt;

&lt;p&gt;下面是一段在 macOS 上执行 ping 命令的结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ping -c 3 127.0.0.1
PING 127.0.0.1 (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.058 ms
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.165 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.164 ms

--- 127.0.0.1 ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 0.058/0.129/0.165/0.050 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意后面的统计输出，这对你排查间歇性的连接问题很有帮助。比如说，是否有数据包丢失？网络延迟怎么样（查看消息的往返时间）&lt;/p&gt;

&lt;p&gt;如果你与主机之间有防火墙的话，ping 发送的请求可能会被阻止。防火墙管理员定义了一些规则强制阻止一些请求，主要的原因就是他们不想自己的主机是可以被发现的。如果你的机器也出现这种情况的话，请确保在规则中添加了允许 ICMP 包的发送&lt;/p&gt;

&lt;p&gt;ICMP 是 ping 命令使用的协议，但它也是 TCP 和其他底层用于传递错误消息的协议，如果你遇到奇怪的行为或缓慢的连接，可能就是这个原因&lt;/p&gt;

&lt;p&gt;ICMP 消息通过类型和代号来定义。下面有一些重要的信息可以参考：&lt;/p&gt;

&lt;p&gt;ICMP 类型 | ICMP 代码 | 说明
&amp;ndash;        | &amp;ndash;        | &amp;ndash;
8         | 0         | 打印请求
0         | 0         | 打印回复
3         | 0         | 目标网络不可达
3         | 1         | 目标主机不可达
3         | 2         | 目标协议不可达
3         | 3         | 目标端口不可达
3         | 4         | 需要分片，但是 DF(Don&amp;rsquo;t fragmentation) 标识已被设置
11        | 0         | 网络存在环路&lt;/p&gt;

&lt;p&gt;查看 &lt;a href=&#34;https://en.wikipedia.org/wiki/Path_MTU_Discovery#Problems_with_PMTUD&#34;&gt;Path MTU Discovery&lt;/a&gt; 更多关于分片和 ICMP 消息的内容，里面遇到的问题就是我前面提及的一些奇怪行为&lt;/p&gt;

&lt;h3 id=&#34;netstat&#34;&gt;netstat&lt;/h3&gt;

&lt;p&gt;在 &lt;a href=&#34;#查看 socket 状态&#34;&gt;查看 socket 状态&lt;/a&gt; 一节中我们已经知道如何使用 netstat 来查看 socket 及其状态的信息。这个命令在 macOS, Linux, Windows 上都可以使用&lt;/p&gt;

&lt;p&gt;在之前的示例中我并没有提及 &lt;code&gt;Recv-Q&lt;/code&gt; 和 &lt;code&gt;Send-Q&lt;/code&gt; 列。这些列表示发送或者接收队列中网络缓冲区数据的字节数，但是由于某些原因这些字节还没被远程或者本地应用读写&lt;/p&gt;

&lt;p&gt;换句话说，这些网络中的字节还在操作系统的队列中。一个原因可能是应用程序受 CPU 限制或者无法调用 &lt;code&gt;socket.recv()&lt;/code&gt;、&lt;code&gt;socket.send()&lt;/code&gt; 方法处理，或者因为其它一些网络原因导致的，比如说网络的拥堵、失败、硬件及电缆的问题&lt;/p&gt;

&lt;p&gt;为了复现这个问题，看看到底在错误发生前我应该发送多少数据。我写了一个测试客户端可以连接到测试服务器，并且重复的调用 &lt;code&gt;socket.send()&lt;/code&gt; 方法。测试服务端永远不调用 &lt;code&gt;socket.recv()&lt;/code&gt; 或者 &lt;code&gt;socket.send()&lt;/code&gt; 方法来处理客户端发送的数据，它只接受连接请求。这会导致服务器上的网络缓冲区被填满，最终会在客户端上报错&lt;/p&gt;

&lt;p&gt;首先运行服务端：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./app-server-test.py 127.0.0.1 65432 listening on (&#39;127.0.0.1&#39;, 65432)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行客户端，看看发生了什么：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./app-client-test.py 127.0.0.1 65432 binary test
error: socket.send() blocking io exception for (&#39;127.0.0.1&#39;, 65432):
BlockingIOError(35, &#39;Resource temporarily unavailable&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是用 &lt;code&gt;netstat&lt;/code&gt; 命令在错误发生时执行的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ netstat -an | grep 65432
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4  408300      0  127.0.0.1.65432        127.0.0.1.53225        ESTABLISHED
tcp4       0 269868  127.0.0.1.53225        127.0.0.1.65432        ESTABLISHED
tcp4       0      0  127.0.0.1.65432        *.*                    LISTEN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行就表示服务端（本地端口是 65432）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4  408300      0  127.0.0.1.65432        127.0.0.1.53225        ESTABLISHED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 Recv-Q: 408300&lt;/p&gt;

&lt;p&gt;第二行表示客户端（远程端口是 65432）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4       0 269868  127.0.0.1.53225        127.0.0.1.65432        ESTABLISHED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 Send-Q: 269868&lt;/p&gt;

&lt;p&gt;显然，客户端试着写入字节，但是服务端并没有读取他们。这导致服务端网络缓冲队列中应该保存的数据被积压在接收端，客户端的网络缓冲队列积压到发送端&lt;/p&gt;

&lt;h3 id=&#34;windows&#34;&gt;windows&lt;/h3&gt;

&lt;p&gt;如果你使用的是 windows 电脑，有一个工具套件绝对值得安装 &lt;a href=&#34;https://docs.microsoft.com/en-us/sysinternals/&#34;&gt;Windows Sysinternals&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;里面有个工具叫 &lt;code&gt;TCPView.exe&lt;/code&gt;，它是 windows 下的一个可视化的 netstat 工具。除了地址、端口号和 socket 状态之外，它还会显示发送和接收的数据包以及字节数。就像 Unix 工具集 &lt;code&gt;lsof&lt;/code&gt; 命令一样，你也可以看见进程名和 ID，可以在菜单中查看更多选项&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://files.realpython.com/media/tcpview.53c115c8b061.png&#34; alt=&#34;TCPView&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;wireshark&#34;&gt;Wireshark&lt;/h3&gt;

&lt;p&gt;有时候你可能想查看网络底层发生了什么，忽略应用程序的输出或者外部库调用，想看看网络层面到底收发了什么内容，就像调试器一样，当你需要看清这些的时候，没有别的办法&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.wireshark.org/&#34;&gt;Wireshark&lt;/a&gt; 是一款可以运行在 macOS, Linux, Windows 以及其它系统上的网络协议分析、流量捕获工具，GUI 版本的程序叫做
&lt;code&gt;wireshark&lt;/code&gt;，命令 行的程序叫做 &lt;code&gt;tshark&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;流量捕获是一个非常好用的方法，它可以让你看到网络上应用程序的行为，收集到关于收发消息多少、频率等信息，你也可以看到客户端或者服务端如何关闭/取消连接，或者停止响应，当你需要排除故障的时候这些信息非常的有用&lt;/p&gt;

&lt;p&gt;网上还有很多关于 &lt;code&gt;wireshark&lt;/code&gt; 和 &lt;code&gt;TShark&lt;/code&gt; 的基础使用教程&lt;/p&gt;

&lt;p&gt;这有一个使用 wireshark 捕获本地网络数据的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://files.realpython.com/media/wireshark.529c058891dc.png&#34; alt=&#34;wireshark&#34; /&gt;&lt;/p&gt;

&lt;p&gt;还有一个和上面一样的使用 tshark 命令输出的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tshark -i lo0 &#39;tcp port 65432&#39;
Capturing on &#39;Loopback&#39;
    1   0.000000    127.0.0.1 → 127.0.0.1    TCP 68 53942 → 65432 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=32 TSval=940533635 TSecr=0 SACK_PERM=1
    2   0.000057    127.0.0.1 → 127.0.0.1    TCP 68 65432 → 53942 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=32 TSval=940533635 TSecr=940533635 SACK_PERM=1
    3   0.000068    127.0.0.1 → 127.0.0.1    TCP 56 53942 → 65432 [ACK] Seq=1 Ack=1 Win=408288 Len=0 TSval=940533635 TSecr=940533635
    4   0.000075    127.0.0.1 → 127.0.0.1    TCP 56 [TCP Window Update] 65432 → 53942 [ACK] Seq=1 Ack=1 Win=408288 Len=0 TSval=940533635 TSecr=940533635
    5   0.000216    127.0.0.1 → 127.0.0.1    TCP 202 53942 → 65432 [PSH, ACK] Seq=1 Ack=1 Win=408288 Len=146 TSval=940533635 TSecr=940533635
    6   0.000234    127.0.0.1 → 127.0.0.1    TCP 56 65432 → 53942 [ACK] Seq=1 Ack=147 Win=408128 Len=0 TSval=940533635 TSecr=940533635
    7   0.000627    127.0.0.1 → 127.0.0.1    TCP 204 65432 → 53942 [PSH, ACK] Seq=1 Ack=147 Win=408128 Len=148 TSval=940533635 TSecr=940533635
    8   0.000649    127.0.0.1 → 127.0.0.1    TCP 56 53942 → 65432 [ACK] Seq=147 Ack=149 Win=408128 Len=0 TSval=940533635 TSecr=940533635
    9   0.000668    127.0.0.1 → 127.0.0.1    TCP 56 65432 → 53942 [FIN, ACK] Seq=149 Ack=147 Win=408128 Len=0 TSval=940533635 TSecr=940533635
   10   0.000682    127.0.0.1 → 127.0.0.1    TCP 56 53942 → 65432 [ACK] Seq=147 Ack=150 Win=408128 Len=0 TSval=940533635 TSecr=940533635
   11   0.000687    127.0.0.1 → 127.0.0.1    TCP 56 [TCP Dup ACK 6#1] 65432 → 53942 [ACK] Seq=150 Ack=147 Win=408128 Len=0 TSval=940533635 TSecr=940533635
   12   0.000848    127.0.0.1 → 127.0.0.1    TCP 56 53942 → 65432 [FIN, ACK] Seq=147 Ack=150 Win=408128 Len=0 TSval=940533635 TSecr=940533635
   13   0.001004    127.0.0.1 → 127.0.0.1    TCP 56 65432 → 53942 [ACK] Seq=150 Ack=148 Win=408128 Len=0 TSval=940533635 TSecr=940533635
^C13 packets captured
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;

&lt;p&gt;这一节主要用来引用一些额外的信息和外部资源链接&lt;/p&gt;

&lt;h3 id=&#34;python-文档&#34;&gt;Python 文档&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Python’s &lt;a href=&#34;https://docs.python.org/3/library/socket.html&#34;&gt;socket module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python’s &lt;a href=&#34;https://docs.python.org/3/howto/sockets.html#socket-howto&#34;&gt;Socket Programming HOWTO&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;错误信息&#34;&gt;错误信息&lt;/h3&gt;

&lt;p&gt;下面这段话来自 python 的 socket 模块文档：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;所有的错误都会触发异常，像无效参数类型和内存不足的常见异常可以被抛出；从
Python 3.3 开始，与 socket 或地址语义相关的错误会引发 OSError 或其子类之一的异
常 &lt;a href=&#34;https://docs.python.org/3/library/socket.html&#34;&gt;引用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;异常                   | &lt;code&gt;errno&lt;/code&gt; 常量 | 说明
BlockingIOError        | EWOULDBLOCK  | 资源暂不可用，比如在非阻塞模式下调用 &lt;code&gt;send()&lt;/code&gt; 方法，对方太繁忙面没有读取，发送队列满了，或者网络有问题
OSError                | EADDRINUSE   | 端口被战用，确保没有其它的进程与当前的程序运行在同一地址/端口上，你的服务器设置了 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 参数
ConnectionResetError   | ECONNRESET   | 连接被重置，远端的进程崩溃，或者 socket 意外关闭，或是有防火墙或链路上的设配有问题
TimeoutError           | ETIMEDOUT    | 操作超时，对方没有响应
ConnectionRefusedError | ECONNREFUSED | 连接被拒绝，没有程序监听指定的端口&lt;/p&gt;

&lt;h3 id=&#34;socket-地址族&#34;&gt;socket 地址族&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;socket.AF_INET&lt;/code&gt; 和 &lt;code&gt;socket.AF_INET6&lt;/code&gt; 是 &lt;code&gt;socket.socket()&lt;/code&gt; 方法调用的第一个参数
，表示地址协议族，API 使用了一个期望传入指定格式参数的地址，这取决于是
&lt;code&gt;AF_INET&lt;/code&gt; 还是 &lt;code&gt;AF_INET6&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;地址族         | 协议 | 地址元组                        | 说明
&amp;ndash;              | &amp;ndash;   | &amp;ndash;                              | &amp;ndash;
socket.AF_INET  | IPv4 | (host, port)                    | host 参数是个如 &lt;code&gt;www.example.com&lt;/code&gt; 的主机名称，或者如 &lt;code&gt;10.1.2.3&lt;/code&gt; 的 IPv4 地址
socket.AF_INET6 | IPv6 | (host, port, flowinfo, scopeid) | 主机名同上，IPv6 地址 如：&lt;code&gt;fe80::6203:7ab:fe88:9c23&lt;/code&gt;，flowinfo 和 scopeid 分别表示 C 语言结构体 &lt;code&gt;sockaddr_in6&lt;/code&gt; 中的 &lt;code&gt;sin6_flowinfo&lt;/code&gt; 和 &lt;code&gt;sin6_scope_id&lt;/code&gt; 成员&lt;/p&gt;

&lt;p&gt;注意下面这段 python socket 模块中关于 host 值和地址元组文档&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对于 IPv4 地址，使用主机地址的方式有两种：&lt;code&gt;&#39;&#39;&lt;/code&gt; 空字符串表示 &lt;code&gt;INADDR_ANY&lt;/code&gt;，字符
&lt;code&gt;&#39;&amp;lt;broadcast&amp;gt;&#39;&lt;/code&gt; 表示 &lt;code&gt;INADDR_BROADCAST&lt;/code&gt;，这个行为和 IPv6 不兼容，因此如果你的
程序中使用的是 IPv6 就应该避免这种做法。&lt;a href=&#34;https://docs.python.org/3/library/socket.html#socket-families&#34;&gt;源文档
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我在本教程中使用了 IPv4 地址，但是如果你的机器支持，也可以试试 IPv6 地址。&lt;code&gt;socket.getaddrinfo()&lt;/code&gt; 方法会返回五个元组的序列，这包括所有创建 socket 连接的必要参数，&lt;code&gt;socket.getaddrinfo()&lt;/code&gt; 方法理解并处理传入的 IPv6 地址和主机名&lt;/p&gt;

&lt;p&gt;下面的例子中程序将返回一个通过 TCP 连接到 &lt;code&gt;example.org&lt;/code&gt; 80 端口上的地址信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; socket.getaddrinfo(&amp;quot;example.org&amp;quot;, 80, proto=socket.IPPROTO_TCP)
[(&amp;lt;AddressFamily.AF_INET6: 10&amp;gt;, &amp;lt;SocketType.SOCK_STREAM: 1&amp;gt;,
 6, &#39;&#39;, (&#39;2606:2800:220:1:248:1893:25c8:1946&#39;, 80, 0, 0)),
 (&amp;lt;AddressFamily.AF_INET: 2&amp;gt;, &amp;lt;SocketType.SOCK_STREAM: 1&amp;gt;,
 6, &#39;&#39;, (&#39;93.184.216.34&#39;, 80))]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 IPv6 可用的话结果可能有所不同，上面返回的值可以被用于 &lt;code&gt;socket.socket()&lt;/code&gt; 和
&lt;code&gt;socket.connect()&lt;/code&gt; 方法调用的参数，在 python socket 模块文档中的 &lt;a href=&#34;https://docs.python.org/3/library/socket.html#example&#34;&gt;示例
&lt;/a&gt; 一节中有客户端和服务端
程序&lt;/p&gt;

&lt;h3 id=&#34;使用主机名&#34;&gt;使用主机名&lt;/h3&gt;

&lt;p&gt;这一节主要适用于使用 &lt;code&gt;bind()&lt;/code&gt; 和 &lt;code&gt;connect()&lt;/code&gt; 或 &lt;code&gt;connect_ex()&lt;/code&gt; 方法时如何使用主机名，然而当你使用回环地址做为主机名时，它总是会解析到你期望的地址。这刚好与客户端使用主机名的场景相反，它需要 DNS 解析的过程，比如 &lt;code&gt;www.example.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面一段来自 python socket 模块文档&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你主机名称做为 IPv4/v6 socket 地址的 host 部分，程序可能会出现非预期的结果
，由于 python 使用了 DNS 查找过程中的第一个结果，socket 地址会被解析成与真正的
IPv4/v6 地址不同的其它地址，这取决于 DNS 解析和你的 host 文件配置。如果想得到
确定的结果，请使用数字格式的地址做为 host 参数的值 &lt;a href=&#34;https://docs.python.org/3/library/socket.html&#34;&gt;源文档
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常回环地址 &lt;code&gt;localhost&lt;/code&gt; 会被解析到 &lt;code&gt;127.0.0.1&lt;/code&gt; 或 &lt;code&gt;::1&lt;/code&gt; 上，你的系统可能就是这么设置的，也可能不是。这取决于你系统配置，与所有 IT 相关的事情一样，总会有例外的情况，没办法完全保证 localhost 被解析到了回环地址上&lt;/p&gt;

&lt;p&gt;比如在 Linux 上，查看 &lt;code&gt;man nsswitch.conf&lt;/code&gt; 的结果，域名切换配置文件，还有另外一个 macOS 和 Linux 通用的配置文件地址是：&lt;code&gt;/etc/hosts&lt;/code&gt;，在 windows 上则是&lt;code&gt;C:\Windows\System32\drivers\etc\hosts&lt;/code&gt;，hosts 文件包含了一个文本格式的静态域名地址映射表，总之 DNS 也是一个难题&lt;/p&gt;

&lt;p&gt;有趣的是，在撰写这篇文章的时候（2018 年 6 月），有一个关于 &lt;a href=&#34;https://tools.ietf.org/html/draft-ietf-dnsop-let-localhost-be-localhost-02&#34;&gt;让 localhost 成为真正的 localhost&lt;/a&gt;的 RFC 草案，讨论就是围绕着 localhost 使用的情况开展的&lt;/p&gt;

&lt;p&gt;最重要的一点是你要理解当你在应用程序中使用主机名时，返回的地址可能是任何东西，如果你有一个安全性敏感的应用程序，不要使用主机名。取决于你的应用程序和环境，这可能会困扰到你&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 安全方面的考虑和最佳实践总是好的，即使你的程序不是安全敏感型的应用。如果你的应用程序访问了网络，那它就应该是安全的稳定的。这表示至少要做到以下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;经常会有系统软件升级和安全补丁，包括 python，你是否使用了第三方的库？如果是的话，确保他们能正常工作并且更新到了新版本&lt;/li&gt;
&lt;li&gt;尽量使用专用防火墙或基于主机的防火墙来限制与受信任系统的连接&lt;/li&gt;
&lt;li&gt;DNS 服务是如何配置的？你是否信任配置内容及其配置者&lt;/li&gt;
&lt;li&gt;在调用处理其他代码之前，请确保尽可能地对请求数据进行了清理和验证，还要为此添加测试用例，并且经常运行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;无论是否使用主机名称，你的应用程序都需要支持安全连接（加密授权），你可能会用到 &lt;a href=&#34;https://en.wikipedia.org/wiki/Transport_Layer_Security&#34;&gt;TLS&lt;/a&gt;，这是一个超越了本教程的范围的话题。可以从 python 的 &lt;a href=&#34;https://docs.python.org/3/library/ssl.html&#34;&gt;SSL&lt;/a&gt; 模块文档了解如何开始使用它，这个协议和你的浏览器使用的安全协议是一样的&lt;/p&gt;

&lt;p&gt;考虑到接口、IP 地址、域名解析这些「变量」，你应该怎么应对？如果你还没有网络应用程序审查流程，可以使用以下建议：&lt;/p&gt;

&lt;p&gt;应用程序 | 使用       | 建议
&amp;ndash;       | &amp;ndash;         | &amp;ndash;
服务端   | 回环地址   | 使用 IP 地址 127.0.0.1 或 ::1
服务端   | 以太网地址 | 使用 IP 地址，比如：10.1.2.3，使用空字符串表示本机所有 IP 地址
客户端   | 回环地址   | 使用 IP 地址 127.0.0.1 或 ::1
客户端   | 以太网地址 | 使用统一的不依赖域名解析的 IP 地址，特殊情况下才会使用主机地址，查看上面的安全提示&lt;/p&gt;

&lt;p&gt;对于客户端或者服务端来说，如果你需要授权连接到主机，请查看如何使用 TLS&lt;/p&gt;

&lt;h3 id=&#34;阻塞调用&#34;&gt;阻塞调用&lt;/h3&gt;

&lt;p&gt;如果一个 socket 函数或者方法使你的程序挂起，那么这个就是个阻塞调用，比如 accept(), connect(), send(), 和 recv() 都是 &lt;strong&gt;阻塞&lt;/strong&gt; 的，它们不会立即返回，阻塞调用在返回前必须等待系统调用 (I/O) 完成。所以调用者 —— 你，会被阻止直到系统调用结束或者超过延迟时间或者有错误发生&lt;/p&gt;

&lt;p&gt;阻塞的 socket 调用可以设置成非阻塞的模式，这样他们就可以立即返回。如果你想做到这一点，就得重构并重新设计你的应用程序&lt;/p&gt;

&lt;p&gt;由于调用直接返回了，但是数据确没就绪，被调用者处于等待网络响应的状态，没法完成它的工作，这种情况下，当前 socket 的状态码 errno 应该是 &lt;code&gt;socket.EWOULDBLOCK&lt;/code&gt;。&lt;code&gt;setblocking()&lt;/code&gt; 方法是支持非阻塞模式的&lt;/p&gt;

&lt;p&gt;默认情况下，socket 会以阻塞模式创建，查看 &lt;a href=&#34;https://docs.python.org/3/library/socket.html#notes-on-socket-timeouts&#34;&gt;socket 延迟的注意事项&lt;/a&gt; 中三种模式的解释&lt;/p&gt;

&lt;h3 id=&#34;关闭连接&#34;&gt;关闭连接&lt;/h3&gt;

&lt;p&gt;有趣的是 TCP 连接一端打开，另一端关闭的状态是完全合法的，这被称做 TCP「半连接」，是否需要这种保持状态是由应用程序决定的，通常来说不需要。这种状态下，关闭方将不能发送任何数据，它只能接收数据&lt;/p&gt;

&lt;p&gt;我不是在提倡你采用这种方法，但是作为一个例子，HTTP 使用了一个名为「Connection」的头来标准化规定应用程序是否关闭或者保持连接状态，更多内容请查看 &lt;a href=&#34;https://tools.ietf.org/html/rfc7230#section-6.3&#34;&gt;RFC 7230 中 6.3 节, HTTP 协议 (HTTP/1.1): 消息语法与路由&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当你在设计应用程序及其应用层协议的时候，最好先了解一下如何关闭连接，有时这很简单而且很明显，或者采取一些可以实现的原型，这取决于你的应用程序以及消息循环如何被处理成期望的数据，只要确保 socket 在完成工作后总是能正确关闭&lt;/p&gt;

&lt;h3 id=&#34;字节序&#34;&gt;字节序&lt;/h3&gt;

&lt;p&gt;查看维基百科 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F&#34;&gt;字节序&lt;/a&gt; 中关于不同的 CPU 是如何在内存中存储字节序列的，处理单个字节时没有任何问题，但是当把多个字节处理成单个值（四字节整型）时，如果和你通信的另一端使用了不同的字节序时字节顺序需要被反转&lt;/p&gt;

&lt;p&gt;字节顺序对于字符文本来说也很重要，字符文本通过表示为多字节的序列，就像 Unicode 一样。除非你只使用 &lt;code&gt;true&lt;/code&gt; 和 ASCII 字符来控制客户端和服务端的实现，否则使用 utf-8 格式或者支持字节序标识(BOM) 的 Unicode 字符集会比较合适&lt;/p&gt;

&lt;p&gt;在应用层协议中明确的规定使用编码格式是很重要的，你可以规定所有的文本都使用 utf-8 或者用「content-encoding」头指定编码格式，这将使你的程序不需要检测编码方式，当然也应该尽量避免这么做&lt;/p&gt;

&lt;p&gt;当数据被调用存储到了文件或者数据库中而且又没有数据的元信息的时候，问题就很麻烦了，当数据被传到其它端，它将试着检测数据的编码方式。有关讨论，请参阅 Wikipedia 的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Unicode&#34;&gt;Unicode&lt;/a&gt; 文章，它引用了 &lt;a href=&#34;https://tools.ietf.org/html/rfc3629#page-6&#34;&gt;RFC 3629:UTF-8, a transformation format of ISO 10646&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;然而 UTF-8 的标准 RFC 3629 中推荐禁止在 UTF-8 协议中使用标记字节序 (BOM)，但是
讨 论了无法实现的情况，最大的问题在于如何使用一种模式在不依赖 BOM 的情况下区分
UTF-8 和其它编码方式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;避开这些问题的方法就是总是存储数据使用的编码方式，换句话说，如果不只用 utf-8 格式的编码或者其它的带有 BOM 的编码就要尝试以某种方式将编码方式存储为元数据，然后你就可以在数据上附加编码的头信息，告诉接收者编码方式&lt;/p&gt;

&lt;p&gt;TCP/IP 使用的字节顺序是 &lt;a href=&#34;https://en.wikipedia.org/wiki/Endianness#Big&#34;&gt;big-endian&lt;/a&gt;，被称做网络序。网络序被用来表示底层协议栈中的整型数字，好比 IP 地址和端口号，python 的 socket 模块有几个函数可以把这种整型数字从网络字节序转换成主机字节序&lt;/p&gt;

&lt;p&gt;函数            | 说明
&amp;ndash;              | &amp;ndash;
socket.ntohl(x) | 把 32 位的正整型数字从网络字节序转换成主机字节序，在网络字节序和主机字节序相同的机器上这是个空操作，否则将是一个 4 字节的交换操作
socket.ntohs(x) | 把 16 位的正整型数字从网络字节序转换成主机字节序，在网络字节序和主机字节序相同的机器上这是个空操作，否则将是一个 2 字节的交换操作
socket.htonl(x) | 把 32 位的正整型数字从主机字节序转换成网络字节序，在网络字节序和主机字节序相同的机器上这是个空操作，否则将是一个 4 字节的交换操作
socket.htons(x) | 把 16 位的正整型数字从主机字节序转换成网络字节序，在网络字节序和主机字节序相同的机器上这是个空操作，否则将是一个 2 字节的交换操作&lt;/p&gt;

&lt;p&gt;你也可以使用 &lt;a href=&#34;https://docs.python.org/3/library/struct.html&#34;&gt;struct&lt;/a&gt; 模块打包或者解包二进制数据（使用格式化字符串）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import struct
network_byteorder_int = struct.pack(&#39;&amp;gt;H&#39;, 256)
python_int = struct.unpack(&#39;&amp;gt;H&#39;, network_byteorder_int)[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;

&lt;p&gt;我们在本教程中介绍了很多内容，网络和 socket 是很大的一个主题，如果你对它们都比较陌生，不要被这些规则和大写字母术语吓到&lt;/p&gt;

&lt;p&gt;为了理解所有的东西如何工作的，有很多部分需要了解。但是，就像 python 一样，当你花时间去了解每个独立的部分时它才开始变得有意义&lt;/p&gt;

&lt;p&gt;我们看过了 python socket 模块中底层的一些 API，并了解了如何使用它们创建客户端服务器应用程序。我们也创建了一个自定义类来做为应用层的协议，并用它在不同的端点之间交换数据，你可以使用这个类并在些基础上快速且简单地构建出一个你自己的 socket 应用程序&lt;/p&gt;

&lt;p&gt;你可以在 Github 上找到 &lt;a href=&#34;https://github.com/realpython/materials/tree/master/python-sockets-tutorial&#34;&gt;源代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;恭喜你坚持到最后！你现在就可以在程序中很好地使用 socket 了&lt;/p&gt;

&lt;p&gt;我希望这个教程能为你开始 socket 编程旅途中提供一些信息、示例、或者灵感&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTPie 官方文档中文翻译版</title>
      <link>https://keelii.com/2018/09/03/HTTPie/</link>
      <pubDate>Mon, 03 Sep 2018 19:10:27 +0000</pubDate>
      
      <guid>https://keelii.com/2018/09/03/HTTPie/</guid>
      <description>

&lt;p&gt;HTTPie 是一个命令行 HTTP 客户端。目标是让 CLI 与 Web services 的交互尽可能的更友
好。它提供了一个简单的 &lt;code&gt;http&lt;/code&gt; 命令，可以让我们用简单自然的表述发送任意 HTTP 请求
，并且可以输出带代码高亮的结果。HTTPie 可以使用在测试、调试以及通用的与 HTTP 交
互场景&lt;/p&gt;

&lt;h2 id=&#34;主要功能特性&#34;&gt;主要功能特性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;自然而且简单的命令语句&lt;/li&gt;
&lt;li&gt;格式化且高亮显示输出内容&lt;/li&gt;
&lt;li&gt;内置 JSON 支持&lt;/li&gt;
&lt;li&gt;表单和文件上传&lt;/li&gt;
&lt;li&gt;支持 HTTPS, 代理和授权验证&lt;/li&gt;
&lt;li&gt;支持多样化的请求数据格式&lt;/li&gt;
&lt;li&gt;自定义 headers 头&lt;/li&gt;
&lt;li&gt;持久 sessions 存储&lt;/li&gt;
&lt;li&gt;类似 &lt;code&gt;wget&lt;/code&gt; 的下载模式&lt;/li&gt;
&lt;li&gt;兼容 Python 2.6, 2.7 以及 3.x&lt;/li&gt;
&lt;li&gt;支持 Linux, macOS 和 Windows 操作系统&lt;/li&gt;
&lt;li&gt;插件支持&lt;/li&gt;
&lt;li&gt;详细的文档说明&lt;/li&gt;
&lt;li&gt;完善的测试用例覆盖&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;h3 id=&#34;macos&#34;&gt;macOS&lt;/h3&gt;

&lt;p&gt;在 macOS 系统中推荐使用 &lt;a href=&#34;brew.sh&#34;&gt;Homebrew&lt;/a&gt; 来安装:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install httpie
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然 MacPorts 也是可以的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;port install httpie
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;linux&#34;&gt;Linux&lt;/h3&gt;

&lt;p&gt;大多数的 Linux 构建版都提供了包管理组件，可以使用他们来安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 基于 Debian Linux 的构建版，比如 Ubuntu
apt-get install httpie

# 基于 RPM Linux 的构建版
yum install httpie

# Arch Linux 系统
pacman -S httpie
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;windows-及其它&#34;&gt;Windows 及其它&lt;/h3&gt;

&lt;p&gt;使用 &lt;a href=&#34;https://pip.pypa.io/en/latest/installing/&#34;&gt;pip&lt;/a&gt; 是一种通用的（可以使用在
Windows, MacOS, Linux &amp;hellip;）并且提供最新版本安装包的安装方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 确保使用了最新版本的 pip 和 setuptools:
pip install --upgrade pip setuptools

pip install --upgrade httpie
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;开发版&#34;&gt;开发版&lt;/h3&gt;

&lt;p&gt;最新的开发版本可以直接通过 github 安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Homebrew
brew install httpie --HEAD

# pip
pip install --upgrade https://github.com/jkbrzt/httpie/archive/master.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;python-版本&#34;&gt;Python 版本&lt;/h3&gt;

&lt;p&gt;虽然兼容 Python 2.6, 2.7 版本的，但是如果可以的话还是建议使用最新版的 Python 3.x
来安装 HTTPie。这将保证一些比较新的功能（比如：&lt;a href=&#34;#服务器名称指示
-sni-server-name-indication&#34;&gt;SNI&lt;/a&gt; ）可以开箱即用。Python 3 在 Homebrew 0.9.4 版本以上
已经成为了默认的 Python 版本。可以使用 &lt;code&gt;http --debug&lt;/code&gt; 来查看 HTTPie 使用的
python 版本&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;最简单的使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http httpie.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用语法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http [flags] [METHOD] URL [ITEM [ITEM]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用 &lt;code&gt;http --help&lt;/code&gt; 来查看更多使用方法：&lt;/p&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;p&gt;自定义 HTTP 方法，HTTP 头和 JSON 数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http PUT example.org X-API-Token:123 name=John
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表单提交：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -f POST example.org hello=World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用一个输出参数 &lt;code&gt;-v&lt;/code&gt; 来查看请求信息（默认不显示请求信息）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -v example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;a href=&#34;http://developer.github.com/v3/issues/comments/#create-a-comment&#34;&gt;Github
API&lt;/a&gt; 向 issue
发送一条评论（需要授权验证参数）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -a USERNAME POST https://api.github.com/repos/jkbrzt/httpie/issues/83/comments body=&#39;HTTPie is awesome! :heart:&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过命令行的输入重定向上传文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http example.org &amp;lt; file.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;wget&lt;/code&gt; 风格下载文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --download example.org/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用命令会话对同一 host 进行请求之间的持久通信：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --session=logged-in -a username:password httpbin.org/get API-Key:123
http --session=logged-in httpbin.org/headers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义请求 host 头：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http localhost:8000 Host:example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;http-方法&#34;&gt;HTTP 方法&lt;/h2&gt;

&lt;p&gt;HTTP 方法的名称在 URL 参数之前：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http DELETE example.org/todos/7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这看起来就像是原生的 HTTP 请求发送的文本一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;DELETE /todos/7 HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;请求-url&#34;&gt;请求 URL&lt;/h2&gt;

&lt;p&gt;HTTPie 唯一必传的一个参数是请求 URL，默认的方案不出意料的是 &lt;code&gt;http://&lt;/code&gt;，可以在请
求的时候缺省 - &lt;code&gt;http example.org&lt;/code&gt; 是没问题的&lt;/p&gt;

&lt;h3 id=&#34;querystring-参数&#34;&gt;Querystring 参数&lt;/h3&gt;

&lt;p&gt;如果需要在命令行手动构建 URLs，你可能会觉得使用 &lt;code&gt;param==value&lt;/code&gt; 添加参数的方式是
比较方便的，这样你就不需要担心命令行中转义链接字符串 &lt;code&gt;&amp;amp;&lt;/code&gt; 的问题，当然参数中的特
殊字符也将被自动转义（除非已经转义过）。用下面的命令搜索 &lt;code&gt;HTTPie logo&lt;/code&gt; 可以在
google 图片上结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http www.google.com search==&#39;HTTPie logo&#39; tbm==isch

GET /?search=HTTPie+logo&amp;amp;tbm=isch HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;localhost-的-url-缩写&#34;&gt;localhost 的 URL 缩写&lt;/h3&gt;

&lt;p&gt;另外，类似 &lt;code&gt;curl&lt;/code&gt; 的 localhost 缩写也是支持的。这表示你可以使用 &lt;code&gt;:3000&lt;/code&gt; 来代替
&lt;code&gt;http://localhost:3000&lt;/code&gt;, 如果不传入端口号，&lt;code&gt;80&lt;/code&gt; 将会默认被使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http :/foo

GET /foo HTTP/1.1
Host: localhost
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http :3000/bar

GET /bar HTTP/1.1
Host: localhost:3000
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http :

GET / HTTP/1.1
Host: localhost
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自定义默认的方案&#34;&gt;自定义默认的方案&lt;/h3&gt;

&lt;p&gt;你可以使用 &lt;code&gt;--default-scheme &amp;lt;URL_SCHEME&amp;gt;&lt;/code&gt; 参数来指定非 HTTP 的其它协义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;alias https=&#39;http --default-scheme=https&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;请求项&#34;&gt;请求项&lt;/h2&gt;

&lt;p&gt;不同的请求项类型提供一种便捷的方法来指定 HTTP 头、简单的 JSON
、表单数据、文件、URL 参数&lt;/p&gt;

&lt;p&gt;URL 参数后面紧随的是 &lt;code&gt;键/值&lt;/code&gt; 对参数都会被拼装成请求发送。不同类型的 &lt;code&gt;键/值&lt;/code&gt; 对分
割符号分别是：&lt;code&gt;:&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;:=&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;=@&lt;/code&gt;, &lt;code&gt;:=@&lt;/code&gt;。用 &lt;code&gt;@&lt;/code&gt; 分割的参数表示文件路径&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;项类型(item type)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述(Description)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;HTTP 头参数&lt;br/&gt; &lt;code&gt;Name:Value&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;任意的 HTTP 头，比如：&lt;code&gt;X-API-Token:123&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;URL 参数&lt;br/&gt; &lt;code&gt;name==value&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;通过分割符 &lt;code&gt;==&lt;/code&gt; 表示一个查询字符串的 &lt;code&gt;键/值&lt;/code&gt; 对&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;数据域&lt;br/&gt; &lt;code&gt;field=value&lt;/code&gt;,&lt;br/&gt; &lt;code&gt;field=@file.txt&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;请求一个默认会被序列化成 JSON 的数据域，或者表单类型 form-encoded&lt;code&gt;(--form, -f)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;纯 JSON 域&lt;br/&gt; &lt;code&gt;field:=json&lt;/code&gt;,&lt;br/&gt; &lt;code&gt;field:=@file.json&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当需要指定一个或者多数域参数类型 &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; .. 时非常有用， 比如：meals:=&amp;rsquo;[&amp;ldquo;ham&amp;rdquo;,&amp;ldquo;spam&amp;rdquo;]&amp;rsquo; or pies:=&lt;a href=&#34;注意引号&#34;&gt;1,2,3&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;Form 表单文件域&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;仅当传入参数 &lt;code&gt;--form, -f&lt;/code&gt; 时有效，比如 &lt;code&gt;screenshot@~/Pictures/img.png&lt;/code&gt; 文件内容将会被序列化成 &lt;code&gt;multipart/form-data&lt;/code&gt; 发送&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;数据域不是唯一的指定请求数据的方式，&lt;a href=&#34;#重定向输入&#34;&gt;重定向输入&lt;/a&gt;也可以&lt;/p&gt;

&lt;h3 id=&#34;字符转义规则&#34;&gt;字符转义规则&lt;/h3&gt;

&lt;p&gt;可以使用 &lt;code&gt;\&lt;/code&gt; 来转义不应该被用于分割符的情况。比如 &lt;code&gt;foo\==bar&lt;/code&gt; 会被转义成一个数据
键值对（foo= 和 bar）而不是 URL 参数&lt;/p&gt;

&lt;p&gt;通常情况需要使用引号包围值，比如 &lt;code&gt;foo=&#39;bar baz&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果有一个域的名字或者 header 以减号开头，你需要把这些参数放在一个特殊符号 &lt;code&gt;--&lt;/code&gt;
&lt;strong&gt;后面&lt;/strong&gt; ，这样做是为了和 &lt;code&gt;--arguments&lt;/code&gt; 区分开&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http httpbin.org/post  --  -name-starting-with-dash=foo -Unusual-Header:bar

POST /post HTTP/1.1
-Unusual-Header: bar
Content-Type: application/json

{
    &amp;quot;-name-starting-with-dash&amp;quot;: &amp;quot;value&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;json&#34;&gt;JSON&lt;/h2&gt;

&lt;p&gt;JSON 是现代 web services 通用规范，HTTPie 也默认遵循了它的 &lt;strong&gt;不严格的数据类型&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http PUT example.org name=John email=john@example.org

PUT / HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Content-Type: application/json
Host: example.org

{
    &amp;quot;name&amp;quot;: &amp;quot;John&amp;quot;,
    &amp;quot;email&amp;quot;: &amp;quot;john@example.org&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;默认行为&#34;&gt;默认行为&lt;/h3&gt;

&lt;p&gt;如果你的命令包含了一些请求项数据，它们将默认被序列化成 JSON 对象。HTTPie 会默认
自动添加下面两个 header 头，当然这两个头也可以重新传入&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;Content-Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;code&gt;application/json&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;Accept&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;application/json, */*&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;明确的-json&#34;&gt;明确的 JSON&lt;/h3&gt;

&lt;p&gt;你可以使用命令行参数 &lt;code&gt;--json, -j&lt;/code&gt; 明确地设置 &lt;code&gt;Accept&lt;/code&gt; 为 &lt;code&gt;application/json&lt;/code&gt; 而无
需在意发送的数据是什么（这是个快捷方式，也可以使用普通的 header 注解：&lt;code&gt;http url
Accept:&#39;application/json, */*&#39;&lt;/code&gt;），另外，HTTPie 会试着检测 JSON 响应，即使
&lt;code&gt;Content-Type&lt;/code&gt; 是不正常的 &lt;code&gt;text/plain&lt;/code&gt; 或者未知类型&lt;/p&gt;

&lt;h3 id=&#34;非字符串的-json-域&#34;&gt;非字符串的 JSON 域&lt;/h3&gt;

&lt;p&gt;非字符串类型的 JSON 域使用 &lt;code&gt;:=&lt;/code&gt; 分割，这可以允许你嵌入原生纯 JSON 到结果对象，文
本和原生的纯 JSNO 文件也可以使用 &lt;code&gt;=@&lt;/code&gt; 和 &lt;code&gt;:=G&lt;/code&gt; 嵌入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http PUT api.example.com/person/1 \
    name=John \
    age:=29 married:=false hobbies:=&#39;[&amp;quot;http&amp;quot;, &amp;quot;pies&amp;quot;]&#39; \  # Raw JSON
    description=@about-john.txt \   # Embed text file
    bookmarks:=@bookmarks.json      # Embed JSON file

PUT /person/1 HTTP/1.1
Accept: application/json, */*
Content-Type: application/json
Host: api.example.com

{
    &amp;quot;age&amp;quot;: 29,
    &amp;quot;hobbies&amp;quot;: [
        &amp;quot;http&amp;quot;,
        &amp;quot;pies&amp;quot;
    ],
    &amp;quot;description&amp;quot;: &amp;quot;John is a nice guy who likes pies.&amp;quot;,
    &amp;quot;married&amp;quot;: false,
    &amp;quot;name&amp;quot;: &amp;quot;John&amp;quot;,
    &amp;quot;bookmarks&amp;quot;: {
        &amp;quot;HTTPie&amp;quot;: &amp;quot;http://httpie.org&amp;quot;,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过请注意，当发送复杂数据的时候，这个例子使用的语法会显得很笨重。在这种情况下 &lt;a href=&#34;#重定向输入&#34;&gt;
重定向输入&lt;/a&gt; 将会更合适：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http POST api.example.com/person/1 &amp;lt; person.json
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;表单&#34;&gt;表单&lt;/h2&gt;

&lt;p&gt;提交表单和发送 JSON 请求很相似，通常情况下唯一的不同是添加额外的 &lt;code&gt;--form, -f&lt;/code&gt; 参
数，这将确保数据域和 &lt;code&gt;Content-Type&lt;/code&gt; 被设置成 &lt;code&gt;application/x-www-form-urlencoded;
charset=utf-8&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;普通的表单&#34;&gt;普通的表单&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --form POST api.example.org/person/1 name=&#39;John Smith&#39;

POST /person/1 HTTP/1.1
Content-Type: application/x-www-form-urlencoded; charset=utf-8

name=John+Smith
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文件上传表单&#34;&gt;文件上传表单&lt;/h3&gt;

&lt;p&gt;如果有一个文件域，序列化方式和 content type 会是 &lt;code&gt;multipart/form-data&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -f POST example.com/jobs name=&#39;John Smith&#39; cv@~/Documents/cv.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的请求和下面的 HTML 表单发送请求是一样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form enctype=&amp;quot;multipart/form-data&amp;quot; method=&amp;quot;post&amp;quot; action=&amp;quot;http://example.com/jobs&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot; /&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;cv&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 &lt;code&gt;@&lt;/code&gt; 用来模拟文件上传域，而 &lt;code&gt;=@&lt;/code&gt;
是把文件内容以文本的方式嵌入到数据域的值里面&lt;/p&gt;

&lt;h2 id=&#34;http-头&#34;&gt;HTTP 头&lt;/h2&gt;

&lt;p&gt;可以使用 &lt;code&gt;Header:Value&lt;/code&gt; 注解的形式来添加自定义头信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http example.org  User-Agent:Bacon/1.0  &#39;Cookie:valued-visitor=yes;foo=bar&#39;  \
    X-Foo:Bar  Referer:http://httpie.org/

GET / HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Cookie: valued-visitor=yes;foo=bar
Host: example.org
Referer: http://httpie.org/
User-Agent: Bacon/1.0
X-Foo: Bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;默认的请求头&#34;&gt;默认的请求头&lt;/h3&gt;

&lt;p&gt;有几个默认的请求头是 HTTPie 设置的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;GET / HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
User-Agent: HTTPie/&amp;lt;version&amp;gt;
Host: &amp;lt;taken-from-URL&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;空头和重新设置默认头&#34;&gt;空头和重新设置默认头&lt;/h3&gt;

&lt;p&gt;可以使用 &lt;code&gt;Header:&lt;/code&gt; 来取消上面的几个默认头信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http httpbin.org/headers Accept: User-Agent:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求中的 &lt;code&gt;Accept&lt;/code&gt; 和 &lt;code&gt;User-Agent&lt;/code&gt; 头都会被移除&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;Header;&lt;/code&gt; 表示添加一个为空的头信息，注意须使用引号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -v httpbin.org/headers &#39;Host;&#39;

GET /headers HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host:
User-Agent: HTTPie/0.9.9
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;授权验证&#34;&gt;授权验证&lt;/h2&gt;

&lt;p&gt;目前支持的验证方案有基础和摘要两种（查看更多 &lt;a href=&#34;#授权插件&#34;&gt;授权插件&lt;/a&gt;），有两种标识
来控制验证：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--auth, -a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把 &lt;code&gt;用户名:密码&lt;/code&gt; 做为键值对参数传入，如果只指定用户名可以使用 &lt;code&gt;-a 用户名&lt;/code&gt;，密码在接下来的提示符中输入，空密码使用 &lt;code&gt;username:&lt;/code&gt;，&lt;code&gt;username:password@hostname&lt;/code&gt; 格式的 URL 语法也是支持的，证书通过 &lt;code&gt;-a&lt;/code&gt; 参数传入且具有更高的优先级&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--auth-type, -A&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定指定身份验证机制。&lt;code&gt;basic&lt;/code&gt;(默认) 和 &lt;code&gt;digest&lt;/code&gt; 两种&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;basic-授权&#34;&gt;Basic 授权&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -a username:password example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;digest-授权&#34;&gt;Digest 授权&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -A digest -a username:password example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;密码提示&#34;&gt;密码提示&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -a username example.org&amp;lt;Paste&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;netrc&#34;&gt;.netrc&lt;/h3&gt;

&lt;p&gt;从你的 &lt;code&gt;~/.netrc&lt;/code&gt; 文件授权也可以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat ~/.netrc
machine httpbin.org
login httpie
password test

http httpbin.org/basic-auth/httpie/test
HTTP/1.1 200 OK
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;授权插件&#34;&gt;授权插件&lt;/h3&gt;

&lt;p&gt;授权机制可以使用安装插件的方式来实现，可以在 Python Package 上面找到更多相关插件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pd/httpie-api-auth&#34;&gt;httpie-api-auth&lt;/a&gt;: ApiAuth&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/httpie/httpie-aws-auth&#34;&gt;httpie-aws-auth&lt;/a&gt;: AWS / Amazon S3&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/akamai-open/httpie-edgegrid&#34;&gt;httpie-edgegrid&lt;/a&gt;: EdgeGrid&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/guardian/httpie-hmac-auth&#34;&gt;httpie-hmac-auth&lt;/a&gt;: HMAC&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/teracyhq/httpie-jwt-auth&#34;&gt;httpie-jwt-auth&lt;/a&gt;: JWTAuth (JSON Web Tokens)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ndzou/httpie-negotiate&#34;&gt;httpie-negotiate&lt;/a&gt;: SPNEGO (GSS Negotiate)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/httpie/httpie-ntlm&#34;&gt;httpie-ntlm&lt;/a&gt;: NTLM (NT LAN Manager)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/httpie/httpie-oauth&#34;&gt;httpie-oauth&lt;/a&gt;: OAuth&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mozilla-services/requests-hawk&#34;&gt;requests-hawk&lt;/a&gt;: Hawk&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;http-重定向&#34;&gt;HTTP 重定向&lt;/h2&gt;

&lt;p&gt;HTTP 重定向默认不会自动跳转，请求发出后命令行只会显示 &lt;strong&gt;第一次&lt;/strong&gt; 收到的响应&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http httpbin.org/redirect/3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;按-header-头中的-location-字段值跳转&#34;&gt;按 header 头中的 location 字段值跳转&lt;/h3&gt;

&lt;p&gt;指定 &lt;code&gt;--follow, -F&lt;/code&gt; 参数让 HTTPie 自动跟随 &lt;code&gt;30x&lt;/code&gt; 响应头中的 &lt;code&gt;location&lt;/code&gt;
字段值进行跳转，并且显示最终的响应内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --follow httpbin.org/redirect/3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;显示中间的跳转响应&#34;&gt;显示中间的跳转响应&lt;/h3&gt;

&lt;p&gt;如果你也想看到更多的跳转信息，可以指定 &lt;code&gt;--all&lt;/code&gt; 参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --follow --all httpbin.org/redirect/3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;限制重定向最大次数&#34;&gt;限制重定向最大次数&lt;/h3&gt;

&lt;p&gt;改变默认最大 &lt;code&gt;30&lt;/code&gt; 次重定向值可以使用 &lt;code&gt;--max-redirects=&amp;lt;limit&amp;gt;&lt;/code&gt; 参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --follow --all --max-redirects=5 httpbin.org/redirect/3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代理&#34;&gt;代理&lt;/h2&gt;

&lt;p&gt;你可以通过添加参数 &lt;code&gt;--proxy&lt;/code&gt; 来指定各自协义（为了防止跨协义的重定向，协义被包含
在了参数值中）的代理服务器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --proxy=http:http://10.10.1.10:3128 --proxy=https:https://10.10.1.10:1080 example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加 basic 授权&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --proxy=http:http://user:pass@10.10.1.10:3128 example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;环境变量&#34;&gt;环境变量&lt;/h3&gt;

&lt;p&gt;也可以通过设置 &lt;code&gt;HTTP_PROXY&lt;/code&gt; 和 &lt;code&gt;HTTPS_PROXY&lt;/code&gt; 环境变量来配置代理，底层的 request
库也将使用这些代理配置，如果你想指定某些 host 不使用代理，可以通过添加
&lt;code&gt;NO_PROXY&lt;/code&gt; 参数来实现&lt;/p&gt;

&lt;p&gt;在你的 &lt;code&gt;~/.bash_profile&lt;/code&gt; 文件中（zsh 则在 &lt;code&gt;~/.zshrc&lt;/code&gt; 中）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export HTTP_PROXY=http://10.10.1.10:3128
export HTTPS_PROXY=https://10.10.1.10:1080
export NO_PROXY=localhost,example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;socks&#34;&gt;Socks&lt;/h3&gt;

&lt;p&gt;要启用 socks 代理支持请使用 pip 安装 &lt;code&gt;requests[socks]&lt;/code&gt; 库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install -U requests[socks]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法与其它类型的代理相同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --proxy=http:socks5://user:pass@host:port --proxy=https:socks5://user:pass@host:port example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;https&#34;&gt;HTTPS&lt;/h2&gt;

&lt;h3 id=&#34;服务器-ssl-证书验证&#34;&gt;服务器 SSL 证书验证&lt;/h3&gt;

&lt;p&gt;使用参数 &lt;code&gt;--verify=no&lt;/code&gt; 可以跳过主机 SSL 验证（默认：&lt;code&gt;yes&lt;/code&gt;）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --verify=no https://example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自定义-ca-包&#34;&gt;自定义 CA 包&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;--verify=&amp;lt;CA_BUNDLE_PATH&amp;gt;&lt;/code&gt; 指定 CA 认证包路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --cert=client.pem https://example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;客户端-ssl-证书&#34;&gt;客户端 SSL 证书&lt;/h3&gt;

&lt;p&gt;使用客户端 SSL 证书进行 SSL 通信，可以用 &lt;code&gt;--cert&lt;/code&gt; 参数指定证书文件路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --cert=client.pem https://example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果证书中不包含私钥，可以通过 &lt;code&gt;--cert-key&lt;/code&gt; 参数指定密钥文件路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --cert=client.crt --cert-key=client.key https://example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ssl-版本&#34;&gt;SSL 版本&lt;/h3&gt;

&lt;p&gt;参数 &lt;code&gt;--ssl=&amp;lt;PROTOCOL&amp;gt;&lt;/code&gt; 用来指定你想使用的 SSL 协义版本，默认是 &lt;code&gt;SSL v2.3&lt;/code&gt;。这将
会协商服务端和你安装的 OpenSSL 支持的最高 SSL 协议版本。可用的版本有： &lt;code&gt;ssl2.3&lt;/code&gt;,
&lt;code&gt;ssl3&lt;/code&gt;, &lt;code&gt;tls1&lt;/code&gt;, &lt;code&gt;tls1.1&lt;/code&gt;, &lt;code&gt;tls1.2&lt;/code&gt; （实际上可用的协义可能有很多种，这由你安装
的 OpenSSL 决定）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 指定容易受到攻击的 SSL v3 协义与老服务器进行通信
http --ssl=ssl3 https://vulnerable.example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;服务器名称指示-sni-server-name-indication&#34;&gt;服务器名称指示 SNI(Server Name Indication)&lt;/h3&gt;

&lt;p&gt;如果你的 HTTPie 版本（可以使用 &lt;code&gt;http --debug&lt;/code&gt; 查看版本）小于 2.7.9，又需要使用
SNI 与服务器会话。那么你需要安装额外的依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install --upgrade requests[security]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面的命令测试 SNI 支持&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http https://sni.velox.ch
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;输出参数&#34;&gt;输出参数&lt;/h2&gt;

&lt;p&gt;HTTPie 默认只输出最终响应信息并且打印（header, body同样），你可以通过下面一些参
数控制打印内容：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;命令行参数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&amp;ndash;headers, -h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;仅打印响应头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&amp;ndash;body, -b&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;仅打印响应体&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&amp;ndash;verbose, -v&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印所有的 HTTP 请求来回内容，这将默认开启 &lt;code&gt;--all&lt;/code&gt; 参数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;使用 &lt;code&gt;--verbose&lt;/code&gt; 参数来调试请求或生成文档时是非常有用的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --verbose PUT httpbin.org/put hello=world
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;PUT /put HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Content-Type: application/json
Host: httpbin.org
User-Agent: HTTPie/0.2.7dev

{
    &amp;quot;hello&amp;quot;: &amp;quot;world&amp;quot;
}


HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 477
Content-Type: application/json
Date: Sun, 05 Aug 2012 00:25:23 GMT
Server: gunicorn/0.13.4

{
    […]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;哪部分的-http-请求内容应该打印出来&#34;&gt;哪部分的 HTTP 请求内容应该打印出来&lt;/h3&gt;

&lt;p&gt;所有的 HTTP 输出选项都属于更强大的 &lt;code&gt;--print, -p&lt;/code&gt; 参数的快捷方式。&lt;code&gt;--print, -p&lt;/code&gt;
接受一个字符串，字符串的每个字母都表示下面的 HTTP 某一部分&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;字符&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;代表&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;H&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;请求头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;请求体&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;h&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;响应头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;响应体&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;打印请求头和响应头：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --print=Hh PUT httpbin.org/put hello=world
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查看中间的请求-响应&#34;&gt;查看中间的请求/响应&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;--all&lt;/code&gt; 参数可以查看 HTTP 通信中的所有信息，中间的 HTTP 通信包括跟随重定向
（使用参数&lt;code&gt;--follow&lt;/code&gt;）和使用 HTTP 摘要授权时第一次未授权的请求（使用参数
&lt;code&gt;--auth=diggest&lt;/code&gt;）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 包括最终响应之前的所有响应信息
http --all --follow httpbin.org/redirect/3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中间请求/响应默认会使用 &lt;code&gt;--print, -p&lt;/code&gt; 参数指定的值格式化，可以使用
&lt;code&gt;--history-print, -P&lt;/code&gt; 指定， 参数和 &lt;code&gt;--print, -p&lt;/code&gt; 是一样的。但是这只实用于 &lt;strong&gt;中
间请求&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 中间请求/响应信息使用 H 格式化，最终请求/响应信息使用 Hh 格式化:
http -A digest -a foo:bar --all -p Hh -P H httpbin.org/digest-auth/auth/foo/bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;条件化的-body-内容下载&#34;&gt;条件化的 body 内容下载&lt;/h3&gt;

&lt;p&gt;做为一个优化项，响应体在仅作为输出一部分时才会被下载，这和 &lt;code&gt;HEAD&lt;/code&gt; 类型的请求类似
（除了 HEAD 可以使用在任何 HTTP 请求中）&lt;/p&gt;

&lt;p&gt;比如有一个 API 更新后会返回整个资源，但是你只对更新后响应头中的状态码感兴趣：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --headers PATCH example.org/Really-Huge-Resource name=&#39;New Name&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们在上面设置了只打印头信息，当响应头接收完成的时候服务器连接就会被关闭，
带宽和时间不会浪费在下载响应体，你可以不必在意。响应头总是会被下载的无论它是不是
输出部分&lt;/p&gt;

&lt;h2 id=&#34;重定向输入&#34;&gt;重定向输入&lt;/h2&gt;

&lt;p&gt;直接从 &lt;code&gt;stdin&lt;/code&gt; （标准输入）管道传入请求数据是大部分人认为比较好的方法。 这些数据
被缓冲而且不需要更多的操作就可以做为请求体被使用，使用管道有下面几个好用的方法：&lt;/p&gt;

&lt;p&gt;从一个文件重新定向&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http PUT example.com/person/1 X-API-Token:123 &amp;lt; person.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者从其它程序的输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep &#39;401 Unauthorized&#39; /var/log/httpd/error_log | http POST example.org/intruders
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然也可以使用 &lt;code&gt;echo&lt;/code&gt; 命令来传简单数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#39;{&amp;quot;name&amp;quot;: &amp;quot;John&amp;quot;}&#39; | http PATCH example.com/person/1 X-API-Token:123
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;甚至可以使用 web services&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http GET https://api.github.com/repos/jkbrzt/httpie | http POST httpbin.org/post
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用 &lt;code&gt;cat&lt;/code&gt; 命令来输入多行文本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat | http POST example.com
&amp;lt;paste&amp;gt;
^D
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat | http POST example.com/todos Content-Type:text/plain
- buy milk
- call parents
^D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 macOS 中可以使用 &lt;code&gt;pbpaste&lt;/code&gt; 命令把剪贴板中的内容做为数据发送&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pbpaste | http PUT example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;stdin&lt;/code&gt; 传递数据的方式 &lt;strong&gt;不能&lt;/strong&gt; 和指定数据域的方式混合使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#39;data&#39; | http POST example.org more=data   # 不可以
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;从一个文件中取请求数据&#34;&gt;从一个文件中取请求数据&lt;/h3&gt;

&lt;p&gt;指定文件路径（&lt;code&gt;@/path/to/file&lt;/code&gt;）方式可以替代上面使用 &lt;code&gt;stdin&lt;/code&gt; 的方式&lt;/p&gt;

&lt;p&gt;这个方法有个优点，&lt;code&gt;Content-Type&lt;/code&gt; 可以根据提供的文件扩展名自动设置成对应的。比如
下面的请求会被设置头 &lt;code&gt;Content-Type: application/xml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http PUT httpbin.org/put @/data/file.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;命令行输出&#34;&gt;命令行输出&lt;/h2&gt;

&lt;p&gt;HTTPie 默认会做一些事情，目的是为了让命令行输出内容有更高的可读性&lt;/p&gt;

&lt;h3 id=&#34;颜色和格式化&#34;&gt;颜色和格式化&lt;/h3&gt;

&lt;p&gt;语法高亮会应用在 HTTP 请求的 headers 和 body 里面。如果你不喜欢默认的配色方案，
可以使用 &lt;code&gt;--style&lt;/code&gt; 参数自定义（使用&lt;code&gt;http --help&lt;/code&gt;命令查看更多选项）&lt;/p&gt;

&lt;p&gt;还有下面几个格式化规则会被使用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP 头会按名称排序&lt;/li&gt;
&lt;li&gt;JSON 数据会有缩进，并且按 key 名排序，unicode 序列会被转换成实际字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这些参数可以用在处理输出结果中：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令行参数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&amp;ndash;pretty=all&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;应用颜色和格式化，默认&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&amp;ndash;pretty=colors&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;仅应用颜色&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&amp;ndash;pretty=format&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;仅应用格式化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&amp;ndash;pretty=none&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不使用颜色和格式化，重定向时默认使用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;二进制数据&#34;&gt;二进制数据&lt;/h3&gt;

&lt;p&gt;二进制数据在命令行中会被禁止，这会使处理响应返回的二进制数据变得更安全，重定向时
也禁止二进制数据，但是会被装饰输出。一旦当我们知道响应体是二进制数据时，连接会关
闭&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http example.org/Movie.mov
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你几乎可以立即看见下面的提示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;HTTP/1.1 200 OK
Accept-Ranges: bytes
Content-Encoding: gzip
Content-Type: video/quicktime
Transfer-Encoding: chunked

+-----------------------------------------+
| NOTE: binary data not shown in terminal |
+-----------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重定向输出&#34;&gt;重定向输出&lt;/h2&gt;

&lt;p&gt;与命令行输出相比，重定向输出使用了不同的默认值，不同之处在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;格式化和种颜色默认不会使用（除非&lt;code&gt;--pretty&lt;/code&gt;被指定）&lt;/li&gt;
&lt;li&gt;只输出响应体（除非指定了输出参数）&lt;/li&gt;
&lt;li&gt;二进制结果不会被禁止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原因是为了把 HTTPie 的结果直接 piping 到其它程序，并且使下载文件不需要额外的参数
标识。多数情况下输出重定向时只有响应体有意义&lt;/p&gt;

&lt;p&gt;下载一个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http example.org/Movie.mov &amp;gt; Movie.mov
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载 Octocat 图片，使用 ImageMagick 修改大小，上传到其它地方：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http octodex.github.com/images/original.jpg | convert - -resize 25% -  | http example.org/Octocats
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;强制使用格式化与颜色，在 &lt;code&gt;less&lt;/code&gt; 的分页中显示请求和响应&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --pretty=all --verbose example.org | less -R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-R&lt;/code&gt; 标识告诉 &lt;code&gt;less&lt;/code&gt; 命令解析 HTTPie 输出中的颜色序列&lt;/p&gt;

&lt;p&gt;你可以使用下面的 bash 函数代码建立一个调用 HTTPie
分页格式化且高亮输出的快捷方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;function httpless {
    # `httpless example.org&#39;
    http --pretty=all --print=hb &amp;quot;$@&amp;quot; | less -R;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;下载模式&#34;&gt;下载模式&lt;/h2&gt;

&lt;p&gt;HTTPie 具有下载模式，这和 &lt;code&gt;wget&lt;/code&gt; 命令类似&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;--download, -d&lt;/code&gt; 标识启用，响应头会打印到命令行，下载响应体的进度条也会显示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --download https://github.com/jkbrzt/httpie/archive/master.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK
Content-Disposition: attachment; filename=httpie-master.tar.gz
Content-Length: 257336
Content-Type: application/x-gzip

Downloading 251.30 kB to &amp;quot;httpie-master.tar.gz&amp;quot;
Done. 251.30 kB in 2.73862s (91.76 kB/s)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;下载文件的文件名&#34;&gt;下载文件的文件名&lt;/h3&gt;

&lt;p&gt;如果没有指定参数 &lt;code&gt;--output, -o&lt;/code&gt;，文件名将由 &lt;code&gt;Content-Disposition&lt;/code&gt; 决定，或者通过
URL 及其 &lt;code&gt;Content-Type&lt;/code&gt;，如果名字已占用，HTTPie 会添加唯一后缀&lt;/p&gt;

&lt;h3 id=&#34;下载的同时-piping&#34;&gt;下载的同时 piping&lt;/h3&gt;

&lt;p&gt;即使响应头和进度状态显示在命令行中，你仍然可以将响应重定向到其它的程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -d https://github.com/jkbrzt/httpie/archive/master.tar.gz |  tar zxf -
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;恢复下载&#34;&gt;恢复下载&lt;/h3&gt;

&lt;p&gt;如果指定 &lt;code&gt;--output, -o&lt;/code&gt;，你可以 &lt;code&gt;--continue, -c&lt;/code&gt;
恢复部分下载。不过仅当服务器支持 &lt;code&gt;Range&lt;/code&gt; 请求而且响应返回 &lt;code&gt;206 Partial Content&lt;/code&gt;
才可以，如果服务器不支持这个功能，那就只会下载整个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -dco file.zip example.org/file
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;其它注意事项&#34;&gt;其它注意事项&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--download&lt;/code&gt; 仅更改响应正文的处理方式&lt;/li&gt;
&lt;li&gt;仍然可以使用自定义 header 头、使用 session 会话，&lt;code&gt;--verbose, -v&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--download&lt;/code&gt; 意味着启用 &lt;code&gt;--follow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果文件没有被完全下载完，HTTPie 将会返回错误状态码 &lt;code&gt;1&lt;/code&gt; 并退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt; 不能和 &lt;code&gt;--download&lt;/code&gt; 一起使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;流式响应&#34;&gt;流式响应&lt;/h2&gt;

&lt;p&gt;响应体会被以块的形式下载和打印，这使程序在不使用大量内存情况下进行流式传输和下载
，然而如果使用颜色和格式化参数，&lt;strong&gt;整个&lt;/strong&gt; 响应体会被缓冲，然后立即处理&lt;/p&gt;

&lt;h3 id=&#34;禁用缓冲&#34;&gt;禁用缓冲&lt;/h3&gt;

&lt;p&gt;可以使用 &lt;code&gt;--stream, -S&lt;/code&gt; 进行下面的操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;输出内容以更小的块更新，不需要任何缓冲，这使得 HTTPie 表现的像 &lt;code&gt;tail -f&lt;/code&gt; 命令
一样&lt;/li&gt;
&lt;li&gt;即使输出被美化，流也会启用：它将应用于响应的每一行并立即更新。这样就可以为持续
时间长的请求提供一个漂亮的输出，例如一个 Twitter 的流 API&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;修饰过的流响应&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --stream -f -a YOUR-TWITTER-NAME https://stream.twitter.com/1/statuses/filter.json track=&#39;Justin Bieber&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像 &lt;code&gt;tail -f&lt;/code&gt; 一样小块的流输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --stream -f -a YOUR-TWITTER-NAME https://stream.twitter.com/1/statuses/filter.json track=Apple \
| while read tweet; do echo &amp;quot;$tweet&amp;quot; | http POST example.org/tweets ; done
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;会话&#34;&gt;会话&lt;/h2&gt;

&lt;p&gt;默认情况下，同一个 host 每个 HTTPie 发出的请求完全独立&lt;/p&gt;

&lt;p&gt;然而，HTTPie 支持使用 &lt;code&gt;--session=SESSION_NAME_OR_PATH&lt;/code&gt; 参数进行持久会话。在同一
个 host 的会话中，自定义 header(除了以&lt;code&gt;Content-&lt;/code&gt; 和 &lt;code&gt;If-&lt;/code&gt; 开头)、authorization、
cookies(手动指定或者服务器发送) 会持续保存&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 创建一个新会话
http --session=/tmp/session.json example.org API-Token:123

# 复制用已存在的会话 API-Token 会自动设置
http --session=/tmp/session.json example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的会话数据都会被存储成纯文本，这表示会话文件可以使用编辑器手动添加或者修改——
其实就是 JSON 数据&lt;/p&gt;

&lt;h3 id=&#34;具名会话&#34;&gt;具名会话&lt;/h3&gt;

&lt;p&gt;每个 host 都可以建一个或者多个会话，比如：下面的命令将为 host 是 &lt;code&gt;example.org&lt;/code&gt;
的请求建一个名为 &lt;code&gt;name1&lt;/code&gt; 的会话：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --session=user1 -a user1:password example.org X-Foo:Bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从现在起，你就通过名字来选择会话，当你选择使用一个会话时，之前用过的授权、HTTP
头都会被自动添加：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --session=user1 example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建或者重用不同的会话，只需要指定不同的名字即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --session=user2 -a user2:password example.org X-Bar:Foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具名会话将被以 JSON 的数据格式存储在 &lt;code&gt;~/.httpie/sessions/&amp;lt;host&amp;gt;/&amp;lt;name&amp;gt;.json&lt;/code&gt;
下面（windows下则是 &lt;code&gt;%APPDATA%\httpie\sessions\&amp;lt;host&amp;gt;\&amp;lt;name&amp;gt;.json&lt;/code&gt;）&lt;/p&gt;

&lt;h3 id=&#34;匿名会话&#34;&gt;匿名会话&lt;/h3&gt;

&lt;p&gt;不同与具名会话，你也可以直接使用一个文件路径来指定会话文件的存储地址，这也可以在
不同的 host 间复用会话：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --session=/tmp/session.json example.org
http --session=/tmp/session.json admin.example.org
http --session=~/.httpie/sessions/another.example.org/test.json example.org
http --session-read-only=/tmp/session.json example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;只读会话&#34;&gt;只读会话&lt;/h3&gt;

&lt;p&gt;如果复用一个会话又不想更新会话信息，可以通过指定
&lt;code&gt;--session-read-only=SESSION_NAME_OR_PATH&lt;/code&gt; 来实现&lt;/p&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;p&gt;HTTPie 使用了一个简单的 JSON 配置文件&lt;/p&gt;

&lt;h3 id=&#34;配置文件路径&#34;&gt;配置文件路径&lt;/h3&gt;

&lt;p&gt;默认的配置文件路径在 &lt;code&gt;~/.httpie/config.json&lt;/code&gt; （window 在
&lt;code&gt;%APPDATA%\httpie\config.json&lt;/code&gt;），配置文件的路径也可以通过修改环境变量
&lt;code&gt;HTTPIE_CONFIG_DIR&lt;/code&gt; 来更改，可以使用 &lt;code&gt;http --debug&lt;/code&gt; 命令查看当前配置文件路径&lt;/p&gt;

&lt;h3 id=&#34;可配置的参数&#34;&gt;可配置的参数&lt;/h3&gt;

&lt;p&gt;JSON 配置文件包含以下的键：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;default_options&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参数默认值数组（默认为空），数组里面的参数会被应用于每次 HTTPie 的调用&lt;/p&gt;

&lt;p&gt;比如说，你可以使用这个选项改变默认的样式和输出参数：&lt;code&gt;&amp;quot;default_options&amp;quot;:
[&amp;quot;--style=fruity&amp;quot;, &amp;quot;--body&amp;quot;]&lt;/code&gt; ，另外一个常用的默认参数是 &lt;code&gt;&amp;quot;--session=default&amp;quot;&lt;/code&gt;，
这会让 HTTPie 总是使用会话（名称为default）。也可以使用 &lt;code&gt;--form&lt;/code&gt; 改变默认 &lt;strong&gt;不严
格的&lt;/strong&gt; JSON 类型为 form 类型&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__meta__&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;HTTPie 自动存储了一些它自己的元数据，不要动它&lt;/p&gt;

&lt;h3 id=&#34;取消之前指定的参数&#34;&gt;取消之前指定的参数&lt;/h3&gt;

&lt;p&gt;配置文件中的参数和其它任何指定参数的方法，都可以使用 &lt;code&gt;--no-OPTION&lt;/code&gt; 参数来取消，
比如：&lt;code&gt;--no-style&lt;/code&gt; 或者 &lt;code&gt;--no-session&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;脚本&#34;&gt;脚本&lt;/h2&gt;

&lt;p&gt;当你在 shell 脚本中使用 HTTPie 的时候，&lt;code&gt;--check-status&lt;/code&gt; 标识会比较好用。这个标识
将告知 HTTPie 如果响应状态码是 &lt;code&gt;3xx&lt;/code&gt;, &lt;code&gt;4xx&lt;/code&gt;, &lt;code&gt;5xx&lt;/code&gt; 时程序将退出并显示对应的错误
码 &lt;code&gt;3&lt;/code&gt;（除非 &lt;code&gt;--follow&lt;/code&gt; 参数被指定）, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

if http --check-status --ignore-stdin --timeout=2.5 HEAD example.org/health &amp;amp;&amp;gt; /dev/null; then
    echo &#39;OK!&#39;
else
    case $? in
        2) echo &#39;Request timed out!&#39; ;;
        3) echo &#39;Unexpected HTTP 3xx Redirection!&#39; ;;
        4) echo &#39;HTTP 4xx Client Error!&#39; ;;
        5) echo &#39;HTTP 5xx Server Error!&#39; ;;
        6) echo &#39;Exceeded --max-redirects=&amp;lt;n&amp;gt; redirects!&#39; ;;
        *) echo &#39;Other Error!&#39; ;;
    esac
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;最佳实践&#34;&gt;最佳实践&lt;/h2&gt;

&lt;p&gt;在非交互式调用的情况下通常不希望使用 &lt;code&gt;stdin&lt;/code&gt; 的默认行为，可以使用
&lt;code&gt;--ignore-stdin&lt;/code&gt; 参数来禁止它&lt;/p&gt;

&lt;p&gt;如果没有这个选项，HTTPie 可能会挂起，这是一个常见的问题。发生的场景可能是——例如
从定时任务中调用HTTPie时，&lt;code&gt;stdin&lt;/code&gt; 未连接到终端。因此，重定向输入的规则适用，即
HTTPie 开始读取它，希望请求体将被传递。由于没有数据也没有 EOF，它会被卡住。因此
，除非你将一些数据传递给 HTTPie，否则应在脚本中使用此标志&lt;/p&gt;

&lt;p&gt;当然使用 &lt;code&gt;--timeout&lt;/code&gt; 参数手动设置（默认 30 秒）延迟时间是个比较好的做法&lt;/p&gt;

&lt;h2 id=&#34;元信息&#34;&gt;元信息&lt;/h2&gt;

&lt;h3 id=&#34;接口设计&#34;&gt;接口设计&lt;/h3&gt;

&lt;p&gt;命令行参数的设计与通过网络发送 HTTP 请求的过程密切相关。这使得 HTTPie 的命令更容
易记忆和阅读。有时你甚至可以把原生的 HTTP 请求串连到一行就很自然的形成了 HTTPie
的命令行参数。例如 对比下面这个原生 HTTP 请求：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;POST /collection HTTP/1.1
X-API-Key: 123
User-Agent: Bacon/1.0
Content-Type: application/x-www-form-urlencoded

name=value&amp;amp;name2=value2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和使用 HTTPie 命令发送同样的参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -f POST example.org/collection \
  X-API-Key:123 \
  User-Agent:Bacon/1.0 \
  name=value \
  name2=value2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意他们两者的顺序和参数都非常相似，并且只有一小部分命令用于控制 HTTPie（&lt;code&gt;-f&lt;/code&gt; 表
示让 HTTPie 发送一个 from 请求），并且不直接对应于请求的任何部分&lt;/p&gt;

&lt;p&gt;两种模式：&lt;code&gt;--pretty=all&lt;/code&gt;（命令行中默认）、&lt;code&gt;--pretty=none&lt;/code&gt;（重定向输出时默认），
对交互式使用和脚本调用都比较友好，HTTPie 在这过程中作为通用的 HTTP 客户端&lt;/p&gt;

&lt;p&gt;由于 HTTPie 还在频繁的开发中，现有的一些命令行参数在最终版 &lt;code&gt;1.0&lt;/code&gt; 发布之前可能会
有一些微小的调整。这些调整都会在&lt;a href=&#34;#变更日志&#34;&gt;变更日志&lt;/a&gt; 里面记录&lt;/p&gt;

&lt;h3 id=&#34;用户支持&#34;&gt;用户支持&lt;/h3&gt;

&lt;p&gt;你可以通过下面的一些途径找到帮助支持&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jkbr/httpie/issues&#34;&gt;GitHub issues&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitter.im/jkbrzt/httpie&#34;&gt;Our Gitter chat room&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/&#34;&gt;StackOverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Twitter &lt;a href=&#34;https://twitter.com/clihttp&#34;&gt;@clihttp&lt;/a&gt;，也可以直接 &lt;a href=&#34;https://twitter.com/jkbrzt&#34;&gt;@jkbrzt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;相关项目&#34;&gt;相关项目&lt;/h3&gt;

&lt;h4 id=&#34;依赖&#34;&gt;依赖&lt;/h4&gt;

&lt;p&gt;HTTPie 底层使用了两个特别棒的库：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://python-requests.org/&#34;&gt;Requests&lt;/a&gt; — Python HTTP 库
&lt;a href=&#34;http://pygments.org/&#34;&gt;Pygments&lt;/a&gt; — Python 代码高亮&lt;/p&gt;

&lt;h4 id=&#34;httpie-的朋友&#34;&gt;HTTPie 的朋友&lt;/h4&gt;

&lt;p&gt;HTTPie 可以和下面两个好友愉快地玩耍：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://stedolan.github.io/jq/&#34;&gt;jq&lt;/a&gt;
&lt;a href=&#34;https://github.com/eliangcs/http-prompt&#34;&gt;http-prompt&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;贡献&#34;&gt;贡献&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jakubroztocil/httpie/blob/master/CONTRIBUTING.rst&#34;&gt;CONTRIBUTING.rst&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;变更日志&#34;&gt;变更日志&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jkbrzt/httpie/blob/master/CHANGELOG.rst&#34;&gt;CHANGELOG&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;插图&#34;&gt;插图&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/claudiatd/httpie-artwork&#34;&gt;claudiatd/httpie-artwork&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;许可证&#34;&gt;许可证&lt;/h3&gt;

&lt;p&gt;BSD-3-Clause: &lt;a href=&#34;https://github.com/jkbrzt/httpie/blob/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;作者&#34;&gt;作者&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://roztocil.co/&#34;&gt;Jakub Roztocil&lt;/a&gt; (&lt;a href=&#34;https://twitter.com/jkbrzt&#34;&gt;@jkbrzt&lt;/a&gt;)
创造了 HTTPie，还有一些 &lt;a href=&#34;https://github.com/jkbrzt/httpie/contributors&#34;&gt;优秀的人&lt;/a&gt; 也贡献力量&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VIM 代码片段插件 ultisnips 使用教程</title>
      <link>https://keelii.com/2018/08/26/vim-plugin-ultisnips-advanced-tips/</link>
      <pubDate>Sun, 26 Aug 2018 17:59:45 +0800</pubDate>
      
      <guid>https://keelii.com/2018/08/26/vim-plugin-ultisnips-advanced-tips/</guid>
      <description>

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/SirVer/ultisnips&#34;&gt;Ultisnips&lt;/a&gt; 插件安装分两部分，一个是 ultisnips 插件本身，另外一个是代码片段仓库。一般来说把默认的代码片段仓库下载下来按需修改后上传到自己的 github 即可。如果你和我一样也使用 vim-plug 来管理插件的话，添加下面的代码到你的 vimrc 中保存刷新即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Plug &#39;SirVer/ultisnips&#39;
# 你自己的代码仓库 git 地址
Plug &#39;keelii/vim-snippets&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的示例中所有的代码片段都存放在插件安装目录下面的 &lt;code&gt;vim-snippets/UltiSnips&lt;/code&gt; 中，文件命名格式为 &lt;code&gt;ft&lt;/code&gt;.snippets, &lt;code&gt;ft&lt;/code&gt; 就是 vim 中的 &lt;code&gt;filetype&lt;/code&gt;，其中有个 &lt;code&gt;all.snippets&lt;/code&gt; 是唯一一个所有文件都适用的代码片段&lt;/p&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;p&gt;快捷键设置，我一般使用 tab 来触发代码片段补全，&lt;strong&gt;且不使用 YCM&lt;/strong&gt; （官方文档表示使用YCM的话就不能使用tab补全）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;let g:UltiSnipsExpandTrigger=&amp;quot;&amp;lt;tab&amp;gt;&amp;quot;
&amp;quot; 使用 tab 切换下一个触发点，shit+tab 上一个触发点
let g:UltiSnipsJumpForwardTrigger=&amp;quot;&amp;lt;tab&amp;gt;&amp;quot;
let g:UltiSnipsJumpBackwardTrigger=&amp;quot;&amp;lt;S-tab&amp;gt;&amp;quot;
&amp;quot; 使用 UltiSnipsEdit 命令时垂直分割屏幕
let g:UltiSnipsEditSplit=&amp;quot;vertical&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;依赖&#34;&gt;依赖&lt;/h2&gt;

&lt;p&gt;ultisnips 插件需要你的 vim 支持 python，可以在 vim 命令模式下使用下面的检测你的 vim 版本是否支持 python&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 1 表示支持
:echo has(&amp;quot;python&amp;quot;)
:echo has(&amp;quot;python3&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;定义一个代码片段&#34;&gt;定义一个代码片段&lt;/h2&gt;

&lt;h3 id=&#34;定义格式&#34;&gt;定义格式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;snippet 触发字符 [&amp;quot;代码片段说明&amp;quot; [参数]]
代码片段内容
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;最小化的一个代码片段&#34;&gt;最小化的一个代码片段&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;snippet if &amp;quot;if (condition) { ... }&amp;quot;
if (${1:true}) {
    $0
}
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时当你在 vim 中输入 if 敲 tab 就会展开一条 if 语句，第一个触发点是 if 条件表达式，最后一个是 if 语句体&lt;/p&gt;

&lt;p&gt;&lt;code&gt;${1:true}&lt;/code&gt; 表示这是第一个触发点，占位符为 &lt;code&gt;true&lt;/code&gt;，如果占位符没有默认值可直接使用 &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;可视选择区的内容为占位符&#34;&gt;可视选择区的内容为占位符&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;snippet if &amp;quot;if (...)&amp;quot;
if (${1:true}) {
    ${VISUAL}
}
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;${VISUAL}&lt;/code&gt; 表示在 vim 中使用可视模式下选择的文本，这个在重构代码的时候&lt;strong&gt;非常有用&lt;/strong&gt;（后面会有高级用法），上个图感受一下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t25252/299/1019207883/36468/bca93de/5b84a8a9N8dd5a8c5.gif&#34; alt=&#34;if-with-visual-mode&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;代码片段的参数&#34;&gt;代码片段的参数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 表示触发字符应该在一行的开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; 表示触发字符可以在单词内（连续展示会使用这个选项）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; 表示触发字符的前后必须是一个字母分界点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 表示触发字符可以是一个正则表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; 表示展开的代码片段中如果有制表符，原样输出，即使你的 vimrc 里面设置了 expandtab&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; 表示删除代码片段右边的所有空白字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e&lt;/code&gt; 表示自定义上下文&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 表示自动触发，不需要按 tab，类似于 VIM 中的 abbr&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内容解释器&#34;&gt;内容解释器&lt;/h2&gt;

&lt;p&gt;Ultisnips 定义的代码片段中支持三种不同的语言注入：shell, vimscript, python，在代码片段中用反引号表示&lt;/p&gt;

&lt;h2 id=&#34;shell-代码&#34;&gt;shell 代码&lt;/h2&gt;

&lt;p&gt;就是在你的命令行 shell 能执行的代码片段，比如输出当前时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜ date
2018年 8月27日 星期一 18时19分38秒 CST
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码片段中用反引号「`」引用即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;snippet today
Today is the `date`.
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入 today 按 tab 展开后（格式和上面shell中的不一样，估计是因为 vim 语言设置的问题）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Today is the Mon Aug 27 18:24:51 CST 2018.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;vimscript-代码&#34;&gt;vimscript 代码&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;indent&lt;/code&gt; 来输出当前缩进值，使用前缀 &lt;code&gt;!v&lt;/code&gt; 表示是 vimscript&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;snippet indent
Indent is: `!v indent(&amp;quot;.&amp;quot;)`.
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;//img12.360buyimg.com/devfe/jfs/t23467/4/2565317844/22166/a39566b/5b84a97fNa6174311.gif&#34; alt=&#34;vimscript-indent-size&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;python-代码&#34;&gt;python 代码&lt;/h3&gt;

&lt;p&gt;在代码片段中解释执行 python 代码是 ultisnips 最强大的功能，以前缀 &lt;code&gt;!p&lt;/code&gt; 开始。系统会向 python 中注入一些变量，可以使用 python 代码直接对其进行操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fn&lt;/code&gt; - 表示当前文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt; -  当前文件名的路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; - 占位符的字典，可以使用 &lt;code&gt;t[1], t[2], t.v&lt;/code&gt; 来取占位符内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snip&lt;/code&gt; - &lt;a href=&#34;https://github.com/SirVer/ultisnips/blob/6fdc3647f72e0a1f321ea6bd092ecd01f7c187ba/pythonx/UltiSnips/text_objects/_python_code.py#L56&#34;&gt;UltiSnips.TextObjects.SnippetUtil&lt;/a&gt; 对象的一个实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;match&lt;/code&gt; - 正则代码片段时返回的匹配元素（非常强大）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中最常用的 &lt;code&gt;snip&lt;/code&gt; 对象提供了下面一些变量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;snip.rv&lt;/code&gt; 表示 return value，python 代码执行后处理过的字符串赋给 rv 即可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snip.fn&lt;/code&gt; 表示当前文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snip.ft&lt;/code&gt; 表示当前文件类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snip.v&lt;/code&gt; 表示 VISUAL 模式变量，其中 &lt;code&gt;snip.v.mode&lt;/code&gt; 表示模式类型，&lt;code&gt;snip.v.text&lt;/code&gt; 表示 VISUAL 模式中选择的字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t27739/311/103185395/173892/d6a786e3/5b84af90Nfa6cd193.gif&#34; alt=&#34;python-snippet-var&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;占位符选择&#34;&gt;占位符选择&lt;/h2&gt;

&lt;p&gt;UltiSnips 支持使用快捷键切换占位符，我使用 &lt;code&gt;&amp;lt;tab&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;shift-tab&amp;gt;&lt;/code&gt; 来切换 &lt;code&gt;下一个&lt;/code&gt; 和 &lt;code&gt;上一个&lt;/code&gt; 占位符，占位符切换的作用域为当前代码片段内部（即使占位符已被修改过），当光标移动出去以后就不起作用了&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img12.360buyimg.com/devfe/jfs/t24559/158/2571218888/171431/2459a91d/5b84bf9aN96a7ee7e.gif&#34; alt=&#34;mul-placeholder-editing&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;自定义上下文&#34;&gt;自定义上下文&lt;/h2&gt;

&lt;p&gt;自定义上下文可以通过正则匹配来决定代码片断是否可用，比如判断在指定的 if 语句里面才起作用的代码片断，定义格式如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;snippet 触发字符 &amp;ldquo;描述&amp;rdquo; &amp;ldquo;表达式&amp;rdquo; 参数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比如我们定义一个 &lt;strong&gt;只有&lt;/strong&gt; 在上一行以 &lt;code&gt;if (DEVELOPMENT) {&lt;/code&gt; 开头才可以展开的代码片段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;snippet dbg &amp;quot;if (DEVELOPMENT) dbg&amp;quot; &amp;quot;re.match(&#39;^if \(DEVELOPMENT\) \{&#39;, snip.buffer[snip.line-1])&amp;quot; be
debugger;
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常见用法&#34;&gt;常见用法&lt;/h2&gt;

&lt;h3 id=&#34;行内连续展开&#34;&gt;行内连续展开&lt;/h3&gt;

&lt;p&gt;这个常见于需要连续展开代码片段的情况，比如，有两个片段，一个打印变量，一个处理 JSON 序列化。这时需要使用参数选项 &lt;code&gt;i&lt;/code&gt;n-word&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t25579/50/1036526670/419976/53521e3b/5b84c7d2Nd6a0cb5e.gif&#34; alt=&#34;continue-expand-snippets&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用正则代码片段&#34;&gt;使用正则代码片段&lt;/h3&gt;

&lt;p&gt;通常写代码的时候需要使用 log, print 等来打印上下文中的变量。使用普通片段按 cl 展示 console.log() 然后把变量字符复制进括号，这样操作会比较复杂。使用正则来动态匹配前面的字符可以很好的解决这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;# 展开 console.log
snippet &amp;quot;([^\s]\w+)\.log&amp;quot; &amp;quot;console.log(postfix)&amp;quot; r
console.log(`!p snip.rv = match.group(1)`)$0
endsnippet
# 当前行转换成大写
snippet &amp;quot;([^\s].*)\.upper&amp;quot; &amp;quot;Uppercase(postfix)&amp;quot; r
`!p snip.rv = match.group(1).upper()`$0
endsnippet
# 上一个单词转换成小写
snippet &amp;quot;([^\s]\w+)\.lower&amp;quot; &amp;quot;Lowercase(postfix)&amp;quot; r
`!p snip.rv = match.group(1).lower()`$0
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动图演示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t25492/223/971280921/61984/701b0ab1/5b84cc6aN6fe8ea04.gif&#34; alt=&#34;expand-regexp-snippets&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：正则代码片段只适用于单行文本处理，如果是多行转换还是得用到下面的 python + VISUAL 代码片段来处理&lt;/p&gt;

&lt;h3 id=&#34;使用-python-解释器-visual-模式实现代码注释功能&#34;&gt;使用 python 解释器 + VISUAL 模式实现代码注释功能&lt;/h3&gt;

&lt;p&gt;通常我们需要使用一大堆插件来实现各种代码的注释功能。不过 Ultisnips 提供了 VISUAL 模式可以提取 vim 可视模式中选择的内容到代码片段里面，于是我们就可以结合起来制作一个&lt;strong&gt;具有注释功能的代码片段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流程大概是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;进入 vim 可视模式，选择要注释的内容&lt;/li&gt;
&lt;li&gt;按 tab，清除选择内容&lt;/li&gt;
&lt;li&gt;输入代码片段触发字符，按 tab 完成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于实现的 python 代码相对复杂一些，主要分成两个方法。单行注释和多行注释，注意 Ultisnips 中可以直接写 python 但是大段的方法建议放在插件目录下面的 pythonx 目录下面，使用的时候在对应的代码片段中的全局 python 代码 &lt;code&gt;global !p&lt;/code&gt; 引入即可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单行注释&lt;/strong&gt;(pythonx/javascript_snippets.py)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def comment(snip, START=&amp;quot;&amp;quot;, END=&amp;quot;&amp;quot;):
    lines = snip.v.text.split(&#39;\n&#39;)[:-1]
    first_line = lines[0]
    spaces = &#39;&#39;
    initial_indent = snip._initial_indent

    # Get the first non-empty line
    for idx, l in enumerate(lines):
        if l.strip() != &#39;&#39;:
            first_line = lines[idx]
            sp = re.findall(r&#39;^\s+&#39;, first_line)
            if len(sp):
                spaces = sp[0]
            break            

    # Uncomment
    if first_line.strip().startswith(START):
        result = [line.replace(START, &amp;quot;&amp;quot;, 1).replace(END, &amp;quot;&amp;quot;, 1) if line.strip() else line for line in lines]
    else:
        result = [f&#39;{spaces}{START}{line[len(spaces):]}{END}&#39; if line.strip() else line for line in lines ]

    # Remove initial indent
    if result[0] and initial_indent:
        result[0] = result[0].replace(initial_indent, &#39;&#39;, 1)

    if result:
        return &#39;\n&#39;.join(result)
    else:
        return &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;多行注释：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def comment_inline(snip, START=&amp;quot;/* &amp;quot;, END=&amp;quot; */&amp;quot;):
    text = snip.v.text
    lines = text.split(&#39;\n&#39;)[:-1]
    first_line = lines[0]
    initial_indent = snip._initial_indent
    spaces = &#39;&#39;

    # Get the first non-empty line
    for idx, l in enumerate(lines):
        if l.strip() != &#39;&#39;:
            first_line = lines[idx]
            sp = re.findall(r&#39;^\s+&#39;, first_line)
            if len(sp):
                spaces = sp[0]
            break            

    if text.strip().startswith(START):
        result = text.replace(START, &#39;&#39;, 1).replace(END, &#39;&#39;, 1)
    else:
        result = text.replace(spaces, spaces + START, 1).rstrip(&#39;\n&#39;) + END + &#39;\n&#39;

    if initial_indent:
        result = result.replace(initial_indent, &#39;&#39;, 1)

    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;代码片段定义：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;global !p
from javascript_snippets import (
	comment, comment_inline
)
endglobal

# ...

snippet c &amp;quot;Toggle comment every single line&amp;quot;
`!p
snip.rv = comment(snip, START=&#39;// &#39;, END=&#39;&#39;)
`$0
endsnippet

snippet ci &amp;quot;Toggle comment inline.&amp;quot;
`!p
snip.rv = comment_inline(snip, START=&amp;quot;/* &amp;quot;, END=&amp;quot; */&amp;quot;)
`$0
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动图演示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t24175/330/2554434390/319822/5d8cf724/5b850d67N4c475946.gif&#34; alt=&#34;python-snippets-to-comment&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不同的语言可以在对应的片段文件中定义并传入注释符号参数即可，有了这个功能就可以愉快的删除其它的 vim 注释插件了 😀&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fuzzy finder(fzf&#43;vim) 使用全指南</title>
      <link>https://keelii.com/2018/08/12/fuzzy-finder-full-guide/</link>
      <pubDate>Sun, 12 Aug 2018 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2018/08/12/fuzzy-finder-full-guide/</guid>
      <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;Fuzzy finder&lt;/a&gt; 是一款使用 GO 语言编写的交互式的 Unix 命令行工具。可以用来查找任何 &lt;strong&gt;列表&lt;/strong&gt; 内容，文件、Git 分支、进程等。所有的命令行工具可以生成列表输出的都可以再通过管道 pipe 到 fzf 上进行搜索和查找&lt;/p&gt;

&lt;h2 id=&#34;优点&#34;&gt;优点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GO 语言编写，编译完生成可执行文件没有任何依赖&lt;/li&gt;
&lt;li&gt;搜索/查找速度飞快&lt;/li&gt;
&lt;li&gt;功能全面/可视化界面体验很棒&lt;/li&gt;
&lt;li&gt;周边插件丰富 (vim, tmux, fuzzy auto-completion)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;以 macOS 为例子，直接使用 homebrew 安装即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install fzf
# 如果要使用内置的快捷键绑定和命令行自动完成功能的话可以按需安装
$(brew --prefix)/opt/fzf/install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;命令行下执行 &lt;code&gt;fzf&lt;/code&gt; 即可展示当前目录下所有文件列表，可以用键盘上下键或者鼠标点出来选择
&lt;a href=&#34;https://img10.360buyimg.com/devfe/jfs/t26002/277/432949068/59208/9725245b/5b6fc71fN03036763.png&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t26002/277/432949068/59208/9725245b/5b6fc71fN03036763.png&#34; alt=&#34;fzf-normal&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;或许你会觉得这个查找提示看起来挺漂亮的，但是并没有什么卵用，因为查找出来就没有然后了。其实这也是 Fuzzy finder 最核心的地方，他只是一个通用的下拉查找功能，自己本身并不关心你用它来做什么，通常我们需要组合使用才会有很好的效果&lt;/p&gt;

&lt;h3 id=&#34;用-vim-打开文件&#34;&gt;用 vim 打开文件&lt;/h3&gt;

&lt;p&gt;比如我们用 vim 组合 fzf 来查找并打开目录下的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim $(fzf)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t25372/5/461999989/83158/3ce44a5/5b6fc7f2Nd6432499.gif&#34; alt=&#34;fzf-vim&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;切换当前工作目录&#34;&gt;切换当前工作目录&lt;/h3&gt;

&lt;p&gt;再比如进入到某个文件夹下面，使用 fzf 的过滤选择真是太方便了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd $(find * -type d | fzf)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是个组合 (cd+find+fzf) 命令，完成切换到任意子目录的功能。可以看出来当 fzf 和其它命令组合使用时就能使得一些操作更方便：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用 find 命令找出所有的子目录&lt;/li&gt;
&lt;li&gt;把子目录列表 pipe 到 fzf 上进行选择&lt;/li&gt;
&lt;li&gt;再把结果以子命令的形式传给 cd&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t23848/96/1951894215/50884/20a513d7/5b6fcabbNb77c46d5.gif&#34; alt=&#34;fzf-find-cd&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;切换-git-分支&#34;&gt;切换 git 分支&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout $(git branch -r | fzf)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t23242/262/2000817850/127859/c0955478/5b6fce70N3c3573ae.gif&#34; alt=&#34;fzf-git-branch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不过这样组合使用命令的实在太长了，如果你不使用自动补全的话巧起来很累的。建议把常用的 alias 放在 .zshrc 中管理嘛&lt;/p&gt;

&lt;h3 id=&#34;shell-命令行补全&#34;&gt;shell 命令行补全&lt;/h3&gt;

&lt;p&gt;fzf 默认使用 &lt;code&gt;**&lt;/code&gt; 来补全 shell 命令，比起默认的 tab 补全，fzf 补全不知道高到哪里去了。cd, vim, kill, ssh, export&amp;hellip; 统统都能补全，好用哭了 🤣&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t24820/280/435378103/490486/3777afba/5b6fedc6N59529380.gif&#34; alt=&#34;fzf-completion&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;p&gt;fzf 提供了两个 &lt;em&gt;环境变量&lt;/em&gt; 配置参数，来分别设置默认的调用命令和 fzf 默认配置参数&lt;/p&gt;

&lt;h3 id=&#34;核心命令-fzf-default-command&#34;&gt;核心命令 FZF_DEFAULT_COMMAND&lt;/h3&gt;

&lt;p&gt;对于使用 fzf 来查找文件的情况，fzf 其实底层是调用的 Unix 系统 &lt;code&gt;find&lt;/code&gt; 命令，如果你觉得 find 不好用也可以使用其它查找文件的命令行工具「我使用 &lt;a href=&#34;https://github.com/sharkdp/fd&#34;&gt;fd&lt;/a&gt;」。注意：对原始命令添加一些参数应该在这个环境变量里面添加&lt;/p&gt;

&lt;p&gt;比如说我们一般都会查找文件 &lt;code&gt;-type f&lt;/code&gt;，通常会忽略一些文件夹/目录 &lt;code&gt;--exclude=...&lt;/code&gt;，下面是我的变量值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export FZF_DEFAULT_COMMAND=&amp;quot;fd --exclude={.git,.idea,.vscode,.sass-cache,node_modules,build} --type f&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;界面展示-fzf-default-opts&#34;&gt;界面展示 FZF_DEFAULT_OPTS&lt;/h3&gt;

&lt;p&gt;界面展示这些参数在 &lt;code&gt;fzf --help&lt;/code&gt; 中都有，按需配置即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export FZF_DEFAULT_OPTS=&amp;quot;--height 40% --layout=reverse --preview &#39;(highlight -O ansi {} || cat {}) 2&amp;gt; /dev/null | head -500&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;界面配置参数加上后就漂亮多了
&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t24178/228/1983729650/93496/412c5c52/5b6fd697N0d686b66.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t24178/228/1983729650/93496/412c5c52/5b6fd697N0d686b66.png&#34; alt=&#34;fzf-with-preview&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--preview&lt;/code&gt; 表示在右侧显示文件的预览界面，语法高亮的设置使用了 &lt;a href=&#34;http://www.andre-simon.de/doku/highlight/en/highlight.php&#34;&gt;highlight&lt;/a&gt; 如果 highlight 失败则使用最常见的 &lt;code&gt;cat&lt;/code&gt; 命令来查看文件内容&lt;/p&gt;

&lt;p&gt;highlight 安装可能会有个小插曲。highlight 需要手动编译安装，默认安装目录在 &lt;code&gt;/usr/bin&lt;/code&gt;, &lt;code&gt;/usr/share&lt;/code&gt; 下面。然而在 macOS 中由于 &lt;abbr title=&#34;System Integrity Protection&#34;&gt;SIP&lt;/abbr&gt; 保护，用户安装的程序不能在这几个目录下面「即使有 sudo 权限也不行」。我们可以手动更改下 highlight 源代码中 makefile 中的参数即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;# PREFIX = /usr
PREFIX = /usr/local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将 &lt;code&gt;PREFIX = /usr&lt;/code&gt; 改成 &lt;code&gt;PREFIX = /usr/local&lt;/code&gt;，然后 &lt;code&gt;make&lt;/code&gt;，&lt;code&gt;sudo make install&lt;/code&gt; 就可以了&lt;/p&gt;

&lt;h3 id=&#34;触发命令行补全-fzf-completion-trigger&#34;&gt;触发命令行补全 FZF_COMPLETION_TRIGGER&lt;/h3&gt;

&lt;p&gt;默认是 &lt;code&gt;**&lt;/code&gt;，一般不用修改&lt;/p&gt;

&lt;h2 id=&#34;vim-fzf-插件&#34;&gt;VIM fzf 插件&lt;/h2&gt;

&lt;p&gt;如果你使用 vim，那么官方提供的插件会让你的 vim 使用更加流畅&lt;/p&gt;

&lt;h3 id=&#34;安装插件&#34;&gt;安装插件&lt;/h3&gt;

&lt;p&gt;如果你本地安装过 fzf 命令行工具了，只需要在 .vimrc 里面添加下面两个插件配置即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Plug &#39;/usr/local/opt/fzf&#39;
Plug &#39;junegunn/fzf.vim&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：使用了 &lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;vim-plug&lt;/a&gt; 插件管理&lt;/p&gt;

&lt;p&gt;插件主要对 fzf 集成绑定了一些和 vim 相关的功能，比如：查找当前 Buffer、Tag、Marks。甚至切换 window 更换 vim 主题配色等&lt;/p&gt;

&lt;p&gt;命令模式下敲 &lt;code&gt;Files&lt;/code&gt; 即可选择当前目录下所有文件，&lt;code&gt;Buffers&lt;/code&gt; 可以过滤当前所有 vim buffer 内容&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t25240/349/434572567/558564/433c151a/5b6fdfadNfd6ea407.gif&#34; alt=&#34;fzf-vim-plugin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再配置几个常用快捷键就可以直接取代 CtrlP 插件了 🤔&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ctrl + p 查看文件列表&lt;/li&gt;
&lt;li&gt;Ctrl + e 查看当前 Buffer，两次 Ctrl + e 快速切换上次打开的 Buffer&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;nmap &amp;lt;C-p&amp;gt; :Files&amp;lt;CR&amp;gt;
nmap &amp;lt;C-e&amp;gt; :Buffers&amp;lt;CR&amp;gt;
let g:fzf_action = { &#39;ctrl-e&#39;: &#39;edit&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;当然 fzf 还可以在很多其它场景下用来。如果你想使用可视化的列表选择而不是咣咣敲命令，那就自己搭配一些组合来使用吧&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jQuery ajax 方法 data 参数默认 encode 失败的 bug</title>
      <link>https://keelii.com/2018/05/25/jquery-ajax-data-param-auto-encode-bug/</link>
      <pubDate>Fri, 25 May 2018 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2018/05/25/jquery-ajax-data-param-auto-encode-bug/</guid>
      <description>&lt;p&gt;使用 jQuery ajax 方法调用异步接口时 data 参数默认会被添加转码 &lt;code&gt;encodeURIComponent&lt;/code&gt;，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$.ajax({
    url: &#39;http://your.domain.com/action&#39;,
    dataType: &#39;jsonp&#39;,
    data: {
        spaces: &#39;a b&#39;,
        other: &#39;&amp;amp;&#39;
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码会向 &lt;code&gt;http://your.domain.com/action?spaces=a+b&amp;amp;other=%26&lt;/code&gt; 发送 get 请求，奇怪的是参数中的 &lt;code&gt;&amp;amp;&lt;/code&gt; 被正确转码成 &lt;code&gt;%26&lt;/code&gt;，但是  被转成了 &lt;code&gt;+&lt;/code&gt; 而不是 &lt;code&gt;%20&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;看看正确的转码结果长啥样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;encodeURIComponent(&#39;&amp;amp;&#39;) // =&amp;gt; &amp;quot;%26&amp;quot;
encodeURIComponent(&#39; &#39;) // =&amp;gt; &amp;quot;%20&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然 data 参数里面的 key,value 都要被 encodeURIComponent，那么出现这种情况只能去查 jQuery 源代码了。jQuery 会调用 $.param 方法来编码 data 参数，大概在 &lt;strong&gt;jQuery-1.7.2&lt;/strong&gt; 的 &lt;em&gt;(7736)&lt;/em&gt; 行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;param: function( a, traditional ) {
    // ...
    } else {
        // If traditional, encode the &amp;quot;old&amp;quot; way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for ( var prefix in a ) {
            buildParams( prefix, a[ prefix ], traditional, add );
        }
    }

    // Return the resulting serialization
    return s.join( &amp;quot;&amp;amp;&amp;quot; ).replace( r20, &amp;quot;+&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;param 方法内部会再调用 &lt;code&gt;buildParams&lt;/code&gt; 来把 data 对象键值对添加编码，一切都很正常&lt;/p&gt;

&lt;p&gt;然饿最后一行 &lt;code&gt;replace( r20, &amp;quot;+&amp;quot; )&lt;/code&gt; 是什么鬼！&lt;code&gt;r20&lt;/code&gt; 变量是内部的一个空白转义符的正则 &lt;code&gt;/%20/g&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这就有点意思了，为啥把正确的空格编码再转回 &lt;code&gt;+&lt;/code&gt; 呢？&lt;/p&gt;

&lt;p&gt;外事不决问 Google，搜索 &lt;code&gt;why jquery ajax convert %20 to +&lt;/code&gt; 结果发现有一条 jQuery 官方的 github issue: &lt;a href=&#34;https://github.com/jquery/jquery/issues/2658&#34;&gt;Only change %20 to + for application/x-www-form-urlencoded&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t20344/242/259059096/183424/9e8e0f30/5b078bbdN06c75a01.png&#34; alt=&#34;google-why-jquery-convert-space-to-plus&#34; /&gt;&lt;/p&gt;

&lt;p&gt;根据 issue 的描述大意是说 &lt;code&gt;convert %20 to +&lt;/code&gt; 这个逻辑只应该在 POST 请求的时候做转换，而不是所有请求。我们的示例中的 jsonp 刚好是 get 请求&lt;/p&gt;

&lt;p&gt;继续往下看找到了一个 &lt;a href=&#34;https://github.com/dmethvin/jquery/commit/60453ce299a0c84550e70010ceea12d538226bf5&#34;&gt;commit(60453ce)&lt;/a&gt; 修复了这个问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img14.360buyimg.com/devfe/jfs/t20692/166/263146843/79735/7f45adb2/5b078b49N8f97629d.png&#34; alt=&#34;jquery-param-encode-bug&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意一点，我们并不能简单的在 data 对象传入的时候手动添加 &lt;code&gt;encodeURIComponent&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$.ajax({
    url: &#39;http://your.domain.com/action&#39;,
    dataType: &#39;jsonp&#39;,
    data: {
        // 错误的做法
        spaces: encodeURIComponent(&#39;a b&#39;),
        other: &#39;&amp;amp;&#39;
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 spaces 参数有别的应该被正常编码的字符串，这样会导致正常的被编码的字符被 &lt;strong&gt;两次&lt;/strong&gt; encodeURIComponent。所以要正确解决这个问题需要修改 jQuery 源代码，这个可以参考上面的那个 fix commit&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>又双叒叕写了一个 host 管理插件</title>
      <link>https://keelii.com/2017/11/07/yet-another-host-manager-plugin/</link>
      <pubDate>Tue, 07 Nov 2017 12:51:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/11/07/yet-another-host-manager-plugin/</guid>
      <description>

&lt;p&gt;切 host 对于平常开发来说再正常不过了，可是「切 host 难」的问题一直没解决，因为手动修改 host 文件会有很多（系统dns、浏览器）缓存问题。经常听到xx说「我这是好的呀，你 host 有问题吧&amp;hellip;」&lt;/p&gt;

&lt;p&gt;在 windows 下我一直使用 fiddler 来切换 host，很多人可能不知道这个功能。他的实现本质就是实用代理映射来实现 host 切换。这样的欢最大的优点就是 &lt;strong&gt;无延迟，秒切 host&lt;/strong&gt; 这个体验就非常赞，而且是系统级别的，也就是说别的浏览器里面也适用（前提是浏览器代理设置为系统）&lt;/p&gt;

&lt;p&gt;然后由于最近切换到 mac 开发环境，发现 mac 下面的解决方案都不是很完美，或者说不适合我的要求。无外乎以下几种：&lt;/p&gt;

&lt;h2 id=&#34;物理修改-host-文件&#34;&gt;物理修改 host 文件&lt;/h2&gt;

&lt;p&gt;像 iHosts, Switchhosts 这类，但据我所知这种方法都有延迟&lt;/p&gt;

&lt;h2 id=&#34;抓包工具代理切-host&#34;&gt;抓包工具代理切 host&lt;/h2&gt;

&lt;p&gt;比如 mac 下的 Wireshark、Charles，这些工具据说很强大，可是我自己用不惯，而且我是需求也很小，杀鸡焉用牛刀。fiddler for mac 虽然也能跑起来，但是体验太差了，界面卡的要死&lt;/p&gt;

&lt;h2 id=&#34;浏览器插件代理切-host&#34;&gt;浏览器插件代理切 host&lt;/h2&gt;

&lt;p&gt;像 Chrome 下的 Chrome-host-switch、 Switch host plus 等，试用了下效果很理想。美中不足的是体验不好，只有标签没有分组，把标签当分组切的人很蛋疼&lt;/p&gt;

&lt;p&gt;简单看了下 switch host plus 的实现方式，再加上自己之前也写过 chrome 插件就决定自己造个轮子。Chrome 插件基于html、css、javascript 自然很适合前端来做&lt;/p&gt;

&lt;p&gt;由于最近在看 react 相关的东西，刚好拿来练练手。技术选型基本上都是现成的框架拿来用就行了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;react &amp;amp; redux 构建整体应用&lt;/li&gt;
&lt;li&gt;bulma.css 简洁小巧的 CSS 框架&lt;/li&gt;
&lt;li&gt;localStorage 数据直接写本地存储&lt;/li&gt;
&lt;li&gt;create react app 构建打包应用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;应用截图&#34;&gt;应用截图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t11611/80/1444685331/28555/590b5dfa/5a013f0aN19565830.png&#34; alt=&#34;ahm-640x440&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t11845/332/1453803626/635686/c8e4f98/5a013fe8N41db44e3.png&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t11845/332/1453803626/635686/c8e4f98/5a013fe8N41db44e3.png&#34; alt=&#34;ahm-1280x800&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;功能&#34;&gt;功能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;秒切 host 无延迟 😎&lt;/li&gt;
&lt;li&gt;基于 chrome 代理 ❤️&lt;/li&gt;
&lt;li&gt;兼容 socket 代理 🤔&lt;/li&gt;
&lt;li&gt;简洁好用，无多余功能 👏&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/awesome-host-manager/pikaoeecieigblebdddckmlegonlogha?hl=zh-CN&#34;&gt;Chrome 应用商店&lt;/a&gt;（建议）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/keelii/awesome-host-manager/master/awesome-host-manager.crx&#34;&gt;下载 .crx 文件&lt;/a&gt; chrome 中打开 chrome://extensions/ 将.crx 文件托进安装即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;h4 id=&#34;host-proxy&#34;&gt;Host proxy&lt;/h4&gt;

&lt;p&gt;和 host 文件规则一致&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;192.168.100.1 your.domain.com your-anther.domain.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;socket-proxy&#34;&gt;Socket proxy&lt;/h4&gt;

&lt;p&gt;新建分组加入以下规则（按自己实际情况修改）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOCKS5 127.0.0.1:1080
SOCKS 127.0.0.1:1080
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;源代码&#34;&gt;源代码&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/keelii/awesome-host-manager&#34;&gt;Github&lt;/a&gt;(MIT)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解决 seajs parseDependencies 方法引起的依赖解析错误问题</title>
      <link>https://keelii.com/2017/11/03/fix-seajs-parse-dep-bug/</link>
      <pubDate>Fri, 03 Nov 2017 15:51:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/11/03/fix-seajs-parse-dep-bug/</guid>
      <description>&lt;p&gt;使用 seajs 的过程中偶尔会发现 require 进来的模块甚至都没有加载。查看源代码之后发现 seajs 是通过正则表达式匹配出了模块 factory 中的 require 路径&lt;/p&gt;

&lt;p&gt;正常情况下，下面这个模块里面 require 的外部模块会解析出依赖 &lt;code&gt;GLOBAL_ROOT/base/cookie&lt;/code&gt; 和 &lt;code&gt;GLOBAL_ROOT/base/utils&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;define(&#39;moduleName&#39;, function() {
    var a = require(&#39;GLOBAL_ROOT/base/cookie&#39;)
    var b = require(&#39;GLOBAL_ROOT/base/utils&#39;)
    // 正常情况 a 应该是个对象，
    console.log(a)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果 cookie 模块加载失败，a 就会返回 null 这时候再调 a 上面的方法就会报错。当 seajs 内部解析依赖时发生了错误时就会出现这种情况，由于我们使用的是比较老的 seajs 版本（2.2.0），去查看源代码发现 parseDependencies 方法使用了一个正则表达式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var REQUIRE_RE = /&amp;quot;(?:\\&amp;quot;|[^&amp;quot;])*&amp;quot;|&#39;(?:\\&#39;|[^&#39;])*&#39;|\/\*[\S\s]*?\*\/|\/(?:\\\/|[^\/\r\n])+\/(?=[^\/])|\/\/.*|\.\s*require|(?:^|[^$])\brequire\s*\(\s*([&amp;quot;&#39;])(.+?)\1\s*\)/g
var SLASH_RE = /\\\\/g

function parseDependencies(code) {
  var ret = []

  code.replace(SLASH_RE, &amp;quot;&amp;quot;)
      .replace(REQUIRE_RE, function(m, m1, m2) {
        if (m2) {
          ret.push(m2)
        }
      })

  return ret
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在控制台里面跑一下看看结果，上面的模块解析正确：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t11401/113/1005903134/64122/b08677b9/59fc23d6N998f2848.png&#34; alt=&#34;seajs-works-well&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是我自己的场景并没有这么简单，我贴上自己的代码时就异常了，由于源码比较多我就放到 jsbin 上了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jsbin.com/bowazakosu/edit?html,js,console,output&#34;&gt;压缩成一行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jsbin.com/likonikoye/edit?html,js,console,output&#34;&gt;格式化压缩代码后&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有意思的地方就在于 压缩成一行 的代码中是异常的，但是当我把代码格式化后就正常了？！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;seajs 3.x 版本以后 &lt;a href=&#34;https://github.com/seajs/seajs/blob/3.0.0/src/util-deps.js&#34;&gt;util-deps.js&lt;/a&gt; 引入了一个依赖解析器方法，直接用这个替代原来的即可。至于为什么那个正则对于压缩后的代码没起作用我暂还没详细研究，不过感觉像获取模块依赖关系这种静态分析任务还是用解析器靠谱点，正则有太多的不确定性，虽然它能节省很多代码&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>macOS Sierra 开发环境配置指南</title>
      <link>https://keelii.com/2017/10/07/macos-development-setup-guide/</link>
      <pubDate>Sat, 07 Oct 2017 17:19:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/10/07/macos-development-setup-guide/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文来自于我自己配置两台 macOS 开发环境的过程，主要记录一些常用的配置技巧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;系统设置&#34;&gt;系统设置&lt;/h2&gt;

&lt;h3 id=&#34;更改计算机名称&#34;&gt;更改计算机名称&lt;/h3&gt;

&lt;p&gt;macOS 默认的计算机名称「xx的xx」，我一般会把这个名字改成英文，在命令行中看起来会漂亮一点。修改 &lt;code&gt;系统设置-共享-电脑名称&lt;/code&gt; 即可&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t9919/194/838196844/87087/80259170/59d8e3f4N4277172a.png&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t9919/194/838196844/87087/80259170/59d8e3f4N4277172a.png&#34; alt=&#34;computer-name&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;触控板&#34;&gt;触控板&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;设置轻点触控板为鼠标点击&lt;/li&gt;
&lt;li&gt;设置三指拖动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t10129/124/847447368/253995/96574062/59d8e534Nc3e40d9f.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t10129/124/847447368/253995/96574062/59d8e534Nc3e40d9f.png&#34; alt=&#34;tap-click&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://img10.360buyimg.com/devfe/jfs/t10396/219/830021333/98488/bcc6e984/59d8e43cN04d84771.png&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t10396/219/830021333/98488/bcc6e984/59d8e43cN04d84771.png&#34; alt=&#34;drag-drop&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;finder&#34;&gt;Finder&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;开启新 Fidder 窗口时打开 &lt;code&gt;桌面&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行搜索时 &lt;code&gt;搜索当前文件夹&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;显示所有文件扩展名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t9571/278/833569016/71935/221e5956/59d8e45dN67661921.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t9571/278/833569016/71935/221e5956/59d8e45dN67661921.png&#34; alt=&#34;finder&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;其它&#34;&gt;其它&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;系统偏好设置-键盘-输入法-自动切换到文稿输入法&lt;/code&gt; 应用切换的时候会保持原来的输入法不变&lt;/li&gt;
&lt;li&gt;&lt;code&gt;桌面空白处右键-排序方式-贴紧网格&lt;/code&gt; 右键整理图标的时候就会按网格排列&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;开发环境设置&#34;&gt;开发环境设置&lt;/h2&gt;

&lt;h3 id=&#34;安装-command-line-tools&#34;&gt;安装 Command line tools&lt;/h3&gt;

&lt;p&gt;方便后续编译安装其它应用&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t9601/44/840280004/58067/a2e0aa5e/59d8e496N2cdf9cca.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t9601/44/840280004/58067/a2e0aa5e/59d8e496N2cdf9cca.png&#34; alt=&#34;xcode-select&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;xcode-select --install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-brew&#34;&gt;安装 brew&lt;/h3&gt;

&lt;p&gt;一般命令行的工具，或者开发环境包都用 &lt;a href=&#34;https://brew.sh/&#34;&gt;brew&lt;/a&gt; 来安装。GUI 的应用直接去网站下载安装包即可，App Store 我一般用来购买安装一些收费软件&lt;/p&gt;

&lt;p&gt;打开命令行执行下面的命令来安装 brew&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面的命令替换 brew 源为&lt;a href=&#34;https://lug.ustc.edu.cn/wiki/mirrors/help/brew.git&#34;&gt;中科大镜像&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 替换brew.git:
cd &amp;quot;$(brew --repo)&amp;quot;
git remote set-url origin https://mirrors.ustc.edu.cn/brew.git

# 替换homebrew-core.git:
cd &amp;quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;quot;
git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 brew 安装下载源码包有时是用 curl 的，所以可以配置下 curl 来走 &lt;em&gt;番习习墙&lt;/em&gt; 代理，我一般在配置文件中设置 &lt;code&gt;vim ~/.curlrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;socks5 = &amp;quot;127.0.0.1:1080&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-zsh-oh-my-zsh&#34;&gt;安装 Zsh &amp;amp; oh-my-zsh&lt;/h3&gt;

&lt;p&gt;Zsh 是一种 &lt;a href=&#34;https://zh.wikipedia.org/wiki/Unix_shell&#34;&gt;shell&lt;/a&gt;，功能和 bash, csh 一样，用来和操作系统交互&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装 zsh
brew install zsh
# 安装 oh-my-zsh 插件
# 更换默认 shell 为 zsh
chsh -s /bin/zsh
sh -c &amp;quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功的话会有下面的提示&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t10303/164/828630186/232717/e8624f08/59d8e4d7N2c9b44f6.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t10303/164/828630186/232717/e8624f08/59d8e4d7N2c9b44f6.png&#34; alt=&#34;ohmyzsh&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装自动补全提示插件 &lt;a href=&#34;https://github.com/zsh-users/zsh-autosuggestions&#34;&gt;zsh-autosuggestions&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions
source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://img30.360buyimg.com/devfe/jfs/t10564/347/828202786/16788/8bd58613/59d8e50cN2ef8aa62.gif&#34;&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t10564/347/828202786/16788/8bd58613/59d8e50cN2ef8aa62.gif&#34; alt=&#34;zsh-autosuggestions&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装-配置-iterm2&#34;&gt;安装/配置 iTerm2&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.iterm2.com/&#34;&gt;下载&lt;/a&gt; 并安装，打开 Preferences 偏好设置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;General&lt;/code&gt; 关闭 &lt;code&gt;Native full screen windows&lt;/code&gt; 我不使用系统的全屏（因为有过渡动画），是为了使用全局快捷键 &lt;strong&gt;立即&lt;/strong&gt; 调出命令行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Profiles-Window-Transparency&lt;/code&gt; 设置透明度 10%~20% 即可，太高会和桌面背景冲突。如果需要临时禁用透明度可以使用快捷键 &lt;code&gt;⌘+u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Keys-Hotkey&lt;/code&gt; 设置全局显示隐藏快捷键 系统级别的快捷键设置为 &lt;code&gt;⌘+\&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;最佳实践，启动 iTerm2 后按 &lt;code&gt;⌘+enter&lt;/code&gt; 全屏，然后 &lt;code&gt;⌘+\&lt;/code&gt; 隐藏它，这时候就可以做别的事情去了。任何时间想再用 iTerm2 只需要按 &lt;code&gt;⌘+\&lt;/code&gt; 即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;brew-常用工具&#34;&gt;brew 常用工具&lt;/h3&gt;

&lt;p&gt;下面这些都是用 brew 安装的，即 &lt;code&gt;brew install xxx&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;htop&#34;&gt;htop&lt;/h4&gt;

&lt;p&gt;用来查看当前运行的程序，top 命令的升级版&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t10783/119/847515894/438295/9e4709ce/59d8e566N62c288f9.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t10783/119/847515894/438295/9e4709ce/59d8e566N62c288f9.png&#34; alt=&#34;htop&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;tree&#34;&gt;tree&lt;/h4&gt;

&lt;p&gt;显示文件为树形菜单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  keelii.github.io tree . -L 2
.
├── config.toml
├── content
│   ├── about
│   └── archives
├── deploy.sh
├── public
│   ├── 2016
...
│   └── tags
└── themes
    └── octo-enhance

17 directories, 8 files
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;httpie&#34;&gt;httpie&lt;/h4&gt;

&lt;p&gt;使用比 curl 简单多了，而且还有一些代码高亮的效果&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t9175/233/2384082355/52554/472f733/59d8e58fN956a159a.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t9175/233/2384082355/52554/472f733/59d8e58fN956a159a.png&#34; alt=&#34;httpie&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;vim&#34;&gt;vim&lt;/h4&gt;

&lt;p&gt;安装 vim 添加一些默认的模块和编程语言支持 cscope, lua, python 并且覆盖系统默认的 vim&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install vim --HEAD --with-cscope --with-lua --with-override-system-vim --with-luajit --with-python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 vim-plug&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;autojump&#34;&gt;autojump&lt;/h4&gt;

&lt;p&gt;方便在命令行中快速跳转目录，安装后程序会读取你 cd 过的目录并存起来，方便后面用快捷方式调用，支持模糊匹配。&lt;strong&gt;注意: autojump 只会记录安装后使用 cd 命令进入过的目录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//img10.360buyimg.com/devfe/jfs/t10066/212/961703883/22512/ed0565/59dae741N3fcc655c.gif&#34;&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t10066/212/961703883/22512/ed0565/59dae741N3fcc655c.gif&#34; alt=&#34;autojump&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;yarn&#34;&gt;yarn&lt;/h4&gt;

&lt;p&gt;npm 的替代品，Production Ready。如果系统中安装过 node，就使用 &lt;code&gt;yarn --without-node&lt;/code&gt; 命令只安装 yarn 工具&lt;/p&gt;

&lt;h3 id=&#34;安装-python-pip&#34;&gt;安装 python pip&lt;/h3&gt;

&lt;p&gt;下载 &lt;a href=&#34;https://bootstrap.pypa.io/get-pip.py&#34;&gt;get-pip.py&lt;/a&gt; 在命令行中使用 python 运行这个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo python get-pip.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;更改各种程序语言包源&#34;&gt;更改各种程序语言包源&lt;/h3&gt;

&lt;h4 id=&#34;ruby-gemrc&#34;&gt;ruby - .gemrc&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/
gem sources -l
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat ~/.gemrc
---
:backtrace: false
:bulk_threshold: 1000
:sources:
- https://mirrors.tuna.tsinghua.edu.cn/rubygems/
:update_sources: true
:verbose: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;node-yarnrc-npmrc&#34;&gt;node - .yarnrc/.npmrc&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat ~/.yarnrc
registry &amp;quot;https://registry.npm.taobao.org&amp;quot;
disturl &amp;quot;https://npm.taobao.org/dist&amp;quot;
electron_mirror &amp;quot;http://cdn.npm.taobao.org/dist/electron/&amp;quot;
node_inspector_cdnurl &amp;quot;https://npm.taobao.org/mirrors/node-inspector&amp;quot;
sass_binary_site &amp;quot;http://cdn.npm.taobao.org/dist/node-sass&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dotfiles-配置文件&#34;&gt;dotfiles 配置文件&lt;/h3&gt;

&lt;p&gt;可以参照我的 &lt;a href=&#34;https://github.com/keelii/dotfiles&#34;&gt;dotfiles&lt;/a&gt; 配置文件&lt;/p&gt;

&lt;h3 id=&#34;其它-gui-应用&#34;&gt;其它 GUI 应用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.alfredapp.com/&#34;&gt;Alfred&lt;/a&gt; 程序启动器&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://theunarchiver.com/&#34;&gt;The Unarchiver&lt;/a&gt; ⇒ 解压工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/magnet/id441258766?mt=12&#34;&gt;Magent&lt;/a&gt; ⇒ 排列窗口（付费）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mowglii.com/itsycal/&#34;&gt;Itsycal&lt;/a&gt; ⇒ 简洁版日历&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href=&#34;http://snip.qq.com/&#34;&gt;Snip&lt;/a&gt; ⇒ 屏幕截图&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href=&#34;http://snappy-app.com/&#34;&gt;Snappy&lt;/a&gt; ⇒ 屏幕截图、修改分享&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.snipaste.com/&#34;&gt;Snipaste&lt;/a&gt; ⇒ 更好用的屏幕截图&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pasteapp.me/&#34;&gt;Paste&lt;/a&gt; 剪贴板管理工具（付费）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://typora.io/&#34;&gt;Typora&lt;/a&gt; 正确的使用 markdown 写文档笔记等&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pqrs.org/osx/karabiner/&#34;&gt;Karabiner-Elements&lt;/a&gt; ⇒ 改键器, 改键方案参照&lt;a href=&#34;https://keelii.com/2017/10/03/how-to-map-single-command-key-on-mac/&#34;&gt;上篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://freemacsoft.net/appcleaner/&#34;&gt;AppCleaner 2&lt;/a&gt; ⇒ 卸载应用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cockos.com/licecap/&#34;&gt;licecap for mac&lt;/a&gt; ⇒ 录制 gif 图片&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zipzapmac.com/go2shell&#34;&gt;Go2shell&lt;/a&gt; ⇒ Finder 当前目录打开命令行&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>macOS 单独设置 command(⌘) 键点击功能</title>
      <link>https://keelii.com/2017/10/03/how-to-map-single-command-key-on-mac/</link>
      <pubDate>Tue, 03 Oct 2017 17:10:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/10/03/how-to-map-single-command-key-on-mac/</guid>
      <description>&lt;p&gt;由于最近全面切换工作环境到 Mac 上，快捷键基本上成了适应期的最大问题&lt;/p&gt;

&lt;p&gt;传统意义上像 &lt;code&gt;Ctrl, Alt, Shift, Win, Option, Command&lt;/code&gt; 都属于 &lt;code&gt;修饰键&lt;/code&gt;，只能和其它键配合使用才可以（Ctrl+c,Ctrl+v），单独敲击并没有效果&lt;/p&gt;

&lt;p&gt;但是 Win 键在 Windows 中被赋予了更多的功能，下面这几个系统级别的快捷键用起来是非常方便的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Win + E&lt;/code&gt; ⇒ 打开资源管理器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Win + D&lt;/code&gt; ⇒ 显示桌面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Win + L&lt;/code&gt; ⇒ 锁定计算机&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前使用过 Windows 和 Ubuntu gnome，特别方便的一点就是 super(Win) 键 &lt;strong&gt;不仅&lt;/strong&gt; 可以做为修饰键和其它键组合使用，而且还可以响应 &lt;strong&gt;单独的&lt;/strong&gt; 点击事件，Windows 中点击 Win 键会全局呼出 &lt;em&gt;开始菜单&lt;/em&gt; 方便我们 &lt;em&gt;查找/打开&lt;/em&gt; 应用。这样的话单独点击相当于可以少按一个按键，切找应用什么的非常快&lt;/p&gt;

&lt;p&gt;Mac 中我通常使用 Spotlight 来快速切换程序。用惯了 Mac 的人会觉得 command 键位非常舒服好按（键位原因），这时候我希望尽可能把常用的键组织到 command 上又 &lt;strong&gt;不影响&lt;/strong&gt; 原来的组合键，比如我有下面两个最常使用的快捷键：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘&lt;/code&gt; ⇒ 呼出 Spotlight&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ + Space&lt;/code&gt; ⇒ 切换输入法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而 Mac 系统中并不允许我们这么做 🤔，于是我使用了一个改键器 &lt;a href=&#34;https://pqrs.org/osx/karabiner/&#34;&gt;Karabiner&lt;/a&gt; 😎&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t9160/329/2610957899/117091/8481138f/59d34e67Nb3bd2a2d.png&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t9160/329/2610957899/117091/8481138f/59d34e67Nb3bd2a2d.png&#34; alt=&#34;mac-karabiner&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我的配置方法是使用 &lt;code&gt;Complex Modifications&lt;/code&gt; 因为它允许我把修饰键改成其它按钮功能。在这里我将其改为一个没用的键位（f13 - PrtSc），因为 Spotlight 不接受单独的修饰键，所以只能这样区线救国了&lt;/p&gt;

&lt;p&gt;然后在系统偏好设置 - 键盘 - 快捷键 中将 Spotlight 设置成 F13&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img12.360buyimg.com/devfe/jfs/t9769/96/578527884/124966/ff1a2f04/59d34fbeN5b1e4775.png&#34;&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t9769/96/578527884/124966/ff1a2f04/59d34fbeN5b1e4775.png&#34; alt=&#34;mac-spotlight&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意：默认的 Complex Modifications 里面是空的，需要你手动导入一个叫 &lt;a href=&#34;https://pqrs.org/osx/karabiner/complex_modifications/#modifier_keys&#34;&gt;Tapping modifier-keys produces a f-key.&lt;/a&gt;。然后我们 &lt;code&gt;enable&lt;/code&gt; 这条：&lt;strong&gt;Press left_command alone produces F14&lt;/strong&gt;，噫~我们是要 map 成 F13 这里默认的是 F14，怎么改下呢。改配置文件吧，打开下面这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim ~/.config/karabiner/karabiner.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将里面的 F14 改成 F13 即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;// ...
&amp;quot;complex_modifications&amp;quot;: {
    &amp;quot;parameters&amp;quot;: {
        &amp;quot;basic.to_if_alone_timeout_milliseconds&amp;quot;: 600
    },
    &amp;quot;rules&amp;quot;: [
        {
            &amp;quot;description&amp;quot;: &amp;quot;Press left_command alone produces F14&amp;quot;,
            &amp;quot;manipulators&amp;quot;: [
                {
                    &amp;quot;from&amp;quot;: {
                        &amp;quot;key_code&amp;quot;: &amp;quot;left_command&amp;quot;,
                        &amp;quot;modifiers&amp;quot;: { &amp;quot;optional&amp;quot;: [ &amp;quot;any&amp;quot; ] }
                    },
                    &amp;quot;to&amp;quot;: [ { &amp;quot;key_code&amp;quot;: &amp;quot;left_command&amp;quot; } ],
                    &amp;quot;to_if_alone&amp;quot;: [ { &amp;quot;key_code&amp;quot;: &amp;quot;f14&amp;quot; } ],
                    &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;
                }
            ]
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样基本上的完成我的需求了，打开应用只需要按一次 ⌘ 即可呼出 Spotlight，像打开 Google Chrome 只需要两个键即可 &lt;code&gt;⌘ g&lt;/code&gt;、Webstorm &lt;code&gt;⌘ w&lt;/code&gt;、Firefox &lt;code&gt;⌘ f&lt;/code&gt; &amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;备注：我用的机器是 Mac mini 主机 + filco 87 键盘&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>jQuery data 方法的一个小特技</title>
      <link>https://keelii.com/2017/05/03/a-trick-from-jquery-data-method/</link>
      <pubDate>Wed, 03 May 2017 17:59:45 +0800</pubDate>
      
      <guid>https://keelii.com/2017/05/03/a-trick-from-jquery-data-method/</guid>
      <description>&lt;p&gt;通常我们在用 JavaScript 操作 DOM 元素的时候会往 DOM 上临时添加一些参数，用来记住一些状态，或者从后端取参数值等&lt;/p&gt;

&lt;p&gt;一般通过在 HTML 标签上添加自定义属性来实现，但是这样会不可避免的访问 DOM，性能上并不好。如果你使用 jQuery 的话建议使用 &lt;code&gt;$el.data()&lt;/code&gt; 方法来取元素上 &lt;code&gt;data-*&lt;/code&gt; 的值，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;demo&amp;quot; data-key=&amp;quot;value&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    $(&#39;#demo&#39;).attr(&#39;data-key&#39;)
    $(&#39;#demo&#39;).data(&#39;key&#39;)  // 第一次访问 DOM，以后从缓存取
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个方法的区别在于 attr 每次都会直接访问 DOM 元素，而 data 方法会缓存第一次的查找，后续调用不需要访问 DOM&lt;/p&gt;

&lt;p&gt;很明显建议使用后者，但是在 &lt;strong&gt;低版本的 jQuery&lt;/strong&gt; 中默认会对 data 方法取到的值进行粗暴的强制数据类型转换「parseFloat」。看下面代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;demo0&amp;quot; data-key=&amp;quot;abc&amp;quot;&amp;gt;字符串&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo1&amp;quot; data-key=&amp;quot;123&amp;quot;&amp;gt;数字&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo2&amp;quot; data-key=&amp;quot;123e456&amp;quot;&amp;gt;科学计数法&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo3&amp;quot; data-key=&amp;quot;0000123&amp;quot;&amp;gt;八进制数字&amp;lt;/div&amp;gt;
&amp;lt;script src=&amp;quot;jquery-1.6.4&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    $(&#39;#demo0&#39;).data(&#39;key&#39;)  // &amp;quot;abc&amp;quot;
    $(&#39;#demo1&#39;).data(&#39;key&#39;)  // 123
    $(&#39;#demo2&#39;).data(&#39;key&#39;)  // Infinity
    $(&#39;#demo3&#39;).data(&#39;key&#39;)  // 83
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面两种显然出错了，就是因为 jQuery 对属性值进行了强制 parseFloat 操作。这种转换是方便了使用者，如果是数字的话我们取到这个值进行计算什么的就不用再转数据类型了，但是一不小心就会出 bug&lt;/p&gt;

&lt;p&gt;发现这个 bug 的时候第一感觉是 jQuery 不应该没考虑到这一点呀。后来果断去查了下最新版的 jQuery 源代码，发现已经修复了。核心代码在 &lt;a href=&#34;https://github.com/jquery/jquery/blob/master/src/data.js#L36&#34;&gt;data.js 35 行&lt;/a&gt;，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getData( data ) {
    if ( data === &amp;quot;true&amp;quot; ) {
        return true;
    }

    if ( data === &amp;quot;false&amp;quot; ) {
        return false;
    }

    if ( data === &amp;quot;null&amp;quot; ) {
        return null;
    }

    // Only convert to a number if it doesn&#39;t change the string
    // 重点就在这里 →_→
    if ( data === +data + &amp;quot;&amp;quot; ) {
        return +data;
    }

    if ( rbrace.test( data ) ) {
        return JSON.parse( data );
    }

    return data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getData 方法就返回了节点属性的值，只不过加了一些特殊处理使得我们取到了没有 bug 的值，关键地方就在这里： &lt;code&gt;data === +data + &amp;quot;&amp;quot;&lt;/code&gt; 。这行代码做了些什么神奇的事情&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;将节点的属性值强制转换成数字「+data」后再转成字符串「+ &amp;ldquo;&amp;ldquo;」，如果转换后的值与原来相等就取转换后的值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以简单的这么理解：jQuery 会尝试转换数据类型，如果转换后和转换前的 &lt;strong&gt;长得一样&lt;/strong&gt; 那么 jQuery 就认为它是需要被转换成数字的。这样就可以完美规避上面例子中的两种问题，我们来测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var data = &#39;abc&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值

var data = &#39;123&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // true 转换，使用转换后的数字类型值

var data = &#39;123e456&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值

var data = &#39;0000123&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>