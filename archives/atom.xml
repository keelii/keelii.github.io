<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Archives on Something</title>
    <link>https://keelii.github.io/archives/</link>
    <description>Recent content in Archives on Something</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 07 Nov 2017 12:51:27 +0000</lastBuildDate>
    
        <atom:link href="https://keelii.github.io/archives/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>又双叕写了一个 host 管理插件</title>
      <link>https://keelii.github.io/2017/11/07/yet-another-host-manager-plugin/</link>
      <pubDate>Tue, 07 Nov 2017 12:51:27 +0000</pubDate>
      
      <guid>https://keelii.github.io/2017/11/07/yet-another-host-manager-plugin/</guid>
      <description>

&lt;p&gt;切 host 对于平常开发来说再正常不过了，可是「切 host 难」的问题一直没解决，因为手动修改 host 文件会有很多（系统dns、浏览器）缓存问题。经常听到xx说「我这是好的呀，你 host 有问题吧&amp;hellip;」&lt;/p&gt;

&lt;p&gt;在 windows 下我一直使用 fiddler 来切换 host，很多人可能不知道这个功能。他的实现本质就是实用代理映射来实现 host 切换。这样的欢最大的优点就是 &lt;strong&gt;无延迟，秒切 host&lt;/strong&gt; 这个体验就非常赞，而且是系统级别的，也就是说别的浏览器里面也适用（前提是浏览器代理设置为系统）&lt;/p&gt;

&lt;p&gt;然后由于最近切换到 mac 开发环境，发现 mac 下面的解决方案都不是很完美，或者说不适合我的要求。无外乎以下几种：&lt;/p&gt;

&lt;h2 id=&#34;物理修改-host-文件&#34;&gt;物理修改 host 文件&lt;/h2&gt;

&lt;p&gt;像 iHosts, Switchhosts 这类，但据我所知这种方法都有延迟&lt;/p&gt;

&lt;h2 id=&#34;抓包工具代理切-host&#34;&gt;抓包工具代理切 host&lt;/h2&gt;

&lt;p&gt;比如 mac 下的 Wireshark、Charles，这些工具据说很强大，可是我自己用不惯，而且我是需求也很小，杀鸡焉用牛刀。fiddler for mac 虽然也能跑起来，但是体验太差了，界面卡的要死&lt;/p&gt;

&lt;h2 id=&#34;浏览器插件代理切-host&#34;&gt;浏览器插件代理切 host&lt;/h2&gt;

&lt;p&gt;像 Chrome 下的 Chrome-host-switch、 Switch host plus 等，试用了下效果很理想。美中不足的是体验不好，只有标签没有分组，把标签当分组切的人很蛋疼&lt;/p&gt;

&lt;p&gt;简单看了下 switch host plus 的实现方式，再加上自己之前也写过 chrome 插件就决定自己造个轮子。Chrome 插件基于html、css、javascript 自然很适合前端来做&lt;/p&gt;

&lt;p&gt;由于最近在看 react 相关的东西，刚好拿来练练手。技术选型基本上都是现成的框架拿来用就行了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;react &amp;amp; redux 构建整体应用&lt;/li&gt;
&lt;li&gt;bulma.css 简洁小巧的 CSS 框架&lt;/li&gt;
&lt;li&gt;localStorage 数据直接写本地存储&lt;/li&gt;
&lt;li&gt;create react app 构建打包应用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;应用截图&#34;&gt;应用截图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t11611/80/1444685331/28555/590b5dfa/5a013f0aN19565830.png&#34; alt=&#34;ahm-640x440&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t11845/332/1453803626/635686/c8e4f98/5a013fe8N41db44e3.png&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t11845/332/1453803626/635686/c8e4f98/5a013fe8N41db44e3.png&#34; alt=&#34;ahm-1280x800&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;功能&#34;&gt;功能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;秒切 host 无延迟 😎&lt;/li&gt;
&lt;li&gt;基于 chrome 代理 ❤️&lt;/li&gt;
&lt;li&gt;兼容 socket 代理 🤔&lt;/li&gt;
&lt;li&gt;简洁好用，无多余功能 👏&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/awesome-host-manager/pikaoeecieigblebdddckmlegonlogha?hl=zh-CN&#34;&gt;Chrome 应用商店&lt;/a&gt;（建议）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/keelii/awesome-host-manager/master/awesome-host-manager.crx&#34;&gt;下载 .crx 文件&lt;/a&gt; chrome 中打开 chrome://extensions/ 将.crx 文件托进安装即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;h4 id=&#34;host-proxy&#34;&gt;Host proxy&lt;/h4&gt;

&lt;p&gt;和 host 文件规则一致&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;192.168.100.1 your.domain.com your-anther.domain.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;socket-proxy&#34;&gt;Socket proxy&lt;/h4&gt;

&lt;p&gt;新建分组加入以下规则（按自己实际情况修改）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOCKS5 127.0.0.1:1080
SOCKS 127.0.0.1:1080
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;源代码&#34;&gt;源代码&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/keelii/awesome-host-manager&#34;&gt;Github&lt;/a&gt;(MIT)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解决 seajs parseDependencies 方法引起的依赖解析错误问题</title>
      <link>https://keelii.github.io/2017/11/03/fix-seajs-parse-dep-bug/</link>
      <pubDate>Fri, 03 Nov 2017 15:51:27 +0000</pubDate>
      
      <guid>https://keelii.github.io/2017/11/03/fix-seajs-parse-dep-bug/</guid>
      <description>&lt;p&gt;使用 seajs 的过程中偶尔会发现 require 进来的模块甚至都没有加载。查看源代码之后发现 seajs 是通过正则表达式匹配出了模块 factory 中的 require 路径&lt;/p&gt;

&lt;p&gt;正常情况下，下面这个模块里面 require 的外部模块会解析出依赖 &lt;code&gt;GLOBAL_ROOT/base/cookie&lt;/code&gt; 和 &lt;code&gt;GLOBAL_ROOT/base/utils&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;define(&#39;moduleName&#39;, function() {
    var a = require(&#39;GLOBAL_ROOT/base/cookie&#39;)
    var b = require(&#39;GLOBAL_ROOT/base/utils&#39;)
    // 正常情况 a 应该是个对象，
    console.log(a)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果 cookie 模块加载失败，a 就会返回 null 这时候再调 a 上面的方法就会报错。当 seajs 内部解析依赖时发生了错误时就会出现这种情况，由于我们使用的是比较老的 seajs 版本（2.2.0），去查看源代码发现 parseDependencies 方法使用了一个正则表达式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var REQUIRE_RE = /&amp;quot;(?:\\&amp;quot;|[^&amp;quot;])*&amp;quot;|&#39;(?:\\&#39;|[^&#39;])*&#39;|\/\*[\S\s]*?\*\/|\/(?:\\\/|[^\/\r\n])+\/(?=[^\/])|\/\/.*|\.\s*require|(?:^|[^$])\brequire\s*\(\s*([&amp;quot;&#39;])(.+?)\1\s*\)/g
var SLASH_RE = /\\\\/g

function parseDependencies(code) {
  var ret = []

  code.replace(SLASH_RE, &amp;quot;&amp;quot;)
      .replace(REQUIRE_RE, function(m, m1, m2) {
        if (m2) {
          ret.push(m2)
        }
      })

  return ret
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在控制台里面跑一下看看结果，上面的模块解析正确：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t11401/113/1005903134/64122/b08677b9/59fc23d6N998f2848.png&#34; alt=&#34;seajs-works-well&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是我自己的场景并没有这么简单，我贴上自己的代码时就异常了，由于源码比较多我就放到 jsbin 上了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jsbin.com/bowazakosu/edit?html,js,console,output&#34;&gt;压缩成一行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jsbin.com/likonikoye/edit?html,js,console,output&#34;&gt;格式化压缩代码后&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有意思的地方就在于 压缩成一行 的代码中是异常的，但是当我把代码格式化后就正常了？！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;seajs 3.x 版本以后 &lt;a href=&#34;https://github.com/seajs/seajs/blob/3.0.0/src/util-deps.js&#34;&gt;util-deps.js&lt;/a&gt; 引入了一个依赖解析器方法，直接用这个替代原来的即可。至于为什么那个正则对于压缩后的代码没起作用我暂还没详细研究，不过感觉像获取模块依赖关系这种静态分析任务还是用解析器靠谱点，正则有太多的不确定性，虽然它能节省很多代码&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>macOS Sierra 开发环境配置指南</title>
      <link>https://keelii.github.io/2017/10/07/macos-development-setup-guide/</link>
      <pubDate>Sat, 07 Oct 2017 17:19:27 +0000</pubDate>
      
      <guid>https://keelii.github.io/2017/10/07/macos-development-setup-guide/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文来自于我自己配置两台 macOS 开发环境的过程，主要记录一些常用的配置技巧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;系统设置&#34;&gt;系统设置&lt;/h2&gt;

&lt;h3 id=&#34;更改计算机名称&#34;&gt;更改计算机名称&lt;/h3&gt;

&lt;p&gt;macOS 默认的计算机名称「xx的xx」，我一般会把这个名字改成英文，在命令行中看起来会漂亮一点。修改 &lt;code&gt;系统设置-共享-电脑名称&lt;/code&gt; 即可&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t9919/194/838196844/87087/80259170/59d8e3f4N4277172a.png&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t9919/194/838196844/87087/80259170/59d8e3f4N4277172a.png&#34; alt=&#34;computer-name&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;触控板&#34;&gt;触控板&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;设置轻点触控板为鼠标点击&lt;/li&gt;
&lt;li&gt;设置三指拖动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t10129/124/847447368/253995/96574062/59d8e534Nc3e40d9f.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t10129/124/847447368/253995/96574062/59d8e534Nc3e40d9f.png&#34; alt=&#34;tap-click&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://img10.360buyimg.com/devfe/jfs/t10396/219/830021333/98488/bcc6e984/59d8e43cN04d84771.png&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t10396/219/830021333/98488/bcc6e984/59d8e43cN04d84771.png&#34; alt=&#34;drag-drop&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;finder&#34;&gt;Finder&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;开启新 Fidder 窗口时打开 &lt;code&gt;桌面&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行搜索时 &lt;code&gt;搜索当前文件夹&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;显示所有文件扩展名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t9571/278/833569016/71935/221e5956/59d8e45dN67661921.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t9571/278/833569016/71935/221e5956/59d8e45dN67661921.png&#34; alt=&#34;finder&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;其它&#34;&gt;其它&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;系统偏好设置-键盘-输入法-自动切换到文稿输入法&lt;/code&gt; 应用切换的时候会保持原来的输入法不变&lt;/li&gt;
&lt;li&gt;&lt;code&gt;桌面空白处右键-排序方式-贴紧网格&lt;/code&gt; 右键整理图标的时候就会按网格排列&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;开发环境设置&#34;&gt;开发环境设置&lt;/h2&gt;

&lt;h3 id=&#34;安装-command-line-tools&#34;&gt;安装 Command line tools&lt;/h3&gt;

&lt;p&gt;方便后续编译安装其它应用&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t9601/44/840280004/58067/a2e0aa5e/59d8e496N2cdf9cca.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t9601/44/840280004/58067/a2e0aa5e/59d8e496N2cdf9cca.png&#34; alt=&#34;xcode-select&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;xcode-select --install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-brew&#34;&gt;安装 brew&lt;/h3&gt;

&lt;p&gt;一般命令行的工具，或者开发环境包都用 &lt;a href=&#34;https://brew.sh/&#34;&gt;brew&lt;/a&gt; 来安装。GUI 的应用直接去网站下载安装包即可，App Store 我一般用来购买安装一些收费软件&lt;/p&gt;

&lt;p&gt;打开命令行执行下面的命令来安装 brew&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面的命令替换 brew 源为&lt;a href=&#34;https://lug.ustc.edu.cn/wiki/mirrors/help/brew.git&#34;&gt;中科大镜像&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 替换brew.git:
cd &amp;quot;$(brew --repo)&amp;quot;
git remote set-url origin https://mirrors.ustc.edu.cn/brew.git

# 替换homebrew-core.git:
cd &amp;quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;quot;
git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 brew 安装下载源码包有时是用 curl 的，所以可以配置下 curl 来走 &lt;em&gt;番习习墙&lt;/em&gt; 代理，我一般在配置文件中设置 &lt;code&gt;vim ~/.curlrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;socks5 = &amp;quot;127.0.0.1:1080&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-zsh-oh-my-zsh&#34;&gt;安装 Zsh &amp;amp; oh-my-zsh&lt;/h3&gt;

&lt;p&gt;Zsh 是一种 &lt;a href=&#34;https://zh.wikipedia.org/wiki/Unix_shell&#34;&gt;shell&lt;/a&gt;，功能和 bash, csh 一样，用来和操作系统交互&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装 zsh
brew install zsh
# 安装 oh-my-zsh 插件
# 更换默认 shell 为 zsh
chsh -s /bin/zsh
sh -c &amp;quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功的话会有下面的提示&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t10303/164/828630186/232717/e8624f08/59d8e4d7N2c9b44f6.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t10303/164/828630186/232717/e8624f08/59d8e4d7N2c9b44f6.png&#34; alt=&#34;ohmyzsh&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装自动补全提示插件 &lt;a href=&#34;https://github.com/zsh-users/zsh-autosuggestions&#34;&gt;zsh-autosuggestions&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions
source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://img30.360buyimg.com/devfe/jfs/t10564/347/828202786/16788/8bd58613/59d8e50cN2ef8aa62.gif&#34;&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t10564/347/828202786/16788/8bd58613/59d8e50cN2ef8aa62.gif&#34; alt=&#34;zsh-autosuggestions&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装-配置-iterm2&#34;&gt;安装/配置 iTerm2&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.iterm2.com/&#34;&gt;下载&lt;/a&gt; 并安装，打开 Preferences 偏好设置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;General&lt;/code&gt; 关闭 &lt;code&gt;Native full screen windows&lt;/code&gt; 我不使用系统的全屏（因为有过渡动画），是为了使用全局快捷键 &lt;strong&gt;立即&lt;/strong&gt; 调出命令行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Profiles-Window-Transparency&lt;/code&gt; 设置透明度 10%~20% 即可，太高会和桌面背景冲突。如果需要临时禁用透明度可以使用快捷键 &lt;code&gt;⌘+u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Keys-Hotkey&lt;/code&gt; 设置全局显示隐藏快捷键 系统级别的快捷键设置为 &lt;code&gt;⌘+\&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;最佳实践，启动 iTerm2 后按 &lt;code&gt;⌘+enter&lt;/code&gt; 全屏，然后 &lt;code&gt;⌘+\&lt;/code&gt; 隐藏它，这时候就可以做别的事情去了。任何时间想再用 iTerm2 只需要按 &lt;code&gt;⌘+\&lt;/code&gt; 即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;brew-常用工具&#34;&gt;brew 常用工具&lt;/h3&gt;

&lt;p&gt;下面这些都是用 brew 安装的，即 &lt;code&gt;brew install xxx&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;htop&#34;&gt;htop&lt;/h4&gt;

&lt;p&gt;用来查看当前运行的程序，top 命令的升级版&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t10783/119/847515894/438295/9e4709ce/59d8e566N62c288f9.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t10783/119/847515894/438295/9e4709ce/59d8e566N62c288f9.png&#34; alt=&#34;htop&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;tree&#34;&gt;tree&lt;/h4&gt;

&lt;p&gt;显示文件为树形菜单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  keelii.github.io tree . -L 2
.
├── config.toml
├── content
│   ├── about
│   └── archives
├── deploy.sh
├── public
│   ├── 2016
...
│   └── tags
└── themes
    └── octo-enhance

17 directories, 8 files
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;httpie&#34;&gt;httpie&lt;/h4&gt;

&lt;p&gt;使用比 curl 简单多了，而且还有一些代码高亮的效果&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t9175/233/2384082355/52554/472f733/59d8e58fN956a159a.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t9175/233/2384082355/52554/472f733/59d8e58fN956a159a.png&#34; alt=&#34;httpie&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;vim&#34;&gt;vim&lt;/h4&gt;

&lt;p&gt;安装 vim 添加一些默认的模块和编程语言支持 cscope, lua, python 并且覆盖系统默认的 vim&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install vim --HEAD --with-cscope --with-lua --with-override-system-vim --with-luajit --with-python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 vim-plug&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;autojump&#34;&gt;autojump&lt;/h4&gt;

&lt;p&gt;方便在命令行中快速跳转目录，安装后程序会读取你 cd 过的目录并存起来，方便后面用快捷方式调用，支持模糊匹配。&lt;strong&gt;注意: autojump 只会记录安装后使用 cd 命令进入过的目录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//img10.360buyimg.com/devfe/jfs/t10066/212/961703883/22512/ed0565/59dae741N3fcc655c.gif&#34;&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t10066/212/961703883/22512/ed0565/59dae741N3fcc655c.gif&#34; alt=&#34;autojump&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;yarn&#34;&gt;yarn&lt;/h4&gt;

&lt;p&gt;npm 的替代品，Production Ready。如果系统中安装过 node，就使用 &lt;code&gt;yarn --without-node&lt;/code&gt; 命令只安装 yarn 工具&lt;/p&gt;

&lt;h3 id=&#34;安装-python-pip&#34;&gt;安装 python pip&lt;/h3&gt;

&lt;p&gt;下载 &lt;a href=&#34;https://bootstrap.pypa.io/get-pip.py&#34;&gt;get-pip.py&lt;/a&gt; 在命令行中使用 python 运行这个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo python get-pip.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;更改各种程序语言包源&#34;&gt;更改各种程序语言包源&lt;/h3&gt;

&lt;h4 id=&#34;ruby-gemrc&#34;&gt;ruby - .gemrc&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/
gem sources -l
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat ~/.gemrc
---
:backtrace: false
:bulk_threshold: 1000
:sources:
- https://mirrors.tuna.tsinghua.edu.cn/rubygems/
:update_sources: true
:verbose: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;node-yarnrc-npmrc&#34;&gt;node - .yarnrc/.npmrc&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat ~/.yarnrc
registry &amp;quot;https://registry.npm.taobao.org&amp;quot;
disturl &amp;quot;https://npm.taobao.org/dist&amp;quot;
electron_mirror &amp;quot;http://cdn.npm.taobao.org/dist/electron/&amp;quot;
node_inspector_cdnurl &amp;quot;https://npm.taobao.org/mirrors/node-inspector&amp;quot;
sass_binary_site &amp;quot;http://cdn.npm.taobao.org/dist/node-sass&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dotfiles-配置文件&#34;&gt;dotfiles 配置文件&lt;/h3&gt;

&lt;p&gt;可以参照我的 &lt;a href=&#34;https://github.com/keelii/dotfiles&#34;&gt;dotfiles&lt;/a&gt; 配置文件&lt;/p&gt;

&lt;h3 id=&#34;其它-gui-应用&#34;&gt;其它 GUI 应用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.alfredapp.com/&#34;&gt;Alfred&lt;/a&gt; 程序启动器&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://theunarchiver.com/&#34;&gt;The Unarchiver&lt;/a&gt; ⇒ 解压工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/magnet/id441258766?mt=12&#34;&gt;Magent&lt;/a&gt; ⇒ 排列窗口（付费）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mowglii.com/itsycal/&#34;&gt;Itsycal&lt;/a&gt; ⇒ 简洁版日历&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href=&#34;http://snip.qq.com/&#34;&gt;Snip&lt;/a&gt; ⇒ 屏幕截图&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href=&#34;http://snappy-app.com/&#34;&gt;Snappy&lt;/a&gt; ⇒ 屏幕截图、修改分享&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.snipaste.com/&#34;&gt;Snipaste&lt;/a&gt; ⇒ 更好用的屏幕截图&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pasteapp.me/&#34;&gt;Paste&lt;/a&gt; 剪贴板管理工具（付费）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://typora.io/&#34;&gt;Typora&lt;/a&gt; 正确的使用 markdown 写文档笔记等&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pqrs.org/osx/karabiner/&#34;&gt;Karabiner-Elements&lt;/a&gt; ⇒ 改键器, 改键方案参照&lt;a href=&#34;https://keelii.github.io/2017/10/03/how-to-map-single-command-key-on-mac/&#34;&gt;上篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://freemacsoft.net/appcleaner/&#34;&gt;AppCleaner 2&lt;/a&gt; ⇒ 卸载应用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cockos.com/licecap/&#34;&gt;licecap for mac&lt;/a&gt; ⇒ 录制 gif 图片&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zipzapmac.com/go2shell&#34;&gt;Go2shell&lt;/a&gt; ⇒ Finder 当前目录打开命令行&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>macOS 单独设置 command(⌘) 键点击功能</title>
      <link>https://keelii.github.io/2017/10/03/how-to-map-single-command-key-on-mac/</link>
      <pubDate>Tue, 03 Oct 2017 17:10:27 +0000</pubDate>
      
      <guid>https://keelii.github.io/2017/10/03/how-to-map-single-command-key-on-mac/</guid>
      <description>&lt;p&gt;由于最近全面切换工作环境到 Mac 上，快捷键基本上成了适应期的最大问题&lt;/p&gt;

&lt;p&gt;传统意义上像 &lt;code&gt;Ctrl, Alt, Shift, Win, Option, Command&lt;/code&gt; 都属于 &lt;code&gt;修饰键&lt;/code&gt;，只能和其它键配合使用才可以（Ctrl+c,Ctrl+v），单独敲击并没有效果&lt;/p&gt;

&lt;p&gt;但是 Win 键在 Windows 中被赋予了更多的功能，下面这几个系统级别的快捷键用起来是非常方便的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Win + E&lt;/code&gt; ⇒ 打开资源管理器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Win + D&lt;/code&gt; ⇒ 显示桌面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Win + L&lt;/code&gt; ⇒ 锁定计算机&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前使用过 Windows 和 Ubuntu gnome，特别方便的一点就是 super(Win) 键 &lt;strong&gt;不仅&lt;/strong&gt; 可以做为修饰键和其它键组合使用，而且还可以响应 &lt;strong&gt;单独的&lt;/strong&gt; 点击事件，Windows 中点击 Win 键会全局呼出 &lt;em&gt;开始菜单&lt;/em&gt; 方便我们 &lt;em&gt;查找/打开&lt;/em&gt; 应用。这样的话单独点击相当于可以少按一个按键，切找应用什么的非常快&lt;/p&gt;

&lt;p&gt;Mac 中我通常使用 Spotlight 来快速切换程序。用惯了 Mac 的人会觉得 command 键位非常舒服好按（键位原因），这时候我希望尽可能把常用的键组织到 command 上又 &lt;strong&gt;不影响&lt;/strong&gt; 原来的组合键，比如我有下面两个最常使用的快捷键：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘&lt;/code&gt; ⇒ 呼出 Spotlight&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ + Space&lt;/code&gt; ⇒ 切换输入法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而 Mac 系统中并不允许我们这么做 🤔，于是我使用了一个改键器 &lt;a href=&#34;https://pqrs.org/osx/karabiner/&#34;&gt;Karabiner&lt;/a&gt; 😎&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t9160/329/2610957899/117091/8481138f/59d34e67Nb3bd2a2d.png&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t9160/329/2610957899/117091/8481138f/59d34e67Nb3bd2a2d.png&#34; alt=&#34;mac-karabiner&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我的配置方法是使用 &lt;code&gt;Complex Modifications&lt;/code&gt; 因为它允许我把修饰键改成其它按钮功能。在这里我将其改为一个没用的键位（f13 - PrtSc），因为 Spotlight 不接受单独的修饰键，所以只能这样区线救国了&lt;/p&gt;

&lt;p&gt;然后在系统偏好设置 - 键盘 - 快捷键 中将 Spotlight 设置成 F13&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img12.360buyimg.com/devfe/jfs/t9769/96/578527884/124966/ff1a2f04/59d34fbeN5b1e4775.png&#34;&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t9769/96/578527884/124966/ff1a2f04/59d34fbeN5b1e4775.png&#34; alt=&#34;mac-spotlight&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意：默认的 Complex Modifications 里面是空的，需要你手动导入一个叫 &lt;a href=&#34;https://pqrs.org/osx/karabiner/complex_modifications/#modifier_keys&#34;&gt;Tapping modifier-keys produces a f-key.&lt;/a&gt;。然后我们 &lt;code&gt;enable&lt;/code&gt; 这条：&lt;strong&gt;Press left_command alone produces F14&lt;/strong&gt;，噫~我们是要 map 成 F13 这里默认的是 F14，怎么改下呢。改配置文件吧，打开下面这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim ~/.config/karabiner/karabiner.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将里面的 F14 改成 F13 即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;// ...
&amp;quot;complex_modifications&amp;quot;: {
    &amp;quot;parameters&amp;quot;: {
        &amp;quot;basic.to_if_alone_timeout_milliseconds&amp;quot;: 600
    },
    &amp;quot;rules&amp;quot;: [
        {
            &amp;quot;description&amp;quot;: &amp;quot;Press left_command alone produces F14&amp;quot;,
            &amp;quot;manipulators&amp;quot;: [
                {
                    &amp;quot;from&amp;quot;: {
                        &amp;quot;key_code&amp;quot;: &amp;quot;left_command&amp;quot;,
                        &amp;quot;modifiers&amp;quot;: { &amp;quot;optional&amp;quot;: [ &amp;quot;any&amp;quot; ] }
                    },
                    &amp;quot;to&amp;quot;: [ { &amp;quot;key_code&amp;quot;: &amp;quot;left_command&amp;quot; } ],
                    &amp;quot;to_if_alone&amp;quot;: [ { &amp;quot;key_code&amp;quot;: &amp;quot;f14&amp;quot; } ],
                    &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;
                }
            ]
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样基本上的完成我的需求了，打开应用只需要按一次 ⌘ 即可呼出 Spotlight，像打开 Google Chrome 只需要两个键即可 &lt;code&gt;⌘ g&lt;/code&gt;、Webstorm &lt;code&gt;⌘ w&lt;/code&gt;、Firefox &lt;code&gt;⌘ f&lt;/code&gt; &amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;备注：我用的机器是 Mac mini 主机 + filco 87 键盘&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>jQuery data 方法的一个小特技</title>
      <link>https://keelii.github.io/2017/05/03/a-trick-from-jquery-data-method/</link>
      <pubDate>Wed, 03 May 2017 17:59:45 +0800</pubDate>
      
      <guid>https://keelii.github.io/2017/05/03/a-trick-from-jquery-data-method/</guid>
      <description>&lt;p&gt;通常我们在用 JavaScript 操作 DOM 元素的时候会往 DOM 上临时添加一些参数，用来记住一些状态，或者从后端取参数值等&lt;/p&gt;

&lt;p&gt;一般通过在 HTML 标签上添加自定义属性来实现，但是这样会不可避免的访问 DOM，性能上并不好。如果你使用 jQuery 的话建议使用 &lt;code&gt;$el.data()&lt;/code&gt; 方法来取元素上 &lt;code&gt;data-*&lt;/code&gt; 的值，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;demo&amp;quot; data-key=&amp;quot;value&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    $(&#39;#demo&#39;).attr(&#39;data-key&#39;)
    $(&#39;#demo&#39;).data(&#39;key&#39;)  // 第一次访问 DOM，以后从缓存取
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个方法的区别在于 attr 每次都会直接访问 DOM 元素，而 data 方法会缓存第一次的查找，后续调用不需要访问 DOM&lt;/p&gt;

&lt;p&gt;很明显建议使用后者，但是在 &lt;strong&gt;低版本的 jQuery&lt;/strong&gt; 中默认会对 data 方法取到的值进行粗暴的强制数据类型转换「parseFloat」。看下面代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;demo0&amp;quot; data-key=&amp;quot;abc&amp;quot;&amp;gt;字符串&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo1&amp;quot; data-key=&amp;quot;123&amp;quot;&amp;gt;数字&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo2&amp;quot; data-key=&amp;quot;123e456&amp;quot;&amp;gt;科学计数法&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo3&amp;quot; data-key=&amp;quot;0000123&amp;quot;&amp;gt;八进制数字&amp;lt;/div&amp;gt;
&amp;lt;script src=&amp;quot;jquery-1.6.4&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    $(&#39;#demo0&#39;).data(&#39;key&#39;)  // &amp;quot;abc&amp;quot;
    $(&#39;#demo1&#39;).data(&#39;key&#39;)  // 123
    $(&#39;#demo2&#39;).data(&#39;key&#39;)  // Infinity
    $(&#39;#demo3&#39;).data(&#39;key&#39;)  // 83
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面两种显然出错了，就是因为 jQuery 对属性值进行了强制 parseFloat 操作。这种转换是方便了使用者，如果是数字的话我们取到这个值进行计算什么的就不用再转数据类型了，但是一不小心就会出 bug&lt;/p&gt;

&lt;p&gt;发现这个 bug 的时候第一感觉是 jQuery 不应该没考虑到这一点呀。后来果断去查了下最新版的 jQuery 源代码，发现已经修复了。核心代码在 &lt;a href=&#34;https://github.com/jquery/jquery/blob/master/src/data.js#L36&#34;&gt;data.js 35 行&lt;/a&gt;，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getData( data ) {
    if ( data === &amp;quot;true&amp;quot; ) {
        return true;
    }

    if ( data === &amp;quot;false&amp;quot; ) {
        return false;
    }

    if ( data === &amp;quot;null&amp;quot; ) {
        return null;
    }

    // Only convert to a number if it doesn&#39;t change the string
    // 重点就在这里 →_→
    if ( data === +data + &amp;quot;&amp;quot; ) {
        return +data;
    }

    if ( rbrace.test( data ) ) {
        return JSON.parse( data );
    }

    return data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getData 方法就返回了节点属性的值，只不过加了一些特殊处理使得我们取到了没有 bug 的值，关键地方就在这里： &lt;code&gt;data === +data + &amp;quot;&amp;quot;&lt;/code&gt; 。这行代码做了些什么神奇的事情&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;将节点的属性值强制转换成数字「+data」后再转成字符串「+ &amp;ldquo;&amp;ldquo;」，如果转换后的值与原来相等就取转换后的值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以简单的这么理解：jQuery 会尝试转换数据类型，如果转换后和转换前的 &lt;strong&gt;长得一样&lt;/strong&gt; 那么 jQuery 就认为它是需要被转换成数字的。这样就可以完美规避上面例子中的两种问题，我们来测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var data = &#39;abc&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值

var data = &#39;123&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // true 转换，使用转换后的数字类型值

var data = &#39;123e456&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值

var data = &#39;0000123&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sublime text 3 配置 ESLint 代码检查</title>
      <link>https://keelii.github.io/2017/04/29/sublime-text-3-configure-eslint/</link>
      <pubDate>Sat, 29 Apr 2017 17:17:24 +0800</pubDate>
      
      <guid>https://keelii.github.io/2017/04/29/sublime-text-3-configure-eslint/</guid>
      <description>

&lt;h2 id=&#34;安装环境&#34;&gt;安装环境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Windows 7 SP1 企业版&lt;/li&gt;
&lt;li&gt;Sublime text 3 Build 3162&lt;/li&gt;
&lt;li&gt;Node.js v6.9.5&lt;/li&gt;
&lt;li&gt;Yarn 0.23.2 (可用 npm 代替)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装-eslint&#34;&gt;安装 ESLint&lt;/h2&gt;

&lt;p&gt;到你的项目根目录生成一个 package.json 文件，如果没有使用 &lt;code&gt;yarn init -y&lt;/code&gt; 来自动生成&lt;/p&gt;

&lt;p&gt;ESLint 默认的 parser 是 esprima，如果你需要检查 Babel 转义的 JSX 等文件那可以选择安装 &lt;a href=&#34;https://github.com/babel/babel-eslint&#34;&gt;babel-eslint&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yarn init -y
yarn global add eslint
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 sublime text 3 配置 eslint 来做代码检查&lt;/p&gt;

&lt;h2 id=&#34;安装-sublime-text-3-插件&#34;&gt;安装 Sublime text 3 插件&lt;/h2&gt;

&lt;h3 id=&#34;安装-sublime-linter-和-sublimelinter-contrib-eslint&#34;&gt;安装 Sublime​Linter 和 SublimeLinter-contrib-eslint&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://packagecontrol.io/packages/SublimeLinter&#34;&gt;Sublime​Linter&lt;/a&gt; 是一个代码检查框架插件，功能非常强大，支持各种语言的检查。但是它本身并没有代码检查的功能，需要借助 ESLint 这样的特定语言检查支持。我们只需要使用对应的 &lt;a href=&#34;https://packagecontrol.io/packages/SublimeLinter-contrib-eslint&#34;&gt;Sublime​Linter-contrib-eslint&lt;/a&gt; 插件即可&lt;/p&gt;

&lt;p&gt;在 Sublime text 中 &lt;code&gt;Ctrl + Shift + p &amp;gt; Package Control:Install Package&lt;/code&gt; 里面搜索关键词 &lt;code&gt;linter&lt;/code&gt;，&lt;strong&gt;注意&lt;/strong&gt;别选成了 SummitLinter。然后再搜索 &lt;code&gt;eslint&lt;/code&gt; 找到 SublimeLinter-contrib-eslint 安装（不得不吐槽下 Sublime package 搜索匹配让人无法理解）&lt;/p&gt;

&lt;h2 id=&#34;配置-eslint&#34;&gt;配置 ESLint&lt;/h2&gt;

&lt;p&gt;到项目根目录下面使用 eslint 命令交互式的生成配置文件。这里 ESLint 会让你确认项目的配置项目，包括代码风格、目标文件等。我一般选择 &lt;code&gt;Answer questions about your style&lt;/code&gt;，即通过选择性的回答命令行中的问题让 ESLint 生成适合我项目的配置文件&lt;/p&gt;

&lt;p&gt;生成的配置文件我一般选择 JavaScript 因为这样比较方便写注释。我的配置项大概如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;How would you like to configure ESLint?
Answer questions about your style
Are you using ECMAScript 6 features? No
Where will your code run? Browser
Do you use CommonJS? No
Do you use JSX? No
What style of indentation do you use? Spaces
What quotes do you use for strings? Single
What line endings do you use? Unix
Do you require semicolons? No
What format do you want your config file to be in? JavaScript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的配置文件竟然是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
    &amp;quot;env&amp;quot;: {
        &amp;quot;browser&amp;quot;: true
    },
    &amp;quot;extends&amp;quot;: &amp;quot;eslint:recommended&amp;quot;,
    &amp;quot;rules&amp;quot;: {
        &amp;quot;indent&amp;quot;: [
            &amp;quot;error&amp;quot;,
            4
        ],
        &amp;quot;linebreak-style&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;unix&amp;quot;
        ],
        &amp;quot;quotes&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;single&amp;quot;
        ],
        &amp;quot;semi&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;never&amp;quot;
        ]
    }
}; // Do you require semicolons? No !!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 &lt;code&gt;extends&lt;/code&gt; 设置成 &lt;code&gt;eslint:recommended&lt;/code&gt; 表示在 &lt;a href=&#34;http://eslint.org/docs/rules/&#34;&gt;ESLint 规则页面&lt;/a&gt; 中标记成 「✔」 的项都开启检测&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;打开项目中任意一个 JavaScript 文件，右键 &lt;code&gt;SublimeLint &amp;gt; Lint this view&lt;/code&gt; 来试试检查当前文件，如果有错误，编辑器会展示对应 Gutter 错误行和信息。可以使用 &lt;code&gt;SublimeLint &amp;gt; Show all errors&lt;/code&gt; 来查看所有的错误&lt;/p&gt;

&lt;p&gt;上个图吧&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t4531/175/3699692200/112024/b747eb91/590466dcN6f0ad2ac.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t4531/175/3699692200/112024/b747eb91/590466dcN6f0ad2ac.png&#34; alt=&#34;sublimetext-eslint&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nginx 配置 Google fonts 反向代理开启 HTTP2/SSL 支持</title>
      <link>https://keelii.github.io/2017/04/22/proxy-google-fonts-with-ssl-http2-support/</link>
      <pubDate>Sat, 22 Apr 2017 11:19:58 +0800</pubDate>
      
      <guid>https://keelii.github.io/2017/04/22/proxy-google-fonts-with-ssl-http2-support/</guid>
      <description>

&lt;p&gt;由于博客主题使用了 Google fonts PT Serif 字体，国内只能通过中科大的代理来使用 Google fonts 字体。然而最近发现其速度不稳定，响应时间有时候甚至超过 600ms。刚好因为自己有 &lt;a href=&#34;http://www.vultr.com/?ref=6805146&#34;&gt;vultr 的 VPS(带小尾巴)&lt;/a&gt; 就自己动手搭了个来用&lt;/p&gt;

&lt;p&gt;VPS 环境如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ubuntu 14.04&lt;/li&gt;
&lt;li&gt;Nginx 1.12.0 (最新版各别配置与之前不一样)&lt;/li&gt;
&lt;li&gt;Openssl 1.0.2j (新版 Nginx 开启 http2 需要的最低 openssl 版本)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重新编译安装-nginx&#34;&gt;重新编译安装 Nginx&lt;/h2&gt;

&lt;p&gt;如果之前编译安装没开启相关模块的话需要重新编译，大概参数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-openssl=/usr/local/ssl --with-http_v2_module --with-http_sub_module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译完没有出错的话就 &lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt; 就 OK 了&lt;/p&gt;

&lt;h2 id=&#34;配置-nginx-反代&#34;&gt;配置 Nginx 反代&lt;/h2&gt;

&lt;h3 id=&#34;基本配置&#34;&gt;基本配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;upstream google {
    server fonts.googleapis.com:80;
}

upstream gstatic {
    server fonts.gstatic.com:80;
}
proxy_temp_path   /your/path/tmp 1 2;
proxy_cache_path  /your/path/cache levels=1:2 keys_zone=cache1:100m inactive=30d max_size=1g;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;80-端口配置&#34;&gt;80 端口配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
    listen 80;
    server_name your.proxy.domain;
    root /your/path/;
    location /css {
        sub_filter &#39;fonts.gstatic.com&#39; &#39;your.proxy.domain&#39;;
        sub_filter_once off;
        sub_filter_types text/css;
        proxy_pass_header Server;
        proxy_set_header Host fonts.googleapis.com;
        proxy_set_header Accept-Encoding &#39;&#39;;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://google;
        proxy_cache cache1;
        proxy_cache_key $host$uri$is_args$args;
        proxy_cache_valid 200 304 10m;
        expires 365d;
    }
    location / {
        proxy_pass_header Server;
        proxy_set_header Host fonts.gstatic.com;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://gstatic;
        proxy_cache cache1;
        proxy_cache_key $host$uri$is_args$args;
        proxy_cache_valid 200 304 10m;
        expires 365d;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;443-端口配置&#34;&gt;443 端口配置&lt;/h3&gt;

&lt;p&gt;首先你得有个免费的 HTTPS 证书，这个可以参考我之前的文章：&lt;a href=&#34;https://keelii.github.io/2016/06/12/free-https-cert-lets-encrypt-apply-install/&#34;&gt;免费 Https 证书（Let&amp;rsquo;S Encrypt）申请与配置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意设置 &lt;code&gt;sub_filter&lt;/code&gt; 字段的时候 &lt;strong&gt;你的域名要加上 https://&lt;/strong&gt;，要不然会出现代理的 CSS 文件中的字体文件引用是 HTTP 而请求报 &lt;code&gt;blocked/mixed-content&lt;/code&gt; 错&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
    listen 443 ssl http2;

    ssl on;
    ssl_certificate /etc/letsencrypt/live/your.proxy.domain/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your.proxy.domain/privkey.pem;
    ssl_dhparam /etc/ssl/certs/dhparams.pem;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers HIGH:!aNULL:!MD5;

    server_name  your.proxy.domain;
    root /var/sites/fonts/;

    location /css {
        sub_filter &#39;http://fonts.gstatic.com&#39; &#39;https://your.proxy.domain&#39;;
        sub_filter_once off;
        sub_filter_types text/css;
        proxy_pass_header Server;
        proxy_set_header Host fonts.googleapis.com;
        proxy_set_header Accept-Encoding &#39;&#39;;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://google;
        proxy_cache cache1;
        proxy_cache_key $host$uri$is_args$args;
        proxy_cache_valid 200 304 10m;
        expires 365d;
    }

    location / {
        proxy_pass_header Server;
        proxy_set_header Host fonts.gstatic.com;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://gstatic;
        proxy_cache cache1;
        proxy_cache_key $host$uri$is_args$args;
        proxy_cache_valid 200 304 10m;
        expires 365d;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安全防盗链&#34;&gt;安全防盗链&lt;/h3&gt;

&lt;p&gt;如果不共享给其它人用的话还需要在配置中加入 referer 白名单判断，不符合条件的将返回 403&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;valid_referers server_name *.your.domain.com *.other.domain.com;
if ($invalid_referer) {
    return 403;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关系代数的基本运算</title>
      <link>https://keelii.github.io/2017/02/19/basic-operations-of-relation-algebra/</link>
      <pubDate>Sun, 19 Feb 2017 15:10:38 +0800</pubDate>
      
      <guid>https://keelii.github.io/2017/02/19/basic-operations-of-relation-algebra/</guid>
      <description>

&lt;h2 id=&#34;关系代数运算符&#34;&gt;关系代数运算符&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;集合运算符&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;英文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$∪$&lt;/td&gt;
&lt;td&gt;并&lt;/td&gt;
&lt;td&gt;Union&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$−$&lt;/td&gt;
&lt;td&gt;差&lt;/td&gt;
&lt;td&gt;Difference&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$∩$&lt;/td&gt;
&lt;td&gt;交&lt;/td&gt;
&lt;td&gt;Intersection&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$×$&lt;/td&gt;
&lt;td&gt;笛卡尔积&lt;/td&gt;
&lt;td&gt;Cartesian Product&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;比较运算符&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$&amp;gt;$&lt;/td&gt;
&lt;td&gt;大于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$≥$&lt;/td&gt;
&lt;td&gt;大于等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$&amp;lt;$&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$≤$&lt;/td&gt;
&lt;td&gt;小于等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$=$&lt;/td&gt;
&lt;td&gt;等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$≠$&lt;/td&gt;
&lt;td&gt;不等于&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;专门的关系运算符&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;英文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$σ$&lt;/td&gt;
&lt;td&gt;选择&lt;/td&gt;
&lt;td&gt;Selection&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$π$&lt;/td&gt;
&lt;td&gt;投影&lt;/td&gt;
&lt;td&gt;Projection&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$⋈$&lt;/td&gt;
&lt;td&gt;链接&lt;/td&gt;
&lt;td&gt;Join&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$÷$&lt;/td&gt;
&lt;td&gt;除&lt;/td&gt;
&lt;td&gt;Division&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;逻辑运算符&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$∧$&lt;/td&gt;
&lt;td&gt;与&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$∨$&lt;/td&gt;
&lt;td&gt;或&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$¬$&lt;/td&gt;
&lt;td&gt;非&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;5-种基本的关系代数运算&#34;&gt;5 种基本的关系代数运算&lt;/h2&gt;

&lt;h3 id=&#34;并-union&#34;&gt;并（Union）&lt;/h3&gt;

&lt;p&gt;关系 R 与 S 具有相同的关系模式，即 R 与 S 的元数相同（结构相同），R 与 S 的并是属于 R 或者属于 S 的元组构成的集合，记作 R ∪ S，定义如下：&lt;/p&gt;

&lt;div&gt;
$$R∪S=\{t|t∈R∨t∈S\}$$
&lt;/div&gt;

&lt;h3 id=&#34;差-difference&#34;&gt;差（Difference）&lt;/h3&gt;

&lt;p&gt;关系 R 与 S 具有相同的关系模式，关系 R 与 S 的差是属于 R 但不属于 S 的元组构成的集合，记作 R − S，定义如下：&lt;/p&gt;

&lt;div&gt;
$$R−S=\{t|t∈R∨t∉S\}$$
&lt;/div&gt;

&lt;h3 id=&#34;广义笛卡尔积-extended-cartesian-product&#34;&gt;广义笛卡尔积（Extended Cartesian Product）&lt;/h3&gt;

&lt;p&gt;两个无数分别为 n 目和 m 目的关系 R 和 S 的 笛卡尔积是一个 (n+m) 列的元组的集合。组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组，记作 R × S，定义如下：&lt;/p&gt;

&lt;div&gt;
$$R×S=\{t|t=&lt;(t^n,t^m)∧t^n∈R∧t^m∈S\}$$
&lt;/div&gt;

&lt;p&gt;$(t^n,t^m)$ 表示元素 $t^n$ 和 $t^m$ 拼接成的一个元组&lt;/p&gt;

&lt;h3 id=&#34;投影-projection&#34;&gt;投影（Projection）&lt;/h3&gt;

&lt;p&gt;投影运算是从关系的垂直方向进行运算，在关系 R 中选出若干属性列 A 组成新的关系，记作 $π_A(R)$，其形式如下：&lt;/p&gt;

&lt;div&gt;
$$π_A(R)=\{t[A]|t∈R\}$$
&lt;/div&gt;

&lt;h3 id=&#34;选择-selection&#34;&gt;选择（Selection）&lt;/h3&gt;

&lt;p&gt;选择运算是从关系的水平方向进行运算，是从关系 R 中选择满足给定条件的元组，记作 $σ_F(R)$，其形式如下：&lt;/p&gt;

&lt;div&gt;
$$σ_F(R)=\{t|t∈R∧F(t)=True\}$$
&lt;/div&gt;

&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;

&lt;p&gt;设有关系 R、S 如图所示，求 $R∪S$、 $R−S$、 $R×S$、 $π_{A,C}(R)$、 $σ_{A&amp;gt;B}(R)$ 和 $σ_{3&amp;lt;4}(R×S)$&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3967/269/2409299226/5377/e997b909/58a95fceNddd39fd7.png&#34; alt=&#34;关系表RS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;进行并、差运算后结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t3949/95/2458170516/5487/1c7f1f38/58a967b1N42db123f.png&#34; alt=&#34;并差&#34; /&gt;&lt;/p&gt;

&lt;p&gt;进行笛卡尔、 投影、 选择运算后结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t3943/109/2403665652/38834/c636281b/58a9685dN20af0b9b.png&#34; alt=&#34;笛卡尔_投影_选择&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;扩展的关系代数运算&#34;&gt;扩展的关系代数运算&lt;/h2&gt;

&lt;h3 id=&#34;交-intersection&#34;&gt;交（Intersection）&lt;/h3&gt;

&lt;p&gt;关系 R 和 S 具有相同的关系模式，交是由属于 R 同时双属于 S 的元组构成的集合，记作 R∩S，形式如下：&lt;/p&gt;

&lt;div&gt;
$$R∩S=\{t|t∈R∧t∈S\}$$
&lt;/div&gt;

&lt;h3 id=&#34;链接-join&#34;&gt;链接（Join）&lt;/h3&gt;

&lt;p&gt;注：下面的 θ 链接应该记作：&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3967/158/2461240249/2389/530d7d07/58aa580aNe9908740.png&#34; alt=&#34;theta链接&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;θ-链接&#34;&gt;θ 链接&lt;/h4&gt;

&lt;p&gt;从 R 与 S的笛卡尔积中选取属性间满足一定条件的元组，可由基本的关系运算笛卡尔积和选取运算导出，表示为：&lt;/p&gt;

&lt;div&gt;
$$R \Join_{XθY} S = σ_{XθY}(R×S)$$
&lt;/div&gt;

&lt;p&gt;XθY 为链接的条件，θ 是比较运算符，X 和 Y 分别为 R 和 S 上度数相等且可比的属性组&lt;/p&gt;

&lt;p&gt;例如：求 $R \Join_{R.A&amp;lt;S.B} S$，如果为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t3133/127/6662942086/21071/88c200da/58aa5b1fN3e2316d5.png&#34; alt=&#34;theta链接小于过程&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;等值链接&#34;&gt;等值链接&lt;/h4&gt;

&lt;p&gt;当 θ 为「=」时，称之为等值链接，记为： $R\Join_{X=Y}S$&lt;/p&gt;

&lt;h4 id=&#34;自然链接&#34;&gt;自然链接&lt;/h4&gt;

&lt;p&gt;自然链接是一种特殊的等值链接，它要求两个关系中进行比较的分量必须是 &lt;strong&gt;相同的属性组&lt;/strong&gt;，并且在结果集中将 &lt;strong&gt;重复的属性列&lt;/strong&gt; 去掉&lt;/p&gt;

&lt;p&gt;例如：设有关系 R、S 如图所示，求 $R \Join S$&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t3982/212/2472511181/5973/54467e2a/58aa5ffaN970f7e5a.png&#34; alt=&#34;关系RS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;先求出笛卡尔积 $R×S$，找出比较分量（有相同属性组），即: R.A/S.A 与 R.C/S.C&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3841/5/4275908218/12385/79e83d01/58aa6066Nd003e697.png&#34; alt=&#34;求出笛卡尔积&#34; /&gt;&lt;/p&gt;

&lt;p&gt;取等值链接 $R.A = S.A$ 且 $R.C = S.C$&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3256/75/6205568741/12327/2b1dc867/58aa60e8N38a84108.png&#34; alt=&#34;找出相同属性的比较分量&#34; /&gt;&lt;/p&gt;

&lt;p&gt;结果集中去掉重复属性列，注意无论去掉 R.A 或者 S.A 效果都一样，因为他们的值相等，结果集中只会有属性 A、B、C、D&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t3217/183/6576493853/4744/ccb96965/58aa612eN043f7425.png&#34; alt=&#34;结果集中找出重复属性列&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最终得出结果&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t3247/65/6676502314/2874/657ddb0c/58aa617eN2457f536.png&#34; alt=&#34;RS自然链接结果&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;除-division&#34;&gt;除（Division）&lt;/h3&gt;

&lt;p&gt;设有以下如图关系，求 $R÷S$&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3151/348/6716540896/7287/dc01ad2e/58aaaf3bN1cae8b1a.png&#34; alt=&#34;关系RS1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;取关系 R 中有的但 S 中没有的属性组，即：A、B&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t3202/137/6722879648/7244/3b47a185/58aaaf81N0b2491b5.png&#34; alt=&#34;关系RS1取属性AB&#34; /&gt;&lt;/p&gt;

&lt;p&gt;取唯一 A、B 属性组值的象集&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t3871/170/2430481542/5179/be5899c5/58aaafe6N8297b49f.png&#34; alt=&#34;关系RS1取属性AB对应的象集&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可知关系S存在于 a,b/c,k 象集 中。即 $R÷S$ 得&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3130/361/6704334588/3366/6b7e0b56/58aab058N3a3c374d.png&#34; alt=&#34;关系RS1除结果&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sku 多维属性状态判断算法</title>
      <link>https://keelii.github.io/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/</link>
      <pubDate>Thu, 22 Dec 2016 15:55:52 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/</guid>
      <description>

&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;这个问题来源于选择商品属性的场景。比如我们买衣服、鞋子这类物件，一般都需要我们选择合适的颜色、尺码等属性&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t3118/276/4984729113/37788/61331934/585b8939Na04471ff.png&#34; alt=&#34;color_size&#34; /&gt;&lt;/p&gt;

&lt;p&gt;先了解一下 sku 的学术概念吧&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;最小库存管理单元（Stock Keeping Unit, SKU）是一个会计学名词，定义为库存管理中的最小可用单元，例如纺织品中一个SKU通常表示规格、颜色、款式，而在连锁零售门店中有时称单品为一个SKU。最小库存管理单元可以区分不同商品销售的最小单元，是科学管理商品的采购、销售、物流和财务管理以及POS和MIS系统的数据统计的需求，通常对应一个管理信息系统的编码。 —— form wikipedia &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E5%AD%98%E8%B4%A7%E5%8D%95%E4%BD%8D&#34;&gt;最小存货单位&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的结合上面的实例来说： sku 就是你上购物网站买到的最终商品，对应的上图中已选择的属性是：颜色 &lt;strong&gt;黑色&lt;/strong&gt; - 尺码 &lt;strong&gt;37&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我先看看后端数据结构一般是这样的，一个线性数组，每个元素是一个描述当前 sku 的 map，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
   { &amp;quot;颜色&amp;quot;: &amp;quot;红&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;大&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;A&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3158054&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;白&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;中&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;B&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3133859&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;蓝&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;小&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;C&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3516833&amp;quot; }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前端展示的时候显然需要 group 一下，按不同的属性分组，目的就是让用户按属性的维度去选择，group 后的数据大概是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;颜色&amp;quot;: [&amp;quot;红&amp;quot;, &amp;quot;白&amp;quot;, &amp;quot;蓝&amp;quot;],
    &amp;quot;尺码&amp;quot;: [&amp;quot;大&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;小&amp;quot;],
    &amp;quot;型号&amp;quot;: [&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的在网页上大概是这样的 UI&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3307/119/4891794144/3339/dbde7abe/585b9042N5e527489.png&#34; alt=&#34;ui_demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候，就会有一个问题，这些元子属性能组成的集合（用户的选择路径） &lt;strong&gt;远远大于&lt;/strong&gt; 真正可以组成的集合，比如上面的属性集合可以组合成一个 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF&#34;&gt;笛卡尔积&lt;/a&gt;，即。可以组合成以下序列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[
    [&amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot;],    // ✔
    [&amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot;],    // ✔
    [&amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;C&amp;quot;]     // ✔
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据公式可以知道，&lt;strong&gt;一个由 3 个元素，每个元素是有 3 个元素的子集构成的集合，能组成的笛卡尔积一共有 3 的 3 次幂，也就是 27 种&lt;/strong&gt;，然而源数据只可以形成 3 种组合&lt;/p&gt;

&lt;p&gt;这种情况下最好能提前判断出来不可选的路径并置灰，告诉用户，否则会造成误解&lt;/p&gt;

&lt;h2 id=&#34;确定规则&#34;&gt;确定规则&lt;/h2&gt;

&lt;p&gt;看下图，如果我们定义红色为当前选中的商品的属性，即当前选中商品为 &lt;code&gt;红-大-A&lt;/code&gt;，这个时候如何确认其它非已选属性是否可以组成可选路径？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t3100/104/4921509103/3867/ea2bdd9b/585b9636Nc5d3efd4.png&#34; alt=&#34;ui_selected&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则是这样的：&lt;/strong&gt; 假设当前用户想选 &lt;code&gt;白-大-A&lt;/code&gt;，刚好这个选择路径是不存在的，那么我们就把 &lt;code&gt;白&lt;/code&gt; 置灰&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t3175/51/4906988054/3771/93679a78/585b9717Nf53b5e3e.png&#34; alt=&#34;ui_selected_disabled&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以此类推，如果要确认 &lt;code&gt;蓝&lt;/code&gt; 属性是否可用，需要查找 &lt;code&gt;蓝-大-A&lt;/code&gt; 路径是否存在&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;解决方法&#34;&gt;解决方法&lt;/h2&gt;

&lt;p&gt;根据上面的逻辑代码实现思路就有了：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;遍历所有非已选元素：&lt;code&gt;&amp;quot;白&amp;quot;, &amp;quot;蓝&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;遍历所有属性行： &lt;code&gt;&amp;quot;颜色&amp;quot;, &amp;quot;尺码&amp;quot;, &amp;quot;型号&amp;quot;&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;取： a) 当前元素 b) 非当前元素所在的其它属性已选元素，形成一个路径&lt;/li&gt;
&lt;li&gt;判断此路径是否存在，如果不存在将当前元素置灰&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看来问题似乎已经解决了，然而 &amp;hellip;&lt;/p&gt;

&lt;p&gt;我们忽略了一个非常重要的问题：上例中虽然 &lt;code&gt;白&lt;/code&gt; 元素置灰，但是实际上 &lt;code&gt;白&lt;/code&gt; 是可以被点击的！因为用户可以选择 &lt;code&gt;白-中-B&lt;/code&gt; 路径&lt;/p&gt;

&lt;p&gt;如果用户点击了 &lt;code&gt;白&lt;/code&gt; 情况就变得复杂了很多，我们假设用户 &lt;strong&gt;只选择了一个&lt;/strong&gt;元素 &lt;code&gt;白&lt;/code&gt;，此时如何判断其它未选元素是否可选？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t3238/138/4916973929/3751/11a121a7/585b9c36N668cd64b.png&#34; alt=&#34;ui_selected_one&#34; /&gt;&lt;/p&gt;

&lt;p&gt;即：如何确定 &lt;code&gt;&amp;quot;大&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;&lt;/code&gt; 需要置灰？ 注意我们并不需要确认 &lt;code&gt;&amp;quot;红&amp;quot;，&amp;quot;蓝&amp;quot;&lt;/code&gt; 是否可选，因为属性里面的元素都是 &lt;strong&gt;单选&lt;/strong&gt;，当前的属性里任何元素都可选的&lt;/p&gt;

&lt;h3 id=&#34;缩小问题规模&#34;&gt;缩小问题规模&lt;/h3&gt;

&lt;p&gt;我们先 &lt;strong&gt;缩小问题范围&lt;/strong&gt;：当前情况下（只有一个 &lt;code&gt;白&lt;/code&gt; 已选）如何确定尺码 &lt;code&gt;&amp;quot;大&amp;quot;&lt;/code&gt; 需要置灰？ 你可能会想到根据我们之间的逻辑，需要分别查找：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;白 - 大 - A&lt;/li&gt;
&lt;li&gt;白 - 大 - B&lt;/li&gt;
&lt;li&gt;白 - 大 - C&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他们都不存在的时候把尺码 &lt;code&gt;大&lt;/code&gt; 置灰，问题似乎也可以解决。其实这样是不对的，因为 &lt;strong&gt;型号没有被选择过&lt;/strong&gt;，所以只需要知道 &lt;code&gt;白-大&lt;/code&gt;是否可选即可&lt;/p&gt;

&lt;p&gt;同时还有一个问题，如果已选的个数不确定而且维度可以增加到不确定呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t3931/229/741708498/8439/ce1088f3/585ba187N9bf3b55d.png&#34; alt=&#34;ui_muli-attr&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这种情况下如果还按之前的算法，即使实现也非常复杂。这时候就要考虑换一种思维方式&lt;/p&gt;

&lt;h3 id=&#34;调整思路&#34;&gt;调整思路&lt;/h3&gt;

&lt;p&gt;之前我们都是反向思考，找出不可选应该置灰的元素。我们现在正向的考虑，如何确定属性是否可选。而且多维的情况下用户可以跳着选。比如：用户选了两个元素 &lt;code&gt;白，B&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t3292/20/4882441565/5337/7c12589c/585ba3f5Nc07d80f6.png&#34; alt=&#34;ui_muli-attr_two&#34; /&gt;  &lt;em&gt;图1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我们再回过头来看下 &lt;strong&gt;原始存在的数据&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[
   { &amp;quot;颜色&amp;quot;: &amp;quot;红&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;大&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;A&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3158054&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;白&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;中&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;B&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3133859&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;蓝&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;小&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;C&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3516833&amp;quot; }
]
// 即
[
   [ &amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot; ],   // 存在
   [ &amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot; ],   // 存在
   [ &amp;quot;蓝&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;C&amp;quot; ]    // 存在
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然：如果第一条数据 &lt;code&gt;&amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot;&lt;/code&gt; 存在，那么下面这些子组合 &lt;strong&gt;肯定都存在&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;红&lt;/li&gt;
&lt;li&gt;大&lt;/li&gt;
&lt;li&gt;A&lt;/li&gt;
&lt;li&gt;红 - 大&lt;/li&gt;
&lt;li&gt;红 - A&lt;/li&gt;
&lt;li&gt;大 - A&lt;/li&gt;
&lt;li&gt;红 - 大 - A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同理：如果第二条数据 &lt;code&gt;&amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot;&lt;/code&gt; 存在，那么下面这些子组合 &lt;strong&gt;肯定都存在&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;白&lt;/li&gt;
&lt;li&gt;中&lt;/li&gt;
&lt;li&gt;B&lt;/li&gt;
&lt;li&gt;白 - 中&lt;/li&gt;
&lt;li&gt;白 - B&lt;/li&gt;
&lt;li&gt;中 - B&lt;/li&gt;
&lt;li&gt;白 - 中 - B&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;我们提前把 &lt;strong&gt;所有存在的路径中的子组合&lt;/strong&gt; 算出来，算法上叫取集合所有子集，数学上叫 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%86%AA%E9%9B%86&#34;&gt;幂集&lt;/a&gt;， 形成一个所有存在的路径表，算法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * 取得集合的所有子集「幂集」
 arr = [1,2,3]

     i = 0, ps = [[]]:
         j = 0; j &amp;lt; ps.length =&amp;gt; j &amp;lt; 1:
             i=0, j=0 ps.push(ps[0].concat(arr[0])) =&amp;gt; ps.push([].concat(1)) =&amp;gt; [1]
                      ps = [[], [1]]

     i = 1, ps = [[], [1]] :
         j = 0; j &amp;lt; ps.length =&amp;gt; j &amp;lt; 2
             i=1, j=0 ps.push(ps[0].concat(arr[1])) =&amp;gt; ps.push([].concat(2))  =&amp;gt; [2]
             i=1, j=1 ps.push(ps[1].concat(arr[1])) =&amp;gt; ps.push([1].concat(2)) =&amp;gt; [1,2]
                      ps = [[], [1], [2], [1,2]]

     i = 2, ps = [[], [1], [2], [1,2]]
         j = 0; j &amp;lt; ps.length =&amp;gt; j &amp;lt; 4
             i=2, j=0 ps.push(ps[0].concat(arr[2])) =&amp;gt; ps.push([3])    =&amp;gt; [3]
             i=2, j=1 ps.push(ps[1].concat(arr[2])) =&amp;gt; ps.push([1, 3]) =&amp;gt; [1, 3]
             i=2, j=2 ps.push(ps[2].concat(arr[2])) =&amp;gt; ps.push([2, 3]) =&amp;gt; [2, 3]
             i=2, j=3 ps.push(ps[3].concat(arr[2])) =&amp;gt; ps.push([2, 3]) =&amp;gt; [1, 2, 3]
                      ps = [[], [1], [2], [1,2], [3], [1, 3], [2, 3], [1, 2, 3]]
 */
function powerset(arr) {
    var ps = [[]];
    for (var i=0; i &amp;lt; arr.length; i++) {
        for (var j = 0, len = ps.length; j &amp;lt; len; j++) {
            ps.push(ps[j].concat(arr[i]));
        }
    }
    return ps;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个存在的子集集合，再回头看 &lt;em&gt;图1&lt;/em&gt; 举例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t3292/20/4882441565/5337/7c12589c/585ba3f5Nc07d80f6.png&#34; alt=&#34;ui_muli-attr_two&#34; /&gt;  &lt;em&gt;图1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何确定 &lt;code&gt;红&lt;/code&gt; 可选？ 只需要确定 &lt;code&gt;红-B&lt;/code&gt; 可选&lt;/li&gt;
&lt;li&gt;如何确定 &lt;code&gt;中&lt;/code&gt; 可选？ 需要确定 &lt;code&gt;白-中-B&lt;/code&gt; 可选&lt;/li&gt;
&lt;li&gt;如何确定 &lt;code&gt;2G&lt;/code&gt; 可选？ 需要确定 &lt;code&gt;白-B-2G&lt;/code&gt; 可选&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法描述如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;遍历所有非已选元素

&lt;ol&gt;
&lt;li&gt;遍历所有属性行

&lt;ol&gt;
&lt;li&gt;取： a) 当前元素 b) 非当前元素所在的其它属性已选元素（如果当前属性中没已选元素，则跳过），形成一个路径&lt;/li&gt;
&lt;li&gt;判断此路径是否存在（在所有存在的路径表中查询），如果不存在将当前元素置灰&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以最开始的后端数据为例，生成的所有可选路径表如下：
注意路径用分割符号「-」分开是为了查找路径时方便，不用遍历&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;, &amp;quot;3133859&amp;quot;, &amp;quot;3516833&amp;quot;]
    },
    &amp;quot;红&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;大&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;红-大&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;A&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;红-A&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;大-A&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;红-大-A&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;白&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;中&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;白-中&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;B&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;白-B&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;中-B&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;白-中-B&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;蓝&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;小&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;蓝-小&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;C&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;蓝-C&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;小-C&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;蓝-小-C&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了更清楚的说明这个算法，再上一张图来解释下吧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3232/357/5124948788/54677/7df39060/58620377Nde9640c3.jpg&#34; alt=&#34;color-size-sel&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以根据上面的逻辑得出，计算状态后的界面应该是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t3160/115/5120711700/3214/2e9b7205/5862159bN7d072d5f.png&#34; alt=&#34;color_size_with_state&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在这种情况下如果用户点击 尺码 &lt;code&gt;中&lt;/code&gt; 应该怎么交互呢？&lt;/p&gt;

&lt;h3 id=&#34;优化体验&#34;&gt;优化体验&lt;/h3&gt;

&lt;p&gt;因为当前情况下路径 &lt;code&gt;红-中-A&lt;/code&gt; 并不存在，如果点击 &lt;code&gt;中&lt;/code&gt;，那么除了尺码 &lt;code&gt;中&lt;/code&gt; 之外其它的属性中 &lt;strong&gt;至少有一个&lt;/strong&gt; 属性和 &lt;code&gt;中&lt;/code&gt; 的路径搭配是不存在的&lt;/p&gt;

&lt;p&gt;交互方面需求是：如果不存在就高亮当前属性行，使用户必须选择到可以和 &lt;code&gt;中&lt;/code&gt; 组合存在的属性。而且用户之间选择过的属性要做一次缓存&lt;/p&gt;

&lt;p&gt;所以当点击不存在的属性时交互流程是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;无论当前属性存不存在，先高亮（选中）当前属性&lt;/li&gt;
&lt;li&gt;清除其它所有已选属性&lt;/li&gt;
&lt;li&gt;更新当前状态（只选当前属性）下的其它属性可选状态&lt;/li&gt;
&lt;li&gt;遍历非当前属性行的其它属性查找对应的在缓存中的已选属性&lt;/li&gt;
&lt;li&gt;如果缓存中对应的属性存在（可选），则默认选中缓存属性并 &lt;strong&gt;再次更新&lt;/strong&gt; 其它可选状态。不存在，则高亮当前属性行（深色背景）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个过程的流程图大概是这样的，点进不存在的属性就会进入「单选流程」&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t3232/297/5253318434/61277/1eb899ea/58653ae6Nf0a3ed56.png&#34; alt=&#34;select_diag&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假设后端数据是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[
   { &amp;quot;颜色&amp;quot;: &amp;quot;红&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;大&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;A&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3158054&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;白&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;大&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;A&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3158054&amp;quot; }, // 多加了一条
   { &amp;quot;颜色&amp;quot;: &amp;quot;白&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;中&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;B&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3133859&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;蓝&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;小&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;C&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3516833&amp;quot; }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当前选中状态是：&lt;code&gt;白-大-A&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3235/190/5186335420/3376/e9633659/58624212Ne7f43d1f.png&#34; alt=&#34;color_size_demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果用户点击 &lt;code&gt;中&lt;/code&gt;。这个时候 &lt;code&gt;白-中&lt;/code&gt; 是存在的，但是 &lt;code&gt;中-A&lt;/code&gt; 并不存在，所以保留颜色 &lt;code&gt;白&lt;/code&gt;，高亮型号属性行：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t4111/305/936307630/3771/c6076a9c/58624270N59d19a52.png&#34; alt=&#34;color_size_demo_width_hl&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由此可见和 &lt;code&gt;白-中&lt;/code&gt; 能搭配存在型号只有 &lt;code&gt;B&lt;/code&gt;，而缓存的作用就是为了少让用户选一次颜色 &lt;code&gt;白&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;到这里，基本上主要的功能就实现了。比如库存逻辑处理方式也和不存属性一样，就不再赘述。唯一需要注意的地方是求幂集的复杂度问题&lt;/p&gt;

&lt;h2 id=&#34;算法复杂度&#34;&gt;算法复杂度&lt;/h2&gt;

&lt;p&gt;幂集算法的时间复杂度是 &lt;code&gt;O(2^n)&lt;/code&gt;，也就是说每条数据上面的属性（维度）越多，复杂度越高。sku 数据的多少并不重要，因为是常数级的线性增长，而维度是指数级的增长&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{1}       2^1 = 2
=&amp;gt; {},{1}
{1,2}     2^2 = 4
=&amp;gt; {},{1},{2},{1,2}
{1,2,3}   2^3 = 8
=&amp;gt; {},{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3280/36/5011858321/16515/2187c9c/5864aa23N95cea203.png&#34; alt=&#34;powerset_test&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 chrome 里面简单跑了几个用例，可见这个算法非常低效，如果要使用这个算法，必须控制维度在合理范围内，而且不仅仅算法时间复杂度很高，生成最后的路径表也会非常大，相应的占用内存也很高。&lt;/p&gt;

&lt;p&gt;举个例子：如果有一个 10 维的 sku，那么最终生成的路径表会有 2^10 个（1024） key/value&lt;/p&gt;

&lt;p&gt;最终 demo 可以查看这个：
&lt;a href=&#34;http://codepen.io/keelii/pen/RoOzgb&#34;&gt;sku 多维属性状态判断&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;相关资料：
&lt;a href=&#34;http://git.shepherdwind.com/sku-search-algorithm.html&#34;&gt;sku组合查询算法探索&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TrimPath 模板引擎使用指南</title>
      <link>https://keelii.github.io/2016/11/21/trimpath-template-engine/</link>
      <pubDate>Mon, 21 Nov 2016 12:39:49 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/11/21/trimpath-template-engine/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.summitdowntown.org/site_media/media/javascript/private/trimpath-template-docs/JavaScriptTemplates.html&#34;&gt;TrimPath&lt;/a&gt; 是一款轻量级的前端 JavaScript 模板引擎，语法类似 &lt;a href=&#34;http://freemarker.org/&#34;&gt;FreeMarker&lt;/a&gt;, &lt;a href=&#34;https://velocity.apache.org/&#34;&gt;Velocity&lt;/a&gt;，主要用于方便地渲染 json 数据
&lt;/p&gt;

&lt;h2 id=&#34;语法-syntax&#34;&gt;语法 Syntax&lt;/h2&gt;

&lt;h3 id=&#34;表达式-expressions&#34;&gt;表达式 Expressions&lt;/h3&gt;

&lt;p&gt;表达式和修饰符（其它模板语言中叫做过滤器 filter）中间用 &lt;code&gt;|&lt;/code&gt; 分割且 &lt;strong&gt;不能有空格&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${expr}
${expr|modifier}
${expr|modifier1:arg1,arg2|modifier2:arg1,arg2|...|modifierN:arg1,arg2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;语句-statements&#34;&gt;语句 Statements&lt;/h3&gt;

&lt;h4 id=&#34;控制流-control-flow&#34;&gt;控制流 Control Flow&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{if testExpr}
    {elseif testExpr}
    {else}
{/if}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;循环-loops&#34;&gt;循环 Loops&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{for varName in listExpr}
{/for}

{for varName in listExpr}
    ...循环主体...
{forelse}
    ...当 listExpr 是 null 或者 length 为 0 ...
{/for}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;变量声明-variable-declarations&#34;&gt;变量声明 Variable Declarations&lt;/h4&gt;

&lt;p&gt;变量声明语句用花括号 &lt;code&gt;{}&lt;/code&gt; 括起来，不需要关闭。类似 JavaScript 中的赋值语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{var varName}
{var varName = varInitExpr}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;宏声明-macro-declarations&#34;&gt;宏声明 Macro Declarations&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{macro macroName(arg1, arg2, ...argN)}
    ...macro 主体...
{/macro}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;cdata-部分-cdata-text-sections&#34;&gt;CDATA 部分 CDATA Text Sections&lt;/h4&gt;

&lt;p&gt;CDATA 部分用来告诉模板引擎不用做任何解析渲染，直接输出。比如展示一个模板字符串本身&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{cdata}
    ${customer.firstName} ${customer.lastName}
{/cdata}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;in-line-javascript&#34;&gt;In-line JavaScript&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;eval blocks&lt;/strong&gt; 用来执行 JavaScript 代码片段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{eval}
    ...模板渲染的时候执行的 JavaScript 代码...
{/eval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;minify blocks&lt;/strong&gt; 用来压缩内容中的换行符，比如压缩 HTML 属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;commentPanel&amp;quot; style=&amp;quot;{minify}
      display:none;
      margin: 1em;
      border: 1px solid #333;
      background: #eee;
      padding: 1em;
    {/minify}&amp;quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;修饰符-modifier&#34;&gt;修饰符 Modifier&lt;/h2&gt;

&lt;p&gt;修饰符用来处理上一个表达式的结果，并输出内容。类似于 Linux shell 中的管道操作符，使用「|」分割不同修饰符，可以串联使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${name|capitalize}
${name|default:&amp;quot;noname&amp;quot;|capitalize}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;内置修饰符&#34;&gt;内置修饰符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;capitalize&lt;/strong&gt; 返回大写内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;default:valueWhenNull&lt;/strong&gt; 如果内容为 null，返回 valueWhenNull&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;eat&lt;/strong&gt; 返回空内容，一般用于表达式求值后又不想展示输出的内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;escape&lt;/strong&gt; 转换 HTML 字符实体，比如： &amp;amp; 转换成 &amp;amp;amp;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;h&lt;/strong&gt; 和 escape 效果一样&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;自定义修饰符&#34;&gt;自定义修饰符&lt;/h3&gt;

&lt;p&gt;自定义修饰符可以挂载到 contextObject 上的 &lt;code&gt;_MODIFIERS&lt;/code&gt; 属性上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Modifiers = {
  toFixed: function(value, num) {
    return value.toFixed(num)
  }
}
var out = &#39;${num|toFixed:2}&#39;.process({
  _MODIFIERS: Modifiers,
  num: 1024
})
// =&amp;gt; &amp;quot;1024.00&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;宏-macro&#34;&gt;宏 Macro&lt;/h2&gt;

&lt;p&gt;macro 一般用来封装可复用 HTML 模板，类似函数的功能。对于每个模板来说 macro 是私用的。如果想公用 macro，可以保存 macro 引用到 contextObject 上（下次调用 process() 方法的时候再手动挂载上!? ）。需要在调用 process() 方法之前给 contextObject 设置一个空的 exported 属性：&lt;code&gt;contextObject[&#39;exported&#39;] = {}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个公用的 macro 设计的有点奇葩，可以参考这个 &lt;a href=&#34;http://codepen.io/keelii/pen/dOvgOJ&#34;&gt;示例&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{macro link(href, name)}
    &amp;lt;a href=&amp;quot;${href}&amp;quot;&amp;gt;${name}&amp;lt;/a&amp;gt;
{/macro}

${link(&#39;http://google.com&#39;, &#39;google&#39;)}      =&amp;gt; &amp;lt;a href=&amp;quot;http://google.com&amp;quot;&amp;gt;google&amp;lt;/a&amp;gt;
${link(&#39;http://facebook.com&#39;, &#39;facebook&#39;)}  =&amp;gt; &amp;lt;a href=&amp;quot;http://facebook.com&amp;quot;&amp;gt;facebook&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var data = {
    name: &#39;iPhone 6 Plus&#39;,
    weight: 480,
    ram: &#39;16gb&#39;,
    networks: [
        &#39;移动（TD-LTE)&#39;,
        &#39;联通(TD-LTE)&#39;,
        &#39;电信(FDD-LTE)&#39;
    ]
}

data._MODIFIERS = {
    toFixed: function(n, num) {
        return n.toFixed(num)
    }
}

var template = &#39;\
名称: ${name}&amp;lt;br&amp;gt;\
重量：${weight|toFixed:2}&amp;lt;br&amp;gt;\
内存：${ram|capitalize}&amp;lt;br&amp;gt;\
网络：\
{for item in networks}\
  {if item_index!=0}|{/if}\
  ${item}\
{/for}&#39;;

template.process(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;名称: iPhone 6 Plus&amp;lt;br&amp;gt;
重量：480.00&amp;lt;br&amp;gt;
内存：16GB&amp;lt;br&amp;gt;
网络：
  移动（TD-LTE)
 | 联通(TD-LTE)
 | 电信(FDD-LTE)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>