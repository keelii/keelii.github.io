<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Archives on 臨池不輟</title>
    <link>https://keelii.com/archives/</link>
    <description>Recent content in Archives on 臨池不輟</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 25 Aug 2019 18:33:57 +0800</lastBuildDate>
    
        <atom:link href="https://keelii.com/archives/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>漫谈哲学与编程</title>
      <link>https://keelii.com/2019/08/25/philosophy-and-programming/</link>
      <pubDate>Sun, 25 Aug 2019 18:33:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/08/25/philosophy-and-programming/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://i.v2ex.co/nfs1f0Yn.jpeg&#34; alt=&#34;philosophy and programming&#34; /&gt;&lt;/p&gt;

&lt;p&gt;谈到哲学，多数人都会直觉性的认为它是很高深的一门学问。实际上大多数情况并非如此，哲学研究的往往是非常简单的一些命题，而这些命题在常人看来可能并没有现实意义。&lt;/p&gt;

&lt;p&gt;比如说：到底是先有鸡还是先有蛋的问题；比如说：一个号称只给不能给自己理发的人理发的理发师到底能不能给自己理发的问题。当然本文的目的并不在于讨论这两个问题，我们来聊聊几个稍微简单一些的概念：&lt;/p&gt;

&lt;h3 id=&#34;哲学中的理性与感性&#34;&gt;哲学中的理性与感性&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;理性是超越的，本质在于追求无限&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;超越&lt;/strong&gt;的意思是说理性本身不依赖任何现实或者经验社会中的任何对象，&lt;strong&gt;无限&lt;/strong&gt;实际上就是说理性本身需要达到的某种理想状态。&lt;/p&gt;

&lt;p&gt;比方说：「&lt;strong&gt;100%的金」&lt;/strong&gt; 就是一种无限状态。我们不使用任何经验就可以判断出 100% 的金是必然有的，概念上没人能否定这一点。&lt;/p&gt;

&lt;p&gt;但是运用在经验社会中的知识来判断，这个命题就是不正确的，或者说不具有*普遍*的正确性。因为我们知道无论人类的技术如何高超也无法制造出来 100% 的金。即使到 99.99% 逻辑上也没到达 100%。&lt;/p&gt;

&lt;p&gt;这个时候人们对于类似的事情就会产生了不同的反应。有的人会因为理想状态达不到而&lt;strong&gt;反向&lt;/strong&gt;地认为原来的命题是错误的；有的人内心则有一种说不清道不明的东西指引着他，不会因为到达不到无限状态而肯定整个命题。&lt;/p&gt;

&lt;p&gt;这个问题也一直困扰了我很久，因为在现实生活中在你看来很多明显正确的事情忽出现了一个反例，结果就会有一堆人来告诉你你错了。&lt;/p&gt;

&lt;p&gt;德国哲学家康德在《&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BA%AF%E7%B2%B9%E7%90%86%E6%80%A7%E6%89%B9%E5%88%A4&#34;&gt;纯粹理性批判&lt;/a&gt;》这本书中给出了一种解释：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;理性的调节性是引导经验去追求无限，追求绝对，但是永远也达不到。达不到也有作用 — 它使得经验科学不断的前进，并且有了明确的目的和方向…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;类似的哲学观点好就好在一但明白了其中的本质和它阐述的真理以后，它就可以在某种层次上解释经验世界的各种现象。这或许就是大家说的哲学是任何其它学科的奠基，是第一学科的原因。&lt;/p&gt;

&lt;p&gt;对应的在编程领域也有一些无限的概念，对于多数前端工程师来讲「实现一个无限级的下拉菜单」似乎也在表达着一种无限状态。当然用户在使用的时候根本不可能用到无限级的菜单，无限级的菜单在交互方面也也是极其反人类的，一步可以做到的事情没人愿意多增加一步。但是为什么程序员们热衷于实现这种类似的无限状态。实际上这就是理性的力量，总有一种说不清楚的力量在引导着你，你也没法解释。&lt;/p&gt;

&lt;p&gt;理解了这一点你就会有一个很简单的评判程序好坏的论点，即：程序或者代码是否表现了某种&lt;strong&gt;无限&lt;/strong&gt;状态？如果你的程序函数里面只是几个简单的 if else，那你有没有考虑过如果当输入不断的增加或者变化时，原来的代码是否还可以正常返回。或者说在不考虑硬件等客观条件的前提下，你的程序是否存在极限状态。&lt;/p&gt;

&lt;p&gt;我们经常在知乎或者其它论坛上争论一些问题，本质上讲大家都没有区分清楚自己对于一个论点的&lt;strong&gt;逻辑认知&lt;/strong&gt;和&lt;strong&gt;情感认知&lt;/strong&gt;。太多人喜欢用自己的感情认知去否定逻辑事实，以至于争来争去谁也没能说服谁，试图用唯心观点去解释唯物的现象或者相反，这是极其不正确的。&lt;/p&gt;

&lt;p&gt;一个典型的问题是我不久之前在知乎上回答的一个问题：&lt;a href=&#34;https://www.zhihu.com/question/309891718&#34;&gt;谁能大致说下vue和react的最大区别之处&lt;/a&gt;？我的回答简单总结就两句话：Vue 有一种设计层面追求的简洁感性之美，React 则是一种数学层面的逻辑一致之美。本质上讲没有什么好坏之分。但是诸如些类的一些前端框架问题正在变成一种帮派化的「站队」风气。&lt;/p&gt;

&lt;h3 id=&#34;编程中的低阶-low-level-与高阶-hight-level&#34;&gt;编程中的低阶（low-level）与高阶（hight-level）&lt;/h3&gt;

&lt;p&gt;注意这里讲的 low/hight level 并不是计算机术语中特定的某种形式。&lt;/p&gt;

&lt;p&gt;有个笑话是这么讲的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个程序员去相亲，程序员自己介绍说「我是做嵌入式C语言底层开发的」，妹子反问「那啥时候做到高层开发呢」？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;程序员们内心都有一个做底层开发的梦，因为这才是一个真正的程序员的追求与理想。&lt;/p&gt;

&lt;p&gt;但是现实往往相反，大多数程序员每天都在写业务代码（重复的 CRUD）。所以很多程序员得出来一个结论就是：越底层的东西越重要，越高层的东西越肤浅。通常这也会行成一条鄙视链，他们会不由自主地忽略高层的东西。&lt;/p&gt;

&lt;p&gt;注意这里有两个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;业务代码有没有价值？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然有了，业务部分的代码是系统的最终结果。从结果导向上讲底层代码如何优雅、实现如何科学我们根本不关心，我们更关心整个系统层面的稳定与健壮。这是一种领导的高层次视角。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;底层的东西就一定重要？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;并不一定，这里说的不一定不是要完全否定底层的重要性。恰恰相反，软件领域一些特别优秀或者说伟大的软件底层并不是那么的如人意。比方说微软开发的 VSCode 代码编辑器。要是从底层去讨论它的构架合理性那确实挺像一个笑话的。因为本质上讲 VSCode 基于 electron，它把编辑器放在了一个 webview 中去运行，但是 webview 是用来浏览网页的，而且 electron 居然把 NodeJS 运行时也整合进去，以至于最小的一个应用解压完也有上百兆。&lt;/p&gt;

&lt;p&gt;这感觉就像是上学的时候你很期待一个数学教授教你数学课，但是实际上你的数学课却是一个体育老师带的，这不是可不可以的问题对吧。&lt;/p&gt;

&lt;p&gt;然而 VSCode 这样做的结果是：它还真的成功了，而且编辑器的性能比很多原生软件做的都要好，以至于周围所有人都在使用它，VSCode 在 Github 上名列前茅，也改变了很多程序员对于微软的刻板印象。&lt;/p&gt;

&lt;p&gt;如果我们再回过头从哲学的角度去思考这个问题，实际上计算机中的&lt;strong&gt;底层&lt;/strong&gt;与&lt;strong&gt;高层&lt;/strong&gt;正好对应着哲学中的&lt;strong&gt;理性&lt;/strong&gt;与&lt;strong&gt;感性&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;底层更注重逻辑严谨，因为这是构建高层建筑的基础，它面向的是理论&lt;/li&gt;
&lt;li&gt;高层更注重表现形式，因为高层的部分呈现出来的是一个完整的系统，它面向的对象是人。是人，那需求就是多样化的，因为人的想法总是特别的感性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理性的认知是有对错可以批判的，但是感性的直观是没有对错的，因为即使是同一种声音、颜色对不同人观感都是不一样的。&lt;/p&gt;

&lt;p&gt;比如说你在火车上看书，对面的人说话声音太大吵到了你。你说：你们说话小声点可以吗？对方会说：车上这么多人说话为啥就我们吵到你了？你说：因为就你们声音最大。对方说：我咋没觉得？&lt;/p&gt;

&lt;h3 id=&#34;现实中的主观与客观&#34;&gt;现实中的主观与客观&lt;/h3&gt;

&lt;p&gt;现实生活中我们经常会遇到一些对于论点的评价：主观还是客观。但是很多人没搞清楚这两个词的关系。多数人都觉得客观的观点就是好的，主观的就是臆断的。&lt;/p&gt;

&lt;p&gt;主观和客观的关系就像是主人与客人的关系一样，有的人会认为应该主随客便，有的人则认为应该是客随主便。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果一个人表达的观点全是主观的，那我们会认为这些观点是不可以讨论与评判的，不经过讨论批判的观点是站不住脚的。&lt;/li&gt;
&lt;li&gt;如果一个人表达的观点全是客观的，那似乎也不对，因为这些观点全是别人的，你可能忽略了自己的意识，最终只能游走在别人的规则中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任何语言中都有那么一些词语是成对儿出现的，像因果、主客、高低，这些词在被造出来的时候就是成对出现的，缺一不可。没有前者，后者将不会单独存在。它们之间没有绝对性的对于错。如果有，那对方就没有了存在的意义，反过来自己也将不存在。&lt;/p&gt;

&lt;p&gt;当有人抛出一个观点的时候我的经验是一定要听清楚对方说的是「我觉得」还是「我认为」。「我觉得」那必然就是人家的主观感受，这种观点我们就没必要讨论了。你应该回复：「嗯，没错，确实是这样的。」。如果对方说「我认为」那你要是有不同的观点就完全可以和他讨论，因为说「我认为」的观点必然是有一些客观事实做为依据的，有事实有逻辑，那就可以有对错。&lt;/p&gt;

&lt;h3 id=&#34;结语&#34;&gt;结语&lt;/h3&gt;

&lt;p&gt;哲学中的知识并不能完全解释现实中的事物，因为哲学研究的终点是一些没有结论的东西：上帝、自由、灵魂不朽。这些东西并非常人能理解的，但是人们对于无限真理的追求驱使着大家去研究它，很多人会觉得既然研究不出来结果那是不是就没意义了，当然不是。事实恰恰相反，如果我们把所有的事物本质都研究清楚了，那我们的存在也将失去意义。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>法布里斯·贝拉 — 一个真正的程序员</title>
      <link>https://keelii.com/2019/07/13/a-real-programmer-fabrice-bellard/</link>
      <pubDate>Sat, 13 Jul 2019 18:33:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/13/a-real-programmer-fabrice-bellard/</guid>
      <description>&lt;p&gt;&lt;strong&gt;法布里斯·贝拉&lt;/strong&gt;是一位法国著名的计算机程序员，在7月9日前我对他几乎一无所知。也就在这一天他发布了 &lt;a href=&#34;https://bellard.org/quickjs/&#34;&gt;QuickJS&lt;/a&gt; 引擎的首个公开发行版。这个名字才进入了很多和我一样无知的前端工程师的世界里。&lt;/p&gt;

&lt;p&gt;官网中是这么介绍 QuickJS 的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;QuickJS 是一个精巧可嵌入的 JavaScript 引擎。它支持 &lt;a href=&#34;https://tc39.es/ecma262/&#34;&gt;ES2019&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:JavaScript&#34;&gt;&lt;a href=&#34;#fn:JavaScript&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 中的很多特性 — 模块、异步生成器和代理。可选支持数学扩展 — 大整型，大浮点型数和操作符重载。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;主要的功能特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;轻量级很方便嵌入：源代码也只有几个 C 文件，没有外部依赖，一个简单的 hello world 程序会被编译成190Kb 的 x86 代码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;超快的解释器及启动时间：在一个普通的桌面 PC 上跑 ECMAScript 测试套件中的 56000 个用例只需要 100 秒&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;几乎完成的 ES2019 新特性支持，模块、异常生成器和完整的 Annex B&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Hypothetical-Ref&#34;&gt;&lt;a href=&#34;#fn:Hypothetical-Ref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 支持&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以将 JavaScript 源代码编译成无任何外部依赖的可执行程序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;垃圾回收使用引用计数机制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数学扩展支持：大整型，大浮点型数、操作符重载、大整型模式、数学模式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 JavaScript 实现的具有色彩支持的命令行解释器&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内置的微型标准库（C语言包装而成）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript 引擎在这之前只有主流的 Google V8，忽然出现这么一个项目，还是非常令人震惊的，尤其是它上面的这些特性，某种程度上让前端看到了新希望。&lt;/p&gt;

&lt;p&gt;QuickJS 发布后不久后，便在 Hack news、Twitter 上引发了大量的讨论，我也不由得起了八卦之心。下面引用一些网友的讨论：&lt;/p&gt;

&lt;p&gt;HN 上有网友回复到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is there anything that Fabrice can&amp;rsquo;t do? I mean, FFMpeg is almost a PhD thesis in and of itself, and he still manages to find time to make TinyC, QEMU, and now this. To say I&amp;rsquo;m jealous of his skills would be an understatement.&lt;/p&gt;

&lt;p&gt;还有什么事情是&lt;strong&gt;法布里斯&lt;/strong&gt;不能做的吗？我的意思是，FFMpeg 几乎是一个 PhD 论文级别的项目，但是他仍然有时间写 TinyC、QEMU 现在又是 QuickJS。我对他的佩服之情已经远超「嫉妒」之心。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;后面的网友也是八卦之心作祟：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I have two question in my mind. 我有两个问题&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Are there anyone on HN knows him in real life? HN 上有了解法布里斯在现实生活中的样子吗？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Does anyone have other people in their mind who is in the same league as this man? — 大家心目中与法布里斯类似的人有哪些？&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;++第一个问题++：根据几个（有机会见到过本人）网友的描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I know Fabrice a little. He&amp;rsquo;s definitely real, smart and humble. — 我知道一点关于&lt;strong&gt;法布里斯&lt;/strong&gt;。他是肯定是一个实际存在的、聪明且谦逊人。&lt;/p&gt;

&lt;p&gt;He is definitely very humble and a very good listener. — 他绝对是一个非常谦逊、内敛人，是一个非常好的倾听者。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;++第二个问题++：简单来说就是有没有和法布里斯一样利害的程序员，网友纷纷回复了自己眼中最利害的程序员名字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dan Bernstein&lt;/strong&gt; — 德裔美国数学家，密码学家和程序员。埃因霍温理工大学数学与计算机科学系的个人教授。发明了chacha20算法（几乎所有的现在加密算法都在使用它）。1995年，伯恩斯坦将&lt;strong&gt;伯恩斯坦诉合众国案&lt;/strong&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:-&#34;&gt;&lt;a href=&#34;#fn:-&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;件提起诉讼。该案的裁决宣称软件是第一修正案下的受保护言论。此前加密算法是高度机密的，受到国家/政府管制的，而伯恩斯坦自己认为写的 Snuffle 加密算法及相关的源代码是某种意义上的言论自由，因此与美国政府打官司最后还赢了，在那之后发表自由/开源软件才被视为一种言论自由。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Richard Stallman&lt;/strong&gt; — 理查德·马修·斯托曼，美国程序员，自由软件活动家。&lt;a href=&#34;https://zh.wikipedia.org/wiki/GCC&#34; title=&#34;GCC&#34;&gt;GCC&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/GNU%E4%BE%A6%E9%94%99%E5%99%A8&#34; title=&#34;GNU调试器&#34;&gt;GDB&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/Emacs&#34; title=&#34;Emacs&#34;&gt;GNU Emacs&lt;/a&gt; 都是他的作品&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linus Torvalds&lt;/strong&gt; — 芬兰程序员，Linux内核的最早作者，是当今世界最著名的计算机程序员、黑客之一。他的作品 Linux、Git 或许是开源软件领域最成功的两个项目。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;John Carmack&lt;/strong&gt; — 约翰·卡马克，美国的电玩游戏程序员、id Software 的创始人之一。卡马克创造的游戏引擎被用来制作其他的第一人称射击游戏，比如《半条命》和《荣誉勋章》&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rob Pike and Ken Thompson&lt;/strong&gt; — 肯·汤普逊，他创造了Go 语言、&lt;a href=&#34;https://zh.wikipedia.org/wiki/B%E8%AF%AD%E8%A8%80&#34; title=&#34;B语言&#34;&gt;B语言&lt;/a&gt;（&lt;a href=&#34;https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80&#34; title=&#34;C语言&#34;&gt;C语言&lt;/a&gt;的前身）。与&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87&#34; title=&#34;丹尼斯·里奇&#34;&gt;丹尼斯·里奇&lt;/a&gt;同为1983年&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96&#34; title=&#34;图灵奖&#34;&gt;图灵奖&lt;/a&gt;得主。&lt;/p&gt;

&lt;p&gt;后面还有有提到前端比较熟悉的 TJ 大神等。&lt;/p&gt;

&lt;p&gt;法布里斯与其它程序员不同的是他似乎很少有网络社交，平常人想与他沟通只能用 email，他没有任何社交账号。如果提到 Linus，你脑海里面一定会出现那些他说过的名言：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Talk is cheap. Show me the code, I am linus i&amp;rsquo;m your god.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linus 的利害之处在于他说他是你的上帝，一般人连否定这句话的资格都没有。从前我也一直很崇拜 Linus，因为它比较高调，语出惊人又无法否定。法布里斯则不一样，相比而言更低调，更有传统程序员的特点。但是朴实的外表怎么能遮住人家的才华呢。&lt;/p&gt;

&lt;p&gt;法布里斯的每个作品都是那么惊艳：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开源软件 FFmpeg，几乎被现在所有主流的媒体播放器使用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;发明了贝拉公式—最快圆周率算法，这个计算 N 位 PI 的公式比传统的 BBQ 算法要快 47%&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在PC上用软件实现 4G LTE 基站&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 JavaScript 写了一个 PC 虚拟机 &lt;a href=&#34;https://zh.wikipedia.org/wiki/Jslinux&#34; title=&#34;Jslinux&#34;&gt;Jslinux&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;QuickJS 问世后，JavaScript 之父 Brendan Eich 也坐不住了，称赞法布里斯是&lt;strong&gt;超级黑客&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/13/5d297b8fad00320486.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;实际上我觉得不应该给这些利害的程序员以程序员的「分类」，因为写代码/编程对于他们来说只是一种手段或者方法，最重要的是他们创造出来的东西会让世界上所有的人受益。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:JavaScript&#34;&gt;JavaScript 语言最新的标准规范 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:JavaScript&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Hypothetical-Ref&#34;&gt;Hypothetical Reference Decoder  &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Hypothetical-Ref&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:-&#34;&gt;伯恩斯坦诉合众国案 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:-&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>我想要 AOP — 使用 AOP 分离关注点</title>
      <link>https://keelii.com/2019/07/06/i-want-my-aop-cn/</link>
      <pubDate>Sat, 06 Jul 2019 18:33:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/06/i-want-my-aop-cn/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&#34;https://www.javaworld.com/article/2073918/i-want-my-aop---part-1.html&#34;&gt;I want my AOP&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;关注点&lt;/strong&gt;表示人们的一种特殊的意愿、理念或是某个感兴趣的领域。从技术角度来讲：软件系统包括若干&lt;strong&gt;核心的&lt;/strong&gt;、&lt;strong&gt;系统级别的&lt;/strong&gt;关注点。比方说：信用卡处理系统的&lt;strong&gt;核心&lt;/strong&gt;关注点是处理交易，同时系统级别的关注点或许应该是处理日志、事务、一致性、授权、安全、性能等。许多这种关注点被叫做&lt;strong&gt;横切关注点&lt;/strong&gt; — 往往会影响许多模块的实现。&lt;/p&gt;

&lt;p&gt;使用目前的编程方法，跨越多个模块横切关注点会导致系统更难设计、理解、实现和迭代。&lt;/p&gt;

&lt;p&gt;阅读完全的「我想要 AOP」系列文章：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第一部分&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二部分&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第三部分&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;面向切面的编程相比之前的方法更简单的分享了关注点，从而提供横切关注点的模块化。&lt;/p&gt;

&lt;p&gt;在本系列文章中，第一篇涉及 AOP 的概念，我首先解释了在一般复杂的软件系统中由横切关注点引起的问题。然后，我引入了 AOP 核心概念，并展示了 AOP 是如何通过横切关注点解决问题的。&lt;/p&gt;

&lt;p&gt;这个系列的第二篇文章将介绍 AspectJ，Xerox PARC 基于 Java 实现的 AOP 框架。最后一篇文章将以几个示例的方式向你展示 AOP 的概念，并基于建立更易懂、易实现、易迭代的软件系统。&lt;/p&gt;

&lt;h2 id=&#34;软件编程方法的演进&#34;&gt;软件编程方法的演进&lt;/h2&gt;

&lt;p&gt;早些年的计算机科学领域，开发者直接使用机器码进行编程。不幸的是，程序员花了更多时间去考虑特定机器的指令集而不是手头的问题。慢慢地，我们迁移到高级编程语言，高级编程语言允许对底层机器码进行一些抽象。然后结构化的语言出现了；我们现在可以根据任务的执行过程来分解我们的问题。然而，随着复杂度的增长，我们需要更好的技术。面向对象的编程让我们可以把系统看成一系列的合作对象。类可以让我们隐藏接口背后的实现细节。多态提供了通用行的为和接口，并允许更特殊的组件更改指定定行为，而无需接触基本概念的实现。&lt;/p&gt;

&lt;p&gt;编程方法和语言定义了我们与机器交流的方式。每一种新方法都提供某种分解问题的方式：机器码、独立于机器的代码、过程、类等等。每种方法都在建立某种&lt;strong&gt;系统需求&lt;/strong&gt;与&lt;strong&gt;程序结构&lt;/strong&gt;之间的对应关系。这些编程方法的演进让我们可以创建越来越复杂的系统。反过来复杂的系统使得我们又必须使用更先进的技术去解决这些复杂度。&lt;/p&gt;

&lt;p&gt;目前来讲，放多新的软件项目开发都使用面向对象的编程模式。的确，面向对象的编程模式能模拟常见行为方面表现出了强大的能力。然而，我们很快将会看见，或许你已经有所体验了，面向对象的编程模式没能充分地解决许多跨区的行为的问题 — 那种通常不相关的模块。相比而言，面向切面的编程方法填补了这个空白。AOP 很可能代表了编程方法演进的下一个重要方向。&lt;/p&gt;

&lt;h2 id=&#34;将系统看做一系列的关注点&#34;&gt;将系统看做一系列的关注点&lt;/h2&gt;

&lt;p&gt;我们可以将复杂系统看做是多个关注点的联合实现。典型的系统可能包含多种关注点，包括业务逻辑、性能、数据持久化 、日志，以及调试、授权、安全、线程安全 、错误检查等等。而且你还会遇到开发流程中的关注点，比如说：可理解、可维护，可追溯、更易迭代。图1描绘出了一个系统中不同模块关注点的实现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/05/5d1f0bb5278bd31387.gif&#34; alt=&#34;&#34; /&gt;图1&lt;/p&gt;

&lt;p&gt;图2展示了一系列的需求（一个光束）通过关注点识别器（棱镜）分离各种关注点成为独立模块。这个过程就对应着我们开发过程的关注点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/05/5d1f0d071673b46919.gif&#34; alt=&#34;&#34; /&gt;图2&lt;/p&gt;

&lt;h2 id=&#34;在系统中进行横切&#34;&gt;在系统中进行横切&lt;/h2&gt;

&lt;p&gt;开发者建立一个系统并且负责实现多个需求。我们可以把这些需求大体上从&lt;strong&gt;核心模块&lt;/strong&gt;级别需求与&lt;strong&gt;系统级别&lt;/strong&gt;需求两个维度进行分类。许多系统级别的需求相互之间（或与模块级别的需求）是正交的（相互依赖）。系统级别的需求倾向于横切许多核心模块，比如，一个个典型的企业应用包含的横切关注点有：身份验证，日志记录，资源池，管理，性能和存储管理。每个都被横切成多个子系统。比如，存储管理会影响每个业务对象。&lt;/p&gt;

&lt;p&gt;让我们举个简单的例子，比如有一个单例实现封装了一些业务逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SomeBusinessClass extends OtherBusinessClass {
    // 核心数据成员
    // 其它数据成员：比如日志，数据一致性标识
    // 重写基类中的方法
    public void performSomeOperation(OperationInformation info) {
        // 保证授权正常
        // 保证条件正常满足
        // 锁定对象保证数据一致性
        // 线程进入threads access it
        // 保证缓存正常
        // 打印操作启动日志
        // ==== 进行具体的操作 ====
        // 打印操作完成日志
        // 解锁对象
    }
    // 与上面类似的其它操作
    public void save(PersitanceStorage ps) {
    }
    public void load(PersitanceStorage ps) {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中我们必须考虑至少三个问题，首先，&lt;strong&gt;其它数据成员&lt;/strong&gt;不属于这个类所关心的内容。其次，performSomeOperation 的实现似乎比核心操作执行了更多的逻辑；它处理了日志、授权、线程安全以及其它&lt;strong&gt;外部&lt;/strong&gt;关注点。重要的是，似乎这些许多外围关注点其它类也会用到。最后，save() 和 load() 方法操作存储层，这两个方法放在这个类中比较合适还是放在其它类中比较合适，这个问题并不是很清楚。&lt;/p&gt;

&lt;h2 id=&#34;横切关注的问题&#34;&gt;横切关注的问题&lt;/h2&gt;

&lt;p&gt;虽然会跨模块横切关注点，但是现在的技术实现倾向于使用一维的方式实现，把问题聚焦在需求与实现的单一维度。这个单一维度的实现将变成&lt;strong&gt;核心模块&lt;/strong&gt;级别的实现。其余的需求围绕着这个主导维度被分类。换句话说，需求空间是多维的，然而实现空间是单维的。这种不匹配会导致需求与实现之间的映射难以做到。&lt;/p&gt;

&lt;h3 id=&#34;症状&#34;&gt;症状&lt;/h3&gt;

&lt;p&gt;使用目前的方法实现横切关注点会出现一些问题/症状，大体上分两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码纠缠&lt;/strong&gt;：系统中的模块可能会同时地与多个需求交互。比如，开发者经常同时考虑业务逻辑、性能、同步、日志和安全等问题。大量的并行需求导致需要许多关注点的实现同时存在，最终导致代码纠缠。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码分散&lt;/strong&gt;：由于横切关注点，按定义，很多模块都需要分离，甚至是相关的实现都需要分离。比如，一个使用数据库的系统，性能问题可能会影响所有访问数据库的模块&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;暗示&#34;&gt;暗示&lt;/h3&gt;

&lt;p&gt;代码纠缠与代码分散对软件设计和开发有以下影响：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不可追溯&lt;/strong&gt;：同时分离多个关注点会&lt;strong&gt;掩盖&lt;/strong&gt;关注点与实现之间的对应关系，导致关系不清楚&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;低效的&lt;/strong&gt;：同时实现多个关注点会打乱开发者的注意力，将注意力分散到外围问题上，这将导致低效&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码复用性低&lt;/strong&gt;：由于模块实现了多个需求，其它系统将无法很容易地复用这个模块，进一步导致低效&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码质量低&lt;/strong&gt;：代码纠缠会产生一些不易查觉的问题。此外，一次关注太多问题，某些关注点可能没有被真正关注到&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;难于迭代&lt;/strong&gt;：有限的视界和受限的资源通常会产生仅解决当前关注点的设计。解决未来问题通常需要重新实现。由于这个实现并不是模块化的，这表示触摸许多模块。为了实现新需求需要修改每个子系统可能会引起不一致的问题。它还需要大量的测试工作来保证实现做出的变更没有引入新问题。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;目前的解决方式&#34;&gt;目前的解决方式&lt;/h3&gt;

&lt;p&gt;由于大多数系统都可以横切关注点，因此出现模块化实现的一些技术就不足为奇了。这些技术包括混入（mix-in）类，设计模式和领域特定的解决方案。&lt;/p&gt;

&lt;p&gt;使用混入类可以让你延迟分离关注点到最终的实现。主类包含混入类实例，并允许系统的其他部分设置该实例。例如，上面的信用卡处理例子，将一个实现了业务逻辑的类组合成混入类，系统的其它模块可以通过配置来获取适合自身的日志器。例如，日志器可以设置成使用文件系统或者消息中间件。发送日志的被延后了，但是各个消息发送点（调用的地方）还是需要加入相关的代码。&lt;/p&gt;

&lt;p&gt;基于行为的设计模式，比如说访问者、模板方法，可以让你延迟实现。但是就像混入类一样，控制操作—调用访问逻辑或者模板方法—仍然在主类中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;领域特定&lt;/strong&gt;的解决方案，比如说框架和应用服务，让开发者可以用模块化的方式实现横切关注点。比如 EJB 架构，在安全、管理、性能和持久容器管理方面实现横切关注点。Bean 的开发者专注于业务逻辑，部署工程师专注于部署相关问题，比如 bean-data 与数据库的对应关系。对于 Bean 开发者来讲其余需要关注的就只有存储的问题了。在这个例子中你可以使用基于 XML 的映射描述符来实现横切关注点。&lt;/p&gt;

&lt;p&gt;领域特定的解决方案提供了一种特殊的办法来解决指定的问题。它的缺点是，开发者必须为它学习新的技术。然后由于这些解决方案都是领域特定的，它并不能直接有效地横切关注点。&lt;/p&gt;

&lt;h2 id=&#34;构架设计的窘境&#34;&gt;构架设计的窘境&lt;/h2&gt;

&lt;p&gt;好的系统架构会考眼前与未来的一些需求，从而避免打补丁式的实现。但是这有一个问题，预测未来是一件非常困难的事情。如果你没有搞清楚未来的需求，那就需要改变、或者将系统的很多地方重新实现。另外一方面，将精力聚焦在低可能性的一些需求会导致过度的设计、混乱和臃肿的系统。因此系统构架的一个困境是：应该设计到什么程度？我应该保守式的设计还是盈余式的设计。&lt;/p&gt;

&lt;p&gt;比方说，构架中是否应该追念一个初始化时并不需要的日志系统？如果是，日志打点的地方应该在哪里，什么样的信息应该被记录？这个是一个类似的出现在优化相关需求过程中的困境—我们很少提前知道瓶颈，常归的做法是构建一个系统，对其进行分析，并通过优化进行改进以提高性能。这种方法会潜在引导我们根据分析结果去修改系统很多部分。过不了多久，一个新的瓶颈又会出现，而这个瓶颈很可能就是上一步的改进引起的。设计可复用库架构的任务会变得非常困难，因为找到库的所有的使用场景并非易事。&lt;/p&gt;

&lt;p&gt;总之，架构师很少知道系统所有可能需要解决的问题。即使提前了解了需求，一个实现的具体细节可能并没有被考虑到。因此，架构师面临着究竟应该保守设计还是盈余设计的困境。&lt;/p&gt;

&lt;h2 id=&#34;aop-的基本概念&#34;&gt;AOP 的基本概念&lt;/h2&gt;

&lt;p&gt;到这里我们主要讨论了模块化的横切关注点会有很大益处。研究人员已经研究了在「关注点分离」这一更为泛化的主题下完成该任务的各种方法。 AOP 就是这样的一种方法。AOP 力争将关注点彻底分离，以克服上述问题。&lt;/p&gt;

&lt;p&gt;AOP 的核心在于，以松散耦合的方式让你实现一个独立的关注点，然后结合这些实现成为一个最终的系统。确实，AOP 使用松散耦合、模块化的&lt;strong&gt;分离关注点&lt;/strong&gt;的方式来创建系统。相反，OOP，则使用松散耦合、模块化的实现&lt;strong&gt;共同关注点&lt;/strong&gt;方式来创建系统。AOP 中模块化的单位叫做*横切面*（aspect），好比 OOP 中共同的关注点是*类*（class）。&lt;/p&gt;

&lt;p&gt;AOP涉及三个不同的开发步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;切面分解&lt;/strong&gt;：将需求分解并识别出横切关注点与共同关注点。你可以将系统级别的关注点与模块级别关注点分离。比如说，上面提到的信用卡模块，你需要识别三种关注点：信用卡核心流程，日志和授权。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;关注点实现&lt;/strong&gt;：分离的实现各个关注点。像上面的例子一样，你可以单独实现核心流程、日志和授权三个单元。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;切面重组&lt;/strong&gt;：在这个步骤中，切面集成器通过创建模块化单元来指定重组规则 — 切面。重组过程（也称为&lt;strong&gt;编织&lt;/strong&gt;或集成）使用此信息来组合成最终系统。比如上面的信用卡例子，你得使用一种 AOP 实现的*语言*具体/规范化操作中哪一步需要打日志。还得指定每个操作在被前都需要清除授权。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/06/5d207ff77b21c16740.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;AOP 实现横切关注点的方法与 OOP 不一样。对于 AOP 来讲，每个关注点的实现并不会意识到其它关注点下在横切它。比如上面的信用卡例子，信用止处理模块并不知道其它的关注点是日志、授权操作。这对于 OOP 来讲意味着很大的范式转换。&lt;/p&gt;

&lt;p&gt;注意：一个 AOP 的实现可以采用其它编程方法作为它的基本方法。因此可以保证基础系统非常完善。比如说，一个 AOP 的实现可以选择 OOP 做为基础系统，这样就可以获得 OOP 共同关注点的优势。每个独立的关注点可以采用 OOP 技术识别关注点。这类似于过程式的语言可以做为许多 OOP 语言的基础语言。&lt;/p&gt;

&lt;h2 id=&#34;编织的例子&#34;&gt;编织的例子&lt;/h2&gt;

&lt;p&gt;编织器是一个将独立的关注点纺织起来的过程。换句话说，编织器根据提供给它的某些标准将不同的执行逻辑片段编织起来。&lt;/p&gt;

&lt;p&gt;为了能够演示编织过程，让我们回到之前的信用卡处理系统的例子。为了看起来更简单，我们只考虑两个操作：信用卡和借记卡。并且已经有一个合适的日志器了。&lt;/p&gt;

&lt;p&gt;考虑下面的信用卡处理模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CreditCardProcessor {
    public void debit(CreditCard card, Currency amount) 
       throws InvalidCardException, NotEnoughAmountException,
              CardExpiredException {
        // Debiting logic
    }
    
    public void credit(CreditCard card, Currency amount) 
        throws InvalidCardException {
        // Crediting logic
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样还有一个日志接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Logger {
    public void log(String message);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们想要的组合需要以下编织规则，这些规则以自然语言表示（稍后将提供这些编织规则的编程语言版本）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打印每个公共操作的开始&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打印每个公共操作完成&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打印每个公共操作的异常&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;编织器随后将使用这些规则，并关注每个实现以产生等价于以下代码的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CreditCardProcessorWithLogging {
    Logger _logger;
    public void debit(CreditCard card, Money amount) 
        throws InvalidCardException, NotEnoughAmountException,
               CardExpiredException {
        _logger.log(&amp;quot;Starting CreditCardProcessor.credit(CreditCard,
Money) &amp;quot;
                    + &amp;quot;Card: &amp;quot; + card + &amp;quot; Amount: &amp;quot; + amount);
        // Debiting logic
        _logger.log(&amp;quot;Completing CreditCardProcessor.credit(CreditCard,
Money) &amp;quot;
                    + &amp;quot;Card: &amp;quot; + card + &amp;quot; Amount: &amp;quot; + amount);
    }
    
    public void credit(CreditCard card, Money amount) 
        throws InvalidCardException {
        System.out.println(&amp;quot;Debiting&amp;quot;);
        _logger.log(&amp;quot;Starting CreditCardProcessor.debit(CreditCard,
Money) &amp;quot;
                    + &amp;quot;Card: &amp;quot; + card + &amp;quot; Amount: &amp;quot; + amount);
        // Crediting logic
        _logger.log(&amp;quot;Completing CreditCardProcessor.credit(CreditCard,
Money) &amp;quot;
                    + &amp;quot;Card: &amp;quot; + card + &amp;quot; Amount: &amp;quot; + amount);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;分解-aop-语言&#34;&gt;分解 AOP 语言&lt;/h2&gt;

&lt;p&gt;就像其它编程语言方法的实现，AOP 实现包括两个部分：一种语言规范和一种实现。语言规范描述语言的构成与语法。实现则根据语言规范去论证代码的正确性，然后转换成机器码然后执行。在这小节中，我将解释 AOP 语言的不同组成部分。&lt;/p&gt;

&lt;h4 id=&#34;aop-语言的规范&#34;&gt;AOP 语言的规范&lt;/h4&gt;

&lt;p&gt;在一个高层次上，AOP 语言有两种组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;关注点的实现&lt;/strong&gt;：创建一个独立的需求与代码之间的对应关系，这样编译器才能翻译成可执行代码。由于关注点的实现需要通过具体的过程，你可以使用传统的语言，比如 C，C++ 或者 Java&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;编织规则的规范&lt;/strong&gt;：如何将独立的关注点实现结合成最终的系统。为了达到这个目标，实现需要使用或者创建一种语言来具体说明结合的规则。具体化编织规则的语言可以是实现语言的一种扩展，或者其它完全不同的东西。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;aop-语言的实现&#34;&gt;AOP 语言的实现&lt;/h4&gt;

&lt;p&gt;AOP 语言编译器有以下两个逻辑步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;结合独立的关注点&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;转换最终结果成可执行代码&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;AOP 语言实现编织器的方法有很多，包括源码到源码的翻译。你可以预处理独立切面的源码，然后将它加工成编织过的源码。然后 AOP 编译器将这些源码转交给基本语言编译器用来生成最终可执行代码，最后让 Java 编译器把代码编译成子节码。同样的，编织过程可以是子节码级别的；毕竟，子节码也是一种源代码。引外底层系统—VM虚拟机，是可以感知到切面的。使用这种基于 Java 的 AOP 实现，比如，VM虚拟机将首先加载编织规则，然后将这些规则应用到随后加载的类中。换句话说，它表现得像是 JIT 化的切面编织。&lt;/p&gt;

&lt;h2 id=&#34;aop-的益处&#34;&gt;AOP 的益处&lt;/h2&gt;

&lt;p&gt;AOP 有助于克服由代码纠缠和代码分散引起的上述问题。以下是 AOP 提供的其他优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;模块化地横切关注点&lt;/strong&gt;：AOP 使得每个独立的关注点有最小化的耦合，最终产出模块化的实现。这样的一种实现会产生很少的重复代码。由于每个关注点的实现是分离的，也将减少无用代码，更重要的模块化的实现让最终系统更易于理解与维护。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;更便于系统迭代&lt;/strong&gt;：由于切面模块对于横切关注点是无感知的，添加新功能、新切面将变得简单。而且当你在系统中添加新模块时，现有的切面将横切它们，这有助于你构建一系列连贯的迭代演进。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;延迟设计目标的绑定&lt;/strong&gt;：回顾下架构师的困境，有了 AOP，架构师对于将来的需求就可以推迟做出设计上的决定，因为他可以用分离的切面来实现。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;更高的代码复用性&lt;/strong&gt;：由于 AOP 分离的实现每个切面，每个独立模块之间的耦合更加的松散。比如说，你可以使用不同的日志器来记录你模块与数据库的操作。通常来讲，松散耦合的实现是代码高复用性的关键点。 AOP 的实现比 OOP 的实现更加松散耦合。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;aspectj-一种-java-的-aop-实现&#34;&gt;AspectJ：一种 Java 的 AOP 实现&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第十篇：拦截器）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-10/</link>
      <pubDate>Wed, 03 Jul 2019 18:40:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-10/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/05/5d1edebfa26f771380.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;拦截器&lt;/strong&gt;（Interceptors）是一个使用 @Injectable() 装饰的类，它必须实现 NestInterceptor 接口。&lt;/p&gt;

&lt;p&gt;拦截器有一系列的功能，这些功能的设计灵感都来自于面向切面的编程（AOP）技术。这使得下面这些功能成为可能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在函数执行前/后绑定&lt;strong&gt;额外的逻辑&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;转换&lt;/strong&gt;一个函数的返回值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;转换&lt;/strong&gt;函数抛出的异常&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;基础函数的行为&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据特定的条件&lt;strong&gt;完全的重写&lt;/strong&gt;一个函数（比如：缓存）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;基础&#34;&gt;基础&lt;/h2&gt;

&lt;p&gt;每个拦截器都要实现 intercept() 方法，此方法有两个参数。第一个是 ExecutionContext 实例（这和守卫中的对象一样）。ExecutionContext 继承自 ArgumentsHost。上一节中我们见过，它是一个包装了传递向原始处理器而且根据应用的不同包含不同的参数数组的类&lt;/p&gt;

&lt;h2 id=&#34;执行上下文&#34;&gt;执行上下文&lt;/h2&gt;

&lt;p&gt;ExecutionContext 通过继承 ArgumentsHost，提供了更多的执行过种中的更多细节，它看起来长这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export interface ExecutionContext extends ArgumentsHost {
  getClass&amp;lt;T = any&amp;gt;(): Type&amp;lt;T&amp;gt;;
  getHandler(): Function;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getHandler() 方法返回一个将会被调用的路由处理器的引用。getClass() 方法返回控制器类的类型。例如，如果当前进行着一个 POST 请求，假定它会由 CatsController 的 create() 方法处理，那么 getHandler() 方法将返回 create() 方法的引用，而 getClass() 则会返回 CatsController 的类型（非实例）&lt;/p&gt;

&lt;h2 id=&#34;调用处理器&#34;&gt;调用处理器&lt;/h2&gt;

&lt;p&gt;第二个参数是一个 CallHandler。CallHandler 接口实现了 handle() 方法，这个方法就是你可以在你拦截器的某个地方调用的路由处理器。如果你的 intercept() 方法中没调用 handle() 方法，那么路由处理器将不会被执行。&lt;/p&gt;

&lt;p&gt;不像守卫与过滤器，拦截器对于一次请求响应有完全的&lt;strong&gt;控制权与责任&lt;/strong&gt;。这样的方式意味着 intercept() 方法可以高效地包装请求/响应流。因此，你可以在最终的路由处理器执行前/后实现自己的逻辑。显然，你已经可以通过在 intercept() 方法中的 handle() 调用之前写自己的代码，但是后续的逻辑应该如何处理？因为 handle() 方法返回的是一个 Observable，我们可以使用 RxJS 做到修改后来的响应。使用 AOP 技术，路由处理器的调用被称做一个 &lt;strong&gt;切点&lt;/strong&gt;（Pointcut），这表示一个我们的自定义的逻辑插入的地方。&lt;/p&gt;

&lt;p&gt;假如有一个 &lt;code&gt;POST /cats&lt;/code&gt; 的请求，这个请求将被 CatsController 中的 create() 方法处理。如果一个没调用 handle() 方法的拦截器在某处被调用，create() 方法将不会被执行。一但 handle() 方法被调用（它的 Observable 已返回），create() 处理器将被触发。一但响应流通过 Observable 接收到，附加的操作可以在注上被执行，最后的结果将返回给调用方。&lt;/p&gt;

&lt;h2 id=&#34;切面拦截&#34;&gt;切面拦截&lt;/h2&gt;

&lt;p&gt;我们将要研究的第一个例子就是用户登录的交互。下面展示了一个简单的日志拦截器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&amp;lt;any&amp;gt; {
    console.log(&#39;Before...&#39;);

    const now = Date.now();
    return next
      .handle()
      .pipe(
        tap(() =&amp;gt; console.log(`After... ${Date.now() - now}ms`)),
      );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 handle() 方法返回了一个 RxJS 的 Observable 对象，对于修改流我们将有更多的选择。上面的示例中我们使用了 tap() 操作符。它在 Observable 流的正常或异常终止时调用我们的匿名日志记录函数，但不会干扰到响应周期。&lt;/p&gt;

&lt;h2 id=&#34;绑定拦截器&#34;&gt;绑定拦截器&lt;/h2&gt;

&lt;p&gt;我们可以使用 @UseInterceptors() 装饰器来绑定一个拦截器，和管道、守卫一样，它即可以是控制器作用域的，也可以是方法作用域的，或者是全局的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@UseInterceptors(LoggingInterceptor)
export class CatsController {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的实现，在请求进入 CatsController 后，你将看到下面的日志输出。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Before...
After... 1ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;响应映射&#34;&gt;响应映射&lt;/h2&gt;

&lt;p&gt;我们已经知道了 handle() 方法返回一个 Observable。流包含路由处理器返回的值，因此，我们可以很容易的使用 RxJS 的 map() 操作符改变它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：响应映射功能并不适用于库级别的响应策略（不可以使用 @Res 装饰器）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;让我们新建一个 TransformInterceptor，它可以修改每个响应。它将使用 map() 操作符来给响应对象符加 data 属性，并且将这个新的响应返回给客户端。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;
import { map } from &#39;rxjs/operators&#39;;

export interface Response&amp;lt;T&amp;gt; {
  data: T;
}

@Injectable()
export class TransformInterceptor&amp;lt;T&amp;gt; implements NestInterceptor&amp;lt;T, Response&amp;lt;T&amp;gt;&amp;gt; {
  intercept(context: ExecutionContext, next: CallHandler): Observable&amp;lt;Response&amp;lt;T&amp;gt;&amp;gt; {
    return next.handle().pipe(map(data =&amp;gt; ({ data })));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当有请求进入时，响应看起来将会是下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;data&amp;quot;: []
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拦截器对于创建整个应用层面的可复用方案有非常大的意义。比如说，我们需要将所有响应中出现的 null 值改成空字符串 &amp;ldquo;&amp;ldquo;。我们可以使用拦截器功能仅用下面一行代码就可以实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;
import { map } from &#39;rxjs/operators&#39;;

@Injectable()
export class ExcludeNullInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&amp;lt;any&amp;gt; {
    return next
      .handle()
      .pipe(map(value =&amp;gt; value === null ? &#39;&#39; : value ));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;异常映射&#34;&gt;异常映射&lt;/h2&gt;

&lt;p&gt;另外一个有趣的用例是使用 RxJS 的 catchError() 操作符来重写异常捕获：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  BadGatewayException,
  CallHandler,
} from &#39;@nestjs/common&#39;;
import { Observable, throwError } from &#39;rxjs&#39;;
import { catchError } from &#39;rxjs/operators&#39;;

@Injectable()
export class ErrorsInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&amp;lt;any&amp;gt; {
    return next
      .handle()
      .pipe(
        catchError(err =&amp;gt; throwError(new BadGatewayException())),
      );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;流重写&#34;&gt;流重写&lt;/h2&gt;

&lt;p&gt;有一些情况下我们希望完全阻止处理器的调用并返回一个不同的值。比如缓存的实现。让我们来试试使用缓存拦截器来实现它。当然真正的缓存实现还包含 TTL，缓存验证，缓存大小等问题，我们这个例子只是一个简单的示意。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from &#39;@nestjs/common&#39;;
import { Observable, of } from &#39;rxjs&#39;;

@Injectable()
export class CacheInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&amp;lt;any&amp;gt; {
    const isCached = true;
    if (isCached) {
      return of([]);
    }
    return next.handle();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中我们硬编码了 isCached 变量，以及返回的缓存数据 []。关键点在于我们返回了一个新的流，使用了 RxJS 的 of() 操作符。因此路由处理器永远不会被调用。为了实现一个更完整的解决方案，你可以通过使用 Reflector 创建一个自定义的装饰器来实现缓存功能。&lt;/p&gt;

&lt;h2 id=&#34;更多的操作符&#34;&gt;更多的操作符&lt;/h2&gt;

&lt;p&gt;RxJS 的操作符有很多种能力，我们可以考虑下面这种用例。你需要处理路由请求的超时问题。当你的响应很久都没正常返回时，你会想把它关闭并返回一个错误的响应。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;
import { timeout } from &#39;rxjs/operators&#39;;

@Injectable()
export class TimeoutInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&amp;lt;any&amp;gt; {
    return next.handle().pipe(timeout(5000))
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5 秒后，请求处理将会被取消。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第九篇：守卫）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-9/</link>
      <pubDate>Wed, 03 Jul 2019 18:39:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-9/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;守卫&lt;/strong&gt;（Guards）是一个使用 @Injectable() 装饰的类，它必须实现 CanActivate 接口。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/05/5d1ec2a0e2ae056395.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;守卫&lt;/strong&gt;只有&lt;strong&gt;一个&lt;/strong&gt;职责，就是决定请求是否需要被控制器处理。一般用在权限、角色的场景中。&lt;/p&gt;

&lt;p&gt;守卫和中间件的区别在于：中间件很简单，next 方法调用后中间的任务就完成了。但是守卫需要关心上下游，它需要鉴别请求与控制器之间的关系。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;守卫会在中间件逻辑之==后==、拦截器/管道之==前==执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;授权守卫&#34;&gt;授权守卫&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, CanActivate, ExecutionContext } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise&amp;lt;boolean&amp;gt; | Observable&amp;lt;boolean&amp;gt; {
    const request = context.switchToHttp().getRequest();
    return validateRequest(request);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;canActivate 返回 true，控制器正常执行，false 请求会被 deny&lt;/p&gt;

&lt;h2 id=&#34;执行上下文&#34;&gt;执行上下文&lt;/h2&gt;

&lt;p&gt;ExecutionContext 不但继承了 ArgumentsHost，还有两个额外方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export interface ExecutionContext extends ArgumentsHost {
  getClass&amp;lt;T = any&amp;gt;(): Type&amp;lt;T&amp;gt;;
  getHandler(): Function;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getHandler() 方法会返回一个将被调用的方法处理器，getClass() 返回处理器对应的控制器类。&lt;/p&gt;

&lt;h2 id=&#34;基于角色的认证&#34;&gt;基于角色的认证&lt;/h2&gt;

&lt;p&gt;我们来实现一个小型的基于角色的认证系统。&lt;/p&gt;

&lt;p&gt;创建一个守卫，先让它返回 true，后面再改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, CanActivate, ExecutionContext } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;

@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise&amp;lt;boolean&amp;gt; | Observable&amp;lt;boolean&amp;gt; {
    return true;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;绑定守卫&#34;&gt;绑定守卫&lt;/h2&gt;

&lt;p&gt;就像过滤器一样，守卫可以是控制器作用域的，也可以是方法作用域或者全局作用域。我们使用 @UseGuards 来引用一个控制器作用域的守卫。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Controller(&#39;cats&#39;)
@UseGuards(RolesGuard)
export class CatsController {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想引用到全局作用域可以调用 useGlobalGuards 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const app = await NestFactory.create(ApplicationModule);
app.useGlobalGuards(new RolesGuard());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们在根模块外层引用了全局守卫，这时守卫无法注入依赖。所以我们还需要在要模块上引入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Module } from &#39;@nestjs/common&#39;;
import { APP_GUARD } from &#39;@nestjs/core&#39;;

@Module({
  providers: [
    {
      provide: APP_GUARD,
      useClass: RolesGuard,
    },
  ],
})
export class ApplicationModule {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;反射&#34;&gt;反射&lt;/h2&gt;

&lt;p&gt;虽然现在已经有了守卫，但是它还没有执行上下文。CatsController 应该有一些需要访问到的权限类型。比如：管理员（admin）角色可以访问、其它角色不可以。&lt;/p&gt;

&lt;p&gt;这时我们需要对控制器（或方法）添加一些&lt;strong&gt;元数据&lt;/strong&gt;，用来标记这个控制器的权限类型。在 Nest 中我们通常使用 @SetMetadata() 装饰器来完成这个工作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@SetMetadata(&#39;roles&#39;, [&#39;admin&#39;])
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码表示给 create 方法设置角色的元数据，用来标识 create 方法只能是 roles 关联的一些角色（admin…）才能访问到的。&lt;/p&gt;

&lt;p&gt;如果你觉得 SetMetadata 这个装饰器看着不是那么见名知意，也可以实现一个自定义的装饰器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { SetMetadata } from &#39;@nestjs/common&#39;;

export const Roles = (...roles: string[]) =&amp;gt; SetMetadata(&#39;roles&#39;, roles);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以用更简洁的方式来声明角色权限关系了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@Roles(&#39;admin&#39;)
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;联合在一起使用&#34;&gt;联合在一起使用&lt;/h2&gt;

&lt;p&gt;我们将使用反射机制来获取控制器上的元数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, CanActivate, ExecutionContext } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;
import { Reflector } from &#39;@nestjs/core&#39;;

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private readonly reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const roles = this.reflector.get&amp;lt;string[]&amp;gt;(&#39;roles&#39;, context.getHandler());
    if (!roles) {
      return true;
    }
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const hasRole = () =&amp;gt; user.roles.some((role) =&amp;gt; roles.includes(role));
    return user &amp;amp;&amp;amp; user.roles &amp;amp;&amp;amp; hasRole();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 canActivate 方法返回 false 时，Nest 将会抛出一个 ForbiddenException 异常。你也可以手动抛出别的异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;throw new UnauthorizedException();
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第八篇：管道）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-8/</link>
      <pubDate>Wed, 03 Jul 2019 18:38:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-8/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/04/5d1dc90b3606425009.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;管道&lt;/strong&gt;（Pipes）是一个用 @Injectable() 装饰过的类，它必须实现 PipeTransform 接口。&lt;/p&gt;

&lt;p&gt;从官方的示意图中我们可以看出来管道 pipe 和过滤器 filter 之间的关系：管道偏向于服务端控制器逻辑，过滤器则更适合用客户端逻辑。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;过滤器在客户端发送请求&lt;strong&gt;==后==&lt;/strong&gt;处理，管道则在控制器接收请求&lt;strong&gt;==前==&lt;/strong&gt;处理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;管道通常有两种作用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;转换/变形&lt;/strong&gt;：转换输入数据为目标格式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;验证&lt;/strong&gt;：对输入数据时行验证，如果合法让数据通过管道，否则抛出异常。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;管道会处理控制器路由的参数，Nest 会在方法调用前插入管道，管道接收发往该方法的参数，此时就会触发上面两种情况。然后路由处理器会接收转换过的参数数据并处理后续逻辑。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;++小提示++：管道会在异常范围内执行，这表示异常处理层可以处理管道异常。如果管道发生了异常，控制器的执行将会&lt;strong&gt;停止&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;内置管道&#34;&gt;内置管道&lt;/h2&gt;

&lt;p&gt;Nest 内置了两种管道：&lt;code&gt;ValidationPipe&lt;/code&gt; 和 &lt;code&gt;ParseIntPipe&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { PipeTransform, Injectable, ArgumentMetadata } from &#39;@nestjs/common&#39;;

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里可能不太好理解，因为我们前面已经在控制器参数上使用了 @body 装饰器，并且使用 TypeScript 的类型声明它为 CreateCatDto，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是 TypeScript 类型是静态的、编译时类型，当编译成 JavaScript 后在运行时并没有任何类型校验。这时我们就需要自己去验证，或者借助第三方工具、库来验证。&lt;/p&gt;

&lt;p&gt;Nest 官方文档在这一节中使用了 &lt;a href=&#34;https://www.npmjs.com/package/@hapi/joi&#34;&gt;joi&lt;/a&gt; 这个验证库。这个验证库的使用需要传入一个 schema，实际上对应着我们的在 Nest 中写的 dto 类型，所以我们只需要给 joi 传入一个 CreateCatDto 类的实例即可。&lt;/p&gt;

&lt;p&gt;首页在 ValidationPipe 管道中添加 joi 的验证功能。验证通过就返回，不通过直接抛出异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Injectable()
export class JoiValidationPipe implements PipeTransform {
  constructor(private readonly schema: Object) {}

  transform(value: any, metadata: ArgumentMetadata) {
    const { error } = Joi.validate(value, this.schema);
    if (error) {
      throw new BadRequestException(SON.stringify(error.details));
    }
    return value;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;绑定管道&#34;&gt;绑定管道&lt;/h2&gt;

&lt;p&gt;管道有了，我们还需要在控制器方法上绑定它。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@UsePipes(new JoiValidationPipe(createCatSchema))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 @UsePipes 修饰器即可，传入管道的实例，并构造 schema。此时我们的应用就可以在运行时通过 schema 去校验参数对象的开头了。createCatSchema 的写法可以参考&lt;a href=&#34;https://github.com/hapijs/joi/blob/v15.1.0/API.md&#34;&gt;相关文档&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const createCatSchema = {
  name: Joi.string().required(),
  age: Joi.number().required(),
  breed: Joi.string().required(),
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如上面的 schema，如果客户端发送的 POST 请求中如果缺少任意参数 Nest 都会捕获到这个异常并返回信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;statusCode&amp;quot;: 400,
    &amp;quot;error&amp;quot;: &amp;quot;Bad Request&amp;quot;,
    &amp;quot;message&amp;quot;: &amp;quot;[{\&amp;quot;message\&amp;quot;:\&amp;quot;\\\&amp;quot;name\\\&amp;quot; is required\&amp;quot;,\&amp;quot;path\&amp;quot;:[\&amp;quot;name\&amp;quot;],\&amp;quot;type\&amp;quot;:\&amp;quot;any.required\&amp;quot;,\&amp;quot;context\&amp;quot;:{\&amp;quot;key\&amp;quot;:\&amp;quot;name\&amp;quot;,\&amp;quot;label\&amp;quot;:\&amp;quot;name\&amp;quot;}}]&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 message 就是我们在管道中传到异常类 BadRequestException 中的参数。&lt;/p&gt;

&lt;h2 id=&#34;类验证器&#34;&gt;类验证器&lt;/h2&gt;

&lt;p&gt;当然上面这种方法看起来没那么优雅，因为毕竟 CreateCatDto 和 createCatSchema 太重复了。Nest 还支持类型验证器，虽然也需要借助于三方库，但是看起来会优雅很多。&lt;/p&gt;

&lt;p&gt;首先，要使用类验证器，你需要先安装 &lt;a href=&#34;https://github.com/pleerock/class-validator&#34;&gt;class-validator&lt;/a&gt; 库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm i --save class-validator class-transformer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;class-validator 可以让你使用给类变量加装饰器的写法给类添加额外的验证功能。这样以来我们就可以直接在原始的 CreateCatDto 类上添加验证装饰器了，这样看起来就整洁多了，而且还没有重复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { IsString, IsInt } from &#39;class-validator&#39;;

export class CreateCatDto {
  @IsString()
  readonly name: string;

  @IsInt()
  readonly age: number;

  @IsString()
  readonly breed: string;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过管道验证器中的代码也需要适配一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { validate } from &#39;class-validator&#39;;
import { plainToClass } from &#39;class-transformer&#39;;

@Injectable()
export class ValidationPipe implements PipeTransform&amp;lt;any&amp;gt; {
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return value;
    }
    const object = plainToClass(metatype, value);
    const errors = await validate(object);
    if (errors.length &amp;gt; 0) {
      throw new BadRequestException(&#39;Validation failed&#39;);
    }
    return value;
  }

  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object];
    return !types.includes(metatype);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这次的 transform 是 async 异步的，因为内部需要用到异步验证方法。Nest 是支持你这么做的，因为管道可以是异步的。&lt;/p&gt;

&lt;p&gt;然后我们可以插入这个管道，位置可以是方法级别的，也可以是参数级别的。&lt;/p&gt;

&lt;p&gt;++参数作用域++&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
async create(
  @Body(new ValidationPipe()) createCatDto: CreateCatDto,
) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;++方法作用域++&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@UsePipes(new ValidationPipe())
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;管道修饰器入参可以是类而不必是管道实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@UsePipes(ValidationPipe)
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样以来将实例化过程留给框架去做并肝启用依赖注入。&lt;/p&gt;

&lt;p&gt;由于 ValidationPipe 被尽可能的泛化，所以它可以直接使用在全局作用域上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async function bootstrap() {
  const app = await NestFactory.create(ApplicationModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3000);
}
bootstrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;转换用例&#34;&gt;转换用例&lt;/h2&gt;

&lt;p&gt;我们还可以用管道来进行数据转换，比如说上面的例子中 age 虽然声明的是 int 类型，但是我们知道 HTTP 请求传递的都是纯字符流，所以通常我们还要把期望传进行类型转换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from &#39;@nestjs/common&#39;;

@Injectable()
export class ParseIntPipe implements PipeTransform&amp;lt;string, number&amp;gt; {
  transform(value: string, metadata: ArgumentMetadata): number {
    const val = parseInt(value, 10);
    if (isNaN(val)) {
      throw new BadRequestException(&#39;Validation failed&#39;);
    }
    return val;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个管道的功能就是强制转换成 Int 类型，如果转换不成功就抛出异常。我们可以针对性的对传入控制器的&lt;strong&gt;某个&lt;/strong&gt;参数插入这个管道：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get(&#39;:id&#39;)
async findOne(@Param(&#39;id&#39;, new ParseIntPipe()) id) {
  return await this.catsService.findOne(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;内置的验证管道&#34;&gt;内置的验证管道&lt;/h2&gt;

&lt;p&gt;比较贴心的是 Nest 已经内置了如上面的例子类似的一些通用验证器，你可以以参数的方式去实例化 ValidationPipe。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@UsePipes(new ValidationPipe({ transform: true }))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ValidationPipe 接收一个 ValidationPipeOptions 类型的参数，并且这个参数继承自 ValidatorOptions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export interface ValidationPipeOptions extends ValidatorOptions {
  transform?: boolean;
  disableErrorMessages?: boolean;
  exceptionFactory?: (errors: ValidationError[]) =&amp;gt; any;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ValidatorOptions 又继承了如下所有 class-validator 的参数：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Option&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;skipMissingProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If set to true, validator will skip validation of all properties that are missing in the validating object.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;whitelist&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If set to true, validator will strip validated (returned) object of any properties that do not use any validation decorators.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;forbidNonWhitelisted&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If set to true, instead of stripping non-whitelisted properties validator will throw an exception.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;forbidUnknownValues&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If set to true, attempts to validate unknown objects fail immediately.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disableErrorMessages&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If set to true, validation errors will not be returned to the client.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;exceptionFactory&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Takes an array of the validation errors and returns an exception object to be thrown.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;groups&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;string[]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Groups to be used during validation of the object.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dismissDefaultMessages&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If set to true, the validation will not use default messages. Error message always will be &lt;code&gt;undefined&lt;/code&gt; if its not explicitly set.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;validationError.target&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Indicates if target should be exposed in &lt;code&gt;ValidationError&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;validationError.value&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Indicates if validated value should be exposed in &lt;code&gt;ValidationError&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第七篇：异常过滤器）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-7/</link>
      <pubDate>Wed, 03 Jul 2019 18:37:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-7/</guid>
      <description>

&lt;p&gt;Nest 框架内部实现了一个异常处理层，专门用来负责应用程序中&lt;strong&gt;未处理&lt;/strong&gt;的异常。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/02/5d1b66de9370734231.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;默认情况未处理的异常会被全局过滤异常器 HttpException 或者它的子类处理。如果一个未识别的异常（非 HttpException 或未继承自 HttpException）被抛出，下面的信息将被返回给客户端：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;statusCode&amp;quot;: 500,
  &amp;quot;message&amp;quot;: &amp;quot;Internal server error&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基础异常&#34;&gt;基础异常&lt;/h2&gt;

&lt;p&gt;我们可以从控制器的方法中手动抛出一个异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get()
async findAll() {
  throw new HttpException(&#39;Forbidden&#39;, HttpStatus.FORBIDDEN);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端将收到如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;statusCode&amp;quot;: 403,
  &amp;quot;message&amp;quot;: &amp;quot;Forbidden&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然你也可以自定义返回状态值和错误信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get()
async findAll() {
  throw new HttpException({
    status: HttpStatus.FORBIDDEN,
    error: &#39;This is a custom message&#39;,
  }, 403);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;异常的级别&#34;&gt;异常的级别&lt;/h2&gt;

&lt;p&gt;比较好的做法是实现你自己想要的异常类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export class ForbiddenException extends HttpException {
  constructor() {
    super(&#39;Forbidden&#39;, HttpStatus.FORBIDDEN);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后你就可以手动在需要的地方抛出它。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get()
async findAll() {
  throw new ForbiddenException();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;http-异常&#34;&gt;HTTP 异常&lt;/h2&gt;

&lt;p&gt;Nest 内置了以下集成自 HttpException 的异常类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;BadRequestException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UnauthorizedException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NotFoundException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ForbiddenException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NotAcceptableException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;RequestTimeoutException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ConflictException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GoneException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PayloadTooLargeException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UnsupportedMediaTypeException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UnprocessableEntityException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;InternalServerErrorException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NotImplementedException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;BadGatewayException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ServiceUnavailableException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GatewayTimeoutException&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;异常过滤器&#34;&gt;异常过滤器&lt;/h2&gt;

&lt;p&gt;如果你想给异常返回值加一些动态的参数，可以使用异常过滤器来实现。例如下面的异常过滤器将会给 HttpException 添加额外的时间缀和路径参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from &#39;@nestjs/common&#39;;
import { Request, Response } from &#39;express&#39;;

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse&amp;lt;Response&amp;gt;();
    const request = ctx.getRequest&amp;lt;Request&amp;gt;();
    const status = exception.getStatus();

    response
      .status(status)
      .json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：所有的异常过滤器都必须实现泛型接口 ExceptionFilter&lt;T&gt;。就是说你必须要提供一个 catch(exception: T, host: ArgumentsHost) 方法&lt;/p&gt;

&lt;h2 id=&#34;参数宿主&#34;&gt;参数宿主&lt;/h2&gt;

&lt;p&gt;上面代码中的 host 参数是一个类型为 ArgumentsHost 的原生请求处理器包装对象。根据应用程序的不同它具有不同的接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export interface ArgumentsHost {
  getArgs&amp;lt;T extends Array&amp;lt;any&amp;gt; = any[]&amp;gt;(): T;
  getArgByIndex&amp;lt;T = any&amp;gt;(index: number): T;
  switchToRpc(): RpcArgumentsHost;
  switchToHttp(): HttpArgumentsHost;
  switchToWs(): WsArgumentsHost;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;绑定过滤器&#34;&gt;绑定过滤器&lt;/h2&gt;

&lt;p&gt;可以使用 @UseFilters 装饰器让一个控制器方法具有过滤器处理逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@UseFilters(HttpExceptionFilter)
async create(@Body() createCatDto: CreateCatDto) {
  throw new ForbiddenException();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然过滤器可以被使用在不同的作用域上：&lt;strong&gt;方法作用域、控制器作用域、全局作用域&lt;/strong&gt;。比如应用一个控制器作用域的过滤器，可以这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@UseFilters(new HttpExceptionFilter())
export class CatsController {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全局过滤器可以通过如下代码实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async function bootstrap() {
  const app = await NestFactory.create(ApplicationModule);
  app.useGlobalFilters(new HttpExceptionFilter());
  await app.listen(3000);
}
bootstrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过这样注册的全局过滤器无法进入依赖注入，因为它在模块作用域之外。为了解决这个问题，你可以在根模块上面注册一个全局作用域的过滤器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Module } from &#39;@nestjs/common&#39;;
import { APP_FILTER } from &#39;@nestjs/core&#39;;

@Module({
  providers: [
    {
      provide: APP_FILTER,
      useClass: HttpExceptionFilter,
    },
  ],
})
export class ApplicationModule {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;捕获所有异常&#34;&gt;捕获所有异常&lt;/h2&gt;

&lt;p&gt;@Catch() 装饰器不传入参数就默认捕获所有的异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus } from &#39;@nestjs/common&#39;;

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    const status = exception instanceof HttpException
      ? exception.getStatus()
      : HttpStatus.INTERNAL_SERVER_ERROR;

    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;

&lt;p&gt;通常你可能并不需要自己实现完全定制化的异常过滤器，可以继承自 BaseExceptionFilter 即可复用内置的过滤器逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Catch, ArgumentsHost } from &#39;@nestjs/common&#39;;
import { BaseExceptionFilter } from &#39;@nestjs/core&#39;;

@Catch()
export class AllExceptionsFilter extends BaseExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    super.catch(exception, host);
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第六篇：中间件）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-6/</link>
      <pubDate>Wed, 03 Jul 2019 18:36:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-6/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;中间件&lt;/strong&gt;就是一个函数，在路由处理器之前调用。这就表示中间件函数可以访问到请求和响应对象以及应用的请求响应周期中的 next() 中间间函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/01/5d19e2f1938ef39341.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nest 中间件实际上和 Express 的中间件是一样的，Express 文档中对中间件的描述如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;中间件函数主要做以下的事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行任意的代码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对请求/响应做操作&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;终结请求-响应周期&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用下一个栈中的中间件函数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果当前的中间间函数没有终结请求响应周期，那么它必须调用 next() 方法将控制权传递给下一个中间件函数。否则请求将被挂起&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nest 允许你使用函数或者类来实现自己的中间件。如果用类实现，则需要使用 &lt;code&gt;@Injectable()&lt;/code&gt; 装饰，并且实现 &lt;code&gt;NestMiddleware&lt;/code&gt; 接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, NestMiddleware } from &#39;@nestjs/common&#39;;
import { Request, Response } from &#39;express&#39;;

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: Function) {
    console.log(&#39;Request...&#39;);
    next();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;依赖注入&#34;&gt;依赖注入&lt;/h2&gt;

&lt;p&gt;中间件也是支持依赖注入的，就像其它支持方式一样，你可以使用构造函数注入依赖。&lt;/p&gt;

&lt;h2 id=&#34;应用中间件&#34;&gt;应用中间件&lt;/h2&gt;

&lt;p&gt;@Module() 装饰器中并不能指定中间件参数，我们可以在模块类的构 configure() 方法中应用中间件，下面的代码会应用一个 ApplicationModule级别的日志中间件 LoggerMiddleware&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Module({
  imports: [CatsModule],
})
export class ApplicationModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes(&#39;cats&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码 forRoutes 方法表示只将中间件应用在 cats 路由上，还可以是指定的 HTTP 方法，甚至是路由通配符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.forRoutes({ path: &#39;cats&#39;, method: RequestMethod.GET });
.forRoutes({ path: &#39;ab*cd&#39;, method: RequestMethod.ALL });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你也可以指定不包括某些路由规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;consumer
  .apply(LoggerMiddleware)
  .exclude(
    { path: &#39;cats&#39;, method: RequestMethod.GET },
    { path: &#39;cats&#39;, method: RequestMethod.POST }
  )
  .forRoutes(CatsController);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过请注意 exclude 方法不能运用在函数式的中间件上，而且这里指定的 path 也不支持通配符，这只是个快捷方法，如果你真的需要某种路由级别的控制，那完全可以把逻辑写在一个单独的中间件中。&lt;/p&gt;

&lt;h2 id=&#34;函数式的中间件&#34;&gt;函数式的中间件&lt;/h2&gt;

&lt;p&gt;函数式的中间件可以用一个简单无依赖函数来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export function logger(req, res, next) {
  console.log(`Request...`);
  next();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;多个中间件&#34;&gt;多个中间件&lt;/h2&gt;

&lt;p&gt;apply 方法传入多个中间件参数即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;consumer.apply(cors(), helmet(), logger)
.forRoutes(CatsController);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;全局中间件&#34;&gt;全局中间件&lt;/h2&gt;

&lt;p&gt;在实现了 INestApplication 接口的实例上调用 use() 方法即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const app = await NestFactory.create(ApplicationModule);
app.use(logger);
await app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第五篇：模块）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-5/</link>
      <pubDate>Wed, 03 Jul 2019 18:35:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-5/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;模块&lt;/strong&gt;（Module）是一个使用了 @Module() 装饰的类。@Module() 装饰器提供了一些 Nest 需要使用的元数据，用来组织应用程序的结构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/01/5d19d7a33690e19033.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每个应用都至少有一个根模块，根模块就是 Nest 应用的入口。Nest 会从这里查找出整个应用的依赖/调用&lt;a href=&#34;https://en.wikipedia.org/wiki/Graph_(abstract_data_type)&#34;&gt;图&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;@Module() 装饰器接收一个参数对象，有以下取值：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;providers&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;可以被 Nest 的注入器初始化的 providers，至少会在此模块中共享&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;controllers&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;这个模块需要用到的控制器集合&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;imports&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;引入的其它模块集合&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;exports&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此模块提供的 providers 的子集，其它模块引入此模块时可用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;模块默认会封装 providers，如果要在不同模块之间共享 provider 可以在 exports 参数中指定。&lt;/p&gt;

&lt;h2 id=&#34;功能模块&#34;&gt;功能模块&lt;/h2&gt;

&lt;p&gt;使用下面的代码可以将相关的控制器和 Service 包装成一个模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Module } from &#39;@nestjs/common&#39;;
import { CatsController } from &#39;./cats.controller&#39;;
import { CatsService } from &#39;./cats.service&#39;;

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;++小提示++：也可以使用 CLI 来自动生成模块：$ nest g module cats&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样我们就完成了一个模块的封装。&lt;/p&gt;

&lt;h2 id=&#34;共享的模块&#34;&gt;共享的模块&lt;/h2&gt;

&lt;p&gt;在 Nest 中模块默认是单例的，因此你可在不同的模块之间共享任意 Provider 实例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/01/5d19dd669f9c560755.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;模块都是共享的，我们可以通过导出当前模块的指定 Service 来实现其它模块对 Service 的复用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Module } from &#39;@nestjs/common&#39;;
import { CatsController } from &#39;./cats.controller&#39;;
import { CatsService } from &#39;./cats.service&#39;;

@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService] // 导出
})
export class CatsModule {} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;模块的重复导出&#34;&gt;模块的重复导出&lt;/h2&gt;

&lt;p&gt;给模块包装一层即可实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Module({
  imports: [CommonModule],
  exports: [CommonModule],
})
export class CoreModule {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;依赖注入&#34;&gt;依赖注入&lt;/h2&gt;

&lt;p&gt;模块的构造函数中也可以注入指定的 providers，通常用在一些配置参数场景。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {
  constructor(private readonly catsService: CatsService) {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是模块类本身并不可以装饰成 provider，因为这会造成循环依赖&lt;/p&gt;

&lt;h2 id=&#34;全局模块&#34;&gt;全局模块&lt;/h2&gt;

&lt;p&gt;当一些模块在你的应用频繁使用时，可以使用全局模块来避免每次都要调用的问题。Angular 会把 provider 注册到全局作用域上，然而 Nest 会默认将 provider 注册到&lt;strong&gt;模块作用域&lt;/strong&gt;上。如果你没有显示的导出模块的 provider，那么其它地方就无法使用它。&lt;/p&gt;

&lt;p&gt;如果你想让一个模块随处可见，那就使用 @Global() 装饰器来装饰这个模块。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Global()
@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@Global() 装饰器可以让模块获得&lt;strong&gt;全局&lt;/strong&gt;作用域&lt;/p&gt;

&lt;h3 id=&#34;动态模块&#34;&gt;动态模块&lt;/h3&gt;

&lt;p&gt;Nest 模块系统支持&lt;strong&gt;动态模块&lt;/strong&gt;的功能，这将让自定义模块的开发变得容易。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Module, DynamicModule } from &#39;@nestjs/common&#39;;
import { createDatabaseProviders } from &#39;./database.providers&#39;;
import { Connection } from &#39;./connection.provider&#39;;

@Module({
  providers: [Connection],
})
export class DatabaseModule {
  static forRoot(entities = [], options?): DynamicModule {
    const providers = createDatabaseProviders(options, entities);
    return {
      module: DatabaseModule,
      providers: providers,
      exports: providers,
    };
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模块的静态方法 forRoot 返回一个动态模块，可以是同步或者异步模块。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第四篇：Providers）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-4/</link>
      <pubDate>Wed, 03 Jul 2019 18:34:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-4/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Provider&lt;/strong&gt; 主要的设计理念来自于&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC&#34;&gt;控制反转&lt;/a&gt;（Inversion of Control，简称 IOC&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:-&#34;&gt;&lt;a href=&#34;#fn:-&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; ）模式中的依赖注入（Dependency Injection）特性。使用 &lt;code&gt;@Injectable()&lt;/code&gt; 装饰的类就是一个 Provider，装饰器方法会优先于类被解析执行。&lt;/p&gt;

&lt;p&gt;到这里我们应该要了解整个 Nest 框架的三层结构，Nest 和传统的 MVC 框架的区别在于它更注重于后端部分（控制器、服务与数据）的架构，视图层相对比较独立，完全可以由用户自定义配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/01/5d19aa5c9532744345.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nest 的分层借鉴自 Spring，更细化。随着代码库的增长 MVC 模式中 Modal 和 Controller 会变得含糊不清，导致难于维护。&lt;/p&gt;

&lt;h3 id=&#34;services&#34;&gt;Services&lt;/h3&gt;

&lt;p&gt;我们可以自己实现一个名叫 &lt;code&gt;CatsService&lt;/code&gt; 的 Service&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export interface Cat {
  name: string;
  age: number;
  breed: string;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable } from &#39;@nestjs/common&#39;;
import { Cat } from &#39;./interfaces/cat.interface&#39;;

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  create(cat: Cat) {
    this.cats.push(cat);
  }

  findAll(): Cat[] {
    return this.cats;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;++小提示++：也可以使用 CLI 工具自动生成一个 Service $ nest g service cats&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有了 Service 我们就可以在控制器中注入并引用到它了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Controller(&#39;cats&#39;)
export class CatsController {
  constructor(private readonly catsService: CatsService) {}
  // 等同于
  private readonly catsService: CatsService
  constructor(catsService: CatsService) {
    this.catsService = catsService
  }

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise&amp;lt;Cat[]&amp;gt; {
    return this.catsService.findAll();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依赖注入的很多种方法，Nest 使用了构建函数注入的方式，看起来非常直观。这个时候我们就可以发现 Nest 的优点了，至少你能发现 Controller 和 Service 处于完全解耦的状态：Controller 做的事情仅仅是接收请求，并在合适的时候调用到 Service，至于 Service 内部怎么实现的 Controller 完全不在乎。&lt;/p&gt;

&lt;p&gt;这样以来有两个好处：其一，Controller 和 Service 的职责边界很清晰，不存在灰色地带；其二，各自只关注自身职责涉及的功能，比方说 Service 通常来写业务逻辑，但它也仅仅只与业务相关。当然你可能会觉得这很理想，时间长了增加了诸如缓存、验证等逻辑后，代码最终会变得无比庞大而难于维护。事实上这也是一个框架应该考虑和抽象出来的，后续 Nest 会有一系列的解决方法，但目前为至我们只需要了解到 Controller 和 Service 的设计原理即可。&lt;/p&gt;

&lt;h3 id=&#34;依赖注入&#34;&gt;依赖注入&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;constructor(private readonly catsService: CatsService) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得益于 TypeScript 类型，Nest 可以通过 CatsService 类型查找到 catsService，依赖被查找并传入到控制器的构造函数中。&lt;/p&gt;

&lt;p&gt;通常我们在没有依赖注入的时候如果 A 依赖于 B，那么在 A 初始化或者执行中的某个过程需要先创建 B，这时我们就认为 A 对 B 的依赖是&lt;strong&gt;正向&lt;/strong&gt;的。但是这样解决依赖的办法会得得 A 与 B 的逻辑耦合在一起，依赖越来越多代码就会变的越来越糟糕。如下图所示，齿轮之间是相互依赖的，一损俱损。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/01/5d19b545530fe73281.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;控制反转（IOC）模式就是要解决这个问题，它会多引入一个容器（Container）的概念，让一个 IOC 容器去管理 A、B 的依赖并初始化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/01/5d19b570db26721361.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当我们去掉容器时，剩下的齿轮成了一个个独立的功能模块。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/01/5d19b5db066fa32957.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;注入作用域&#34;&gt;注入作用域&lt;/h3&gt;

&lt;p&gt;Providers 有一个和应用程序一样的生命周期。当应用启动，每个依赖都必须被获取到。将会有单独的一章来讲解注入作用域&lt;/p&gt;

&lt;h3 id=&#34;自定义的-providers&#34;&gt;自定义的 Providers&lt;/h3&gt;

&lt;p&gt;Nest 有一个内置的 IOC 容器，用来解析 Providers 之间的关系。这个功能相对于 DI 来讲更底层，但是功能却异常强大，@Injectable() 只是冰山一角。事实上，你可以使用值，类和同步或者异步的工厂。&lt;/p&gt;

&lt;h3 id=&#34;可选的-providers&#34;&gt;可选的 Providers&lt;/h3&gt;

&lt;p&gt;有时候，你可以会需要一个依赖，但是这个依赖并不需要一定被容器解析出来。比如我们通常会传入一个配置对象，但是如果不传会使用一个默认值代替。可以使用 &lt;code&gt;@Optional()&lt;/code&gt; 来装饰一个非必选的参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Injectable()
export class HttpService&amp;lt;T&amp;gt; {
  constructor(
    @Optional() 
    @Inject(&#39;HTTP_OPTIONS&#39;) 
    private readonly httpClient: T
  ) {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基于属性的注入&#34;&gt;基于属性的注入&lt;/h3&gt;

&lt;p&gt;前面我们提过了 Nest 实现注入是基于类的构造函数的，但是在一些特殊情况下，基于属性的注入会特别有用。&lt;/p&gt;

&lt;p&gt;比如一个顶层的类依赖一个或多个 Providers 时，通过在子类的构造函数中调用 super() 方法并不是很优雅，为了避免这种情况我们可以在属性上使用 @Inject() 装饰器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Injectable()
export class HttpService&amp;lt;T&amp;gt; {
  @Inject(&#39;HTTP_OPTIONS&#39;)
  private readonly httpClient: T;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;++警告++：如果你的类并没有继承其它 Provider，那么一定要使用基于构造函数注入方式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;注册-provider&#34;&gt;注册 Provider&lt;/h3&gt;

&lt;p&gt;一般来讲控制器就是 Service 的消费（使用）者，我们需要将这些 Service 注册到 Nest 上，这样就可以让 Nest 帮你完成注入操作。通常我们会使用 @Module 装饰器来完成注册的过程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Module } from &#39;@nestjs/common&#39;;
import { CatsController } from &#39;./cats/cats.controller&#39;;
import { CatsService } from &#39;./cats/cats.service&#39;;

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class ApplicationModule {}
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:-&#34;&gt;控制反转 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:-&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>