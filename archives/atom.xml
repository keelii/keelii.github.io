<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Archives on Something</title>
    <link>https://keelii.com/archives/</link>
    <description>Recent content in Archives on Something</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 26 Aug 2018 17:59:45 +0800</lastBuildDate>
    
        <atom:link href="https://keelii.com/archives/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>VIM 代码片段插件 ultisnips 使用教程</title>
      <link>https://keelii.com/2018/08/26/vim-plugin-ultisnips-advanced-tips/</link>
      <pubDate>Sun, 26 Aug 2018 17:59:45 +0800</pubDate>
      
      <guid>https://keelii.com/2018/08/26/vim-plugin-ultisnips-advanced-tips/</guid>
      <description>

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/SirVer/ultisnips&#34;&gt;Ultisnips&lt;/a&gt; 插件安装分两部分，一个是 ultisnips 插件本身，另外一个是代码片段仓库。一般来说把默认的代码片段仓库下载下来按需修改后上传到自己的 github 即可。如果你和我一样也使用 vim-plug 来管理插件的话，添加下面的代码到你的 vimrc 中保存刷新即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Plug &#39;SirVer/ultisnips&#39;
# 你自己的代码仓库 git 地址
Plug &#39;keelii/vim-snippets&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的示例中所有的代码片段都存放在插件安装目录下面的 &lt;code&gt;vim-snippets/UltiSnips&lt;/code&gt; 中，文件命名格式为 &lt;code&gt;ft&lt;/code&gt;.snippets, &lt;code&gt;ft&lt;/code&gt; 就是 vim 中的 &lt;code&gt;filetype&lt;/code&gt;，其中有个 &lt;code&gt;all.snippets&lt;/code&gt; 是唯一一个所有文件都适用的代码片段&lt;/p&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;p&gt;快捷键设置，我一般使用 tab 来触发代码片段补全，&lt;strong&gt;且不使用 YCM&lt;/strong&gt; （官方文档表示使用YCM的话就不能使用tab补全）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;let g:UltiSnipsExpandTrigger=&amp;quot;&amp;lt;tab&amp;gt;&amp;quot;
&amp;quot; 使用 tab 切换下一个触发点，shit+tab 上一个触发点
let g:UltiSnipsJumpForwardTrigger=&amp;quot;&amp;lt;tab&amp;gt;&amp;quot;
let g:UltiSnipsJumpBackwardTrigger=&amp;quot;&amp;lt;S-tab&amp;gt;&amp;quot;
&amp;quot; 使用 UltiSnipsEdit 命令时垂直分割屏幕
let g:UltiSnipsEditSplit=&amp;quot;vertical&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;依赖&#34;&gt;依赖&lt;/h2&gt;

&lt;p&gt;ultisnips 插件需要你的 vim 支持 python，可以在 vim 命令模式下使用下面的检测你的 vim 版本是否支持 python&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 1 表示支持
:echo has(&amp;quot;python&amp;quot;)
:echo has(&amp;quot;python3&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;定义一个代码片段&#34;&gt;定义一个代码片段&lt;/h2&gt;

&lt;h3 id=&#34;定义格式&#34;&gt;定义格式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;snippet 触发字符 [&amp;quot;代码片段说明&amp;quot; [参数]]
代码片段内容
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;最小化的一个代码片段&#34;&gt;最小化的一个代码片段&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;snippet if &amp;quot;if (condition) { ... }&amp;quot;
if (${1:true}) {
    $0
}
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时当你在 vim 中输入 if 敲 tab 就会展开一条 if 语句，第一个触发点是 if 条件表达式，最后一个是 if 语句体&lt;/p&gt;

&lt;p&gt;&lt;code&gt;${1:true}&lt;/code&gt; 表示这是第一个触发点，占位符为 &lt;code&gt;true&lt;/code&gt;，如果占位符没有默认值可直接使用 &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;可视选择区的内容为占位符&#34;&gt;可视选择区的内容为占位符&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;snippet if &amp;quot;if (...)&amp;quot;
if (${1:true}) {
    ${VISUAL}
}
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;${VISUAL}&lt;/code&gt; 表示在 vim 中使用可视模式下选择的文本，这个在重构代码的时候&lt;strong&gt;非常有用&lt;/strong&gt;（后面会有高级用法），上个图感受一下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t25252/299/1019207883/36468/bca93de/5b84a8a9N8dd5a8c5.gif&#34; alt=&#34;if-with-visual-mode&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;代码片段的参数&#34;&gt;代码片段的参数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 表示触发字符应该在一行的开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; 表示触发字符可以在单词内（连续展示会使用这个选项）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; 表示触发字符的前后必须是一个字母分界点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 表示触发字符可以是一个正则表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; 表示展开的代码片段中如果有制表符，原样输出，即使你的 vimrc 里面设置了 expandtab&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; 表示删除代码片段右边的所有空白字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e&lt;/code&gt; 表示自定义上下文&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 表示自动触发，不需要按 tab，类似于 VIM 中的 abbr&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内容解释器&#34;&gt;内容解释器&lt;/h2&gt;

&lt;p&gt;Ultisnips 定义的代码片段中支持三种不同的语言注入：shell, vimscript, python，在代码片段中用反引号表示&lt;/p&gt;

&lt;h2 id=&#34;shell-代码&#34;&gt;shell 代码&lt;/h2&gt;

&lt;p&gt;就是在你的命令行 shell 能执行的代码片段，比如输出当前时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜ date
2018年 8月27日 星期一 18时19分38秒 CST
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码片段中用反引号「`」引用即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;snippet today
Today is the `date`.
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入 today 按 tab 展开后（格式和上面shell中的不一样，估计是因为 vim 语言设置的问题）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Today is the Mon Aug 27 18:24:51 CST 2018.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;vimscript-代码&#34;&gt;vimscript 代码&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;indent&lt;/code&gt; 来输出当前缩进值，使用前缀 &lt;code&gt;!v&lt;/code&gt; 表示是 vimscript&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;snippet indent
Indent is: `!v indent(&amp;quot;.&amp;quot;)`.
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;//img12.360buyimg.com/devfe/jfs/t23467/4/2565317844/22166/a39566b/5b84a97fNa6174311.gif&#34; alt=&#34;vimscript-indent-size&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;python-代码&#34;&gt;python 代码&lt;/h3&gt;

&lt;p&gt;在代码片段中解释执行 python 代码是 ultisnips 最强大的功能，以前缀 &lt;code&gt;!p&lt;/code&gt; 开始。系统会向 python 中注入一些变量，可以使用 python 代码直接对其进行操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fn&lt;/code&gt; - 表示当前文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt; -  当前文件名的路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; - 占位符的字典，可以使用 &lt;code&gt;t[1], t[2], t.v&lt;/code&gt; 来取占位符内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snip&lt;/code&gt; - &lt;a href=&#34;https://github.com/SirVer/ultisnips/blob/6fdc3647f72e0a1f321ea6bd092ecd01f7c187ba/pythonx/UltiSnips/text_objects/_python_code.py#L56&#34;&gt;UltiSnips.TextObjects.SnippetUtil&lt;/a&gt; 对象的一个实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;match&lt;/code&gt; - 正则代码片段时返回的匹配元素（非常强大）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中最常用的 &lt;code&gt;snip&lt;/code&gt; 对象提供了下面一些变量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;snip.rv&lt;/code&gt; 表示 return value，python 代码执行后处理过的字符串赋给 rv 即可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snip.fn&lt;/code&gt; 表示当前文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snip.ft&lt;/code&gt; 表示当前文件类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snip.v&lt;/code&gt; 表示 VISUAL 模式变量，其中 &lt;code&gt;snip.v.mode&lt;/code&gt; 表示模式类型，&lt;code&gt;snip.v.text&lt;/code&gt; 表示 VISUAL 模式中选择的字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t27739/311/103185395/173892/d6a786e3/5b84af90Nfa6cd193.gif&#34; alt=&#34;python-snippet-var&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;占位符选择&#34;&gt;占位符选择&lt;/h2&gt;

&lt;p&gt;UltiSnips 支持使用快捷键切换占位符，我使用 &lt;code&gt;&amp;lt;tab&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;shift-tab&amp;gt;&lt;/code&gt; 来切换 &lt;code&gt;下一个&lt;/code&gt; 和 &lt;code&gt;上一个&lt;/code&gt; 占位符，占位符切换的作用域为当前代码片段内部（即使占位符已被修改过），当光标移动出去以后就不起作用了&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img12.360buyimg.com/devfe/jfs/t24559/158/2571218888/171431/2459a91d/5b84bf9aN96a7ee7e.gif&#34; alt=&#34;mul-placeholder-editing&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;自定义上下文&#34;&gt;自定义上下文&lt;/h2&gt;

&lt;p&gt;自定义上下文可以通过正则匹配来决定代码片断是否可用，比如判断在指定的 if 语句里面才起作用的代码片断，定义格式如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;snippet 触发字符 &amp;ldquo;描述&amp;rdquo; &amp;ldquo;表达式&amp;rdquo; 参数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比如我们定义一个 &lt;strong&gt;只有&lt;/strong&gt; 在上一行以 &lt;code&gt;if (DEVELOPMENT) {&lt;/code&gt; 开头才可以展开的代码片段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;snippet dbg &amp;quot;if (DEVELOPMENT) dbg&amp;quot; &amp;quot;re.match(&#39;^if \(DEVELOPMENT\) \{&#39;, snip.buffer[snip.line-1])&amp;quot; be
debugger;
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常见用法&#34;&gt;常见用法&lt;/h2&gt;

&lt;h3 id=&#34;行内连续展开&#34;&gt;行内连续展开&lt;/h3&gt;

&lt;p&gt;这个常见于需要连续展开代码片段的情况，比如，有两个片段，一个打印变量，一个处理 JSON 序列化。这时需要使用参数选项 &lt;code&gt;i&lt;/code&gt;n-word&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t25579/50/1036526670/419976/53521e3b/5b84c7d2Nd6a0cb5e.gif&#34; alt=&#34;continue-expand-snippets&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用正则代码片段&#34;&gt;使用正则代码片段&lt;/h3&gt;

&lt;p&gt;通常写代码的时候需要使用 log, print 等来打印上下文中的变量。使用普通片段按 cl 展示 console.log() 然后把变量字符复制进括号，这样操作会比较复杂。使用正则来动态匹配前面的字符可以很好的解决这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;# 展开 console.log
snippet &amp;quot;([^\s]\w+)\.log&amp;quot; &amp;quot;console.log(postfix)&amp;quot; r
console.log(`!p snip.rv = match.group(1)`)$0
endsnippet
# 当前行转换成大写
snippet &amp;quot;([^\s].*)\.upper&amp;quot; &amp;quot;Uppercase(postfix)&amp;quot; r
`!p snip.rv = match.group(1).upper()`$0
endsnippet
# 上一个单词转换成小写
snippet &amp;quot;([^\s]\w+)\.lower&amp;quot; &amp;quot;Lowercase(postfix)&amp;quot; r
`!p snip.rv = match.group(1).lower()`$0
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动图演示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t25492/223/971280921/61984/701b0ab1/5b84cc6aN6fe8ea04.gif&#34; alt=&#34;expand-regexp-snippets&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：正则代码片段只适用于单行文本处理，如果是多行转换还是得用到下面的 python + VISUAL 代码片段来处理&lt;/p&gt;

&lt;h3 id=&#34;使用-python-解释器-visual-模式实现代码注释功能&#34;&gt;使用 python 解释器 + VISUAL 模式实现代码注释功能&lt;/h3&gt;

&lt;p&gt;通常我们需要使用一大堆插件来实现各种代码的注释功能。不过 Ultisnips 提供了 VISUAL 模式可以提取 vim 可视模式中选择的内容到代码片段里面，于是我们就可以结合起来制作一个&lt;strong&gt;具有注释功能的代码片段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流程大概是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;进入 vim 可视模式，选择要注释的内容&lt;/li&gt;
&lt;li&gt;按 tab，清除选择内容&lt;/li&gt;
&lt;li&gt;输入代码片段触发字符，按 tab 完成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于实现的 python 代码相对复杂一些，主要分成两个方法。单行注释和多行注释，注意 Ultisnips 中可以直接写 python 但是大段的方法建议放在插件目录下面的 pythonx 目录下面，使用的时候在对应的代码片段中的全局 python 代码 &lt;code&gt;global !p&lt;/code&gt; 引入即可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单行注释&lt;/strong&gt;(pythonx/javascript_snippets.py)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def comment(snip, START=&amp;quot;&amp;quot;, END=&amp;quot;&amp;quot;):
    lines = snip.v.text.split(&#39;\n&#39;)[:-1]
    first_line = lines[0]
    spaces = &#39;&#39;
    initial_indent = snip._initial_indent

    # Get the first non-empty line
    for idx, l in enumerate(lines):
        if l.strip() != &#39;&#39;:
            first_line = lines[idx]
            sp = re.findall(r&#39;^\s+&#39;, first_line)
            if len(sp):
                spaces = sp[0]
            break            

    # Uncomment
    if first_line.strip().startswith(START):
        result = [line.replace(START, &amp;quot;&amp;quot;, 1).replace(END, &amp;quot;&amp;quot;, 1) if line.strip() else line for line in lines]
    else:
        result = [f&#39;{spaces}{START}{line[len(spaces):]}{END}&#39; if line.strip() else line for line in lines ]

    # Remove initial indent
    if result[0] and initial_indent:
        result[0] = result[0].replace(initial_indent, &#39;&#39;, 1)

    if result:
        return &#39;\n&#39;.join(result)
    else:
        return &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;多行注释：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def comment_inline(snip, START=&amp;quot;/* &amp;quot;, END=&amp;quot; */&amp;quot;):
    text = snip.v.text
    lines = text.split(&#39;\n&#39;)[:-1]
    first_line = lines[0]
    initial_indent = snip._initial_indent
    spaces = &#39;&#39;

    # Get the first non-empty line
    for idx, l in enumerate(lines):
        if l.strip() != &#39;&#39;:
            first_line = lines[idx]
            sp = re.findall(r&#39;^\s+&#39;, first_line)
            if len(sp):
                spaces = sp[0]
            break            

    if text.strip().startswith(START):
        result = text.replace(START, &#39;&#39;, 1).replace(END, &#39;&#39;, 1)
    else:
        result = text.replace(spaces, spaces + START, 1).rstrip(&#39;\n&#39;) + END + &#39;\n&#39;

    if initial_indent:
        result = result.replace(initial_indent, &#39;&#39;, 1)

    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;代码片段定义：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;global !p
from javascript_snippets import (
	comment, comment_inline
)
endglobal

# ...

snippet c &amp;quot;Toggle comment every single line&amp;quot;
`!p
snip.rv = comment(snip, START=&#39;// &#39;, END=&#39;&#39;)
`$0
endsnippet

snippet ci &amp;quot;Toggle comment inline.&amp;quot;
`!p
snip.rv = comment_inline(snip, START=&amp;quot;/* &amp;quot;, END=&amp;quot; */&amp;quot;)
`$0
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动图演示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t24175/330/2554434390/319822/5d8cf724/5b850d67N4c475946.gif&#34; alt=&#34;python-snippets-to-comment&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不同的语言可以在对应的片段文件中定义并传入注释符号参数即可，有了这个功能就可以愉快的删除其它的 vim 注释插件了 😀&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fuzzy finder(fzf&#43;vim) 使用全指南</title>
      <link>https://keelii.com/2018/08/12/fuzzy-finder-full-guide/</link>
      <pubDate>Sun, 12 Aug 2018 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2018/08/12/fuzzy-finder-full-guide/</guid>
      <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;Fuzzy finder&lt;/a&gt; 是一款使用 GO 语言编写的交互式的 Unix 命令行工具。可以用来查找任何 &lt;strong&gt;列表&lt;/strong&gt; 内容，文件、Git 分支、进程等。所有的命令行工具可以生成列表输出的都可以再通过管道 pipe 到 fzf 上进行搜索和查找&lt;/p&gt;

&lt;h2 id=&#34;优点&#34;&gt;优点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GO 语言编写，编译完生成可执行文件没有任何依赖&lt;/li&gt;
&lt;li&gt;搜索/查找速度飞快&lt;/li&gt;
&lt;li&gt;功能全面/可视化界面体验很棒&lt;/li&gt;
&lt;li&gt;周边插件丰富 (vim, tmux, fuzzy auto-completion)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;以 macOS 为例子，直接使用 homebrew 安装即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install fzf
# 如果要使用内置的快捷键绑定和命令行自动完成功能的话可以按需安装
$(brew --prefix)/opt/fzf/install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;命令行下执行 &lt;code&gt;fzf&lt;/code&gt; 即可展示当前目录下所有文件列表，可以用键盘上下键或者鼠标点出来选择
&lt;a href=&#34;https://img10.360buyimg.com/devfe/jfs/t26002/277/432949068/59208/9725245b/5b6fc71fN03036763.png&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t26002/277/432949068/59208/9725245b/5b6fc71fN03036763.png&#34; alt=&#34;fzf-normal&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;或许你会觉得这个查找提示看起来挺漂亮的，但是并没有什么卵用，因为查找出来就没有然后了。其实这也是 Fuzzy finder 最核心的地方，他只是一个通用的下拉查找功能，自己本身并不关心你用它来做什么，通常我们需要组合使用才会有很好的效果&lt;/p&gt;

&lt;h3 id=&#34;用-vim-打开文件&#34;&gt;用 vim 打开文件&lt;/h3&gt;

&lt;p&gt;比如我们用 vim 组合 fzf 来查找并打开目录下的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim $(fzf)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t25372/5/461999989/83158/3ce44a5/5b6fc7f2Nd6432499.gif&#34; alt=&#34;fzf-vim&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;切换当前工作目录&#34;&gt;切换当前工作目录&lt;/h3&gt;

&lt;p&gt;再比如进入到某个文件夹下面，使用 fzf 的过滤选择真是太方便了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd $(find * -type d | fzf)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是个组合 (cd+find+fzf) 命令，完成切换到任意子目录的功能。可以看出来当 fzf 和其它命令组合使用时就能使得一些操作更方便：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用 find 命令找出所有的子目录&lt;/li&gt;
&lt;li&gt;把子目录列表 pipe 到 fzf 上进行选择&lt;/li&gt;
&lt;li&gt;再把结果以子命令的形式传给 cd&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t23848/96/1951894215/50884/20a513d7/5b6fcabbNb77c46d5.gif&#34; alt=&#34;fzf-find-cd&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;切换-git-分支&#34;&gt;切换 git 分支&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout $(git branch -r | fzf)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t23242/262/2000817850/127859/c0955478/5b6fce70N3c3573ae.gif&#34; alt=&#34;fzf-git-branch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不过这样组合使用命令的实在太长了，如果你不使用自动补全的话巧起来很累的。建议把常用的 alias 放在 .zshrc 中管理嘛&lt;/p&gt;

&lt;h3 id=&#34;shell-命令行补全&#34;&gt;shell 命令行补全&lt;/h3&gt;

&lt;p&gt;fzf 默认使用 &lt;code&gt;**&lt;/code&gt; 来补全 shell 命令，比起默认的 tab 补全，fzf 补全不知道高到哪里去了。cd, vim, kill, ssh, export&amp;hellip; 统统都能补全，好用哭了 🤣&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t24820/280/435378103/490486/3777afba/5b6fedc6N59529380.gif&#34; alt=&#34;fzf-completion&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;p&gt;fzf 提供了两个 &lt;em&gt;环境变量&lt;/em&gt; 配置参数，来分别设置默认的调用命令和 fzf 默认配置参数&lt;/p&gt;

&lt;h3 id=&#34;核心命令-fzf-default-command&#34;&gt;核心命令 FZF_DEFAULT_COMMAND&lt;/h3&gt;

&lt;p&gt;对于使用 fzf 来查找文件的情况，fzf 其实底层是调用的 Unix 系统 &lt;code&gt;find&lt;/code&gt; 命令，如果你觉得 find 不好用也可以使用其它查找文件的命令行工具「我使用 &lt;a href=&#34;https://github.com/sharkdp/fd&#34;&gt;fd&lt;/a&gt;」。注意：对原始命令添加一些参数应该在这个环境变量里面添加&lt;/p&gt;

&lt;p&gt;比如说我们一般都会查找文件 &lt;code&gt;-type f&lt;/code&gt;，通常会忽略一些文件夹/目录 &lt;code&gt;--exclude=...&lt;/code&gt;，下面是我的变量值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export FZF_DEFAULT_COMMAND=&amp;quot;fd --exclude={.git,.idea,.vscode,.sass-cache,node_modules,build} --type f&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;界面展示-fzf-default-opts&#34;&gt;界面展示 FZF_DEFAULT_OPTS&lt;/h3&gt;

&lt;p&gt;界面展示这些参数在 &lt;code&gt;fzf --help&lt;/code&gt; 中都有，按需配置即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export FZF_DEFAULT_OPTS=&amp;quot;--height 40% --layout=reverse --preview &#39;(highlight -O ansi {} || cat {}) 2&amp;gt; /dev/null | head -500&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;界面配置参数加上后就漂亮多了
&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t24178/228/1983729650/93496/412c5c52/5b6fd697N0d686b66.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t24178/228/1983729650/93496/412c5c52/5b6fd697N0d686b66.png&#34; alt=&#34;fzf-with-preview&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--preview&lt;/code&gt; 表示在右侧显示文件的预览界面，语法高亮的设置使用了 &lt;a href=&#34;http://www.andre-simon.de/doku/highlight/en/highlight.php&#34;&gt;highlight&lt;/a&gt; 如果 highlight 失败则使用最常见的 &lt;code&gt;cat&lt;/code&gt; 命令来查看文件内容&lt;/p&gt;

&lt;p&gt;highlight 安装可能会有个小插曲。highlight 需要手动编译安装，默认安装目录在 &lt;code&gt;/usr/bin&lt;/code&gt;, &lt;code&gt;/usr/share&lt;/code&gt; 下面。然而在 macOS 中由于 &lt;abbr title=&#34;System Integrity Protection&#34;&gt;SIP&lt;/abbr&gt; 保护，用户安装的程序不能在这几个目录下面「即使有 sudo 权限也不行」。我们可以手动更改下 highlight 源代码中 makefile 中的参数即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;# PREFIX = /usr
PREFIX = /usr/local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将 &lt;code&gt;PREFIX = /usr&lt;/code&gt; 改成 &lt;code&gt;PREFIX = /usr/local&lt;/code&gt;，然后 &lt;code&gt;make&lt;/code&gt;，&lt;code&gt;sudo make install&lt;/code&gt; 就可以了&lt;/p&gt;

&lt;h3 id=&#34;触发命令行补全-fzf-completion-trigger&#34;&gt;触发命令行补全 FZF_COMPLETION_TRIGGER&lt;/h3&gt;

&lt;p&gt;默认是 &lt;code&gt;**&lt;/code&gt;，一般不用修改&lt;/p&gt;

&lt;h2 id=&#34;vim-fzf-插件&#34;&gt;VIM fzf 插件&lt;/h2&gt;

&lt;p&gt;如果你使用 vim，那么官方提供的插件会让你的 vim 使用更加流畅&lt;/p&gt;

&lt;h3 id=&#34;安装插件&#34;&gt;安装插件&lt;/h3&gt;

&lt;p&gt;如果你本地安装过 fzf 命令行工具了，只需要在 .vimrc 里面添加下面两个插件配置即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Plug &#39;/usr/local/opt/fzf&#39;
Plug &#39;junegunn/fzf.vim&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：使用了 &lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;vim-plug&lt;/a&gt; 插件管理&lt;/p&gt;

&lt;p&gt;插件主要对 fzf 集成绑定了一些和 vim 相关的功能，比如：查找当前 Buffer、Tag、Marks。甚至切换 window 更换 vim 主题配色等&lt;/p&gt;

&lt;p&gt;命令模式下敲 &lt;code&gt;Files&lt;/code&gt; 即可选择当前目录下所有文件，&lt;code&gt;Buffers&lt;/code&gt; 可以过滤当前所有 vim buffer 内容&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t25240/349/434572567/558564/433c151a/5b6fdfadNfd6ea407.gif&#34; alt=&#34;fzf-vim-plugin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再配置几个常用快捷键就可以直接取代 CtrlP 插件了 🤔&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ctrl + p 查看文件列表&lt;/li&gt;
&lt;li&gt;Ctrl + e 查看当前 Buffer，两次 Ctrl + e 快速切换上次打开的 Buffer&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;nmap &amp;lt;C-p&amp;gt; :Files&amp;lt;CR&amp;gt;
nmap &amp;lt;C-e&amp;gt; :Buffers&amp;lt;CR&amp;gt;
let g:fzf_action = { &#39;ctrl-e&#39;: &#39;edit&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;当然 fzf 还可以在很多其它场景下用来。如果你想使用可视化的列表选择而不是咣咣敲命令，那就自己搭配一些组合来使用吧&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jQuery ajax 方法 data 参数默认 encode 失败的 bug</title>
      <link>https://keelii.com/2018/05/25/jquery-ajax-data-param-auto-encode-bug/</link>
      <pubDate>Fri, 25 May 2018 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2018/05/25/jquery-ajax-data-param-auto-encode-bug/</guid>
      <description>&lt;p&gt;使用 jQuery ajax 方法调用异步接口时 data 参数默认会被添加转码 &lt;code&gt;encodeURIComponent&lt;/code&gt;，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$.ajax({
    url: &#39;http://your.domain.com/action&#39;,
    dataType: &#39;jsonp&#39;,
    data: {
        spaces: &#39;a b&#39;,
        other: &#39;&amp;amp;&#39;
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码会向 &lt;code&gt;http://your.domain.com/action?spaces=a+b&amp;amp;other=%26&lt;/code&gt; 发送 get 请求，奇怪的是参数中的 &lt;code&gt;&amp;amp;&lt;/code&gt; 被正确转码成 &lt;code&gt;%26&lt;/code&gt;，但是  被转成了 &lt;code&gt;+&lt;/code&gt; 而不是 &lt;code&gt;%20&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;看看正确的转码结果长啥样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;encodeURIComponent(&#39;&amp;amp;&#39;) // =&amp;gt; &amp;quot;%26&amp;quot;
encodeURIComponent(&#39; &#39;) // =&amp;gt; &amp;quot;%20&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然 data 参数里面的 key,value 都要被 encodeURIComponent，那么出现这种情况只能去查 jQuery 源代码了。jQuery 会调用 $.param 方法来编码 data 参数，大概在 &lt;strong&gt;jQuery-1.7.2&lt;/strong&gt; 的 &lt;em&gt;(7736)&lt;/em&gt; 行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;param: function( a, traditional ) {
    // ...
    } else {
        // If traditional, encode the &amp;quot;old&amp;quot; way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for ( var prefix in a ) {
            buildParams( prefix, a[ prefix ], traditional, add );
        }
    }

    // Return the resulting serialization
    return s.join( &amp;quot;&amp;amp;&amp;quot; ).replace( r20, &amp;quot;+&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;param 方法内部会再调用 &lt;code&gt;buildParams&lt;/code&gt; 来把 data 对象键值对添加编码，一切都很正常&lt;/p&gt;

&lt;p&gt;然饿最后一行 &lt;code&gt;replace( r20, &amp;quot;+&amp;quot; )&lt;/code&gt; 是什么鬼！&lt;code&gt;r20&lt;/code&gt; 变量是内部的一个空白转义符的正则 &lt;code&gt;/%20/g&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这就有点意思了，为啥把正确的空格编码再转回 &lt;code&gt;+&lt;/code&gt; 呢？&lt;/p&gt;

&lt;p&gt;外事不决问 Google，搜索 &lt;code&gt;why jquery ajax convert %20 to +&lt;/code&gt; 结果发现有一条 jQuery 官方的 github issue: &lt;a href=&#34;https://github.com/jquery/jquery/issues/2658&#34;&gt;Only change %20 to + for application/x-www-form-urlencoded&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t20344/242/259059096/183424/9e8e0f30/5b078bbdN06c75a01.png&#34; alt=&#34;google-why-jquery-convert-space-to-plus&#34; /&gt;&lt;/p&gt;

&lt;p&gt;根据 issue 的描述大意是说 &lt;code&gt;convert %20 to +&lt;/code&gt; 这个逻辑只应该在 POST 请求的时候做转换，而不是所有请求。我们的示例中的 jsonp 刚好是 get 请求&lt;/p&gt;

&lt;p&gt;继续往下看找到了一个 &lt;a href=&#34;https://github.com/dmethvin/jquery/commit/60453ce299a0c84550e70010ceea12d538226bf5&#34;&gt;commit(60453ce)&lt;/a&gt; 修复了这个问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img14.360buyimg.com/devfe/jfs/t20692/166/263146843/79735/7f45adb2/5b078b49N8f97629d.png&#34; alt=&#34;jquery-param-encode-bug&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意一点，我们并不能简单的在 data 对象传入的时候手动添加 &lt;code&gt;encodeURIComponent&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$.ajax({
    url: &#39;http://your.domain.com/action&#39;,
    dataType: &#39;jsonp&#39;,
    data: {
        // 错误的做法
        spaces: encodeURIComponent(&#39;a b&#39;),
        other: &#39;&amp;amp;&#39;
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 spaces 参数有别的应该被正常编码的字符串，这样会导致正常的被编码的字符被 &lt;strong&gt;两次&lt;/strong&gt; encodeURIComponent。所以要正确解决这个问题需要修改 jQuery 源代码，这个可以参考上面的那个 fix commit&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>又双叒叕写了一个 host 管理插件</title>
      <link>https://keelii.com/2017/11/07/yet-another-host-manager-plugin/</link>
      <pubDate>Tue, 07 Nov 2017 12:51:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/11/07/yet-another-host-manager-plugin/</guid>
      <description>

&lt;p&gt;切 host 对于平常开发来说再正常不过了，可是「切 host 难」的问题一直没解决，因为手动修改 host 文件会有很多（系统dns、浏览器）缓存问题。经常听到xx说「我这是好的呀，你 host 有问题吧&amp;hellip;」&lt;/p&gt;

&lt;p&gt;在 windows 下我一直使用 fiddler 来切换 host，很多人可能不知道这个功能。他的实现本质就是实用代理映射来实现 host 切换。这样的欢最大的优点就是 &lt;strong&gt;无延迟，秒切 host&lt;/strong&gt; 这个体验就非常赞，而且是系统级别的，也就是说别的浏览器里面也适用（前提是浏览器代理设置为系统）&lt;/p&gt;

&lt;p&gt;然后由于最近切换到 mac 开发环境，发现 mac 下面的解决方案都不是很完美，或者说不适合我的要求。无外乎以下几种：&lt;/p&gt;

&lt;h2 id=&#34;物理修改-host-文件&#34;&gt;物理修改 host 文件&lt;/h2&gt;

&lt;p&gt;像 iHosts, Switchhosts 这类，但据我所知这种方法都有延迟&lt;/p&gt;

&lt;h2 id=&#34;抓包工具代理切-host&#34;&gt;抓包工具代理切 host&lt;/h2&gt;

&lt;p&gt;比如 mac 下的 Wireshark、Charles，这些工具据说很强大，可是我自己用不惯，而且我是需求也很小，杀鸡焉用牛刀。fiddler for mac 虽然也能跑起来，但是体验太差了，界面卡的要死&lt;/p&gt;

&lt;h2 id=&#34;浏览器插件代理切-host&#34;&gt;浏览器插件代理切 host&lt;/h2&gt;

&lt;p&gt;像 Chrome 下的 Chrome-host-switch、 Switch host plus 等，试用了下效果很理想。美中不足的是体验不好，只有标签没有分组，把标签当分组切的人很蛋疼&lt;/p&gt;

&lt;p&gt;简单看了下 switch host plus 的实现方式，再加上自己之前也写过 chrome 插件就决定自己造个轮子。Chrome 插件基于html、css、javascript 自然很适合前端来做&lt;/p&gt;

&lt;p&gt;由于最近在看 react 相关的东西，刚好拿来练练手。技术选型基本上都是现成的框架拿来用就行了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;react &amp;amp; redux 构建整体应用&lt;/li&gt;
&lt;li&gt;bulma.css 简洁小巧的 CSS 框架&lt;/li&gt;
&lt;li&gt;localStorage 数据直接写本地存储&lt;/li&gt;
&lt;li&gt;create react app 构建打包应用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;应用截图&#34;&gt;应用截图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t11611/80/1444685331/28555/590b5dfa/5a013f0aN19565830.png&#34; alt=&#34;ahm-640x440&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t11845/332/1453803626/635686/c8e4f98/5a013fe8N41db44e3.png&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t11845/332/1453803626/635686/c8e4f98/5a013fe8N41db44e3.png&#34; alt=&#34;ahm-1280x800&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;功能&#34;&gt;功能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;秒切 host 无延迟 😎&lt;/li&gt;
&lt;li&gt;基于 chrome 代理 ❤️&lt;/li&gt;
&lt;li&gt;兼容 socket 代理 🤔&lt;/li&gt;
&lt;li&gt;简洁好用，无多余功能 👏&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/awesome-host-manager/pikaoeecieigblebdddckmlegonlogha?hl=zh-CN&#34;&gt;Chrome 应用商店&lt;/a&gt;（建议）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/keelii/awesome-host-manager/master/awesome-host-manager.crx&#34;&gt;下载 .crx 文件&lt;/a&gt; chrome 中打开 chrome://extensions/ 将.crx 文件托进安装即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;h4 id=&#34;host-proxy&#34;&gt;Host proxy&lt;/h4&gt;

&lt;p&gt;和 host 文件规则一致&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;192.168.100.1 your.domain.com your-anther.domain.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;socket-proxy&#34;&gt;Socket proxy&lt;/h4&gt;

&lt;p&gt;新建分组加入以下规则（按自己实际情况修改）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOCKS5 127.0.0.1:1080
SOCKS 127.0.0.1:1080
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;源代码&#34;&gt;源代码&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/keelii/awesome-host-manager&#34;&gt;Github&lt;/a&gt;(MIT)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解决 seajs parseDependencies 方法引起的依赖解析错误问题</title>
      <link>https://keelii.com/2017/11/03/fix-seajs-parse-dep-bug/</link>
      <pubDate>Fri, 03 Nov 2017 15:51:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/11/03/fix-seajs-parse-dep-bug/</guid>
      <description>&lt;p&gt;使用 seajs 的过程中偶尔会发现 require 进来的模块甚至都没有加载。查看源代码之后发现 seajs 是通过正则表达式匹配出了模块 factory 中的 require 路径&lt;/p&gt;

&lt;p&gt;正常情况下，下面这个模块里面 require 的外部模块会解析出依赖 &lt;code&gt;GLOBAL_ROOT/base/cookie&lt;/code&gt; 和 &lt;code&gt;GLOBAL_ROOT/base/utils&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;define(&#39;moduleName&#39;, function() {
    var a = require(&#39;GLOBAL_ROOT/base/cookie&#39;)
    var b = require(&#39;GLOBAL_ROOT/base/utils&#39;)
    // 正常情况 a 应该是个对象，
    console.log(a)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果 cookie 模块加载失败，a 就会返回 null 这时候再调 a 上面的方法就会报错。当 seajs 内部解析依赖时发生了错误时就会出现这种情况，由于我们使用的是比较老的 seajs 版本（2.2.0），去查看源代码发现 parseDependencies 方法使用了一个正则表达式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var REQUIRE_RE = /&amp;quot;(?:\\&amp;quot;|[^&amp;quot;])*&amp;quot;|&#39;(?:\\&#39;|[^&#39;])*&#39;|\/\*[\S\s]*?\*\/|\/(?:\\\/|[^\/\r\n])+\/(?=[^\/])|\/\/.*|\.\s*require|(?:^|[^$])\brequire\s*\(\s*([&amp;quot;&#39;])(.+?)\1\s*\)/g
var SLASH_RE = /\\\\/g

function parseDependencies(code) {
  var ret = []

  code.replace(SLASH_RE, &amp;quot;&amp;quot;)
      .replace(REQUIRE_RE, function(m, m1, m2) {
        if (m2) {
          ret.push(m2)
        }
      })

  return ret
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在控制台里面跑一下看看结果，上面的模块解析正确：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t11401/113/1005903134/64122/b08677b9/59fc23d6N998f2848.png&#34; alt=&#34;seajs-works-well&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是我自己的场景并没有这么简单，我贴上自己的代码时就异常了，由于源码比较多我就放到 jsbin 上了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jsbin.com/bowazakosu/edit?html,js,console,output&#34;&gt;压缩成一行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jsbin.com/likonikoye/edit?html,js,console,output&#34;&gt;格式化压缩代码后&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有意思的地方就在于 压缩成一行 的代码中是异常的，但是当我把代码格式化后就正常了？！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;seajs 3.x 版本以后 &lt;a href=&#34;https://github.com/seajs/seajs/blob/3.0.0/src/util-deps.js&#34;&gt;util-deps.js&lt;/a&gt; 引入了一个依赖解析器方法，直接用这个替代原来的即可。至于为什么那个正则对于压缩后的代码没起作用我暂还没详细研究，不过感觉像获取模块依赖关系这种静态分析任务还是用解析器靠谱点，正则有太多的不确定性，虽然它能节省很多代码&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>macOS Sierra 开发环境配置指南</title>
      <link>https://keelii.com/2017/10/07/macos-development-setup-guide/</link>
      <pubDate>Sat, 07 Oct 2017 17:19:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/10/07/macos-development-setup-guide/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文来自于我自己配置两台 macOS 开发环境的过程，主要记录一些常用的配置技巧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;系统设置&#34;&gt;系统设置&lt;/h2&gt;

&lt;h3 id=&#34;更改计算机名称&#34;&gt;更改计算机名称&lt;/h3&gt;

&lt;p&gt;macOS 默认的计算机名称「xx的xx」，我一般会把这个名字改成英文，在命令行中看起来会漂亮一点。修改 &lt;code&gt;系统设置-共享-电脑名称&lt;/code&gt; 即可&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t9919/194/838196844/87087/80259170/59d8e3f4N4277172a.png&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t9919/194/838196844/87087/80259170/59d8e3f4N4277172a.png&#34; alt=&#34;computer-name&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;触控板&#34;&gt;触控板&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;设置轻点触控板为鼠标点击&lt;/li&gt;
&lt;li&gt;设置三指拖动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t10129/124/847447368/253995/96574062/59d8e534Nc3e40d9f.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t10129/124/847447368/253995/96574062/59d8e534Nc3e40d9f.png&#34; alt=&#34;tap-click&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://img10.360buyimg.com/devfe/jfs/t10396/219/830021333/98488/bcc6e984/59d8e43cN04d84771.png&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t10396/219/830021333/98488/bcc6e984/59d8e43cN04d84771.png&#34; alt=&#34;drag-drop&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;finder&#34;&gt;Finder&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;开启新 Fidder 窗口时打开 &lt;code&gt;桌面&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行搜索时 &lt;code&gt;搜索当前文件夹&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;显示所有文件扩展名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t9571/278/833569016/71935/221e5956/59d8e45dN67661921.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t9571/278/833569016/71935/221e5956/59d8e45dN67661921.png&#34; alt=&#34;finder&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;其它&#34;&gt;其它&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;系统偏好设置-键盘-输入法-自动切换到文稿输入法&lt;/code&gt; 应用切换的时候会保持原来的输入法不变&lt;/li&gt;
&lt;li&gt;&lt;code&gt;桌面空白处右键-排序方式-贴紧网格&lt;/code&gt; 右键整理图标的时候就会按网格排列&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;开发环境设置&#34;&gt;开发环境设置&lt;/h2&gt;

&lt;h3 id=&#34;安装-command-line-tools&#34;&gt;安装 Command line tools&lt;/h3&gt;

&lt;p&gt;方便后续编译安装其它应用&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t9601/44/840280004/58067/a2e0aa5e/59d8e496N2cdf9cca.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t9601/44/840280004/58067/a2e0aa5e/59d8e496N2cdf9cca.png&#34; alt=&#34;xcode-select&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;xcode-select --install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-brew&#34;&gt;安装 brew&lt;/h3&gt;

&lt;p&gt;一般命令行的工具，或者开发环境包都用 &lt;a href=&#34;https://brew.sh/&#34;&gt;brew&lt;/a&gt; 来安装。GUI 的应用直接去网站下载安装包即可，App Store 我一般用来购买安装一些收费软件&lt;/p&gt;

&lt;p&gt;打开命令行执行下面的命令来安装 brew&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面的命令替换 brew 源为&lt;a href=&#34;https://lug.ustc.edu.cn/wiki/mirrors/help/brew.git&#34;&gt;中科大镜像&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 替换brew.git:
cd &amp;quot;$(brew --repo)&amp;quot;
git remote set-url origin https://mirrors.ustc.edu.cn/brew.git

# 替换homebrew-core.git:
cd &amp;quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;quot;
git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 brew 安装下载源码包有时是用 curl 的，所以可以配置下 curl 来走 &lt;em&gt;番习习墙&lt;/em&gt; 代理，我一般在配置文件中设置 &lt;code&gt;vim ~/.curlrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;socks5 = &amp;quot;127.0.0.1:1080&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-zsh-oh-my-zsh&#34;&gt;安装 Zsh &amp;amp; oh-my-zsh&lt;/h3&gt;

&lt;p&gt;Zsh 是一种 &lt;a href=&#34;https://zh.wikipedia.org/wiki/Unix_shell&#34;&gt;shell&lt;/a&gt;，功能和 bash, csh 一样，用来和操作系统交互&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装 zsh
brew install zsh
# 安装 oh-my-zsh 插件
# 更换默认 shell 为 zsh
chsh -s /bin/zsh
sh -c &amp;quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功的话会有下面的提示&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t10303/164/828630186/232717/e8624f08/59d8e4d7N2c9b44f6.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t10303/164/828630186/232717/e8624f08/59d8e4d7N2c9b44f6.png&#34; alt=&#34;ohmyzsh&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装自动补全提示插件 &lt;a href=&#34;https://github.com/zsh-users/zsh-autosuggestions&#34;&gt;zsh-autosuggestions&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions
source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://img30.360buyimg.com/devfe/jfs/t10564/347/828202786/16788/8bd58613/59d8e50cN2ef8aa62.gif&#34;&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t10564/347/828202786/16788/8bd58613/59d8e50cN2ef8aa62.gif&#34; alt=&#34;zsh-autosuggestions&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装-配置-iterm2&#34;&gt;安装/配置 iTerm2&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.iterm2.com/&#34;&gt;下载&lt;/a&gt; 并安装，打开 Preferences 偏好设置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;General&lt;/code&gt; 关闭 &lt;code&gt;Native full screen windows&lt;/code&gt; 我不使用系统的全屏（因为有过渡动画），是为了使用全局快捷键 &lt;strong&gt;立即&lt;/strong&gt; 调出命令行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Profiles-Window-Transparency&lt;/code&gt; 设置透明度 10%~20% 即可，太高会和桌面背景冲突。如果需要临时禁用透明度可以使用快捷键 &lt;code&gt;⌘+u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Keys-Hotkey&lt;/code&gt; 设置全局显示隐藏快捷键 系统级别的快捷键设置为 &lt;code&gt;⌘+\&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;最佳实践，启动 iTerm2 后按 &lt;code&gt;⌘+enter&lt;/code&gt; 全屏，然后 &lt;code&gt;⌘+\&lt;/code&gt; 隐藏它，这时候就可以做别的事情去了。任何时间想再用 iTerm2 只需要按 &lt;code&gt;⌘+\&lt;/code&gt; 即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;brew-常用工具&#34;&gt;brew 常用工具&lt;/h3&gt;

&lt;p&gt;下面这些都是用 brew 安装的，即 &lt;code&gt;brew install xxx&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;htop&#34;&gt;htop&lt;/h4&gt;

&lt;p&gt;用来查看当前运行的程序，top 命令的升级版&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t10783/119/847515894/438295/9e4709ce/59d8e566N62c288f9.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t10783/119/847515894/438295/9e4709ce/59d8e566N62c288f9.png&#34; alt=&#34;htop&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;tree&#34;&gt;tree&lt;/h4&gt;

&lt;p&gt;显示文件为树形菜单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  keelii.github.io tree . -L 2
.
├── config.toml
├── content
│   ├── about
│   └── archives
├── deploy.sh
├── public
│   ├── 2016
...
│   └── tags
└── themes
    └── octo-enhance

17 directories, 8 files
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;httpie&#34;&gt;httpie&lt;/h4&gt;

&lt;p&gt;使用比 curl 简单多了，而且还有一些代码高亮的效果&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t9175/233/2384082355/52554/472f733/59d8e58fN956a159a.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t9175/233/2384082355/52554/472f733/59d8e58fN956a159a.png&#34; alt=&#34;httpie&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;vim&#34;&gt;vim&lt;/h4&gt;

&lt;p&gt;安装 vim 添加一些默认的模块和编程语言支持 cscope, lua, python 并且覆盖系统默认的 vim&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install vim --HEAD --with-cscope --with-lua --with-override-system-vim --with-luajit --with-python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 vim-plug&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;autojump&#34;&gt;autojump&lt;/h4&gt;

&lt;p&gt;方便在命令行中快速跳转目录，安装后程序会读取你 cd 过的目录并存起来，方便后面用快捷方式调用，支持模糊匹配。&lt;strong&gt;注意: autojump 只会记录安装后使用 cd 命令进入过的目录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//img10.360buyimg.com/devfe/jfs/t10066/212/961703883/22512/ed0565/59dae741N3fcc655c.gif&#34;&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t10066/212/961703883/22512/ed0565/59dae741N3fcc655c.gif&#34; alt=&#34;autojump&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;yarn&#34;&gt;yarn&lt;/h4&gt;

&lt;p&gt;npm 的替代品，Production Ready。如果系统中安装过 node，就使用 &lt;code&gt;yarn --without-node&lt;/code&gt; 命令只安装 yarn 工具&lt;/p&gt;

&lt;h3 id=&#34;安装-python-pip&#34;&gt;安装 python pip&lt;/h3&gt;

&lt;p&gt;下载 &lt;a href=&#34;https://bootstrap.pypa.io/get-pip.py&#34;&gt;get-pip.py&lt;/a&gt; 在命令行中使用 python 运行这个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo python get-pip.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;更改各种程序语言包源&#34;&gt;更改各种程序语言包源&lt;/h3&gt;

&lt;h4 id=&#34;ruby-gemrc&#34;&gt;ruby - .gemrc&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/
gem sources -l
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat ~/.gemrc
---
:backtrace: false
:bulk_threshold: 1000
:sources:
- https://mirrors.tuna.tsinghua.edu.cn/rubygems/
:update_sources: true
:verbose: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;node-yarnrc-npmrc&#34;&gt;node - .yarnrc/.npmrc&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat ~/.yarnrc
registry &amp;quot;https://registry.npm.taobao.org&amp;quot;
disturl &amp;quot;https://npm.taobao.org/dist&amp;quot;
electron_mirror &amp;quot;http://cdn.npm.taobao.org/dist/electron/&amp;quot;
node_inspector_cdnurl &amp;quot;https://npm.taobao.org/mirrors/node-inspector&amp;quot;
sass_binary_site &amp;quot;http://cdn.npm.taobao.org/dist/node-sass&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dotfiles-配置文件&#34;&gt;dotfiles 配置文件&lt;/h3&gt;

&lt;p&gt;可以参照我的 &lt;a href=&#34;https://github.com/keelii/dotfiles&#34;&gt;dotfiles&lt;/a&gt; 配置文件&lt;/p&gt;

&lt;h3 id=&#34;其它-gui-应用&#34;&gt;其它 GUI 应用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.alfredapp.com/&#34;&gt;Alfred&lt;/a&gt; 程序启动器&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://theunarchiver.com/&#34;&gt;The Unarchiver&lt;/a&gt; ⇒ 解压工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/magnet/id441258766?mt=12&#34;&gt;Magent&lt;/a&gt; ⇒ 排列窗口（付费）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mowglii.com/itsycal/&#34;&gt;Itsycal&lt;/a&gt; ⇒ 简洁版日历&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href=&#34;http://snip.qq.com/&#34;&gt;Snip&lt;/a&gt; ⇒ 屏幕截图&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href=&#34;http://snappy-app.com/&#34;&gt;Snappy&lt;/a&gt; ⇒ 屏幕截图、修改分享&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.snipaste.com/&#34;&gt;Snipaste&lt;/a&gt; ⇒ 更好用的屏幕截图&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pasteapp.me/&#34;&gt;Paste&lt;/a&gt; 剪贴板管理工具（付费）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://typora.io/&#34;&gt;Typora&lt;/a&gt; 正确的使用 markdown 写文档笔记等&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pqrs.org/osx/karabiner/&#34;&gt;Karabiner-Elements&lt;/a&gt; ⇒ 改键器, 改键方案参照&lt;a href=&#34;https://keelii.com/2017/10/03/how-to-map-single-command-key-on-mac/&#34;&gt;上篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://freemacsoft.net/appcleaner/&#34;&gt;AppCleaner 2&lt;/a&gt; ⇒ 卸载应用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cockos.com/licecap/&#34;&gt;licecap for mac&lt;/a&gt; ⇒ 录制 gif 图片&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zipzapmac.com/go2shell&#34;&gt;Go2shell&lt;/a&gt; ⇒ Finder 当前目录打开命令行&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>macOS 单独设置 command(⌘) 键点击功能</title>
      <link>https://keelii.com/2017/10/03/how-to-map-single-command-key-on-mac/</link>
      <pubDate>Tue, 03 Oct 2017 17:10:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/10/03/how-to-map-single-command-key-on-mac/</guid>
      <description>&lt;p&gt;由于最近全面切换工作环境到 Mac 上，快捷键基本上成了适应期的最大问题&lt;/p&gt;

&lt;p&gt;传统意义上像 &lt;code&gt;Ctrl, Alt, Shift, Win, Option, Command&lt;/code&gt; 都属于 &lt;code&gt;修饰键&lt;/code&gt;，只能和其它键配合使用才可以（Ctrl+c,Ctrl+v），单独敲击并没有效果&lt;/p&gt;

&lt;p&gt;但是 Win 键在 Windows 中被赋予了更多的功能，下面这几个系统级别的快捷键用起来是非常方便的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Win + E&lt;/code&gt; ⇒ 打开资源管理器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Win + D&lt;/code&gt; ⇒ 显示桌面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Win + L&lt;/code&gt; ⇒ 锁定计算机&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前使用过 Windows 和 Ubuntu gnome，特别方便的一点就是 super(Win) 键 &lt;strong&gt;不仅&lt;/strong&gt; 可以做为修饰键和其它键组合使用，而且还可以响应 &lt;strong&gt;单独的&lt;/strong&gt; 点击事件，Windows 中点击 Win 键会全局呼出 &lt;em&gt;开始菜单&lt;/em&gt; 方便我们 &lt;em&gt;查找/打开&lt;/em&gt; 应用。这样的话单独点击相当于可以少按一个按键，切找应用什么的非常快&lt;/p&gt;

&lt;p&gt;Mac 中我通常使用 Spotlight 来快速切换程序。用惯了 Mac 的人会觉得 command 键位非常舒服好按（键位原因），这时候我希望尽可能把常用的键组织到 command 上又 &lt;strong&gt;不影响&lt;/strong&gt; 原来的组合键，比如我有下面两个最常使用的快捷键：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘&lt;/code&gt; ⇒ 呼出 Spotlight&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ + Space&lt;/code&gt; ⇒ 切换输入法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而 Mac 系统中并不允许我们这么做 🤔，于是我使用了一个改键器 &lt;a href=&#34;https://pqrs.org/osx/karabiner/&#34;&gt;Karabiner&lt;/a&gt; 😎&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t9160/329/2610957899/117091/8481138f/59d34e67Nb3bd2a2d.png&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t9160/329/2610957899/117091/8481138f/59d34e67Nb3bd2a2d.png&#34; alt=&#34;mac-karabiner&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我的配置方法是使用 &lt;code&gt;Complex Modifications&lt;/code&gt; 因为它允许我把修饰键改成其它按钮功能。在这里我将其改为一个没用的键位（f13 - PrtSc），因为 Spotlight 不接受单独的修饰键，所以只能这样区线救国了&lt;/p&gt;

&lt;p&gt;然后在系统偏好设置 - 键盘 - 快捷键 中将 Spotlight 设置成 F13&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img12.360buyimg.com/devfe/jfs/t9769/96/578527884/124966/ff1a2f04/59d34fbeN5b1e4775.png&#34;&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t9769/96/578527884/124966/ff1a2f04/59d34fbeN5b1e4775.png&#34; alt=&#34;mac-spotlight&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意：默认的 Complex Modifications 里面是空的，需要你手动导入一个叫 &lt;a href=&#34;https://pqrs.org/osx/karabiner/complex_modifications/#modifier_keys&#34;&gt;Tapping modifier-keys produces a f-key.&lt;/a&gt;。然后我们 &lt;code&gt;enable&lt;/code&gt; 这条：&lt;strong&gt;Press left_command alone produces F14&lt;/strong&gt;，噫~我们是要 map 成 F13 这里默认的是 F14，怎么改下呢。改配置文件吧，打开下面这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim ~/.config/karabiner/karabiner.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将里面的 F14 改成 F13 即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;// ...
&amp;quot;complex_modifications&amp;quot;: {
    &amp;quot;parameters&amp;quot;: {
        &amp;quot;basic.to_if_alone_timeout_milliseconds&amp;quot;: 600
    },
    &amp;quot;rules&amp;quot;: [
        {
            &amp;quot;description&amp;quot;: &amp;quot;Press left_command alone produces F14&amp;quot;,
            &amp;quot;manipulators&amp;quot;: [
                {
                    &amp;quot;from&amp;quot;: {
                        &amp;quot;key_code&amp;quot;: &amp;quot;left_command&amp;quot;,
                        &amp;quot;modifiers&amp;quot;: { &amp;quot;optional&amp;quot;: [ &amp;quot;any&amp;quot; ] }
                    },
                    &amp;quot;to&amp;quot;: [ { &amp;quot;key_code&amp;quot;: &amp;quot;left_command&amp;quot; } ],
                    &amp;quot;to_if_alone&amp;quot;: [ { &amp;quot;key_code&amp;quot;: &amp;quot;f14&amp;quot; } ],
                    &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;
                }
            ]
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样基本上的完成我的需求了，打开应用只需要按一次 ⌘ 即可呼出 Spotlight，像打开 Google Chrome 只需要两个键即可 &lt;code&gt;⌘ g&lt;/code&gt;、Webstorm &lt;code&gt;⌘ w&lt;/code&gt;、Firefox &lt;code&gt;⌘ f&lt;/code&gt; &amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;备注：我用的机器是 Mac mini 主机 + filco 87 键盘&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>jQuery data 方法的一个小特技</title>
      <link>https://keelii.com/2017/05/03/a-trick-from-jquery-data-method/</link>
      <pubDate>Wed, 03 May 2017 17:59:45 +0800</pubDate>
      
      <guid>https://keelii.com/2017/05/03/a-trick-from-jquery-data-method/</guid>
      <description>&lt;p&gt;通常我们在用 JavaScript 操作 DOM 元素的时候会往 DOM 上临时添加一些参数，用来记住一些状态，或者从后端取参数值等&lt;/p&gt;

&lt;p&gt;一般通过在 HTML 标签上添加自定义属性来实现，但是这样会不可避免的访问 DOM，性能上并不好。如果你使用 jQuery 的话建议使用 &lt;code&gt;$el.data()&lt;/code&gt; 方法来取元素上 &lt;code&gt;data-*&lt;/code&gt; 的值，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;demo&amp;quot; data-key=&amp;quot;value&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    $(&#39;#demo&#39;).attr(&#39;data-key&#39;)
    $(&#39;#demo&#39;).data(&#39;key&#39;)  // 第一次访问 DOM，以后从缓存取
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个方法的区别在于 attr 每次都会直接访问 DOM 元素，而 data 方法会缓存第一次的查找，后续调用不需要访问 DOM&lt;/p&gt;

&lt;p&gt;很明显建议使用后者，但是在 &lt;strong&gt;低版本的 jQuery&lt;/strong&gt; 中默认会对 data 方法取到的值进行粗暴的强制数据类型转换「parseFloat」。看下面代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;demo0&amp;quot; data-key=&amp;quot;abc&amp;quot;&amp;gt;字符串&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo1&amp;quot; data-key=&amp;quot;123&amp;quot;&amp;gt;数字&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo2&amp;quot; data-key=&amp;quot;123e456&amp;quot;&amp;gt;科学计数法&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo3&amp;quot; data-key=&amp;quot;0000123&amp;quot;&amp;gt;八进制数字&amp;lt;/div&amp;gt;
&amp;lt;script src=&amp;quot;jquery-1.6.4&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    $(&#39;#demo0&#39;).data(&#39;key&#39;)  // &amp;quot;abc&amp;quot;
    $(&#39;#demo1&#39;).data(&#39;key&#39;)  // 123
    $(&#39;#demo2&#39;).data(&#39;key&#39;)  // Infinity
    $(&#39;#demo3&#39;).data(&#39;key&#39;)  // 83
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面两种显然出错了，就是因为 jQuery 对属性值进行了强制 parseFloat 操作。这种转换是方便了使用者，如果是数字的话我们取到这个值进行计算什么的就不用再转数据类型了，但是一不小心就会出 bug&lt;/p&gt;

&lt;p&gt;发现这个 bug 的时候第一感觉是 jQuery 不应该没考虑到这一点呀。后来果断去查了下最新版的 jQuery 源代码，发现已经修复了。核心代码在 &lt;a href=&#34;https://github.com/jquery/jquery/blob/master/src/data.js#L36&#34;&gt;data.js 35 行&lt;/a&gt;，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getData( data ) {
    if ( data === &amp;quot;true&amp;quot; ) {
        return true;
    }

    if ( data === &amp;quot;false&amp;quot; ) {
        return false;
    }

    if ( data === &amp;quot;null&amp;quot; ) {
        return null;
    }

    // Only convert to a number if it doesn&#39;t change the string
    // 重点就在这里 →_→
    if ( data === +data + &amp;quot;&amp;quot; ) {
        return +data;
    }

    if ( rbrace.test( data ) ) {
        return JSON.parse( data );
    }

    return data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getData 方法就返回了节点属性的值，只不过加了一些特殊处理使得我们取到了没有 bug 的值，关键地方就在这里： &lt;code&gt;data === +data + &amp;quot;&amp;quot;&lt;/code&gt; 。这行代码做了些什么神奇的事情&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;将节点的属性值强制转换成数字「+data」后再转成字符串「+ &amp;ldquo;&amp;ldquo;」，如果转换后的值与原来相等就取转换后的值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以简单的这么理解：jQuery 会尝试转换数据类型，如果转换后和转换前的 &lt;strong&gt;长得一样&lt;/strong&gt; 那么 jQuery 就认为它是需要被转换成数字的。这样就可以完美规避上面例子中的两种问题，我们来测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var data = &#39;abc&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值

var data = &#39;123&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // true 转换，使用转换后的数字类型值

var data = &#39;123e456&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值

var data = &#39;0000123&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sublime text 3 配置 ESLint 代码检查</title>
      <link>https://keelii.com/2017/04/29/sublime-text-3-configure-eslint/</link>
      <pubDate>Sat, 29 Apr 2017 17:17:24 +0800</pubDate>
      
      <guid>https://keelii.com/2017/04/29/sublime-text-3-configure-eslint/</guid>
      <description>

&lt;h2 id=&#34;安装环境&#34;&gt;安装环境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Windows 7 SP1 企业版&lt;/li&gt;
&lt;li&gt;Sublime text 3 Build 3162&lt;/li&gt;
&lt;li&gt;Node.js v6.9.5&lt;/li&gt;
&lt;li&gt;Yarn 0.23.2 (可用 npm 代替)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装-eslint&#34;&gt;安装 ESLint&lt;/h2&gt;

&lt;p&gt;到你的项目根目录生成一个 package.json 文件，如果没有使用 &lt;code&gt;yarn init -y&lt;/code&gt; 来自动生成&lt;/p&gt;

&lt;p&gt;ESLint 默认的 parser 是 esprima，如果你需要检查 Babel 转义的 JSX 等文件那可以选择安装 &lt;a href=&#34;https://github.com/babel/babel-eslint&#34;&gt;babel-eslint&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yarn init -y
yarn global add eslint
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 sublime text 3 配置 eslint 来做代码检查&lt;/p&gt;

&lt;h2 id=&#34;安装-sublime-text-3-插件&#34;&gt;安装 Sublime text 3 插件&lt;/h2&gt;

&lt;h3 id=&#34;安装-sublime-linter-和-sublimelinter-contrib-eslint&#34;&gt;安装 Sublime​Linter 和 SublimeLinter-contrib-eslint&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://packagecontrol.io/packages/SublimeLinter&#34;&gt;Sublime​Linter&lt;/a&gt; 是一个代码检查框架插件，功能非常强大，支持各种语言的检查。但是它本身并没有代码检查的功能，需要借助 ESLint 这样的特定语言检查支持。我们只需要使用对应的 &lt;a href=&#34;https://packagecontrol.io/packages/SublimeLinter-contrib-eslint&#34;&gt;Sublime​Linter-contrib-eslint&lt;/a&gt; 插件即可&lt;/p&gt;

&lt;p&gt;在 Sublime text 中 &lt;code&gt;Ctrl + Shift + p &amp;gt; Package Control:Install Package&lt;/code&gt; 里面搜索关键词 &lt;code&gt;linter&lt;/code&gt;，&lt;strong&gt;注意&lt;/strong&gt;别选成了 SummitLinter。然后再搜索 &lt;code&gt;eslint&lt;/code&gt; 找到 SublimeLinter-contrib-eslint 安装（不得不吐槽下 Sublime package 搜索匹配让人无法理解）&lt;/p&gt;

&lt;h2 id=&#34;配置-eslint&#34;&gt;配置 ESLint&lt;/h2&gt;

&lt;p&gt;到项目根目录下面使用 eslint 命令交互式的生成配置文件。这里 ESLint 会让你确认项目的配置项目，包括代码风格、目标文件等。我一般选择 &lt;code&gt;Answer questions about your style&lt;/code&gt;，即通过选择性的回答命令行中的问题让 ESLint 生成适合我项目的配置文件&lt;/p&gt;

&lt;p&gt;生成的配置文件我一般选择 JavaScript 因为这样比较方便写注释。我的配置项大概如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;How would you like to configure ESLint?
Answer questions about your style
Are you using ECMAScript 6 features? No
Where will your code run? Browser
Do you use CommonJS? No
Do you use JSX? No
What style of indentation do you use? Spaces
What quotes do you use for strings? Single
What line endings do you use? Unix
Do you require semicolons? No
What format do you want your config file to be in? JavaScript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的配置文件竟然是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
    &amp;quot;env&amp;quot;: {
        &amp;quot;browser&amp;quot;: true
    },
    &amp;quot;extends&amp;quot;: &amp;quot;eslint:recommended&amp;quot;,
    &amp;quot;rules&amp;quot;: {
        &amp;quot;indent&amp;quot;: [
            &amp;quot;error&amp;quot;,
            4
        ],
        &amp;quot;linebreak-style&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;unix&amp;quot;
        ],
        &amp;quot;quotes&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;single&amp;quot;
        ],
        &amp;quot;semi&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;never&amp;quot;
        ]
    }
}; // Do you require semicolons? No !!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 &lt;code&gt;extends&lt;/code&gt; 设置成 &lt;code&gt;eslint:recommended&lt;/code&gt; 表示在 &lt;a href=&#34;http://eslint.org/docs/rules/&#34;&gt;ESLint 规则页面&lt;/a&gt; 中标记成 「✔」 的项都开启检测&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;打开项目中任意一个 JavaScript 文件，右键 &lt;code&gt;SublimeLint &amp;gt; Lint this view&lt;/code&gt; 来试试检查当前文件，如果有错误，编辑器会展示对应 Gutter 错误行和信息。可以使用 &lt;code&gt;SublimeLint &amp;gt; Show all errors&lt;/code&gt; 来查看所有的错误&lt;/p&gt;

&lt;p&gt;上个图吧&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t4531/175/3699692200/112024/b747eb91/590466dcN6f0ad2ac.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t4531/175/3699692200/112024/b747eb91/590466dcN6f0ad2ac.png&#34; alt=&#34;sublimetext-eslint&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nginx 配置 Google fonts 反向代理开启 HTTP2/SSL 支持</title>
      <link>https://keelii.com/2017/04/22/proxy-google-fonts-with-ssl-http2-support/</link>
      <pubDate>Sat, 22 Apr 2017 11:19:58 +0800</pubDate>
      
      <guid>https://keelii.com/2017/04/22/proxy-google-fonts-with-ssl-http2-support/</guid>
      <description>

&lt;p&gt;由于博客主题使用了 Google fonts PT Serif 字体，国内只能通过中科大的代理来使用 Google fonts 字体。然而最近发现其速度不稳定，响应时间有时候甚至超过 600ms。刚好因为自己有 &lt;a href=&#34;http://www.vultr.com/?ref=6805146&#34;&gt;vultr 的 VPS(带小尾巴)&lt;/a&gt; 就自己动手搭了个来用&lt;/p&gt;

&lt;p&gt;VPS 环境如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ubuntu 14.04&lt;/li&gt;
&lt;li&gt;Nginx 1.12.0 (最新版各别配置与之前不一样)&lt;/li&gt;
&lt;li&gt;Openssl 1.0.2j (新版 Nginx 开启 http2 需要的最低 openssl 版本)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重新编译安装-nginx&#34;&gt;重新编译安装 Nginx&lt;/h2&gt;

&lt;p&gt;如果之前编译安装没开启相关模块的话需要重新编译，大概参数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-openssl=/usr/local/ssl --with-http_v2_module --with-http_sub_module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译完没有出错的话就 &lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt; 就 OK 了&lt;/p&gt;

&lt;h2 id=&#34;配置-nginx-反代&#34;&gt;配置 Nginx 反代&lt;/h2&gt;

&lt;h3 id=&#34;基本配置&#34;&gt;基本配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;upstream google {
    server fonts.googleapis.com:80;
}

upstream gstatic {
    server fonts.gstatic.com:80;
}
proxy_temp_path   /your/path/tmp 1 2;
proxy_cache_path  /your/path/cache levels=1:2 keys_zone=cache1:100m inactive=30d max_size=1g;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;80-端口配置&#34;&gt;80 端口配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
    listen 80;
    server_name your.proxy.domain;
    root /your/path/;
    location /css {
        sub_filter &#39;fonts.gstatic.com&#39; &#39;your.proxy.domain&#39;;
        sub_filter_once off;
        sub_filter_types text/css;
        proxy_pass_header Server;
        proxy_set_header Host fonts.googleapis.com;
        proxy_set_header Accept-Encoding &#39;&#39;;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://google;
        proxy_cache cache1;
        proxy_cache_key $host$uri$is_args$args;
        proxy_cache_valid 200 304 10m;
        expires 365d;
    }
    location / {
        proxy_pass_header Server;
        proxy_set_header Host fonts.gstatic.com;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://gstatic;
        proxy_cache cache1;
        proxy_cache_key $host$uri$is_args$args;
        proxy_cache_valid 200 304 10m;
        expires 365d;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;443-端口配置&#34;&gt;443 端口配置&lt;/h3&gt;

&lt;p&gt;首先你得有个免费的 HTTPS 证书，这个可以参考我之前的文章：&lt;a href=&#34;https://keelii.com/2016/06/12/free-https-cert-lets-encrypt-apply-install/&#34;&gt;免费 Https 证书（Let&amp;rsquo;S Encrypt）申请与配置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意设置 &lt;code&gt;sub_filter&lt;/code&gt; 字段的时候 &lt;strong&gt;你的域名要加上 https://&lt;/strong&gt;，要不然会出现代理的 CSS 文件中的字体文件引用是 HTTP 而请求报 &lt;code&gt;blocked/mixed-content&lt;/code&gt; 错&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
    listen 443 ssl http2;

    ssl on;
    ssl_certificate /etc/letsencrypt/live/your.proxy.domain/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your.proxy.domain/privkey.pem;
    ssl_dhparam /etc/ssl/certs/dhparams.pem;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers HIGH:!aNULL:!MD5;

    server_name  your.proxy.domain;
    root /var/sites/fonts/;

    location /css {
        sub_filter &#39;http://fonts.gstatic.com&#39; &#39;https://your.proxy.domain&#39;;
        sub_filter_once off;
        sub_filter_types text/css;
        proxy_pass_header Server;
        proxy_set_header Host fonts.googleapis.com;
        proxy_set_header Accept-Encoding &#39;&#39;;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://google;
        proxy_cache cache1;
        proxy_cache_key $host$uri$is_args$args;
        proxy_cache_valid 200 304 10m;
        expires 365d;
    }

    location / {
        proxy_pass_header Server;
        proxy_set_header Host fonts.gstatic.com;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://gstatic;
        proxy_cache cache1;
        proxy_cache_key $host$uri$is_args$args;
        proxy_cache_valid 200 304 10m;
        expires 365d;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安全防盗链&#34;&gt;安全防盗链&lt;/h3&gt;

&lt;p&gt;如果不共享给其它人用的话还需要在配置中加入 referer 白名单判断，不符合条件的将返回 403&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;valid_referers server_name *.your.domain.com *.other.domain.com;
if ($invalid_referer) {
    return 403;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>