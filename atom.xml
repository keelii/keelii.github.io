<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Something</title>
    <link>https://keelii.github.io/atom/index.xml</link>
    <description>Recent content on Something</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 03 May 2017 17:59:45 +0800</lastBuildDate>
    <atom:link href="https://keelii.github.io/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>jQuery data 方法的一个小特技</title>
      <link>https://keelii.github.io/2017/05/03/a-trick-from-jquery-data-method/</link>
      <pubDate>Wed, 03 May 2017 17:59:45 +0800</pubDate>
      
      <guid>https://keelii.github.io/2017/05/03/a-trick-from-jquery-data-method/</guid>
      <description>&lt;p&gt;通常我们在用 JavaScript 操作 DOM 元素的时候会往 DOM 上临时添加一些参数，用来记住一些状态，或者从后端取参数值等&lt;/p&gt;

&lt;p&gt;一般通过在 HTML 标签上添加自定义属性来实现，但是这样会不可避免的访问 DOM，性能上并不好。如果你使用 jQuery 的话建议使用 &lt;code&gt;$el.data()&lt;/code&gt; 方法来取元素上 &lt;code&gt;data-*&lt;/code&gt; 的值，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;demo&amp;quot; data-key=&amp;quot;value&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    $(&#39;#demo&#39;).attr(&#39;data-key&#39;)
    $(&#39;#demo&#39;).data(&#39;key&#39;)  // 第一次访问 DOM，以后从缓存取
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个方法的区别在于 attr 每次都会直接访问 DOM 元素，而 data 方法会缓存第一次的查找，后续调用不需要访问 DOM&lt;/p&gt;

&lt;p&gt;很明显建议使用后者，但是在 &lt;strong&gt;低版本 jQuery&lt;/strong&gt; 中默认会对 data 方法取到的值进行粗暴的强制数据类型转换「parseFloat」。看下面代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;demo0&amp;quot; data-key=&amp;quot;abc&amp;quot;&amp;gt;字符串&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo1&amp;quot; data-key=&amp;quot;123&amp;quot;&amp;gt;数字&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo2&amp;quot; data-key=&amp;quot;123e456&amp;quot;&amp;gt;科学计数法&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo3&amp;quot; data-key=&amp;quot;0000123&amp;quot;&amp;gt;八进制数字&amp;lt;/div&amp;gt;
&amp;lt;script src=&amp;quot;jquery-1.6.4&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    $(&#39;#demo0&#39;).data(&#39;key&#39;)  // &amp;quot;abc&amp;quot;
    $(&#39;#demo1&#39;).data(&#39;key&#39;)  // 123
    $(&#39;#demo2&#39;).data(&#39;key&#39;)  // Infinity
    $(&#39;#demo3&#39;).data(&#39;key&#39;)  // 83
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面两种显然出错了，就是因为 jQuery 对属性值进行了强制 parseFloat 操作。这种转换是方便了使用者，如果是数字的话我们取到这个值进行计算什么的就不用再转数据类型了，但是一不小心就会出 bug&lt;/p&gt;

&lt;p&gt;发现这个 bug 的时候第一感觉是 jQuery 不应该没考虑到这一点呀。后来果断去查了下最新版的 jQuery 源代码，发现已经修复了。核心代码在 &lt;a href=&#34;https://github.com/jquery/jquery/blob/master/src/data.js#L36&#34;&gt;data.js 35 行&lt;/a&gt;，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getData( data ) {
    if ( data === &amp;quot;true&amp;quot; ) {
        return true;
    }

    if ( data === &amp;quot;false&amp;quot; ) {
        return false;
    }

    if ( data === &amp;quot;null&amp;quot; ) {
        return null;
    }

    // Only convert to a number if it doesn&#39;t change the string
    // 重点就在这里 →_→
    if ( data === +data + &amp;quot;&amp;quot; ) {
        return +data;
    }

    if ( rbrace.test( data ) ) {
        return JSON.parse( data );
    }

    return data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getData 方法就返回了节点属性的值，只不过加了一些特殊处理使得我们取到了没有 bug 的值，关键地方就在这里： &lt;code&gt;data === +data + &amp;quot;&amp;quot;&lt;/code&gt; 。这行代码做了些什么神奇的事情&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;将节点的属性值强制转换成数字「+data」后再转成字符串「+ &amp;ldquo;&amp;ldquo;」，如果转换后的值与原来相等就取转换后的值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以简单的这么理解：jQuery 会尝试转换数据类型，如果转换后和转换前的 &lt;strong&gt;长得一样&lt;/strong&gt; 那么 jQuery 就认为它是需要被转换成数字的。这样就可以完美规避上面例子中的两种问题，我们来测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var data = &#39;abc&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值

var data = &#39;123&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // true 转换，使用转换后的数字类型值

var data = &#39;123e456&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值

var data = &#39;0000123&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sublime text 3 配置 ESLint 代码检查</title>
      <link>https://keelii.github.io/2017/04/29/sublime-text-3-configure-eslint/</link>
      <pubDate>Sat, 29 Apr 2017 17:17:24 +0800</pubDate>
      
      <guid>https://keelii.github.io/2017/04/29/sublime-text-3-configure-eslint/</guid>
      <description>

&lt;h2 id=&#34;安装环境&#34;&gt;安装环境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Windows 7 SP1 企业版&lt;/li&gt;
&lt;li&gt;Sublime text 3 Build 3162&lt;/li&gt;
&lt;li&gt;Node.js v6.9.5&lt;/li&gt;
&lt;li&gt;Yarn 0.23.2 (可用 npm 代替)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装-eslint&#34;&gt;安装 ESLint&lt;/h2&gt;

&lt;p&gt;到你的项目根目录生成一个 package.json 文件，如果没有使用 &lt;code&gt;yarn init -y&lt;/code&gt; 来自动生成&lt;/p&gt;

&lt;p&gt;ESLint 默认的 parser 是 esprima，如果你需要检查 Babel 转义的 JSX 等文件那可以选择安装 &lt;a href=&#34;https://github.com/babel/babel-eslint&#34;&gt;babel-eslint&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yarn init -y
yarn global add eslint
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 sublime text 3 配置 eslint 来做代码检查&lt;/p&gt;

&lt;h2 id=&#34;安装-sublime-text-3-插件&#34;&gt;安装 Sublime text 3 插件&lt;/h2&gt;

&lt;h3 id=&#34;安装-sublime-linter-和-sublimelinter-contrib-eslint&#34;&gt;安装 Sublime​Linter 和 SublimeLinter-contrib-eslint&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://packagecontrol.io/packages/SublimeLinter&#34;&gt;Sublime​Linter&lt;/a&gt; 是一个代码检查框架插件，功能非常强大，支持各种语言的检查。但是它本身并没有代码检查的功能，需要借助 ESLint 这样的特定语言检查支持。我们只需要使用对应的 &lt;a href=&#34;https://packagecontrol.io/packages/SublimeLinter-contrib-eslint&#34;&gt;Sublime​Linter-contrib-eslint&lt;/a&gt; 插件即可&lt;/p&gt;

&lt;p&gt;在 Sublime text 中 &lt;code&gt;Ctrl + Shift + p &amp;gt; Package Control:Install Package&lt;/code&gt; 里面搜索关键词 &lt;code&gt;linter&lt;/code&gt;，&lt;strong&gt;注意&lt;/strong&gt;别选成了 SummitLinter。然后再搜索 &lt;code&gt;eslint&lt;/code&gt; 找到 SublimeLinter-contrib-eslint 安装（不得不吐槽下 Sublime package 搜索匹配让人无法理解）&lt;/p&gt;

&lt;h2 id=&#34;配置-eslint&#34;&gt;配置 ESLint&lt;/h2&gt;

&lt;p&gt;到项目根目录下面使用 eslint 命令交互式的生成配置文件。这里 ESLint 会让你确认项目的配置项目，包括代码风格、目标文件等。我一般选择 &lt;code&gt;Answer questions about your style&lt;/code&gt;，即通过选择性的回答命令行中的问题让 ESLint 生成适合我项目的配置文件&lt;/p&gt;

&lt;p&gt;生成的配置文件我一般选择 JavaScript 因为这样比较方便写注释。我的配置项大概如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;How would you like to configure ESLint?
Answer questions about your style
Are you using ECMAScript 6 features? No
Where will your code run? Browser
Do you use CommonJS? No
Do you use JSX? No
What style of indentation do you use? Spaces
What quotes do you use for strings? Single
What line endings do you use? Unix
Do you require semicolons? No
What format do you want your config file to be in? JavaScript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的配置文件竟然是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
    &amp;quot;env&amp;quot;: {
        &amp;quot;browser&amp;quot;: true
    },
    &amp;quot;extends&amp;quot;: &amp;quot;eslint:recommended&amp;quot;,
    &amp;quot;rules&amp;quot;: {
        &amp;quot;indent&amp;quot;: [
            &amp;quot;error&amp;quot;,
            4
        ],
        &amp;quot;linebreak-style&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;unix&amp;quot;
        ],
        &amp;quot;quotes&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;single&amp;quot;
        ],
        &amp;quot;semi&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;never&amp;quot;
        ]
    }
}; // Do you require semicolons? No !!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 &lt;code&gt;extends&lt;/code&gt; 设置成 &lt;code&gt;eslint:recommended&lt;/code&gt; 表示在 &lt;a href=&#34;http://eslint.org/docs/rules/&#34;&gt;ESLint 规则页面&lt;/a&gt; 中标记成 「✔」 的项都开启检测&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;打开项目中任意一个 JavaScript 文件，右键 &lt;code&gt;SublimeLint &amp;gt; Lint this view&lt;/code&gt; 来试试检查当前文件，如果有错误，编辑器会展示对应 Gutter 错误行和信息。可以使用 &lt;code&gt;SublimeLint &amp;gt; Show all errors&lt;/code&gt; 来查看所有的错误&lt;/p&gt;

&lt;p&gt;上个图吧&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//img11.360buyimg.com/devfe/jfs/t4531/175/3699692200/112024/b747eb91/590466dcN6f0ad2ac.png&#34;&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t4531/175/3699692200/112024/b747eb91/590466dcN6f0ad2ac.png&#34; alt=&#34;sublimetext-eslint&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nginx 配置 Google fonts 反向代理开启 HTTP2/SSL 支持</title>
      <link>https://keelii.github.io/2017/04/22/proxy-google-fonts-with-ssl-http2-support/</link>
      <pubDate>Sat, 22 Apr 2017 11:19:58 +0800</pubDate>
      
      <guid>https://keelii.github.io/2017/04/22/proxy-google-fonts-with-ssl-http2-support/</guid>
      <description>

&lt;p&gt;由于博客主题使用了 Google fonts PT Serif 字体，国内只能通过中科大的代理来使用 Google fonts 字体。然而最近发现其速度不稳定，响应时间有时候甚至超过 600ms。刚好因为自己有 &lt;a href=&#34;http://www.vultr.com/?ref=6805146&#34;&gt;vultr 的 VPS(带小尾巴)&lt;/a&gt; 就自己动手搭了个来用&lt;/p&gt;

&lt;p&gt;VPS 环境如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ubuntu 14.04&lt;/li&gt;
&lt;li&gt;Nginx 1.12.0 (最新版各别配置与之前不一样)&lt;/li&gt;
&lt;li&gt;Openssl 1.0.2j (新版 Nginx 开启 http2 需要的最低 openssl 版本)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重新编译安装-nginx&#34;&gt;重新编译安装 Nginx&lt;/h2&gt;

&lt;p&gt;如果之前编译安装没开启相关模块的话需要重新编译，大概参数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-openssl=/usr/local/ssl --with-http_v2_module --with-http_sub_module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译完没有出错的话就 &lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt; 就 OK 了&lt;/p&gt;

&lt;h2 id=&#34;配置-nginx-反代&#34;&gt;配置 Nginx 反代&lt;/h2&gt;

&lt;h3 id=&#34;基本配置&#34;&gt;基本配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;upstream google {
    server fonts.googleapis.com:80;
}

upstream gstatic {
    server fonts.gstatic.com:80;
}
proxy_temp_path   /your/path/tmp 1 2;
proxy_cache_path  /your/path/cache levels=1:2 keys_zone=cache1:100m inactive=30d max_size=1g;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;80-端口配置&#34;&gt;80 端口配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
    listen 80;
    server_name your.proxy.domain;
    root /your/path/;
    location /css {
        sub_filter &#39;fonts.gstatic.com&#39; &#39;your.proxy.domain&#39;;
        sub_filter_once off;
        sub_filter_types text/css;
        proxy_pass_header Server;
        proxy_set_header Host fonts.googleapis.com;
        proxy_set_header Accept-Encoding &#39;&#39;;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://google;
        proxy_cache cache1;
        proxy_cache_key $host$uri$is_args$args;
        proxy_cache_valid 200 304 10m;
        expires 365d;
    }
    location / {
        proxy_pass_header Server;
        proxy_set_header Host fonts.gstatic.com;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://gstatic;
        proxy_cache cache1;
        proxy_cache_key $host$uri$is_args$args;
        proxy_cache_valid 200 304 10m;
        expires 365d;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;443-端口配置&#34;&gt;443 端口配置&lt;/h3&gt;

&lt;p&gt;首先你得有个免费的 HTTPS 证书，这个可以参考我之前的文章：&lt;a href=&#34;https://keelii.github.io/2016/06/12/free-https-cert-lets-encrypt-apply-install/&#34;&gt;免费 Https 证书（Let&amp;rsquo;S Encrypt）申请与配置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意设置 &lt;code&gt;sub_filter&lt;/code&gt; 字段的时候 &lt;strong&gt;你的域名要加上 https://&lt;/strong&gt;，要不然会出现代理的 CSS 文件中的字体文件引用是 HTTP 而请求报 &lt;code&gt;blocked/mixed-content&lt;/code&gt; 错&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
    listen 443 ssl http2;

    ssl on;
    ssl_certificate /etc/letsencrypt/live/your.proxy.domain/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your.proxy.domain/privkey.pem;
    ssl_dhparam /etc/ssl/certs/dhparams.pem;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers HIGH:!aNULL:!MD5;

    server_name  your.proxy.domain;
    root /var/sites/fonts/;

    location /css {
        sub_filter &#39;http://fonts.gstatic.com&#39; &#39;https://your.proxy.domain&#39;;
        sub_filter_once off;
        sub_filter_types text/css;
        proxy_pass_header Server;
        proxy_set_header Host fonts.googleapis.com;
        proxy_set_header Accept-Encoding &#39;&#39;;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://google;
        proxy_cache cache1;
        proxy_cache_key $host$uri$is_args$args;
        proxy_cache_valid 200 304 10m;
        expires 365d;
    }

    location / {
        proxy_pass_header Server;
        proxy_set_header Host fonts.gstatic.com;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://gstatic;
        proxy_cache cache1;
        proxy_cache_key $host$uri$is_args$args;
        proxy_cache_valid 200 304 10m;
        expires 365d;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安全防盗链&#34;&gt;安全防盗链&lt;/h3&gt;

&lt;p&gt;如果不共享给其它人用的话还需要在配置中加入 referer 白名单判断，不符合条件的将返回 403&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;valid_referers server_name *.your.domain.com *.other.domain.com;
if ($invalid_referer) {
    return 403;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关系代数的基本运算</title>
      <link>https://keelii.github.io/2017/02/19/basic-operations-of-relation-algebra/</link>
      <pubDate>Sun, 19 Feb 2017 15:10:38 +0800</pubDate>
      
      <guid>https://keelii.github.io/2017/02/19/basic-operations-of-relation-algebra/</guid>
      <description>

&lt;h2 id=&#34;关系代数运算符&#34;&gt;关系代数运算符&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;集合运算符&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;英文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$∪$&lt;/td&gt;
&lt;td&gt;并&lt;/td&gt;
&lt;td&gt;Union&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$−$&lt;/td&gt;
&lt;td&gt;差&lt;/td&gt;
&lt;td&gt;Difference&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$∩$&lt;/td&gt;
&lt;td&gt;交&lt;/td&gt;
&lt;td&gt;Intersection&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$×$&lt;/td&gt;
&lt;td&gt;笛卡尔积&lt;/td&gt;
&lt;td&gt;Cartesian Product&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;比较运算符&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$&amp;gt;$&lt;/td&gt;
&lt;td&gt;大于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$≥$&lt;/td&gt;
&lt;td&gt;大于等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$&amp;lt;$&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$≤$&lt;/td&gt;
&lt;td&gt;小于等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$=$&lt;/td&gt;
&lt;td&gt;等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$≠$&lt;/td&gt;
&lt;td&gt;不等于&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;专门的关系运算符&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;英文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$σ$&lt;/td&gt;
&lt;td&gt;选择&lt;/td&gt;
&lt;td&gt;Selection&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$π$&lt;/td&gt;
&lt;td&gt;投影&lt;/td&gt;
&lt;td&gt;Projection&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$⋈$&lt;/td&gt;
&lt;td&gt;链接&lt;/td&gt;
&lt;td&gt;Join&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$÷$&lt;/td&gt;
&lt;td&gt;除&lt;/td&gt;
&lt;td&gt;Division&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;逻辑运算符&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$∧$&lt;/td&gt;
&lt;td&gt;与&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$∨$&lt;/td&gt;
&lt;td&gt;或&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$¬$&lt;/td&gt;
&lt;td&gt;非&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;5-种基本的关系代数运算&#34;&gt;5 种基本的关系代数运算&lt;/h2&gt;

&lt;h3 id=&#34;并-union&#34;&gt;并（Union）&lt;/h3&gt;

&lt;p&gt;关系 R 与 S 具有相同的关系模式，即 R 与 S 的元数相同（结构相同），R 与 S 的并是属于 R 或者属于 S 的元组构成的集合，记作 R ∪ S，定义如下：&lt;/p&gt;

&lt;div&gt;
$$R∪S=\{t|t∈R∨t∈S\}$$
&lt;/div&gt;

&lt;h3 id=&#34;差-difference&#34;&gt;差（Difference）&lt;/h3&gt;

&lt;p&gt;关系 R 与 S 具有相同的关系模式，关系 R 与 S 的差是属于 R 但不属于 S 的元组构成的集合，记作 R − S，定义如下：&lt;/p&gt;

&lt;div&gt;
$$R−S=\{t|t∈R∨t∉S\}$$
&lt;/div&gt;

&lt;h3 id=&#34;广义笛卡尔积-extended-cartesian-product&#34;&gt;广义笛卡尔积（Extended Cartesian Product）&lt;/h3&gt;

&lt;p&gt;两个无数分别为 n 目和 m 目的关系 R 和 S 的 笛卡尔积是一个 (n+m) 列的元组的集合。组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组，记作 R × S，定义如下：&lt;/p&gt;

&lt;div&gt;
$$R×S=\{t|t=&lt;(t^n,t^m)∧t^n∈R∧t^m∈S\}$$
&lt;/div&gt;

&lt;p&gt;$(t^n,t^m)$ 表示元素 $t^n$ 和 $t^m$ 拼接成的一个元组&lt;/p&gt;

&lt;h3 id=&#34;投影-projection&#34;&gt;投影（Projection）&lt;/h3&gt;

&lt;p&gt;投影运算是从关系的垂直方向进行运算，在关系 R 中选出若干属性列 A 组成新的关系，记作 $π_A(R)$，其形式如下：&lt;/p&gt;

&lt;div&gt;
$$π_A(R)=\{t[A]|t∈R\}$$
&lt;/div&gt;

&lt;h3 id=&#34;选择-selection&#34;&gt;选择（Selection）&lt;/h3&gt;

&lt;p&gt;选择运算是从关系的水平方向进行运算，是从关系 R 中选择满足给定条件的元组，记作 $σ_F(R)$，其形式如下：&lt;/p&gt;

&lt;div&gt;
$$σ_F(R)=\{t|t∈R∧F(t)=True\}$$
&lt;/div&gt;

&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;

&lt;p&gt;设有关系 R、S 如图所示，求 $R∪S$、 $R−S$、 $R×S$、 $π_{A,C}(R)$、 $σ_{A&amp;gt;B}(R)$ 和 $σ_{3&amp;lt;4}(R×S)$&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t3967/269/2409299226/5377/e997b909/58a95fceNddd39fd7.png&#34; alt=&#34;关系表RS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;进行并、差运算后结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img14.360buyimg.com/devfe/jfs/t3949/95/2458170516/5487/1c7f1f38/58a967b1N42db123f.png&#34; alt=&#34;并差&#34; /&gt;&lt;/p&gt;

&lt;p&gt;进行笛卡尔、 投影、 选择运算后结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t3943/109/2403665652/38834/c636281b/58a9685dN20af0b9b.png&#34; alt=&#34;笛卡尔_投影_选择&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;扩展的关系代数运算&#34;&gt;扩展的关系代数运算&lt;/h2&gt;

&lt;h3 id=&#34;交-intersection&#34;&gt;交（Intersection）&lt;/h3&gt;

&lt;p&gt;关系 R 和 S 具有相同的关系模式，交是由属于 R 同时双属于 S 的元组构成的集合，记作 R∩S，形式如下：&lt;/p&gt;

&lt;div&gt;
$$R∩S=\{t|t∈R∧t∈S\}$$
&lt;/div&gt;

&lt;h3 id=&#34;链接-join&#34;&gt;链接（Join）&lt;/h3&gt;

&lt;p&gt;注：下面的 θ 链接应该记作：&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t3967/158/2461240249/2389/530d7d07/58aa580aNe9908740.png&#34; alt=&#34;theta链接&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;θ-链接&#34;&gt;θ 链接&lt;/h4&gt;

&lt;p&gt;从 R 与 S的笛卡尔积中选取属性间满足一定条件的元组，可由基本的关系运算笛卡尔积和选取运算导出，表示为：&lt;/p&gt;

&lt;div&gt;
$$R \Join_{XθY} S = σ_{XθY}(R×S)$$
&lt;/div&gt;

&lt;p&gt;XθY 为链接的条件，θ 是比较运算符，X 和 Y 分别为 R 和 S 上度数相等且可比的属性组&lt;/p&gt;

&lt;p&gt;例如：求 $R \Join_{R.A&amp;lt;S.B} S$，如果为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img14.360buyimg.com/devfe/jfs/t3133/127/6662942086/21071/88c200da/58aa5b1fN3e2316d5.png&#34; alt=&#34;theta链接小于过程&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;等值链接&#34;&gt;等值链接&lt;/h4&gt;

&lt;p&gt;当 θ 为「=」时，称之为等值链接，记为： $R\Join_{X=Y}S$&lt;/p&gt;

&lt;h4 id=&#34;自然链接&#34;&gt;自然链接&lt;/h4&gt;

&lt;p&gt;自然链接是一种特殊的等值链接，它要求两个关系中进行比较的分量必须是 &lt;strong&gt;相同的属性组&lt;/strong&gt;，并且在结果集中将 &lt;strong&gt;重复的属性列&lt;/strong&gt; 去掉&lt;/p&gt;

&lt;p&gt;例如：设有关系 R、S 如图所示，求 $R \Join S$&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t3982/212/2472511181/5973/54467e2a/58aa5ffaN970f7e5a.png&#34; alt=&#34;关系RS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;先求出笛卡尔积 $R×S$，找出比较分量（有相同属性组），即: R.A/S.A 与 R.C/S.C&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t3841/5/4275908218/12385/79e83d01/58aa6066Nd003e697.png&#34; alt=&#34;求出笛卡尔积&#34; /&gt;&lt;/p&gt;

&lt;p&gt;取等值链接 $R.A = S.A$ 且 $R.C = S.C$&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t3256/75/6205568741/12327/2b1dc867/58aa60e8N38a84108.png&#34; alt=&#34;找出相同属性的比较分量&#34; /&gt;&lt;/p&gt;

&lt;p&gt;结果集中去掉重复属性列，注意无论去掉 R.A 或者 S.A 效果都一样，因为他们的值相等，结果集中只会有属性 A、B、C、D&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img12.360buyimg.com/devfe/jfs/t3217/183/6576493853/4744/ccb96965/58aa612eN043f7425.png&#34; alt=&#34;结果集中找出重复属性列&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最终得出结果&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img12.360buyimg.com/devfe/jfs/t3247/65/6676502314/2874/657ddb0c/58aa617eN2457f536.png&#34; alt=&#34;RS自然链接结果&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;除-division&#34;&gt;除（Division）&lt;/h3&gt;

&lt;p&gt;设有以下如图关系，求 $R÷S$&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t3151/348/6716540896/7287/dc01ad2e/58aaaf3bN1cae8b1a.png&#34; alt=&#34;关系RS1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;取关系 R 中有的但 S 中没有的属性组，即：A、B&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t3202/137/6722879648/7244/3b47a185/58aaaf81N0b2491b5.png&#34; alt=&#34;关系RS1取属性AB&#34; /&gt;&lt;/p&gt;

&lt;p&gt;取唯一 A、B 属性组值的象集&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t3871/170/2430481542/5179/be5899c5/58aaafe6N8297b49f.png&#34; alt=&#34;关系RS1取属性AB对应的象集&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可知关系S存在于 a,b/c,k 象集 中。即 $R÷S$ 得&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t3130/361/6704334588/3366/6b7e0b56/58aab058N3a3c374d.png&#34; alt=&#34;关系RS1除结果&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sku 多维属性状态判断算法</title>
      <link>https://keelii.github.io/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/</link>
      <pubDate>Thu, 22 Dec 2016 15:55:52 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/</guid>
      <description>

&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;这个问题来源于选择商品属性的场景。比如我们买衣服、鞋子这类物件，一般都需要我们选择合适的颜色、尺码等属性&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img14.360buyimg.com/devfe/jfs/t3118/276/4984729113/37788/61331934/585b8939Na04471ff.png&#34; alt=&#34;color_size&#34; /&gt;&lt;/p&gt;

&lt;p&gt;先了解一下 sku 的学术概念吧&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;最小库存管理单元（Stock Keeping Unit, SKU）是一个会计学名词，定义为库存管理中的最小可用单元，例如纺织品中一个SKU通常表示规格、颜色、款式，而在连锁零售门店中有时称单品为一个SKU。最小库存管理单元可以区分不同商品销售的最小单元，是科学管理商品的采购、销售、物流和财务管理以及POS和MIS系统的数据统计的需求，通常对应一个管理信息系统的编码。 —— form wikipedia &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E5%AD%98%E8%B4%A7%E5%8D%95%E4%BD%8D&#34;&gt;最小存货单位&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的结合上面的实例来说： sku 就是你上购物网站买到的最终商品，对应的上图中已选择的属性是：颜色 &lt;strong&gt;黑色&lt;/strong&gt; - 尺码 &lt;strong&gt;37&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我先看看后端数据结构一般是这样的，一个线性数组，每个元素是一个描述当前 sku 的 map，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
   { &amp;quot;颜色&amp;quot;: &amp;quot;红&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;大&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;A&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3158054&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;白&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;中&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;B&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3133859&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;蓝&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;小&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;C&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3516833&amp;quot; }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前端展示的时候显然需要 group 一下，按不同的属性分组，目的就是让用户按属性的维度去选择，group 后的数据大概是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;颜色&amp;quot;: [&amp;quot;红&amp;quot;, &amp;quot;白&amp;quot;, &amp;quot;蓝&amp;quot;],
    &amp;quot;尺码&amp;quot;: [&amp;quot;大&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;小&amp;quot;],
    &amp;quot;型号&amp;quot;: [&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的在网页上大概是这样的 UI&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t3307/119/4891794144/3339/dbde7abe/585b9042N5e527489.png&#34; alt=&#34;ui_demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候，就会有一个问题，这些元子属性能组成的集合（用户的选择路径） &lt;strong&gt;远远大于&lt;/strong&gt; 真正可以组成的集合，比如上面的属性集合可以组合成一个 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF&#34;&gt;笛卡尔积&lt;/a&gt;，即。可以组合成以下序列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[
    [&amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot;],    // ✔
    [&amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot;],    // ✔
    [&amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;C&amp;quot;]     // ✔
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据公式可以知道，&lt;strong&gt;一个由 3 个元素，每个元素是有 3 个元素的子集构成的集合，能组成的笛卡尔积一共有 3 的 3 次幂，也就是 27 种&lt;/strong&gt;，然而源数据只可以形成 3 种组合&lt;/p&gt;

&lt;p&gt;这种情况下最好能提前判断出来不可选的路径并置灰，告诉用户，否则会造成误解&lt;/p&gt;

&lt;h2 id=&#34;确定规则&#34;&gt;确定规则&lt;/h2&gt;

&lt;p&gt;看下图，如果我们定义红色为当前选中的商品的属性，即当前选中商品为 &lt;code&gt;红-大-A&lt;/code&gt;，这个时候如何确认其它非已选属性是否可以组成可选路径？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img13.360buyimg.com/devfe/jfs/t3100/104/4921509103/3867/ea2bdd9b/585b9636Nc5d3efd4.png&#34; alt=&#34;ui_selected&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则是这样的：&lt;/strong&gt; 假设当前用户想选 &lt;code&gt;白-大-A&lt;/code&gt;，刚好这个选择路径是不存在的，那么我们就把 &lt;code&gt;白&lt;/code&gt; 置灰&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img13.360buyimg.com/devfe/jfs/t3175/51/4906988054/3771/93679a78/585b9717Nf53b5e3e.png&#34; alt=&#34;ui_selected_disabled&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以此类推，如果要确认 &lt;code&gt;蓝&lt;/code&gt; 属性是否可用，需要查找 &lt;code&gt;蓝-大-A&lt;/code&gt; 路径是否存在&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;解决方法&#34;&gt;解决方法&lt;/h2&gt;

&lt;p&gt;根据上面的逻辑代码实现思路就有了：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;遍历所有非已选元素：&lt;code&gt;&amp;quot;白&amp;quot;, &amp;quot;蓝&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;遍历所有属性行： &lt;code&gt;&amp;quot;颜色&amp;quot;, &amp;quot;尺码&amp;quot;, &amp;quot;型号&amp;quot;&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;取： a) 当前元素 b) 非当前元素所在的其它属性已选元素，形成一个路径&lt;/li&gt;
&lt;li&gt;判断此路径是否存在，如果不存在将当前元素置灰&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看来问题似乎已经解决了，然而 &amp;hellip;&lt;/p&gt;

&lt;p&gt;我们忽略了一个非常重要的问题：上例中虽然 &lt;code&gt;白&lt;/code&gt; 元素置灰，但是实际上 &lt;code&gt;白&lt;/code&gt; 是可以被点击的！因为用户可以选择 &lt;code&gt;白-中-B&lt;/code&gt; 路径&lt;/p&gt;

&lt;p&gt;如果用户点击了 &lt;code&gt;白&lt;/code&gt; 情况就变得复杂了很多，我们假设用户 &lt;strong&gt;只选择了一个&lt;/strong&gt;元素 &lt;code&gt;白&lt;/code&gt;，此时如何判断其它未选元素是否可选？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img13.360buyimg.com/devfe/jfs/t3238/138/4916973929/3751/11a121a7/585b9c36N668cd64b.png&#34; alt=&#34;ui_selected_one&#34; /&gt;&lt;/p&gt;

&lt;p&gt;即：如何确定 &lt;code&gt;&amp;quot;大&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;&lt;/code&gt; 需要置灰？ 注意我们并不需要确认 &lt;code&gt;&amp;quot;红&amp;quot;，&amp;quot;蓝&amp;quot;&lt;/code&gt; 是否可选，因为属性里面的元素都是 &lt;strong&gt;单选&lt;/strong&gt;，当前的属性里任何元素都可选的&lt;/p&gt;

&lt;h3 id=&#34;缩小问题规模&#34;&gt;缩小问题规模&lt;/h3&gt;

&lt;p&gt;我们先 &lt;strong&gt;缩小问题范围&lt;/strong&gt;：当前情况下（只有一个 &lt;code&gt;白&lt;/code&gt; 已选）如何确定尺码 &lt;code&gt;&amp;quot;大&amp;quot;&lt;/code&gt; 需要置灰？ 你可能会想到根据我们之间的逻辑，需要分别查找：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;白 - 大 - A&lt;/li&gt;
&lt;li&gt;白 - 大 - B&lt;/li&gt;
&lt;li&gt;白 - 大 - C&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他们都不存在的时候把尺码 &lt;code&gt;大&lt;/code&gt; 置灰，问题似乎也可以解决。其实这样是不对的，因为 &lt;strong&gt;型号没有被选择过&lt;/strong&gt;，所以只需要知道 &lt;code&gt;白-大&lt;/code&gt;是否可选即可&lt;/p&gt;

&lt;p&gt;同时还有一个问题，如果已选的个数不确定而且维度可以增加到不确定呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img13.360buyimg.com/devfe/jfs/t3931/229/741708498/8439/ce1088f3/585ba187N9bf3b55d.png&#34; alt=&#34;ui_muli-attr&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这种情况下如果还按之前的算法，即使实现也非常复杂。这时候就要考虑换一种思维方式&lt;/p&gt;

&lt;h3 id=&#34;调整思路&#34;&gt;调整思路&lt;/h3&gt;

&lt;p&gt;之前我们都是反向思考，找出不可选应该置灰的元素。我们现在正向的考虑，如何确定属性是否可选。而且多维的情况下用户可以跳着选。比如：用户选了两个元素 &lt;code&gt;白，B&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t3292/20/4882441565/5337/7c12589c/585ba3f5Nc07d80f6.png&#34; alt=&#34;ui_muli-attr_two&#34; /&gt;  &lt;em&gt;图1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我们再回过头来看下 &lt;strong&gt;原始存在的数据&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[
   { &amp;quot;颜色&amp;quot;: &amp;quot;红&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;大&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;A&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3158054&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;白&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;中&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;B&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3133859&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;蓝&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;小&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;C&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3516833&amp;quot; }
]
// 即
[
   [ &amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot; ],   // 存在
   [ &amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot; ],   // 存在
   [ &amp;quot;蓝&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;C&amp;quot; ]    // 存在
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然：如果第一条数据 &lt;code&gt;&amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot;&lt;/code&gt; 存在，那么下面这些子组合 &lt;strong&gt;肯定都存在&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;红&lt;/li&gt;
&lt;li&gt;大&lt;/li&gt;
&lt;li&gt;A&lt;/li&gt;
&lt;li&gt;红 - 大&lt;/li&gt;
&lt;li&gt;红 - A&lt;/li&gt;
&lt;li&gt;大 - A&lt;/li&gt;
&lt;li&gt;红 - 大 - A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同理：如果第二条数据 &lt;code&gt;&amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot;&lt;/code&gt; 存在，那么下面这些子组合 &lt;strong&gt;肯定都存在&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;白&lt;/li&gt;
&lt;li&gt;中&lt;/li&gt;
&lt;li&gt;B&lt;/li&gt;
&lt;li&gt;白 - 中&lt;/li&gt;
&lt;li&gt;白 - B&lt;/li&gt;
&lt;li&gt;中 - B&lt;/li&gt;
&lt;li&gt;白 - 中 - B&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;我们提前把 &lt;strong&gt;所有存在的路径中的子组合&lt;/strong&gt; 算出来，算法上叫取集合所有子集，数学上叫 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%86%AA%E9%9B%86&#34;&gt;幂集&lt;/a&gt;， 形成一个所有存在的路径表，算法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * 取得集合的所有子集「幂集」
 arr = [1,2,3]

     i = 0, ps = [[]]:
         j = 0; j &amp;lt; ps.length =&amp;gt; j &amp;lt; 1:
             i=0, j=0 ps.push(ps[0].concat(arr[0])) =&amp;gt; ps.push([].concat(1)) =&amp;gt; [1]
                      ps = [[], [1]]

     i = 1, ps = [[], [1]] :
         j = 0; j &amp;lt; ps.length =&amp;gt; j &amp;lt; 2
             i=1, j=0 ps.push(ps[0].concat(arr[1])) =&amp;gt; ps.push([].concat(2))  =&amp;gt; [2]
             i=1, j=1 ps.push(ps[1].concat(arr[1])) =&amp;gt; ps.push([1].concat(2)) =&amp;gt; [1,2]
                      ps = [[], [1], [2], [1,2]]

     i = 2, ps = [[], [1], [2], [1,2]]
         j = 0; j &amp;lt; ps.length =&amp;gt; j &amp;lt; 4
             i=2, j=0 ps.push(ps[0].concat(arr[2])) =&amp;gt; ps.push([3])    =&amp;gt; [3]
             i=2, j=1 ps.push(ps[1].concat(arr[2])) =&amp;gt; ps.push([1, 3]) =&amp;gt; [1, 3]
             i=2, j=2 ps.push(ps[2].concat(arr[2])) =&amp;gt; ps.push([2, 3]) =&amp;gt; [2, 3]
             i=2, j=3 ps.push(ps[3].concat(arr[2])) =&amp;gt; ps.push([2, 3]) =&amp;gt; [1, 2, 3]
                      ps = [[], [1], [2], [1,2], [3], [1, 3], [2, 3], [1, 2, 3]]
 */
function powerset(arr) {
    var ps = [[]];
    for (var i=0; i &amp;lt; arr.length; i++) {
        for (var j = 0, len = ps.length; j &amp;lt; len; j++) {
            ps.push(ps[j].concat(arr[i]));
        }
    }
    return ps;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个存在的子集集合，再回头看 &lt;em&gt;图1&lt;/em&gt; 举例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t3292/20/4882441565/5337/7c12589c/585ba3f5Nc07d80f6.png&#34; alt=&#34;ui_muli-attr_two&#34; /&gt;  &lt;em&gt;图1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何确定 &lt;code&gt;红&lt;/code&gt; 可选？ 只需要确定 &lt;code&gt;红-B&lt;/code&gt; 可选&lt;/li&gt;
&lt;li&gt;如何确定 &lt;code&gt;中&lt;/code&gt; 可选？ 需要确定 &lt;code&gt;白-中-B&lt;/code&gt; 可选&lt;/li&gt;
&lt;li&gt;如何确定 &lt;code&gt;2G&lt;/code&gt; 可选？ 需要确定 &lt;code&gt;白-B-2G&lt;/code&gt; 可选&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法描述如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;遍历所有非已选元素

&lt;ol&gt;
&lt;li&gt;遍历所有属性行

&lt;ol&gt;
&lt;li&gt;取： a) 当前元素 b) 非当前元素所在的其它属性已选元素（如果当前属性中没已选元素，则跳过），形成一个路径&lt;/li&gt;
&lt;li&gt;判断此路径是否存在（在所有存在的路径表中查询），如果不存在将当前元素置灰&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以最开始的后端数据为例，生成的所有可选路径表如下：
注意路径用分割符号「-」分开是为了查找路径时方便，不用遍历&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;, &amp;quot;3133859&amp;quot;, &amp;quot;3516833&amp;quot;]
    },
    &amp;quot;红&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;大&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;红-大&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;A&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;红-A&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;大-A&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;红-大-A&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;白&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;中&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;白-中&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;B&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;白-B&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;中-B&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;白-中-B&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;蓝&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;小&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;蓝-小&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;C&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;蓝-C&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;小-C&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;蓝-小-C&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了更清楚的说明这个算法，再上一张图来解释下吧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t3232/357/5124948788/54677/7df39060/58620377Nde9640c3.jpg&#34; alt=&#34;color-size-sel&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以根据上面的逻辑得出，计算状态后的界面应该是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img12.360buyimg.com/devfe/jfs/t3160/115/5120711700/3214/2e9b7205/5862159bN7d072d5f.png&#34; alt=&#34;color_size_with_state&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在这种情况下如果用户点击 尺码 &lt;code&gt;中&lt;/code&gt; 应该怎么交互呢？&lt;/p&gt;

&lt;h3 id=&#34;优化体验&#34;&gt;优化体验&lt;/h3&gt;

&lt;p&gt;因为当前情况下路径 &lt;code&gt;红-中-A&lt;/code&gt; 并不存在，如果点击 &lt;code&gt;中&lt;/code&gt;，那么除了尺码 &lt;code&gt;中&lt;/code&gt; 之外其它的属性中 &lt;strong&gt;至少有一个&lt;/strong&gt; 属性和 &lt;code&gt;中&lt;/code&gt; 的路径搭配是不存在的&lt;/p&gt;

&lt;p&gt;交互方面需求是：如果不存在就高亮当前属性行，使用户必须选择到可以和 &lt;code&gt;中&lt;/code&gt; 组合存在的属性。而且用户之间选择过的属性要做一次缓存&lt;/p&gt;

&lt;p&gt;所以当点击不存在的属性时交互流程是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;无论当前属性存不存在，先高亮（选中）当前属性&lt;/li&gt;
&lt;li&gt;清除其它所有已选属性&lt;/li&gt;
&lt;li&gt;更新当前状态（只选当前属性）下的其它属性可选状态&lt;/li&gt;
&lt;li&gt;遍历非当前属性行的其它属性查找对应的在缓存中的已选属性&lt;/li&gt;
&lt;li&gt;如果缓存中对应的属性存在（可选），则默认选中缓存属性并 &lt;strong&gt;再次更新&lt;/strong&gt; 其它可选状态。不存在，则高亮当前属性行（深色背景）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个过程的流程图大概是这样的，点进不存在的属性就会进入「单选流程」&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img20.360buyimg.com/devfe/jfs/t3232/297/5253318434/61277/1eb899ea/58653ae6Nf0a3ed56.png&#34; alt=&#34;select_diag&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假设后端数据是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[
   { &amp;quot;颜色&amp;quot;: &amp;quot;红&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;大&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;A&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3158054&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;白&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;大&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;A&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3158054&amp;quot; }, // 多加了一条
   { &amp;quot;颜色&amp;quot;: &amp;quot;白&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;中&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;B&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3133859&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;蓝&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;小&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;C&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3516833&amp;quot; }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当前选中状态是：&lt;code&gt;白-大-A&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t3235/190/5186335420/3376/e9633659/58624212Ne7f43d1f.png&#34; alt=&#34;color_size_demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果用户点击 &lt;code&gt;中&lt;/code&gt;。这个时候 &lt;code&gt;白-中&lt;/code&gt; 是存在的，但是 &lt;code&gt;中-A&lt;/code&gt; 并不存在，所以保留颜色 &lt;code&gt;白&lt;/code&gt;，高亮型号属性行：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img13.360buyimg.com/devfe/jfs/t4111/305/936307630/3771/c6076a9c/58624270N59d19a52.png&#34; alt=&#34;color_size_demo_width_hl&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由此可见和 &lt;code&gt;白-中&lt;/code&gt; 能搭配存在型号只有 &lt;code&gt;B&lt;/code&gt;，而缓存的作用就是为了少让用户选一次颜色 &lt;code&gt;白&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;到这里，基本上主要的功能就实现了。比如库存逻辑处理方式也和不存属性一样，就不再赘述。唯一需要注意的地方是求幂集的复杂度问题&lt;/p&gt;

&lt;h2 id=&#34;算法复杂度&#34;&gt;算法复杂度&lt;/h2&gt;

&lt;p&gt;幂集算法的时间复杂度是 &lt;code&gt;O(2^n)&lt;/code&gt;，也就是说每条数据上面的属性（维度）越多，复杂度越高。sku 数据的多少并不重要，因为是常数级的线性增长，而维度是指数级的增长&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{1}       2^1 = 2
=&amp;gt; {},{1}
{1,2}     2^2 = 4
=&amp;gt; {},{1},{2},{1,2}
{1,2,3}   2^3 = 8
=&amp;gt; {},{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t3280/36/5011858321/16515/2187c9c/5864aa23N95cea203.png&#34; alt=&#34;powerset_test&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 chrome 里面简单跑了几个用例，可见这个算法非常低效，如果要使用这个算法，必须控制维度在合理范围内，而且不仅仅算法时间复杂度很高，生成最后的路径表也会非常大，相应的占用内存也很高。&lt;/p&gt;

&lt;p&gt;举个例子：如果有一个 10 维的 sku，那么最终生成的路径表会有 2^10 个（1024） key/value&lt;/p&gt;

&lt;p&gt;最终 demo 可以查看这个：
&lt;a href=&#34;http://codepen.io/keelii/pen/RoOzgb&#34;&gt;sku 多维属性状态判断&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;相关资料：
&lt;a href=&#34;http://git.shepherdwind.com/sku-search-algorithm.html&#34;&gt;sku组合查询算法探索&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TrimPath 模板引擎使用指南</title>
      <link>https://keelii.github.io/2016/11/21/trimpath-template-engine/</link>
      <pubDate>Mon, 21 Nov 2016 12:39:49 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/11/21/trimpath-template-engine/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.summitdowntown.org/site_media/media/javascript/private/trimpath-template-docs/JavaScriptTemplates.html&#34;&gt;TrimPath&lt;/a&gt; 是一款轻量级的前端 JavaScript 模板引擎，语法类似 &lt;a href=&#34;http://freemarker.org/&#34;&gt;FreeMarker&lt;/a&gt;, &lt;a href=&#34;https://velocity.apache.org/&#34;&gt;Velocity&lt;/a&gt;，主要用于方便地渲染 json 数据
&lt;/p&gt;

&lt;h2 id=&#34;语法-syntax&#34;&gt;语法 Syntax&lt;/h2&gt;

&lt;h3 id=&#34;表达式-expressions&#34;&gt;表达式 Expressions&lt;/h3&gt;

&lt;p&gt;表达式和修饰符（其它模板语言中叫做过滤器 filter）中间用 &lt;code&gt;|&lt;/code&gt; 分割且 &lt;strong&gt;不能有空格&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${expr}
${expr|modifier}
${expr|modifier1:arg1,arg2|modifier2:arg1,arg2|...|modifierN:arg1,arg2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;语句-statements&#34;&gt;语句 Statements&lt;/h3&gt;

&lt;h4 id=&#34;控制流-control-flow&#34;&gt;控制流 Control Flow&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{if testExpr}
    {elseif testExpr}
    {else}
{/if}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;循环-loops&#34;&gt;循环 Loops&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{for varName in listExpr}
{/for}

{for varName in listExpr}
    ...循环主体...
{forelse}
    ...当 listExpr 是 null 或者 length 为 0 ...
{/for}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;变量声明-variable-declarations&#34;&gt;变量声明 Variable Declarations&lt;/h4&gt;

&lt;p&gt;变量声明语句用花括号 &lt;code&gt;{}&lt;/code&gt; 括起来，不需要关闭。类似 JavaScript 中的赋值语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{var varName}
{var varName = varInitExpr}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;宏声明-macro-declarations&#34;&gt;宏声明 Macro Declarations&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{macro macroName(arg1, arg2, ...argN)}
    ...macro 主体...
{/macro}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;cdata-部分-cdata-text-sections&#34;&gt;CDATA 部分 CDATA Text Sections&lt;/h4&gt;

&lt;p&gt;CDATA 部分用来告诉模板引擎不用做任何解析渲染，直接输出。比如展示一个模板字符串本身&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{cdata}
    ${customer.firstName} ${customer.lastName}
{/cdata}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;in-line-javascript&#34;&gt;In-line JavaScript&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;eval blocks&lt;/strong&gt; 用来执行 JavaScript 代码片段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{eval}
    ...模板渲染的时候执行的 JavaScript 代码...
{/eval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;minify blocks&lt;/strong&gt; 用来压缩内容中的换行符，比如压缩 HTML 属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;commentPanel&amp;quot; style=&amp;quot;{minify}
      display:none;
      margin: 1em;
      border: 1px solid #333;
      background: #eee;
      padding: 1em;
    {/minify}&amp;quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;修饰符-modifier&#34;&gt;修饰符 Modifier&lt;/h2&gt;

&lt;p&gt;修饰符用来处理上一个表达式的结果，并输出内容。类似于 Linux shell 中的管道操作符，使用「|」分割不同修饰符，可以串联使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${name|capitalize}
${name|default:&amp;quot;noname&amp;quot;|capitalize}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;内置修饰符&#34;&gt;内置修饰符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;capitalize&lt;/strong&gt; 返回大写内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;default:valueWhenNull&lt;/strong&gt; 如果内容为 null，返回 valueWhenNull&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;eat&lt;/strong&gt; 返回空内容，一般用于表达式求值后又不想展示输出的内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;escape&lt;/strong&gt; 转换 HTML 字符实体，比如： &amp;amp; 转换成 &amp;amp;amp;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;h&lt;/strong&gt; 和 escape 效果一样&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;自定义修饰符&#34;&gt;自定义修饰符&lt;/h3&gt;

&lt;p&gt;自定义修饰符可以挂载到 contextObject 上的 &lt;code&gt;_MODIFIERS&lt;/code&gt; 属性上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Modifiers = {
  toFixed: function(value, num) {
    return value.toFixed(num)
  }
}
var out = &#39;${num|toFixed:2}&#39;.process({
  _MODIFIERS: Modifiers,
  num: 1024
})
// =&amp;gt; &amp;quot;1024.00&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;宏-macro&#34;&gt;宏 Macro&lt;/h2&gt;

&lt;p&gt;macro 一般用来封装可复用 HTML 模板，类似函数的功能。对于每个模板来说 macro 是私用的。如果想公用 macro，可以保存 macro 引用到 contextObject 上（下次调用 process() 方法的时候再手动挂载上!? ）。需要在调用 process() 方法之前给 contextObject 设置一个空的 exported 属性：&lt;code&gt;contextObject[&#39;exported&#39;] = {}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个公用的 macro 设计的有点奇葩，可以参考这个 &lt;a href=&#34;http://codepen.io/keelii/pen/dOvgOJ&#34;&gt;示例&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{macro link(href, name)}
    &amp;lt;a href=&amp;quot;${href}&amp;quot;&amp;gt;${name}&amp;lt;/a&amp;gt;
{/macro}

${link(&#39;http://google.com&#39;, &#39;google&#39;)}      =&amp;gt; &amp;lt;a href=&amp;quot;http://google.com&amp;quot;&amp;gt;google&amp;lt;/a&amp;gt;
${link(&#39;http://facebook.com&#39;, &#39;facebook&#39;)}  =&amp;gt; &amp;lt;a href=&amp;quot;http://facebook.com&amp;quot;&amp;gt;facebook&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var data = {
    name: &#39;iPhone 6 Plus&#39;,
    weight: 480,
    ram: &#39;16gb&#39;,
    networks: [
        &#39;移动（TD-LTE)&#39;,
        &#39;联通(TD-LTE)&#39;,
        &#39;电信(FDD-LTE)&#39;
    ]
}

data._MODIFIERS = {
    toFixed: function(n, num) {
        return n.toFixed(num)
    }
}

var template = &#39;\
名称: ${name}&amp;lt;br&amp;gt;\
重量：${weight|toFixed:2}&amp;lt;br&amp;gt;\
内存：${ram|capitalize}&amp;lt;br&amp;gt;\
网络：\
{for item in networks}\
  {if item_index!=0}|{/if}\
  ${item}\
{/for}&#39;;

template.process(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;名称: iPhone 6 Plus&amp;lt;br&amp;gt;
重量：480.00&amp;lt;br&amp;gt;
内存：16GB&amp;lt;br&amp;gt;
网络：
  移动（TD-LTE)
 | 联通(TD-LTE)
 | 电信(FDD-LTE)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践</title>
      <link>https://keelii.github.io/2016/11/17/best-practice-for-phantomjs-and-nodejs-at-jd-s-webdev-front-end-monitor-platform/</link>
      <pubDate>Thu, 17 Nov 2016 09:55:41 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/11/17/best-practice-for-phantomjs-and-nodejs-at-jd-s-webdev-front-end-monitor-platform/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文首发于 &lt;a href=&#34;http://www.infoq.com/cn/articles/practise-of-phantomjs-and-nodejs-in-jingdong&#34;&gt;infoQ&lt;/a&gt; 及「前端之巅」微信公众号（&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;amp;mid=2247484138&amp;amp;idx=1&amp;amp;sn=431702ee926dd3a92403bb58417d88d4&amp;amp;scene=2&amp;amp;srcid=0831H070dVHqyZ5Gg62tZRsl&amp;amp;from=timeline&amp;amp;isappinstalled=0&amp;amp;pass_ticket=UAxLVHRLr%2B46hzwgDjfAanLKPSIcnzOQLPJZtqRkoQeHy03khyC2aD7Lat9WgyiL&#34;&gt;微信群直播记录&lt;/a&gt;），感谢 infoQ 前端之巅尾尾同学对文章的整理和校对、微信群直播的组织策划。「前端之巅」是个非常棒的前端知识分享平台，想了解最前沿的前端知识资讯果断关注吧
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;为什么需要一个前端监控系统&#34;&gt;为什么需要一个前端监控系统&lt;/h2&gt;

&lt;p&gt;通常在一个大型的 Web 项目中有很多监控，比如后端的服务 API 监控，接口存活、调用、延迟等监控，这些一般都用来监控后台接口数据层面的信息。而且对于大型网站系统来说，从后端服务到前台展示会有很多层：内网 VIP、CDN 等。但是这些监控并不能准确地反应用户看到的前端页面状态，比如：页面第三方系统数据调用失败，模块加载异常，数据不正确，空白开天窗等。这时候就需要从前端 DOM 展示的角度去分析和收集用户真正看到的东西，从而检测出页面是否出现异常问题&lt;/p&gt;

&lt;h2 id=&#34;需要监控系统解决的问题&#34;&gt;需要监控系统解决的问题&lt;/h2&gt;

&lt;p&gt;页面通常出现以下问题时需要使用邮件、短信通知相关人员修复问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;状态码返回错误（50x, 40x）无法打开&lt;/li&gt;
&lt;li&gt;模块加载失败&lt;/li&gt;
&lt;li&gt;页面乱码&lt;/li&gt;
&lt;li&gt;数据正确性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;触发报警时要有现场快照，以便复现问题&lt;/p&gt;

&lt;h2 id=&#34;技术选型&#34;&gt;技术选型&lt;/h2&gt;

&lt;p&gt;监控的意义和回归测试的在本质上是一致的，都是对已上线功能进行回归测试，但不同的是监控需要做长期的可持续可循环的回归测试，而测试仅仅需要在上线之后做一次回归&lt;/p&gt;

&lt;p&gt;既然监控和测试的本质一致，那我们完全可以采用测试的方式来做监控系统。在自动化测试技术遍地开花的时代，不乏很多好用的自动化工具，我们只需要把这些自动化工具进行整合为我们所用即可&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NodeJS - 特别适用于网络密集型任务&lt;/li&gt;
&lt;li&gt;PhantomJS - 模拟无界面的浏览器，提供丰富的内核交互 API&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;nodejs&#34;&gt;NodeJS&lt;/h3&gt;

&lt;p&gt;NodeJS 是一个 JavaScript 运行环境，非阻塞 I/O 和异步、事件驱动，这几点对于我们构建基于 DOM 元素的监控是非常重要的&lt;/p&gt;

&lt;h3 id=&#34;phantomjs&#34;&gt;PhantomJS&lt;/h3&gt;

&lt;p&gt;PhantomJS 是一个基于 webkit 的浏览器引擎，可以使用 JavaScript API 来模拟浏览器的操作。它使用 QtWebKit 作为它的浏览器核心，使用 webkit 来编译解释执行 JavaScript 代码。也就是说任何你可以在 webkit 浏览器里做的事情，它都能做到&lt;/p&gt;

&lt;p&gt;它不仅是个隐形的浏览器，提供了诸如 CSS 选择器、支持 Web 标准、DOM 操作、JSON、HTML5、Canvas、SVG 等，同时也提供了处理文件 I/O 的操作等。PhantomJS 的用处可谓非常广泛，诸如网络监测、网页截屏、无浏览器的 Web 测试、页面访问自动化等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么不是 Selenium&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;做自动化测试的同学肯定都知道 Selenium。可以使用 Selenium 将测试用例在浏览器中执行，而且 Selenium 对各种平台和常见浏览器支持比较好，但是 Selenium 上手难度系数略高，而且使用Selenium 需要在服务器端安装浏览器&lt;/p&gt;

&lt;p&gt;考虑到监控主要任务在监控不在测试。系统并不需要太多考虑兼容性，而且监控功能相对单一，主要对页面进行功能上的回归测试，所以选择了 PhantomJS&lt;/p&gt;

&lt;h2 id=&#34;架构设计&#34;&gt;架构设计&lt;/h2&gt;

&lt;h3 id=&#34;架构概览&#34;&gt;架构概览&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17013271/ec2bc29e-4f4f-11e6-9591-0838a0243206.png&#34; alt=&#34;4&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;架构简述&#34;&gt;架构简述&lt;/h3&gt;

&lt;p&gt;对于 DOM 监控服务，在应用层面上进行了垂直划分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;规则管理系统&lt;/li&gt;
&lt;li&gt;规则队列生成器&lt;/li&gt;
&lt;li&gt;长时持续处理器&lt;/li&gt;
&lt;li&gt;PhantomJS 服务&lt;/li&gt;
&lt;li&gt;服务化 API&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在应用层面上进行的垂直划分可以对应用做分布式部署，提高处理能力。后期也方便做性能优化、系统改造扩展等&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;h3 id=&#34;前台规则录入&#34;&gt;前台规则录入&lt;/h3&gt;

&lt;p&gt;这是一个独立的 Web 系统，系统主要用来收集用户录入的页面信息、页面对应的规则、展示错误信息。通过调用后端页面抓取服务来完成页面检测的任务，系统可以创建三种类型的检测页面：常规监控、高级监控、可用性监控&lt;/p&gt;

&lt;h4 id=&#34;常规监控&#34;&gt;常规监控&lt;/h4&gt;

&lt;p&gt;录入一个页面地址，和若干检测规则。注意这里的检测规则，我们把常用的一些检测点抽象成了一条类似测试用例的语句。每条规则用来匹配页面上的一个 DOM 元素，用 DOM 元素的属性来和预期做匹配，如果匹配失败系统就会产生一条错误信息，后续交由报警系统处理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;匹配类型&lt;/strong&gt; 一般有这么几种：&lt;code&gt;长度、文本、HTML、属性&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;处理器&lt;/strong&gt; 类似编程语言中的操作符：&lt;code&gt;大于、大于等于、小于、小于等于、等于、正则&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样做的处就是，录入规则的人只要了解一点 DOM 选择器的知识就可以上手操作了，在我们内部通常是交由测试工程师统一完成规则的录入&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17012424/2963f11e-4f4a-11e6-96f1-a962c767e651.png&#34; alt=&#34;1&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;高级监控&#34;&gt;高级监控&lt;/h4&gt;

&lt;p&gt;主要用来提供高级页面测试的功能，一般由有经验的工程师来撰写测试用例。这个测试用例写起来会有一些学习成本，但是可以模拟 Web 页面操作，如：点击、鼠标移动等事件从而做到精确捕捉页面信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17012590/324509de-4f4b-11e6-9ddc-63e5a140b208.png&#34; alt=&#34;2&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;可用性监控&#34;&gt;可用性监控&lt;/h4&gt;

&lt;p&gt;可用性监控侧重于对页面的可访问性、内容正确性等比较 &lt;strong&gt;严重的问题&lt;/strong&gt; 做即时监控。通常这类页面我们只需要在程序里面启一个 Worker 不断的去获取页面 HTML 就可以对结果进行检测匹配了，所以我们选择了 NodeJS 来做异步的页面抓取队列，高效快速的完成这种网络密集型任务&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17012775/7ccfad00-4f4c-11e6-80b6-60186069bdac.png&#34; alt=&#34;3&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;主动错误上报&#34;&gt;主动错误上报&lt;/h3&gt;

&lt;h4 id=&#34;页面脚本执行错误监控&#34;&gt;页面脚本执行错误监控&lt;/h4&gt;

&lt;p&gt;页面引入一段监控脚本来收集页面产成 error 事件返回的错误信息，自动上报给后端服务，在系统里面可以汇总所有报错信息，以及对应的客户端浏览器版本、操作系统、IP 地址等&lt;/p&gt;

&lt;h4 id=&#34;页面主动上报&#34;&gt;页面主动上报&lt;/h4&gt;

&lt;p&gt;这个功能需要对应的前端工程师在代码中调用错误上报 API，来主动提交错误信息。主要使用的场景有，页面异步服务延时无响应、模块降级兜底主动通知等。监控脚本提供几个简单的 API 来完成这项任务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// error 方法调用后立即上报错误信息并发出邮件、短信通知
errorTracker.error(&#39;错误描述&#39;)
// info 方法调用后立即上报信息，并在单位时间内仅产生一条邮件、短信通知
errorTracker.info(&#39;信息描述&#39;)
// log 方法调用后由报错检测是否达到设置阀值，最终确认是否报错
errorTracker.log(&#39;日志信息&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;后端页面抓取服务&#34;&gt;后端页面抓取服务&lt;/h3&gt;

&lt;p&gt;由于京东很多页面内容是异步加载的，像首页、单品等系统有许多第三方异步接口调用，使用后端程序抓取到的页面数据是同步的，并不能取到动态的 JavaScript 渲染的内容，所以就必须使用像 PhantomJS 这种能模拟浏览器的工具&lt;/p&gt;

&lt;p&gt;常规监控我们使用 PhantomJS 模拟浏览器打开页面进行抓取，然后将监控规则解析成 JavaScript 代码片段执行并收集结果&lt;/p&gt;

&lt;p&gt;高级监控我们使用 PhantomJS 打开页面后向页面注入像 jasmine, mocha 等类似的前端 JavaScript 测试框架，然后在页面执行对应的录入测试用例并返回结果&lt;/p&gt;

&lt;h4 id=&#34;规则队列生成器&#34;&gt;规则队列生成器&lt;/h4&gt;

&lt;p&gt;规则队列生成器会将采集的规则转化类成消息队列，然后交由长时持续处理器一次处理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么采用类消息队列的处理方式？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这和 PhantomJS 的性能是密不可分的，由多次实践发现，PhantomJS 并不能很好地进行并发处理，当并发过多，会导致 CPU 过载，从而导致机器宕机&lt;/p&gt;

&lt;p&gt;在本机环境下的虚拟机中进行并发测试，数据并不理想，极限基本在 ab -n 100 -c 50 左右。 所以为了防止并发导致的问题，就选择了使用类消息队列来避免因为并发过高导致的服务不可用&lt;/p&gt;

&lt;h4 id=&#34;类消息队列的实现&#34;&gt;类消息队列的实现&lt;/h4&gt;

&lt;p&gt;我们这里通过调用内部的分布式缓存系统生成类消息队列，队列的生成其实可以参考数据结构&amp;ndash;队列。最基本的模型就是在缓存中创建一个 KEY ，然后根据队列数据结构的模式进行数据的插入和读取&lt;/p&gt;

&lt;p&gt;当然，类消息队列的中间介质可根据你实际的条件来选择，你也可以使用本机内存实现。这可能会导致应用和类消息队列竞争内存&lt;/p&gt;

&lt;h4 id=&#34;长时持续处理器&#34;&gt;长时持续处理器&lt;/h4&gt;

&lt;p&gt;长时持续处理器是要功能就是消费规则队列生成器生成的类消息队列&lt;/p&gt;

&lt;h4 id=&#34;长时持续处理实现&#34;&gt;长时持续处理实现&lt;/h4&gt;

&lt;p&gt;在长时持续处理器的具体实现中，我们利用了 JavaScript 的 setInterval 方法来持续获取累消息队列的内容下发给规则转化器，然后转发给负载均衡调度器。之后再对返回的结果进行统一处理，比如邮件或者短信报警&lt;/p&gt;

&lt;h4 id=&#34;api&#34;&gt;API&lt;/h4&gt;

&lt;p&gt;PhantomJS 服务可以做为公共 API 提供给客户端进行测试需求的处理， API 通过 HTTP 方式调用。在 API 的处理上需要提供 HTTP 数据到规则和 PhantomJS 的转换。从而又演化出了 HTTP 数据到规则转换器&lt;/p&gt;

&lt;h4 id=&#34;phantomjs-服务&#34;&gt;PhantomJS 服务&lt;/h4&gt;

&lt;p&gt;PhantomJS 服务是指将 PhantomJS 结合 HTTP 服务和子进程进行服务化的处理&lt;/p&gt;

&lt;p&gt;首先、启动 HTTP 服务，然后将长时处理器下发的规则进行进一步转化，转化后启动子进程，HTTP 服务会监听子进程的处理结果，并在处理完毕之后返回&lt;/p&gt;

&lt;h3 id=&#34;报警系统&#34;&gt;报警系统&lt;/h3&gt;

&lt;p&gt;报警系统我们目前使用的是京东内部自己的统一监控平台 UMP，通过调用平台提供的一些 API 来实现报警邮件与短信通知&lt;/p&gt;

&lt;h4 id=&#34;如何根据报警定位到具体页面&#34;&gt;如何根据报警定位到具体页面？&lt;/h4&gt;

&lt;p&gt;用户通过监控管理系统录入规则后，监控系统会根据 UMP 规则针对用户录入的页面生成 UMP 使用的 key。当长时持续处理器发现 PhantomJS 服务返回的结果标示为异常后，就会使用 key 来进行日志记录&lt;/p&gt;

&lt;h4 id=&#34;何时出发报警&#34;&gt;何时出发报警？&lt;/h4&gt;

&lt;p&gt;报警主要分为了短信和邮件报警。邮件报警是在每条异常之后就会发给指定系统用户。短信则是根据异常次数来进行处理的，当异常次数过大，就会下发短信通知&lt;/p&gt;

&lt;h3 id=&#34;部署&#34;&gt;部署&lt;/h3&gt;

&lt;p&gt;对于系统部署可以分为两大块进行。因为机器资源数量有限，没有将所有部分都单独部署&lt;/p&gt;

&lt;p&gt;规则管理系统以及规则队列生成器和持续处理器整合部署在一台机器上，PhantomJS 服务部署在了其他的机器上。进程管理使用了著名的 NPM 模块 —— PM2&lt;/p&gt;

&lt;p&gt;PM2 是一个带有负载均衡功能的 NodeJS 应用的进程管理器。可充分利用 CPU，并保证进程稳定存活&lt;/p&gt;

&lt;p&gt;PM2 特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内建负载均衡（使用 Node cluster 集群模块）&lt;/li&gt;
&lt;li&gt;无缝重启类似 nginx reload&lt;/li&gt;
&lt;li&gt;具有 Ubuntu 和 CentOS 的开机启动脚本&lt;/li&gt;
&lt;li&gt;控制台检测&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过在目前部署任务中，并没有使用内建负载均衡的特性，没用通过集群的方式部署代理。仅使用了后台运行和无缝重启的特性&lt;/p&gt;

&lt;h2 id=&#34;总结与展望&#34;&gt;总结与展望&lt;/h2&gt;

&lt;p&gt;其实我们现在开发的这套监控系统并不复杂，只是合理的运用了一些现有的技术框架。抽象出来我们自己需要的一些功能。但却有效的达到了我们的预期功能，并且节省了很多之前需要人肉测试的时间成本。系统本身还有很多问题在待解决状态，比如报警系统的规则处理与阀值设定，JavaScript 报错的准确过滤机制等，这些问题我们都会逐个解决，并且未来的前端监控系统会成为一个平台，核心服务在后端爬取页面服务，应用端可以有多种形式，比如监控、测试工具等&lt;/p&gt;

&lt;p&gt;一些可以持续优化点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;监控系统虽然在应用层面进行了垂直划分，但是由于机器资源等限制，并没有进行单独功能的部署。这点可能会在后期的使用中进行优化&lt;/li&gt;
&lt;li&gt;PhantomJS 服务还需要进一步优化，以承载大并发，大处理量。提供稳定的服务&lt;/li&gt;
&lt;li&gt;报警由于依赖于公司内部的 UMP 系统，所以并不是特别灵活，后期可以考虑自己实现一套报警机制&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>平滑迁移 Octopress 到 Hugo</title>
      <link>https://keelii.github.io/2016/10/25/migrating-from-octopress-to-hugo-smoothly/</link>
      <pubDate>Tue, 25 Oct 2016 13:27:20 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/10/25/migrating-from-octopress-to-hugo-smoothly/</guid>
      <description>&lt;h2 id=&#34;原由&#34;&gt;原由&lt;/h2&gt;

&lt;p&gt;自从新博客建立以来一直用 &lt;a href=&#34;http://octopress.org/&#34;&gt;Octopress&lt;/a&gt; 这个博客框架来搭建静态文章页面。漂亮的默认主题、方便的发布到 github page 等功能吸引了我&lt;/p&gt;

&lt;p&gt;但就在最近因为家里的用 Macbook，刚好升级到了新版的 Sierria，杯具的是之前安装的 Octopress bundle 都失效了。调试了很久还没把环境搭建好，再加上之前发现 Octopress 的 Markdown 解析器老报错，于是就决定要更换一个配置安装简单点的博客生成器了&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;在参考了这个网站上的各种生成器后 &lt;a href=&#34;https://www.staticgen.com/&#34;&gt;staticgen&lt;/a&gt;，果断选择了 Hugo。没有什么特殊原因，下载安装试用一下就明白了。Hugo 由于是 Go 语言写的，所以你只需要下载好官方给的二进制可执行文件就可以了，再也不用安装各种依赖，然后各种换源什么的乱折腾了。这一点就足以让我转入 Hugo&lt;/p&gt;

&lt;h2 id=&#34;主题&#34;&gt;主题&lt;/h2&gt;

&lt;p&gt;由于自己还是比较喜欢 Octopress 默认的这套主题，所以在读过 Hugo 开发文档后，在严格尊重原主题的原则下修改了部分增强样式，制做了一个适配 Hugo 的 Octopress 主题。虽然 Hugo 官方有一个适配 Octopress 的主题 &lt;a href=&#34;http://themes.gohugo.io/hugo-octopress/&#34;&gt;hugo-octopress&lt;/a&gt; 但是对原主题改动太多，我并不喜欢&lt;/p&gt;

&lt;h2 id=&#34;迁移&#34;&gt;迁移&lt;/h2&gt;

&lt;h3 id=&#34;文章&#34;&gt;文章&lt;/h3&gt;

&lt;p&gt;Octopress 使用的文章描述头是 yaml 格式的，需要转换成 Hugo 的 toml，自己手动写了个 &lt;a href=&#34;https://gist.github.com/keelii/b6c51290e5ee0253f99a6424a7e2faeb&#34;&gt;NodeJS 脚本&lt;/a&gt; 来完成这个工作，基本上很轻松就完成了。注意：建议放在 &lt;code&gt;content/archives&lt;/code&gt; 目录下面，这样的话原来的文件目录和新的就是一致的了&lt;/p&gt;

&lt;p&gt;再吐槽下 md 文件名，Octopress 默认是生成时间为前缀的，如：&lt;code&gt;2016-06-13-name.markdown&lt;/code&gt;。 如果转移到 Hugo 永久链接还要保持原来文件名格式的话就得把这个前缀干掉（&lt;code&gt;name.md&lt;/code&gt;），这样的话排序就乱了。在各种编辑器、文件夹中不按创建顺序排序，看起来很别扭也不方便&lt;/p&gt;

&lt;h3 id=&#34;文章链接&#34;&gt;文章链接&lt;/h3&gt;

&lt;p&gt;考虑到之间已经写过很多文章了，搜索引擎都已收录，所以要保持原来的文章链接格式不变。在 Hugo 配置文件里面加上这段，使用文件名做文章永久链接：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[permalinks]
    archives = &amp;quot;/:year/:month/:day/:filename/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;存档&#34;&gt;存档&lt;/h3&gt;

&lt;p&gt;Octopress 默认的存档地址是 &lt;code&gt;archives&lt;/code&gt;，这个我们可以直接在 Hugo 博客目录 content 里面新建一个目录名为 archives 就可以了，以后新建文章都以这个 Section 为准：&lt;code&gt;hugo new archives/your-post-name.md&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;rss&#34;&gt;RSS&lt;/h3&gt;

&lt;p&gt;Octopress 默认的是 &lt;code&gt;atom.xml&lt;/code&gt;，然而 Hugo 中默认的是 &lt;code&gt;index.xml&lt;/code&gt;。不过我们可以在 Hugo 中做个配置，和之间保持一致：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;RSSUri = &amp;quot;atom.xml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而实际测试的时候在模板里面调用 &lt;code&gt;{{ .RSSlink }}&lt;/code&gt; 始终都返回 index.xml。手动把模板里面的 RSS 链接改成 &lt;code&gt;{{ .Site.BaseURL }}atom.xml&lt;/code&gt; 居然能生效？！这估计是 Hugo 的一个 bug。好在被发现了，要不然新老订阅 RSS 地址不一样事情就比较麻烦了&lt;/p&gt;

&lt;h3 id=&#34;分页&#34;&gt;分页&lt;/h3&gt;

&lt;p&gt;Octopress 默认的格式是 &lt;code&gt;posts/2&lt;/code&gt;，Hugo 中是 &lt;code&gt;posts/2&lt;/code&gt; 同样需要加个配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;paginatePath = &amp;quot;posts&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hugo-的几个基本概念&#34;&gt;Hugo 的几个基本概念&lt;/h2&gt;

&lt;p&gt;这几个概念主要在修改主题的时候能用到&lt;/p&gt;

&lt;h3 id=&#34;front-matter&#34;&gt;Front Matter&lt;/h3&gt;

&lt;p&gt;类似 markdown 文件的配置描述，用来配置文章的标题、时间、链接、分类等元信息，提供给模板调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;+++
title = &amp;quot;post title&amp;quot;
description = &amp;quot;description.&amp;quot;
date = &amp;quot;2012-04-06&amp;quot;
tags = [ &amp;quot;.vimrc&amp;quot;, &amp;quot;plugins&amp;quot;, &amp;quot;spf13-vim&amp;quot;, &amp;quot;vim&amp;quot; ]
categories = [
  &amp;quot;cat1&amp;quot;,
  &amp;quot;cat2&amp;quot;
]
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sections&#34;&gt;Sections&lt;/h3&gt;

&lt;p&gt;在 content 下面的一级目录，通常有分类的概念，但只是文件夹维度的物理隔离&lt;/p&gt;

&lt;h3 id=&#34;types&#34;&gt;Types&lt;/h3&gt;

&lt;p&gt;如果没有为文章指定 type 配置，文章默认就属于当前属的 Section，type 可以在 Front Matter 中指定，而
Section 不可以&lt;/p&gt;

&lt;h3 id=&#34;archetype&#34;&gt;Archetype&lt;/h3&gt;

&lt;p&gt;新建文章时候的默认模板，会带有指定的 Front Matter 头&lt;/p&gt;

&lt;h3 id=&#34;taxonomy&#34;&gt;Taxonomy&lt;/h3&gt;

&lt;p&gt;分类、标签、系列这种描述文章属性的都属于 Taxonomy Terms&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;Hugo 确实是一个不错的博客框架，配置简单、功能强大，很多东西都以「惯例」默认提供了，比如内置 TableOfContents，用来写博客足亦&lt;/p&gt;

&lt;p&gt;不过由于是 Go 语言写的，很多人并不知道有这么好用的一个东西，所以社区并不是很好。这可能就是所谓的编程的帮派论吧&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>简单方法解决 Macbook 电源接口接触不良的问题</title>
      <link>https://keelii.github.io/2016/10/04/rebuild-mbp-power-cord/</link>
      <pubDate>Tue, 04 Oct 2016 17:22:29 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/10/04/rebuild-mbp-power-cord/</guid>
      <description>&lt;p&gt;Macbook 电源用的时候久了，接口里面的几个针脚弹性变差，有时候接通电源然而灯不能亮&lt;/p&gt;

&lt;p&gt;在网上搜索了下发现一个好方法：&lt;strong&gt;接电源那头是突出金属的，稍微打磨下去一点就可以了&lt;/strong&gt;，亲测有效&lt;/p&gt;

&lt;p&gt;PS: 如果没有打磨工具可以直接找个空地面磨，有条件的话磨完再用砂纸抛光下就可以了&lt;/p&gt;

&lt;p&gt;来两张图片看看&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-10-04_09-43-57___SRC_6094.jpg&#34; alt=&#34;mbp-power-cord1&#34; /&gt;
&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-10-04_09-43-53___1719964175.jpg&#34; alt=&#34;mbp-power-cord2&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JavaScript 浏览器事件</title>
      <link>https://keelii.github.io/2016/09/29/javascript-browser-event/</link>
      <pubDate>Thu, 29 Sep 2016 17:22:29 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/09/29/javascript-browser-event/</guid>
      <description>&lt;h2 id=&#34;javascript-浏览器-事件之间的关系&#34;&gt;JavaScript、浏览器、事件之间的关系&lt;/h2&gt;

&lt;p&gt;JavaScript 程序采用了异步事件驱动编程（Event-driven programming）模型，维基百科对它的解释是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;事件驱动程序设计（英语：Event-driven programming）是一种电脑程序设计模型。这种模型的程序运行流程是由用户的动作（如鼠标的按键，键盘的按键动作）或者是由其他程序的消息来决定的。相对于批处理程序设计（batch programming）而言，程序运行的流程是由程序员来决定。批量的程序设计在初级程序设计教学课程上是一种方式。然而，事件驱动程序设计这种设计模型是在交互程序（Interactive program）的情况下孕育而生的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
简页言之，在 web 前端编程里面 JavaScript 通过浏览器提供的事件模型 API 和用户交互，接收用户的输入&lt;/p&gt;

&lt;p&gt;由于用户的行为是不确定的，也就是说不知道用户什么时候发生点击、滚动这些动作。这种场景是传统的同步编程模型没法解决的，因为你不可能等用户操作完了才执行后面的代码&lt;/p&gt;

&lt;p&gt;比如我们在 Python 里面调用接收用户输入的方法 &lt;code&gt;raw_input()&lt;/code&gt; 后终端就会一直等待用户的输入，直到输入完成才会执行后面的代码逻辑。但是在下面这段 NodeJS 代码中，接收用户输入的方法 &lt;code&gt;process.stdin.read&lt;/code&gt; 是在一个事件中调用的。后面的代码不会被阻塞（blocked）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#39;use strict&#39;;

process.stdin.on(&#39;readable&#39;, () =&amp;gt; {
    var chunk = process.stdin.read();
    if (chunk !== null) {
        process.stdout.write(`Async output data: ${chunk}`);
    }
});

process.stdin.on(&#39;end&#39;, () =&amp;gt; {
    process.stdout.write(&#39;end&#39;);
});

console.log(&#39;Will not be blocked&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事件驱动程序模型基本的实现原理基本上都是使用 &lt;a href=&#34;https://www.youtube.com/watch?v=8aGhZQkoFbQ&#34;&gt;事件循环（Event Loop）&lt;/a&gt;，这部分内容涉及浏览器事件模型、回调原理，有兴趣的去看链接里面的视频学习下&lt;/p&gt;

&lt;p&gt;需要说明的是在客户端 JavaScript 中像 setTimeout, XMLHTTPRequest 这类 API &lt;strong&gt;并不是&lt;/strong&gt; JavaScript 语言本身就有的。而是 JavaScript 的宿主环境（在客户端 JavaScript 中就是浏览器），同样像 DOM、BOM、Event API 都是浏览器提供的&lt;/p&gt;

&lt;h2 id=&#34;事件绑定的方法&#34;&gt;事件绑定的方法&lt;/h2&gt;

&lt;h3 id=&#34;dom-元素行内绑定&#34;&gt;DOM 元素行内绑定&lt;/h3&gt;

&lt;p&gt;直接在 DOM 元素上通过设置 &lt;code&gt;on + eventType&lt;/code&gt; 来绑定事件处理程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;#none&amp;quot; onclick=&amp;quot;alert(&#39;clicked.&#39;)&amp;quot;&amp;gt;点击我&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种绑定方法是最原始的，有两个缺点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 事件处理程序和 HTML 结构混杂在一起&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;早期在结构、样式、表现分离的时代很忌讳这一点。现在看来在很多 MVX 框架中将事件绑定和 DOM 结构放在一起处理，这样似乎更方便维护（不用来回切换 HTML,JavaScript 文件），而且也符合可预见（predictable）性的规则&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 命名空间冲突&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为 &lt;code&gt;onclick&lt;/code&gt; 中的 JavaScript 代码片段执行环境是全局作用域。然而在 JavaScript 语言中并没有相关的命名空间特性。所以就很容易造成命名空间的冲突，非要用这种方法绑定事件的话只能用对象来做一些封装&lt;/p&gt;

&lt;h3 id=&#34;古老的绑定方法&#34;&gt;古老的绑定方法&lt;/h3&gt;

&lt;p&gt;使用 DOM Element 上面的 &lt;code&gt;on + eventType&lt;/code&gt; 属性 API&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;#none&amp;quot; id=&amp;quot;button&amp;quot;&amp;gt;click me&amp;lt;/a&amp;gt;
&amp;lt;script&amp;gt;
    var el = getElementById(&#39;button&#39;);
    el.onclick = function() { alert(&#39;button clicked.&#39;) };
    el.onclick = function() { alert(&#39;button clicked (Rewrite event handler before).&#39;) };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法也有一个缺点，因为属性赋值会覆盖原值的。所以无法绑定 &lt;strong&gt;多个&lt;/strong&gt; 事件处理函数，如果我们要注册多个 onload 事件处理程序的话就得自己封装一个方法来防止这种事情发生，下面这个例子可以解决这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function addLoadEvent(fn) {
    var oldonLoad = window.onload;
    if (typeof oldonLoad !== &#39;function&#39;) {
        window.onload = fn;
    } else {
        window.onload = function() {
            oldonLoad();
            fn();
        }
    }
}

addLoadEvent(function() { alert(&#39;onload 1&#39;) });
addLoadEvent(function() { alert(&#39;onload 2&#39;) });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这只是个示例，生产环境很少会用到。一般用 DOM Ready 就可以了，因为 JavaScript 的执行通常不用等到页面资源全部加载完，DOM 加载完就可以了&lt;/p&gt;

&lt;h3 id=&#34;现代-标准的绑定方法&#34;&gt;现代/标准的绑定方法&lt;/h3&gt;

&lt;p&gt;标准的绑定方法有两种，&lt;code&gt;addEventListener&lt;/code&gt; 和 &lt;code&gt;attachEvent&lt;/code&gt; 前者是标准浏览器支持的 API，后者是 IE 8 以下浏览器支持的 API。通常需要我们做个兼容封装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function addEvent(target, type, handler) {
    if (target.addEventListener) {
        target.addEventListener(type, handler, false);
    } else {
        target.attachEvent(&#39;on&#39; + type, handler)
    }
}

addEvent(document, &#39;click&#39;, function() { alert(this === document) });
addEvent(document, &#39;click&#39;, function() { alert(this === document) });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子在 IE 8 以下和标准浏览器的效果是不一样的，问题就在于 &lt;code&gt;addEventListener&lt;/code&gt; 中的事件回调函数中的 this 指向元素（target）本身，而 &lt;code&gt;attachEvent&lt;/code&gt; 则指向 &lt;code&gt;window&lt;/code&gt; 为了修复这个问题上面的 attachEvent 可以做一点小调整让其保持和 &lt;code&gt;addEventListener&lt;/code&gt; 的效果一样，不过这样的话注册的 handler 就是个匿名函数，&lt;strong&gt;无法移除&lt;/strong&gt;！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function addEvent(target, type, handler) {
    if (target.addEventListener) {
        target.addEventListener(type, handler, false);
    } else {
        target.attachEvent(&#39;on&#39; + type, function() {
            return handler.call(target)
        });
    }
}

addEvent(document, &#39;click&#39;, function() { alert(this === document) });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当上面这几种情况同时出现的时候就比较有意思了，可以试试下面这段代码的你输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;javascript:alert(1)&amp;quot; onclick=&amp;quot;alert(2)&amp;quot; id=&amp;quot;link&amp;quot;&amp;gt;click me&amp;lt;/a&amp;gt;
&amp;lt;script&amp;gt;
    var link = document.getElementById(&#39;link&#39;);
    link.onclick = function() { alert(3); }

    $(&#39;#link&#39;).bind(&#39;click&#39;, function() { alert(4); });
    $(&#39;#link&#39;).bind(&#39;click&#39;, function() { alert(5); });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正确的结果应该是 &lt;code&gt;3,4,5,1&lt;/code&gt;，根据结果我们可以得出以下结论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;链接上的 href 伪 javascript 协议相当于在浏览器地址栏执行了一段 JavaScript 代码，链接如果是这种格式，点击的时候相当于执行了这段 JavaScript 脚本&lt;/li&gt;
&lt;li&gt;行内的事件绑定和元素调用 onclick 绑定事件会覆盖&lt;/li&gt;
&lt;li&gt;使用 jQuery（内部使用标准事件注册 API）可以绑定多个事件处理程序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;事件冒泡&#34;&gt;事件冒泡&lt;/h2&gt;

&lt;p&gt;大部分事件会沿着事件触发的目标元素往上传播。比如：&lt;code&gt;body&amp;gt;div&amp;gt;p&amp;gt;span&lt;/code&gt; 如果他们都注册了点击事件，那么在 span 元素上触发点击事件后 p,div,body 各自的点击事件也会按顺序触发&lt;/p&gt;

&lt;p&gt;事件冒泡是可以被停止的，下面这个函数封闭了停止事件冒泡的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function stopPropagation(event) {
    event = event || window.event;
    if (event.stopPropagation) {
        event.stopPropagation()
    } else {// IE
        event.cancelBubble = true
    }
}

addEvent(&#39;ele&#39;, &#39;click&#39;, function(e) {
    // click handler
    stopPropagation(e);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;事件对象&#34;&gt;事件对象&lt;/h2&gt;

&lt;p&gt;标准浏览器中在事件处理程序被调用时 &lt;strong&gt;事件对象&lt;/strong&gt; 会通过参数传递给处理程序，IE 8 及以下浏览器中事件对象可以通过全局的 &lt;code&gt;window.event&lt;/code&gt; 来访问。比如我们要获取当前点击的 DOM Element&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;addEvent(document, &#39;click&#39;, function(event) {
    // IE 8 以下 =&amp;gt; undefined
    console.log(event);
});
addEvent(document, &#39;click&#39;, function(event) {
    event = event || window.event;
    // 标准浏览器 =&amp;gt; [object HTMLHtmlElement]
    // IE 8 以下 =&amp;gt; undefined
    console.log(event.target);
    var target = event.target || event.srcElement;

    console.log(target.tagName);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;事件代理&#34;&gt;事件代理&lt;/h2&gt;

&lt;p&gt;有时候我们需要给 &lt;strong&gt;不存在的&lt;/strong&gt;（可能将来会有）的一段 DOM 元素绑定事件，比如给一段 Ajax 请求完成后渲染的 DOM 节点绑定事件。一般绑定的逻辑会在渲染前执行，绑定的时候找不到元素所以并不能成功，当然你也可以把绑定事件的代码放在 Ajax 请求之后。这样做在一些事件逻辑简单的应用里面没问题，但是会加重数据渲染逻辑和事件处理的逻辑耦合。一但事件处理程序特别多的时候，我们通常建议把事件的逻辑和其它代码逻辑分离，这样方便维护。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们通常使用事件代理/委托（Event Delegation ）。而且通常来说使用 &lt;strong&gt;事件代理的性能会比单独绑定事件高&lt;/strong&gt; 很多，我们来看个例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;
    &amp;lt;li id=&amp;quot;item-1&amp;quot;&amp;gt;item1&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;item-2&amp;quot;&amp;gt;item2&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;item-3&amp;quot;&amp;gt;item3&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;item-4&amp;quot;&amp;gt;item4&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;item-5&amp;quot;&amp;gt;item5&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如 &lt;code&gt;ul&lt;/code&gt; 中的 HTML 是 Ajax 异步插入的，通常我们的做法是 插入完成后遍历每个 li 绑定事件处理程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;script&amp;gt;
    function bindEvent(el, n) {
        addEvent(lis[i], &#39;click&#39;, function() { console.log(i); });
    }
    // 用 setTimeout 模拟 Ajax 伪代码
    setTimeout(function() {
        var ajaxData = &#39;&amp;lt;li id=&amp;quot;item-1&amp;quot;&amp;gt;item1&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-2&amp;quot;&amp;gt;item2&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-3&amp;quot;&amp;gt;item3&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-4&amp;quot;&amp;gt;item4&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-5&amp;quot;&amp;gt;item5&amp;lt;/li&amp;gt;&#39;;
        var ul = document.getElementById(&#39;list&#39;)
        ul.innerHTML(ajaxData);
        var lis = ul.getElementsByTagName(&#39;li&#39;);

        for (var i = 0; i &amp;lt; lis.length; i++) {
            bindEvent(lis[i], i);
        }
    }, 1000);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再使用事件代理把事件绑定到 &lt;code&gt;ul&lt;/code&gt; 元素上，我们知道很多事件可以冒并沿着 DOM 树传播到所有的父元素上，我们只需要判断目标元素是不是我们想绑定的真正元素即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;script&amp;gt;
function delegateEvent(el, eventType, fn) {
    addEvent(el, eventType, function(event) {
        event = event || window.event;
        var target = event.target || event.srcElement;
        fn(target);
    });
}

var el = document.getElementById(&#39;list&#39;);
// 用 setTimeout 模拟 Ajax 伪代码
setTimeout(function() {
    var ajaxData = &#39;&amp;lt;li id=&amp;quot;item-1&amp;quot;&amp;gt;item1&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-2&amp;quot;&amp;gt;item2&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-3&amp;quot;&amp;gt;item3&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-4&amp;quot;&amp;gt;item4&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-5&amp;quot;&amp;gt;item5&amp;lt;/li&amp;gt;&#39;;
    el.innerHTML(ajaxData)
}, 1000);

delegateEvent(el, &#39;click&#39;, function(target) {
    console.log(target.id);
});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然使用了事件代理之后，代码变少了。逻辑也很清晰，关键是以前需要 N 次的绑定操作现在只需要一次&lt;/p&gt;

&lt;h2 id=&#34;jquery-中的事件绑定&#34;&gt;jQuery 中的事件绑定&lt;/h2&gt;

&lt;p&gt;以 jQuery1.6.4 为例，jQuery 提供了很多事件绑定的 API。例如： &lt;code&gt;delegate()&lt;/code&gt;, &lt;code&gt;bind()&lt;/code&gt;, &lt;code&gt;click()&lt;/code&gt;, &lt;code&gt;hover()&lt;/code&gt;, &lt;code&gt;one()&lt;/code&gt;, &lt;code&gt;live()&lt;/code&gt;，这些方法其实都是一些别名，核心是调用了 jQuery 底层事件的 &lt;code&gt;jQuery.event.add&lt;/code&gt; 方法。其实现也是上文提到的 &lt;code&gt;addEventListener&lt;/code&gt; 和 &lt;code&gt;attachEvent&lt;/code&gt; 两个 API&lt;/p&gt;

&lt;p&gt;这些 API 主要是为了方便绑定事件的各种场景，并且内部处理好了兼容性问题。还有一个比较好用的地方就是 &lt;code&gt;事件命名空间&lt;/code&gt;。比如：两个弹出层都向 document 绑定了点击关闭事件，但是如果只想解绑其中一个。这时候使用命名空间再合适不过了。可以试试这个小例子 &lt;a href=&#34;http://jsbin.com/sacinereju/edit?html,output&#34;&gt;Event Binding&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document).bind(&#39;click.handler1&#39;, function() { console.log(1);})
$(document).bind(&#39;click.handler2&#39;, function() { console.log(2);})

$(document).unbind(&#39;click.handler2&#39;);   // 解除指定的
$(document).unbind(&#39;click&#39;);            // 解除所有点击事件
$(document).unbind()                    // 解除所有事件
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自定义事件与发布-订阅者设计模式&#34;&gt;自定义事件与发布/订阅者设计模式&lt;/h2&gt;

&lt;p&gt;自定义事件是设计模式中的 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85&#34;&gt;发布/订阅者&lt;/a&gt; 的一种实现。发布者与订阅者松散地耦合，而且不需要关心对方的存在。&lt;a href=&#34;https://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/&#34;&gt;这里&lt;/a&gt;有 NC 大师的一种实现。实际使用过程中，主要被运用在异步操作比较多的场景和不同系统之间消息通信，之前的&lt;a href=&#34;https://keelii.github.io/2016/07/31/something-have-to-say-with-JD-item/#TOC-25&#34;&gt;文章&lt;/a&gt;中有过一些实例&lt;/p&gt;

&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88&#34;&gt;事件驱动程序设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.quirksmode.org/js/introevents.html&#34;&gt;Introduction to Events&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/&#34;&gt;Custom events in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 15 - 脚本化文档</title>
      <link>https://keelii.github.io/2016/08/12/javascript-definitive-guide-note-13/</link>
      <pubDate>Fri, 12 Aug 2016 15:36:59 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/08/12/javascript-definitive-guide-note-13/</guid>
      <description>&lt;p&gt;每个 Window 对象有一个 document 属性引用了 Document 对象。Document 对象表示窗口的内容，它是一个巨大的 API 中的核心对象，叫做文档对象模型（Document Obejct Model, DOM），用来展示和操作文档内容&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;dom-概览&#34;&gt;DOM 概览&lt;/h2&gt;

&lt;p&gt;HTML 或 XML 文档的嵌套元素在 DOM 中以「树」的形式展示。HTML 文档的树装结构包含表示 HTML 标签或元素（如 body, p）和表示文本字符串的节点，也可能包含表示 HTML 注释的节点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Simple Document&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Heading&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;This is a &amp;lt;i&amp;gt;paragraph&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;置换成 DOM 树表示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
                    +------------+
                    |  Document  |
                    +-----+------+
                          |
                    +-----+------+
                    |   &amp;lt;html&amp;gt;   |
                    +-----+------+
                          |
     +--------------------+--------------------+
     |                                         |
+----+------+                             +----+-----+
|  &amp;lt;head&amp;gt;   |                             |  &amp;lt;body&amp;gt;  |
+----+------+                             +----+-----+
     |                                         |
+----+------+                     +------------+------------+
|  &amp;lt;title&amp;gt;  |                     |                         |
+-----------+                 +----+---+               +---------+
                              |  &amp;lt;h1&amp;gt;  |               |   &amp;lt;p&amp;gt;   |
+------------------+          +--------+               +---------+
| &amp;quot;Simple Document&amp;quot;|                                        |
+------------------+                            +-----------+-----------+
                                                |                       |
                                         +------+--------+         +----+-----+
                                         | &amp;quot;This is a&amp;quot;   |         |   &amp;lt;i&amp;gt;    |
                                         +---------------+         +----+-----+
                                                                        |
                                                                   +----+------+
                                                                   |&amp;quot;paragraph&amp;quot;|
                                                                   +-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上图中每个方框是文档的一个节点（node），它表示一个 Node 对象。注意树形的根部是 Document 节点，它代表整个文档。代表 HTML 元素的节点是 Element 节点。代表文本的节点是 Text 节点。Document、Element 和 Text 是 Node 的子类&lt;/p&gt;

&lt;h2 id=&#34;选取文档元素&#34;&gt;选取文档元素&lt;/h2&gt;

&lt;h3 id=&#34;通过-id-选择元素&#34;&gt;通过 ID 选择元素&lt;/h3&gt;

&lt;p&gt;HTML 元素可以有一个 id 属性，在文档中该值必须 &lt;strong&gt;唯一&lt;/strong&gt;，可以使用 getElementById() 方法选取一个基于唯一 ID 的元素&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var section1 = document.getElementById(&#39;selection1&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在低于 IE 8 版本的浏览器中，&lt;strong&gt;getElementById() 对匹配元素的 ID 不区分大小写，而且也返回匹配 name 属性的元素&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;通过名字选取元素&#34;&gt;通过名字选取元素&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var radiobuttons = document.getElementsByName(&#39;favorite_color&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getElementsByName() 定义在 HTMLDocument 类中，而不在 Document 类中，所以它 &lt;strong&gt;只针对 HTML 文档可用&lt;/strong&gt;，XML 中不可用。它返回一个 NodeList 对象，后者的行为类似一个包含若干 Element 对象的只读数组。在 IE 中，也会返回 id 属性匹配指定的元素&lt;/p&gt;

&lt;h3 id=&#34;通过标签名选取元素&#34;&gt;通过标签名选取元素&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 返回所有的 span 标签元素
var spans = document.getElementsByTagName(&#39;span&#39;);
// 返回所有元素
var allTags = document.getElementsByTagName(&#39;*&#39;);
// 选取第一个 span 里面的所有 a 标签
// Element 类也定义 getElementsByTagName() 方法，
// 它只取调用该方法的元素（spans）的后代元素
var links = spans[0].getElementsByTagName(&#39;a&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTMLDocument 对象还定义了两个属性，它们指代特殊的单个元素而不是集合：&lt;code&gt;document.body&lt;/code&gt; 是一个 HTML 文档的 &lt;body&gt; 元素；&lt;code&gt;document.head&lt;/code&gt; 是 &lt;head&gt; 元素。这些属性总是会定义的。&lt;strong&gt;即使文档中没有 head 或 body 元素，浏览器也将隐式地创建他们&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;getElementsByName() 和 getElementsByTagName() 都返回 NodeList 对象，而类似 document.images 和 document.forms 的属性为 HTMLCollection 对象。
这些对象都是只读类数组对象。有 length 属性，也可以被索引到，也可以进行循环迭代&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;通过-css-类选取元素&#34;&gt;通过 CSS 类选取元素&lt;/h3&gt;

&lt;p&gt;HTML 元素的 class 属性值是一个以空格隔开的列表，可以为空或者包含多个标识符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 查找 class 属性追念 warning 的所有元素
var warnings = document.getElementsByClassName(&#39;warning&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意除了 IE8 及以下低版本浏览器，getElementsByClassName() 在所有的浏览器中都实现了&lt;/p&gt;

&lt;h3 id=&#34;通过-css-选择器选取元素&#34;&gt;通过 CSS 选择器选取元素&lt;/h3&gt;

&lt;p&gt;CSS 样式表有一种非常强大的语法，那就是选择器，用来描述文档中的若干元素&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;#nav          // id=&amp;quot;nav&amp;quot; 的元素
div           // 所有 &amp;lt;div&amp;gt; 元素
.warning      // 所有 class 属性值包含 &amp;quot;warning&amp;quot; 的元素
p[lang=&amp;quot;fr&amp;quot;]  // 所有属性 lang 为 fr 的 &amp;lt;p&amp;gt; 元素
*[lang=&amp;quot;fr&amp;quot;]  // 所有属性 lang 为 fr 的元素
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;文档结构和遍历&#34;&gt;文档结构和遍历&lt;/h2&gt;

&lt;h3 id=&#34;作为节点树的文档&#34;&gt;作为节点树的文档&lt;/h3&gt;

&lt;p&gt;Document 对象、它的 Element 对象和文档中表示文本的 Text 对象都是 Node 对象。Node 对象有以下属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;parentNode&lt;/strong&gt; 该节点的父节点，Document 对象没有父节点，它的 parentNode 返回 null&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;childNodes&lt;/strong&gt; 只读的类数组对象（NodeList 对象），表示该节点的所有子节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;firstChild、lastChild&lt;/strong&gt; 该节点的子节点中的第一个或最后一个&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nextSibling、previoursSibling&lt;/strong&gt; 该节点的兄弟节点中的前一个或下一个&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nodeType&lt;/strong&gt; 该节点的类型

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;11&lt;/strong&gt; - DocumentFragment 节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;9&lt;/strong&gt; - Document 节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;8&lt;/strong&gt; - Comment 节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3&lt;/strong&gt; - Text 节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt; - Element 节点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nodeVlaue&lt;/strong&gt; Text 节点或 Comment 节点的文本内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nodeName&lt;/strong&gt; 元素标签名，以大写形式表示&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 注意删除了空格和换行
// &amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;Hello World!&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
document.childNodes[0].childNodes[1]      // =&amp;gt; body 节点
document.firstChild.firstChild.nextSibling // =&amp;gt; null title 节点的下个兄弟节点为 null
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;属性&#34;&gt;属性&lt;/h2&gt;

&lt;p&gt;HTML 元素由一个标签和一组称为属性（attribute）的名/值对组成&lt;/p&gt;

&lt;h3 id=&#34;html-属性作为-element-的属性&#34;&gt;HTML 属性作为 Element 的属性&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var image = document.getElementById(&#39;myimage&#39;);
var imgurl = image.src;

var f = document.forms[0];
f.action = &#39;http://www.example.com/submit.php&#39;;
f.method = &#39;POST&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTML 属性名不区分大小写，但是 JavaScript 则区分。用 JavaScript 取元素属性名的时候一般用小写，如果属性名是多个单词用驼峰式的规则，例如：defaultChecked、tabIndex。如果属性是 JavaScript 中的保留字，一般用 html 前缀，比如 for 属性，使用 htmlFor 来访问。class 则不同，使用 className 来访问&lt;/p&gt;

&lt;h3 id=&#34;获取和设置非标准-html-属性&#34;&gt;获取和设置非标准 HTML 属性&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var image = document.images[0];
// getAttribute 始终返回字符串
var width = parseInt(image.getAttribute(&#39;width&#39;))
image.setAttribute(&#39;class&#39;, &#39;thumbnail)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数据集属性&#34;&gt;数据集属性&lt;/h3&gt;

&lt;p&gt;有时候在 HTML 元素上绑定一些额外的信息会很有帮助（通常给 JavaScript 来读取），一般可以把信息存储在 HTML 属性上&lt;/p&gt;

&lt;p&gt;HTML 5 提供了一个解决文案。在 HTML 5 文档中，任意以「data-」为前缀的小写的属性名称都是合法的。这些「数据集属性」将不会对元素表示产生影响&lt;/p&gt;

&lt;p&gt;HTML 5 还在 Element 对象上定义了 dataset 属性。该属性指代一个对象，它的各个属性对应于去掉前缀的 data- 属性。因此 dataset.x 应该保存 data-x 属性的值。带连字符的属性对应于驼峰命名法属性名：data-jquery-test 属性就变成 dataset.jqueryTest 属性&lt;/p&gt;

&lt;h3 id=&#34;作为-html-的元素内容&#34;&gt;作为 HTML 的元素内容&lt;/h3&gt;

&lt;p&gt;读取 Element 的 innerHTML 属性作为字符串标记返回那个元素的内容。设置元素的 innerHTML 属性则调用 Web 浏览器的解析器，用新的字符串内容解析替换当前内容&lt;/p&gt;

&lt;p&gt;通常来说设置 innerHTML 效率很高，但是对 innerHTML 属性使用「+=」操作符时效率比较低下，因为它既要序列化又要解析&lt;/p&gt;

&lt;p&gt;HTML 5 还标准化了 outerHTML 属性，表示返回包含标签本身的 HTML 内容&lt;/p&gt;

&lt;p&gt;另外 IE 引入了一个 insertAdjacentHTML() 方法，它将任意的 HTML 标记字符串插入到指定的元素「相邻」的位置。标记是该方法的第二个参数。并且「相邻」的精确含义依赖于第一个参数的值。第一个参数为具有以下值之一的字符串：「beforebegin」、「afterbegin」、「beforeend」、「afterend」&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    |&amp;lt;div id=&amp;quot;target&amp;quot;&amp;gt;|This is the element content|&amp;lt;/div&amp;gt;|
    |                 |                           |      |
 beforebegin     afterbegin                  beforeend afterend
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;作为纯文本的元素内容&#34;&gt;作为纯文本的元素内容&lt;/h3&gt;

&lt;p&gt;查询线文本形式的元素内容，
标准的方法是 Node 的 textContent 属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var para = document.getElementsByTagName(&#39;p&#39;)[0]
var text = para.textContent;
para.textContent = &#39;Hello World!&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;textContent 属性除 IE 其它浏览器都支持，不支持的可以用 innerText 属性来代替。textContent 属性就是将指定元素所有的后代 Text 节点简单地串联在一起。但是和 textContent 不同。innerText 不返回 script 元素的内容，它会忽略多余空白，并试图保留表格格式。同时 innerText 针对某些表格元素（如 table、tbody、tr）是只读的属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function textContente(e) {
    var child, type, s = &#39;&#39;;
    for (child = e.firstChild; child != null; child = child.nextSibling ) {
        type = child.nodeType;
        if ( type === 3 || type === 4 )
            s += child.nodeValue;
        else if ( type === 1 )
            s += textContent(child);
    }
    return s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建-插入和删除节点&#34;&gt;创建、插入和删除节点&lt;/h2&gt;

&lt;p&gt;一个简单的动态插入脚本的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function loadasyn(url) {
    var head = document.getElementsByTagName(&#39;head&#39;)[0];
    var s = document.createElement(&#39;script&#39;);
    s.src = url;
    head.appendChild(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建节点&#34;&gt;创建节点&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.createElement(&#39;script&#39;)
document.createTextNode(&#39;text node content&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种创建新文档节点的方法是复制已存在的节点。第个节点有一个 cloneNode() 方法来返回该节点的一个全新副本。给方法传递参数 true 也能够递归地复制所有后代节点，或传递参数 false 只执行一个浅复制&lt;/p&gt;

&lt;h3 id=&#34;插入节点&#34;&gt;插入节点&lt;/h3&gt;

&lt;p&gt;下面代码展示了 insertBefore() 和 appendChild() 方法使用场景&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function insertAt(parent, child, n) {
    if ( n &amp;lt; 0 || n &amp;gt; parent.childNodes.length ) throw new Error(&#39;invalid index&#39;);
    else if ( n == parent.childNodes.length ) parent.appendChild(child);
    else parent.insertBefore(child, parent.childNodes[n]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;删除和替换节点&#34;&gt;删除和替换节点&lt;/h3&gt;

&lt;p&gt;removeChild() 方法删除一个子节点并用一个新的节点取而代之&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;n.parentNode.removeChild(n);
n.parentNode.replaceChild(document.createTextNode(&#39;[ REDACTED ]&#39;), n)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-documentfragment&#34;&gt;使用 DocumentFragment&lt;/h3&gt;

&lt;p&gt;DocumentFragment 是一种特殊的 Node，它作为其他节点的一个临时窗口。像这样创建一个 DocumentFragment：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var frag = document.createDocumentFragment();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像 Document 节点一样，DocumentFragment 是独立的，而不是任何其他文档的一部分。它的 parentNode 总是 null。但类似 Element，它可以有任意多的子节点，可以用 appendChild()、insertBefore() 等方法来操作它们&lt;/p&gt;

&lt;h2 id=&#34;文档和元素的几何开头和滚动&#34;&gt;文档和元素的几何开头和滚动&lt;/h2&gt;

&lt;h3 id=&#34;文档坐标和视口坐标&#34;&gt;文档坐标和视口坐标&lt;/h3&gt;

&lt;p&gt;元素的位置是以像素来表示的，向右代表 X 坐标增加，向下代表 Y 坐标增加。但是，有两个不同的点作为坐标系原点：元素的 X 和 Y 坐标可以相对于文档的左上角或者相对于在其中显示文档的视口左上角。在顶级窗口和标签页中，「视口」只是实际显示文档内容的浏览器的一部分：它 &lt;strong&gt;不包括&lt;/strong&gt; 浏览器「外壳」（如菜单、工具条和标签页）。针对框架页中显示的文档，视口是定义了框架页的 iframe 元素。无论在何种情况下，当讨论元素的位置时，必须弄清楚所使用的坐标是文档坐标还是视口（窗口）坐标&lt;/p&gt;

&lt;p&gt;如果文档比视口要小，或者说它还未出现滚动，则文档的左上角就是视口的左上角，文档和视口坐标系统是同一个。但是，一般来说，要在两种坐标系之间互相转换，必须加上或者减去滚动的偏移量（scroll offset）&lt;/p&gt;

&lt;p&gt;为了在坐标系之间互相转换，我们需要判定浏览器窗口的流动条的位置。Window 对象的 pageXOffset 和 pageYOffset 属性在所有浏览器中提供这些值。除了 IE 8 以及更早的版本以外。也可以使用 scrollLeft 和 scrollTop 属性来获得滚动条的位置。令人迷惑的是，正常情况下通过查询文档的根节点（document.documentElement）来获取这些属性值，但在怪异模式下，必须在文档的 body 元素上查询它们，下面这个是一种兼容方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getScrollOffsets(w) {
    w = w || window;
    if ( w.pageXOffset != null ) return { x: w.pageXOffset, y: pageYOffset };

    var d = w.document;
    if ( document.compatMode == &#39;CSS1Compat&#39; )
        return { x: d.documentElement.scrollLeft, y: d.documentElement.scrollTop };

    return { x: d.body.scrollLeft, y: d.body.scrollTop };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查询元素的尺寸&#34;&gt;查询元素的尺寸&lt;/h3&gt;

&lt;p&gt;判定一个元素的尺寸和位置最简单的方法是调用它的 getBoundingClientRect() 方法。该方法是在 IE 5 中引入的，而珔当前的所有浏览器都实现了（然而并非如此）。它不需要参数，返回一个有 left, right, top 和 bottom 属性的对象&lt;/p&gt;

&lt;h3 id=&#34;滚动&#34;&gt;滚动&lt;/h3&gt;

&lt;p&gt;window 对象的 scrollTop() 方法接受一个点的 X 和 Y 坐标，并作为滚动条的偏移量设置它们。也就是窗口滚动到指定的点出现在视口的左上角&lt;/p&gt;

&lt;h3 id=&#34;关于元素尺寸-位置和溢出更多的信息&#34;&gt;关于元素尺寸、位置和溢出更多的信息&lt;/h3&gt;

&lt;p&gt;getBoundingClientRect() 方法在所有当前的浏览器上都有定义，但如果需要支持老式浏览器就不行了。元素的尺寸比较简单：任何 HTML 元素的只读属性 offsetWidth 和 offsetHeight 以 CSS 像素返回它的屏幕尺寸。返回尺寸 &lt;strong&gt;包含&lt;/strong&gt; 元素的边框和内边距，除去了外边距&lt;/p&gt;

&lt;p&gt;所有 HTML 元素拥有 offsetLeft 和 offsetTop 属性来返回元素的 X 和 Y 坐标。对于很多元素，这些值是文档坐标，并直接指定元素的位置。&lt;strong&gt;但对于已定位的元素的后代元素和一些其他元素（如表格），这些属性返回的坐标是相对于祖先元素的而非文档。&lt;/strong&gt; offsetParent 属性指定这些属性所相对的父元素。如果 offsetParent 为 null，这些属性都是文档坐标，因此，一般来说用 offsetLeft 和 offsetTop 来计算元素 e 的位置需要一个循环：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getElementPosition(e) {
    var x = 0, y = 0;
    while (e != null) {
        x += e.offsetLeft;
        y += e.offsetTop;
        e = e.offsetParent;
    }
    return { x: x, y: y };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了这些名字以 offset 开头的属性外，所有的文档元素定义了其它的两组属性，基名称一组以 client 开头，另一组以 scroll 开头。即，每个 HTML 元素都有以下这些属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;offsetWidth         clientWidth          scrollWidth
offsetHeight        clientHeight         scrollHeight
offsetLeft          clientLeft           scrollLeft
offsetTop           clientTop            scrollTop
offsetParent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clientWidth 和 clientHeight 类似 offsetWidth 和 offsetHeight，不同的是它们 &lt;strong&gt;不包含边框大小&lt;/strong&gt;，只包含内容和它的内边距。同时，如果浏览器在内边距和边框之间添加了滚动条，clientWidth 和 clientHeight 在其返回值中也不包含滚动条。内联元素，clientWidth 和 clientHeight 总是返回 0&lt;/p&gt;

&lt;h2 id=&#34;html-表单&#34;&gt;HTML 表单&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;表 15-1 HTML 表单元素&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;HTML 元素&lt;/th&gt;
&lt;th&gt;类型属性&lt;/th&gt;
&lt;th&gt;事件处理程序&lt;/th&gt;
&lt;th&gt;描述和事件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;button&amp;rdquo;&amp;gt; or&lt;br&gt; &amp;lt;button type=&amp;ldquo;button&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“button”&lt;/td&gt;
&lt;td&gt;onclick&lt;/td&gt;
&lt;td&gt;按钮&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;checkbox&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“checkbox”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;复选按钮&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;file&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“file”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;文件域，value 属性只读&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;hidden&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“hidden”&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;数据由表单提交，但对用户不可见&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;option&amp;gt;&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;Select 对象的单个选项，事件对象 &lt;br&gt; 在 Select 对象上，而不是 option&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;password&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“password”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;密码输出框，输入的字符不可见&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;radio&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“radio”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;单选按钮&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;reset&amp;rdquo;&amp;gt; or&lt;br&gt; &amp;lt;button type=&amp;ldquo;reset&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“reset”&lt;/td&gt;
&lt;td&gt;onclick&lt;/td&gt;
&lt;td&gt;重置表单按钮&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;select&amp;gt;&lt;/td&gt;
&lt;td&gt;“select-one”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;单选下拉框&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;select multiple&amp;gt;&lt;/td&gt;
&lt;td&gt;“select-multiple”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;多选列表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;submit&amp;rdquo;&amp;gt; or&lt;br&gt; &amp;lt;button type=&amp;ldquo;submit&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“submit”&lt;/td&gt;
&lt;td&gt;onclick&lt;/td&gt;
&lt;td&gt;表单提交按钮&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;text&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“text”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;单行文本输出域；type 默认 text&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;textarea&amp;gt;&lt;/td&gt;
&lt;td&gt;“textarea”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;多行文本输入域&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;选择框和选项元素&#34;&gt;选择框和选项元素&lt;/h3&gt;

&lt;p&gt;Select 元素表示用户可以做出选择的一组选项（用 Option 元素表示）。浏览器通常将其渲染为下拉菜单的形式，但当指定其 size 属性值大于 1 时，它将显示为列表中的选项（可能有滚动条）。Select 元素的 multiple 属性决定了 Select 是不是可以多选&lt;/p&gt;

&lt;p&gt;当用户选取或取消一个选项时， Select 元素触发 onchange 事件。针对「select-one」属性的 Select 元素，它的可读/写属性 selectedIndex 指定了哪个选项当前被选中。针对「select-multiple」元素，单个 selectedIndex 属性不足以表示被选中的一组选项。这种情况下需要遍历 options[] 数组的元素，检测每个 Option 对象的 selected 属性。注意 Option 并没有相关事件处理程序，一般只能给 Select 元素绑定事件&lt;/p&gt;

&lt;h2 id=&#34;其他文档特性&#34;&gt;其他文档特性&lt;/h2&gt;

&lt;h3 id=&#34;document-的属性&#34;&gt;Document 的属性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cookie&lt;/strong&gt; 允许 JavaScript 读、写 HTTP cookie 的属性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;domain&lt;/strong&gt; 允许当 Web 页面交互时，相同域名下互相信任的 Web 服务器之间协作放宽同源策略安全限制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lastModified&lt;/strong&gt; 包含文档修改时间的字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;location&lt;/strong&gt; 与 Window 对象的 location 属性引用同一个 Location 对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;referrer&lt;/strong&gt; 如果有，它表示浏览器来到当前页面的上一个页面。与 HTTP 的 Referer 头信息内容相同&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;title&lt;/strong&gt; 文档中 title 标签的内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;URL&lt;/strong&gt; 文档的 URL，只读字符串而不是 Location 对象。该属性值与 location.href 的 &lt;strong&gt;初始值&lt;/strong&gt;相同，不会发生变化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;document-write-方法&#34;&gt;document.write() 方法&lt;/h3&gt;

&lt;p&gt;document.write() 会将其字符串参数连接起来，然后将结果字符串插入到文档中调用它的脚本元素的位置。当脚本执行结束，浏览器解析生成输出并显示它。例如，下面代码把信息输出到一个静态的 HTML 文档中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
    document.write(&#39;Document title: &#39; + document.title);
    document.write(&#39;URL: &#39; + document.URL);
    document.write(&#39;Referred by: &#39; + document.referrer);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;只有在解析文档时才能使用 write() 方法输出 HTML 到当前文档中&lt;/strong&gt;。也就是说能够在 script 元素的顶层代码中调用 document.write()，就是因为这些脚本的执行是文档解析流程的一部分。如果将 docuemnt.write() 放在一个函数的定义中，而该函数的调用是从一个事件处理程序中发起的，产生的结果未必是你想要的——事实上，它会擦除当前文档和它包含的脚本。同理，在设置了 defer 或 async 属性的脚本中不要使用 document.write()&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>京东单品页前端开发那些不得不说的事儿</title>
      <link>https://keelii.github.io/2016/07/31/something-have-to-say-with-JD-item/</link>
      <pubDate>Sun, 31 Jul 2016 10:48:57 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/07/31/something-have-to-say-with-JD-item/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;详情页也叫做单品页，域名以「item.jd.com/skuid.html」为格式的页面。是负责展示京东商品 SKU 的落地页。主要任务是展示和商品相关的信息，如：价格、促销、库存、推荐，从而引导用户进入购买流程。同时单品页有很多版本。一般分为两类。一类我们通常看到的「通用类目详情页」—— 所有类目都可以使用，一类是不经常看到的「垂直属性详情页」—— 一些有特殊属性的商品集合&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-07-31_04-14-43___item-version.png&#34; alt=&#34;item version&#34; /&gt;&lt;/p&gt;

&lt;p&gt;首先。由于详情页大量（sku上亿）、高并发（日 pv 约 5000 万）等特性，在很长的一段时间里，单品页面都是后端程序生成静态页面使用 CDN 来解决大量、高并发的问题&lt;/p&gt;

&lt;p&gt;其次。单品页涉及的「三方」系统特别多，比如：促销、库存、合约、秒杀、预售、推荐、IM、店铺、评价社区。而单品页的主要任务就是展示这些系统的信息，并且适当的处理他们之间的冲突关系，而这些系统的接口一般都使用 异步 Ajax 来完成，因为 其一 CDN 无法做到页面的动态化，其二 一些系统的信息对实时性要求特别高（价格、秒杀），即使使用后端动态渲染也很难做到无缓存 0 延迟&lt;/p&gt;

&lt;p&gt;基于上面两个原因，注定了单品页是一种重多系统业务逻辑展示型页面。重前端页面。我大概汇总了一下页面上异步接口，总共约有 30 个，页首屏的接口特别重要，接口之间几乎都有耦合关系&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-07-31_06-17-42___async-service.png&#34;&gt;&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-07-31_06-17-42___async-service.png&#34; alt=&#34;item-async-service&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;前端的发展历程&#34;&gt;前端的发展历程&lt;/h2&gt;

&lt;h3 id=&#34;混沌时期&#34;&gt;混沌时期&lt;/h3&gt;

&lt;p&gt;混沌时期的单品页并没有前端开发的概念。核心的功能脚本只有三个：促销价格（promotion.js）、库存地区（iplocation.js）、其它逻辑（pshow.js）。这三个脚本分别是三个不同团队的同事负责维护，当时我刚进入京东的时候在 UED 部门，负责页面脚本整体的维护工作和 pshow的开发。那时候我自己维护的 pshow.js 脚本压缩后只有 80 kb，所有的代码都是过程式的，没有任何使用模式和代码技巧，JS 最多也只被用来做个判断渲染 DOM。那时候的前端工作内容只在 UI 层面，写样式和一些交互脚本&lt;/p&gt;

&lt;p&gt;这个阶段给我最深刻的感觉是单品页后端模板很少维护（后端架构是最老的 aspx 版本）。大多数的改动都要用 JavaScript 去动态渲染。因为后端页面是一个生成器生成的。如果页面后端模板有改动那么就需要全量的生成一次，过程可能需要几个小时&lt;/p&gt;

&lt;h3 id=&#34;初见端倪&#34;&gt;初见端倪&lt;/h3&gt;

&lt;p&gt;当我接手这个项目时刚好有一次大改版，就在这时候老大说页面上的脚本都要放在我们手里维护。然后就是一大波的重构、重写。基本上 pshow 被重写了大概 80% 其它的因为业务逻辑的问题并没有完全重写，只是做了些代码层面的优化&lt;/p&gt;

&lt;p&gt;有一个模板引擎叫 &lt;a href=&#34;http://code.google.com/p/trimpath/&#34;&gt;trimPath&lt;/a&gt;，知道这个的估计都算老前端的了。最早的客户端 JavaScript MVC 模式代表作品，只到现在还是使用。这个阶段像评价这种完全异步加载的模块特别适合使用模板引擎来减少维护的工作量。这个时候虽然页面上的代码并不都是我们写的，但基本上前端对页面的 JavaScript 有了控制权，接下来的事情就是寻找机会逐个优化&lt;/p&gt;

&lt;p&gt;这段时间是最痛苦的时候，维护的工作统一到前端。然后后端几乎没有变化，只是在一段时间将后台的架构从 aspx 过渡到了 java。本质上并没有什么改变。前端却做了比以前更多的事情，也是在这个时候我接手了大量的维护工作（包含全站公共库的维护）使得我意识到了一些自动化、工程化方面的重要性，后文会主要讲解，顺便说下，那时候前端自动化工具 Grunt 刚面世，但是我自己却用的是 &lt;a href=&#34;http://ant.apache.org/&#34;&gt;apache ant&lt;/a&gt;，不过不久就切换到了 Grunt 来构建项目&lt;/p&gt;

&lt;h3 id=&#34;拨云见日&#34;&gt;拨云见日&lt;/h3&gt;

&lt;p&gt;单品页不仅重系统逻辑，也重维护&lt;/p&gt;

&lt;p&gt;在这段时间里一方面有正常的维护类需求要做，一方面自己也不断的学习新知识为以后的改版做铺垫。不过就在这时单品页有历史意义的一次技改出现了 —— 单品页动态化技改。关于后端部分的改造细节可以去 &lt;a href=&#34;http://jinnianshilongnian.iteye.com/blog/2235572&#34;&gt;开涛的文章&lt;/a&gt; 了解&lt;/p&gt;

&lt;p&gt;总的来说这次的改版后很多数据直接从后端读取，不再从前端异步获取而且我们也做过一些异步加载的优化，多接口 combo 从统一服务吐出给前端使用。这时前端就不用再为异步接口的加载时苦脑了，只需要专注系统接口的逻辑&lt;/p&gt;

&lt;p&gt;随着这次技改，前端的代码也迎来了模块化的时代。我们把所有的前端代码都进行了模块化然后基于 SeaJS 重写，配合 Nginx concat 功能实现了本地模块化开发，线上服务端合并&lt;/p&gt;

&lt;h2 id=&#34;单品页前端模块的结构与划分&#34;&gt;单品页前端模块的结构与划分&lt;/h2&gt;

&lt;h3 id=&#34;概览&#34;&gt;概览&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-07-31_09-34-48___first-screen-normal-module.png&#34;&gt;&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-07-31_09-34-48___first-screen-normal-module.png&#34; alt=&#34;first-screen-normal-module&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上图可以看出，基本上最核心的模块都在首屏。每个模块都有单独的一/多个脚本。代码行数（LOC）由 230+ ~ 1200+ 不等。通常来说代码行数越多代码复杂性就越高，逻辑越复杂。很难想象「购买方式」这种只有一行属性选择功能的代码行数却 &lt;strong&gt;高达 1200 多行&lt;/strong&gt;。其主要原因就在于购买方式所在的系统和其它首屏核心系统（库存、促销、地址选择、白条）都有逻辑上的耦合&lt;/p&gt;

&lt;p&gt;看着不错，然而在一个前端工程师眼里至少应该是这样的（我只取了一些典型的模块，并不是全部）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-07-31_10-25-02___first-screen-in-fe-eye.png&#34;&gt;&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-07-31_10-25-02___first-screen-in-fe-eye.png&#34; alt=&#34;first-screen-in-fe-eye&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这就可以解释为什么有的时候只是加一个很小的东西我们都为考虑再三然后通过 AB 测试提取相关数据，最后后再进行决策。单品页的首屏可以说是寸土寸金&lt;/p&gt;

&lt;h3 id=&#34;按什么维度划分模块&#34;&gt;按什么维度划分模块&lt;/h3&gt;

&lt;p&gt;起初我按模块的属性划分，比如：核心、公共脚本、模块脚本。但用了一段时候以后发现这样划分在单品这种大型系统中并不科学，因为这样划分出来的代码只有划分的人知道是什么规则，其它人接手代码很难快速掌握代码架构，而且尤其在模块比较多的时候不方便维护&lt;/p&gt;

&lt;p&gt;后来我尝试完全以功能模块在页面上出现的位置维度划分。这样以来维护起来方便多了，需要修改某个模块代码只需要对照着图里面标识的模块信息就能轻易找到代码&lt;/p&gt;

&lt;h3 id=&#34;整体核心模块&#34;&gt;整体核心模块&lt;/h3&gt;

&lt;p&gt;我们按页面上的模块结构首屏划分出来这几个核心模块：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;curmb - 面包屑&lt;/li&gt;
&lt;li&gt;concat - 联系咨询相关店铺信息&lt;/li&gt;
&lt;li&gt;prom - 价格促销信息&lt;/li&gt;
&lt;li&gt;address - 地区库存选择，配送服务&lt;/li&gt;
&lt;li&gt;color - 颜色尺码&lt;/li&gt;
&lt;li&gt;buytype - 合约机购买方式&lt;/li&gt;
&lt;li&gt;suits - 套装购买&lt;/li&gt;
&lt;li&gt;jdservice - 增值服务&lt;/li&gt;
&lt;li&gt;baitiao - 白条支付&lt;/li&gt;
&lt;li&gt;buybtn - 购买按钮&lt;/li&gt;
&lt;li&gt;info - 地区提示信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;项目的整体树形结构是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-07-31_11-09-56___project-structure.png&#34; alt=&#34;project-structure&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;模块内部结构&#34;&gt;模块内部结构&lt;/h3&gt;

&lt;p&gt;比如下面这个大图预览的功能，我全部放在一个文件夹里面维护，但是逻辑上的 JavaScript 模块是分离的，只是说文件夹（preview）就代表页面上的某一部分功能集合&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-07-31_10-45-41___module-structure.png&#34; alt=&#34;module-structure&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意文件夹的命名有一定的规则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;模块脚本与样式名必须一样&lt;/li&gt;
&lt;li&gt;需要制作 sprite 的图片统一放在 module/i 目录下面，生成的 sprite 图片也在其中&lt;/li&gt;
&lt;li&gt;生成的 mixin 在模块根目录下，便于其它样式文件调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们再来看下自动生成生成的 __sprite.scss 是什么内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/* __sprite.scss 自动生成 */
@mixin sprite-arrow-next {
    width: 22px;
    height: 32px;
    background-image: url(i/__sprite.png);
    background-position: -0px -30px;
}

/* preview.scss 手动添加 */
@import &amp;quot;./__sprite&amp;quot;;
.sprite-arrow-next {
    @include sprite-arrow-next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意引用的 mixin 名称和我们需要手动添加的样式类名一致。当然也可以直接生成一个类名对应的样式，但是灵活性不好。比如 hover 的时候是另外一张图片就没法自动生成了&lt;/p&gt;

&lt;h2 id=&#34;前端技能树&#34;&gt;前端技能树&lt;/h2&gt;

&lt;h3 id=&#34;html&#34;&gt;HTML&lt;/h3&gt;

&lt;h4 id=&#34;dom-节点数&#34;&gt;DOM 节点数&lt;/h4&gt;

&lt;p&gt;与重业务逻辑的页面不同，重展示的页面一般具有很高的 DOM 节点数。比如京东首页，正常情况加载完页面一共有 3500 多个 DOM 节点，基本上全部用于展示商品信息、广告图和内容布局，页面上的三方异步服务也比较少。尤其像频道页基本上没有什么业务上的逻辑，全部是静态页面。这种页面的特点是更新换代频率高，一年两三次改版很正常，CMS 做模块化后两天换个皮肤都是没问题的。但是这种思路并不适合单品页。单品页更重业务逻辑，同时展示层 UI 逻辑也有很多关系&lt;/p&gt;

&lt;p&gt;我自己的经验是：页面上的 DOM 节点数绝对不能超过 5000 个，否则页面滚动的时候就会出现卡顿的情况，尤其是移动端&lt;/p&gt;

&lt;h4 id=&#34;同步渲染还是异步加载&#34;&gt;同步渲染还是异步加载&lt;/h4&gt;

&lt;p&gt;理论情况下最好做法是后端同步动态渲染页面，但是由于 Web 应用中很多功能都是用户行为驱动的。同步加载不可避免的消耗了后端服务资源。比如：非首屏模块（公共头尾、评价）、点击事件触发的 DOM 内容（异步 tab）&lt;/p&gt;

&lt;p&gt;所以我的经验是：能放到后端做判断渲染的 DOM 就尽量放在后端（尤其是首屏）。这样做的好处有四点好处&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;后端渲染页面相对稳定，不像前端 JavaScript 动态渲染 DOM，可能因为脚本报错或者不可用造成模块都无法展示&lt;/li&gt;
&lt;li&gt;可访问性、SEO 及用户体验也比较好。不会产生脚本的渲染抖动问题&lt;/li&gt;
&lt;li&gt;一定程度上减少了前端渲染页面的复杂性，减少前端代码复杂度&lt;/li&gt;
&lt;li&gt;逻辑统一到一个地方维护起来也方便，而且后端应该为业务逻辑负责，前端应该为展示UI 交互负责&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于异步渲染的模块来说，后端通常需要判断 &lt;strong&gt;「页面有什么元素」&lt;/strong&gt;，以及元素之间的依赖对应关系；而前端需要专注于 &lt;strong&gt;「元素应该怎么展示」&lt;/strong&gt;，UI 层面的交互以及模块与模块之前的逻辑关系&lt;/p&gt;

&lt;p&gt;其实更多的时候 异步是一种没有办法的办法，也就是说异步是其它方案都解决不了的情况下才考虑的&lt;/p&gt;

&lt;h4 id=&#34;外链静态资源&#34;&gt;外链静态资源&lt;/h4&gt;

&lt;p&gt;尽量使用外链 CSS 和 JavaScript 资源，一方面便于缓存，减少服务同步输出的资源浪费。IE 6 里面会有一些可怪的 bug，比如有内联样式 style 标签的页面 A 如果在另外一个页面 B 中的 link 标签中引用，那么这段 style 会在 B 页面也起作用&lt;/p&gt;

&lt;h4 id=&#34;使用双协议的-url&#34;&gt;使用双协议的 URL&lt;/h4&gt;

&lt;p&gt;使用 &lt;code&gt;//&lt;/code&gt; 来代替&lt;code&gt;http:&lt;/code&gt; 和 &lt;code&gt;https:&lt;/code&gt; 浏览器会自动适应两种协议的资源访问，兼容性较好。注意 IE 8 下使用脚本更新 src 为双协议时会出现 bug，建议使用 &lt;code&gt;location.protocol&lt;/code&gt; 来判断然后做兼容处理&lt;/p&gt;

&lt;h4 id=&#34;删除元素默认属性&#34;&gt;删除元素默认属性&lt;/h4&gt;

&lt;p&gt;比如 script 标签默认的 type 就是 &lt;code&gt;text/javascript&lt;/code&gt;，如果 script 里面的内容是 JavaScript 时可以不用写 type。另外如果要在页面里面插入一段不需要浏览器解析的 HTML 片段时可以将 type 写成 &lt;code&gt;text/x-template&lt;/code&gt;（任意不存在的 type） 用于放置模板文件，通常用来在脚本中获取其 innerHTML 而无任何负作用&lt;/p&gt;

&lt;h4 id=&#34;给脚本控制元素加上类钩子&#34;&gt;给脚本控制元素加上类钩子&lt;/h4&gt;

&lt;p&gt;在脚本中取页面元素使用 &lt;code&gt;J-&lt;/code&gt; 前缀类名，与普通样式类分离。这样做会生成很多冗余的类名，但却很好的降低了样式和脚本的耦合，并且在重构和脚本职位分开团队里会是一条最佳实践&lt;/p&gt;

&lt;h3 id=&#34;css&#34;&gt;CSS&lt;/h3&gt;

&lt;h4 id=&#34;样式分类&#34;&gt;样式分类&lt;/h4&gt;

&lt;p&gt;所有页面只共享一个 sass Mixin，里面包含了基础的 sass 语法糖、常用类（清浮动、页面整体颜色字体等）&lt;/p&gt;

&lt;p&gt;模块级的样式分为两类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;与脚本无关的公共样式，单独在模块文件夹中组织。比如：按钮、标签页。全部放在 common 模块中维护&lt;/li&gt;
&lt;li&gt;与脚本相关的模块级样式，与对应模块脚本放在一起，可以引用 common 中的公共样式，但不可以被其它模块引用&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;雪碧图&#34;&gt;雪碧图&lt;/h4&gt;

&lt;p&gt;关于雪碧图 我经验是：永远不要想把所有的图标拼合在一起。按模块而不是按页面去拼 sprite 更合理，更方便维护，然后配合构建工具自动接合生成样式文件才是最好的解决方案。当然如果你的页面比较简单，那这条规则并不适用。说到这个问题我就得把珍藏多年的图片拿出来 show 一把，用事实来说明为什么把所有图片都拼在一张图上就一定是对的&lt;/p&gt;

&lt;p&gt;早期由于年轻笃信将所有的 icon 拼在一张图上才是完美的（图 1）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-08-04_01-42-51___640.png&#34; alt=&#34;first-sprite&#34; /&gt;&lt;/p&gt;

&lt;p&gt;后来维护起来实在不方便，就把按钮全部单独接合起来。注意，当时的按钮都是图片，设计方面要求的很严格。加入购物车按钮做的也非常漂亮（图 2）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-08-04_01-42-50___640_1.png&#34; alt=&#34;button-sprite&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后这些都不是最典型的，下面这个 promise icon 才是 （图 3）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-08-04_01-42-50___640_2.png&#34; alt=&#34;promise-sprite&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图里面可以看到，这个功能在第一个版本的时候只有 7 个 icon，后来不断增加，最多的时候达到 77 个。以至于当时每周都会添加两个的频率&lt;/p&gt;

&lt;p&gt;同时这个 icon 当时接合的时候技术上也有问题：不应该把文字也切到图片里面，主要原因是早期 icon 比较少加上外边框样式对齐的问题综合选择了直接使用图片&lt;/p&gt;

&lt;p&gt;后来我就觉得这样是不对的。然后通过和产品的沟通，说明我的考虑以及新的解决方案后得到了认同。结果就是对图片不进行拼合，后台上传经过审核的不带文字 icon，文字由接口输出，然后在产品上做了约定：icon 最多不能超过 4 个，代码里也做了相应限制。这样就能保证页面上的请求数不会太多同时方便系统维护，问题得到了解决&lt;/p&gt;

&lt;h4 id=&#34;适当使用-datauri&#34;&gt;适当使用 DataURI&lt;/h4&gt;

&lt;p&gt;这个在一些小图片场景方面特别适合，比如 1*1 的占位图、loading 图等，不过 IE 6 并不支持这种写法，需要的时候可以加上一些兼容写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.ELazy-loading {
    background: url(data:image/gif;base64,R0lGODlhKwAeAJEAAP///93d3Xq9VAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFFAAAACwDAA0AJQADAAACEpSPAhDtHxacqcr5Lm416f1hBQAh+QQJFAAAACwDAA0AJQADAAACFIyPAcLtDKKcMtn1Mt3RJpw53FYAACH5BAkUAAAALAMADQAlAAMAAAIUjI8BkL0CoxQtrYrenPjcrgDbVAAAOw==) center center no-repeat;
    *background-image: url(//misc.360buyimg.com/lib/skin/e/i/loading-jd.gif);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;关于兼容性&#34;&gt;关于兼容性&lt;/h4&gt;

&lt;p&gt;兼容性可以说是前端工程师在平常开发中花费很大量无意义工作的地方。关于兼容性我想说的是 &lt;strong&gt;如果你不愿意去说服周围的人放弃或者让他们意识到兼容性是个不可能完全解决的问题，那么你就得为那些低级浏览器给你带来的痛苦埋单&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实更好的办法是你和设计、产品沟通然后给出一种分级支持的方案。把每种浏览器定义一个级别。然后在开发功能的时候以「渐进增强」的方式。通常来讲我们的解决方案是在低级浏览器里面保证流程正常进行、模块可以使用，但忽略一些无关紧要的错位、不透明等问题，在高级浏览器里面需要对设计稿进行精确还原，适当的加上一些井上添花在细节。比如微小的动画、逻辑细节上的处理等&lt;/p&gt;

&lt;p&gt;举个例子吧，下面这个进度条表示预约的人数，它是接口异步加载完才展示的。如果加载完就立即设置进度条宽度会显得生硬无趣，但是如果加上一点动画效果的话就好多了。然而问题又来了，如果加上动画那么逻辑上这个进度条应该是一点点的增加，对应的人数也应该是逐个增加。于是我就做了个优化，让人数在这段时间内均匀的增加。这个细节并不是很容易被人发现，但是这种设计会让用户感觉很用心而且有意思&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-07-31_13-31-29___pingou-count.gif&#34; alt=&#34;pingou&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7i7iqa.com1.z0.glb.clouddn.com/note___1___2016-07-31_14-07-24___item-javascript-exec-sequence.png&#34; alt=&#34;javascript-exec-sequence&#34; /&gt;&lt;/p&gt;

&lt;p&gt;单品页的脚本加载/执行顺序：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;等待页面准备就绪（DOM Ready）&lt;/li&gt;
&lt;li&gt;准备就绪后加载入口脚本（main.js），脚本负责其它功能模块的调度，动态接合模块通过 seajs 的 &lt;code&gt;require.async&lt;/code&gt; 方法异步调用&lt;/li&gt;
&lt;li&gt;公共模块（common.js）负责加初始化全局变量并挂载到 pageConfig 命名空间&lt;/li&gt;
&lt;li&gt;动态模块数组，这个是后端通过程序判断处理生成的一个模块名列表。一般只包含首屏需要加载的模块&lt;/li&gt;
&lt;li&gt;后加载模块（lazyinit.js）初始化，这个脚本只做一些页面滚动才加载的模块事件绑定。当模块出现在视口内再使用 require.async 异步加载模块的资源及初始化&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;入口脚本&#34;&gt;入口脚本&lt;/h4&gt;

&lt;p&gt;大致代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
* 模块入口（1. 公共脚本 2. 首屏模块资源 3. 非首屏「后加载模块」）
*/
var entries = [];

// 页面公共脚本样式
entries.push(&#39;common&#39;);
// 页面使用到的首屏模块(后端开发根据页面不同配置需要调用的模块)
entries = entries.concat(config.modules);
// 非首屏「后加载模块」
entries.push(&#39;lazyinit&#39;);

for (var i = 0; i &amp;lt; entries.length; i++) {
    entries[i] = &#39;MOD_ROOT/&#39; + entries[i] + &#39;/&#39; + entries[i];
}

if (/debug=show_modules/.test(location.href)) console.log(entries);

require.async(entries, function() {
    var modules = Array.prototype.slice.call(arguments);
    var len = modules.length;

    for (var i = 0; i &amp;lt; len; i++) {
        var module = modules[i];

        if (module &amp;amp;&amp;amp; typeof module.init === &#39;function&#39;) {
            module.init(config);
        } else {
            console.warn(&#39;Module[%s] must be exports a init function.&#39;, entries[i]);
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意模块路径中的 &lt;code&gt;MOD_ROOT&lt;/code&gt; 是提前在页面定义好的一个 seajs path。目的是为了把前端版本号更新的控制权释放给后端，从而解决了前后端依赖上线不同步造成的缓存延迟问题，配置脚本中只有几个定义好的路径：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;seajs.config({
    paths: {
        &#39;MISC&#39; : &#39;//misc.360buyimg.com&#39;,
        &#39;MOD_ROOT&#39; : &#39;//static.360buyimg.com/item/default/1.0.12/components&#39;,
        &#39;PLG_ROOT&#39; : &#39;//static.360buyimg.com/item/default/1.0.12/components/common/plugins&#39;,
        &#39;JDF_UI&#39;   : &#39;//misc.360buyimg.com/jdf/1.0.0/ui&#39;,
        &#39;JDF_UNIT&#39; : &#39;//misc.360buyimg.com/jdf/1.0.0/unit&#39;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一点，在测试环境的页面中版本号（上面代码中的 1.0.12 是一个全量的版本号）是后端从 URL 上动态读取的（使用参数访问就可以命中对应版本 &lt;code&gt;item.jd.com/sku.html?version=1.0.12&lt;/code&gt;）。这样以来测试环境上就可以并行测试不同版本的需求，而且互不影响。当然如果不同版本的后端代码也有修改的话这样是不行的，因为后端代码也需要有个对应的版本号&lt;/p&gt;

&lt;p&gt;不过我们已经解决了这个问题。后端会在测试环境里 &lt;strong&gt;动态加载后端模板&lt;/strong&gt; 并且可以做到版本号与前端一致。这样以来配合 git 方便的分支策略就可以同时并行开发测试多个需求，不用单独配多个测试环境。什么？你还在使用 SVN！哦。那当我没说过&lt;/p&gt;

&lt;h4 id=&#34;事件处理模型&#34;&gt;事件处理模型&lt;/h4&gt;

&lt;p&gt;客户端的 JavaScript 代码基本上都是事件驱动的，代码的加载解析依赖于浏览器提供的 DOM 事件。比如 onload, mouseover, scroll 等&lt;/p&gt;

&lt;p&gt;事件驱动的的模型特别适用于异步编程，而 JavaScript 天生就是异步，所有的异步操作行为都最终会在一个回调函数（callback）中触发&lt;/p&gt;

&lt;p&gt;比如单品页中价格接口，加载完成后需要更新 DOM 元素来展示实时价格；地区选择接口加载完成后会更新配送信息、库存/商品状态等，伪代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/* onPriceReady 和 onAreaChange 可以认为都是一个 Ajax 异步函数调用
 * code 1 和 code 2 执行到的时间是不确定先后顺序的
 */
/* prom.js */
onPriceReady(function(price) {
    // code 1
    $(&#39;#price&#39;).html(price);
});

/* address.js */
onAreaChange(function(area) {
    // code 2
    $(&#39;#stock&#39;).html(area.stockInfo);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的两段代码分别在两个脚本中维护，因为他们的逻辑相对独立。早期并没有关联关系。后来需求有变，他们之间需要共享一些对方的数据（切换地区后需要重新获取价格数据并展示）。但是物理上又不能放在一起通过使用全局变量的方式共享，而且它们都是异步加载接口后才取到数据的，并不好确定谁先谁后（非要做到那就只能用全局变量双向判断）。所以这样并不能很好的解决问题，而且代码的耦合度会成倍增加&lt;/p&gt;

&lt;p&gt;这时候我们引入了一种设计模式来解决这种问题 —— &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85&#34;&gt;发布者/订阅者&lt;/a&gt;，我们把这种模式抽象成了自定义事件代码来解决这一问题。这段代码是由 YUI 核心开发者 &lt;a href=&#34;https://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/&#34;&gt;Nicholas C. Zakas&lt;/a&gt; 实现的。代码很简单，事件对象主要有两个方法 &lt;code&gt;addListener(type, listener)&lt;/code&gt; 和 &lt;code&gt;fire(event)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;于是我们重构了上面的伪代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/* prom.js */
// 在代码中注册一个地区变化事件，获取变化后的地区 id
// 然后重新请求价格接口并展示
Event.addListener(&#39;onAreaChange&#39;, function(data) {
    getAreaPrice(data.areaIds)
});

onPriceReady(function(price) {
    $(&#39;#price&#39;).html(price);

    Event.fire({
        type: &#39;onPriceReady&#39;,
        data: &#39;Any data you want&#39;
    })
});

/* address.js */
onAreaChange(function(area) {
    $(&#39;#stock&#39;).html(area.stockInfo);

    // 在地区变化后除了做自己该做的事情以外
    // 触发一个名为 onAreaChange 的事件，用来
    // 通知其它订阅者事件完成，并传递地区相关参数
    // 这个时候在 onAreaChange Ajax 回调函数
    // 中就只需要关心自己的逻辑，其它模块的耦合关系
    // 交给它们自己通过订阅事件来处理
    Event.fire({
        type: &#39;onAreaChange&#39;,
        data: area.ids
    })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的一点是，&lt;strong&gt;必须确保事件先注册后触发执行&lt;/strong&gt;，也就是说先 addListener， 再 fire&lt;/p&gt;

&lt;h4 id=&#34;一些典型的性能优化点&#34;&gt;一些典型的性能优化点&lt;/h4&gt;

&lt;p&gt;基本上客户端的 JavaScript 性能问题都来自于 DOM 查找和遍历，在用于的时候一定要小心，可能不经意的一个操作就会损失很多性能，尤其在低端浏览器中。顺便多说一点，现代的 JavaScript 解释器本身是很快的，语言层面的性能问题很少遇到。DOM 查找慢是因为 浏览器给 JavaScript 访问页面提供的一套 DOM API 本身慢&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;缓存 DOM 查找，同时 DOM 查找不要超过 2000 个，低级浏览器会卡顿&lt;/li&gt;
&lt;li&gt;不要使用链式调用 find，如：&lt;code&gt;find(&#39;li&#39;).find(&#39;a&#39;)&lt;/code&gt; 而是 &lt;code&gt;find(&#39;li a&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在切换元素显示状态的时候，如果元素很多。优先使用 &lt;code&gt;show()/hide()&lt;/code&gt; 方法，而不是 &lt;code&gt;css(&#39;display&#39;, &#39;block/none&#39;)&lt;/code&gt; 前者有缓存，后者会强制触发 reflow&lt;/li&gt;
&lt;li&gt;给节点添加 &lt;code&gt;data-xx&lt;/code&gt; 属性在存放一些数据，通过使用 jQuery 的 &lt;code&gt;data(&#39;xx&#39;)&lt;/code&gt; 方法取更高效，减少 DOM 属性访问&lt;/li&gt;
&lt;li&gt;高密度事件（scroll, mousemove）触发场景请使用节流方法&lt;/li&gt;
&lt;li&gt;使用事件代理，而不是直接绑定。如果不确定代码被调用次数，可以先解除绑定再绑定具有命名空间的事件处理函数&lt;/li&gt;
&lt;li&gt;尽量少用 DOM 动画，使用 CSS 3 动画代替&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;前端工程化&#34;&gt;前端工程化&lt;/h2&gt;

&lt;h3 id=&#34;原由&#34;&gt;原由&lt;/h3&gt;

&lt;p&gt;前端工程化其实并不是最近两年才有的概念。大约在 2013 年的时候 Grunt 问世的时候就已经有所涉及。这类打包工具主要的目的是自动化一些开发流程，我最早使用 Grunt 来构建代码的时候只解决了三个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;合并压缩优化样式脚本&lt;/li&gt;
&lt;li&gt;上线完自动备份&lt;/li&gt;
&lt;li&gt;单个文件打包到多目录（历史原因一个文件线上的路径有两种，需要传两个目录）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当时我还在组内做过一个分享，有兴趣的可以去围观一下 &lt;a href=&#34;https://speakerdeck.com/keelii/best-workflow-with-grunt&#34;&gt;Best Workflow With Grunt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其实这些工具出现的原因是：当时前端领域的各种基础设施很缺乏，而前端的工作内容又相对零散。工作时需要开很多的软件。再加上 JavaScript 语言本身也很弱，就连包管理这种基础的东西也没有内置，以至于模块化要通过一些第三方类库来实现，比如：RequireJS, SeaJS&lt;/p&gt;

&lt;p&gt;工具的重要性可以在我之前的一个分享中找到 &lt;a href=&#34;https://speakerdeck.com/keelii/qian-duan-kai-fa-gong-ju&#34;&gt;前端开发工具系列&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;现状&#34;&gt;现状&lt;/h3&gt;

&lt;p&gt;如今前端工程的生态环境由于 NodeJS 的出现已经变得很好了。你可以根据自己的需求选一个合适的直接用到项目里面。像 Grunt, Gulp, browserify, webpack 等。不过要明白这些工具的出现从另一方面证明了前端开发天生存在很多的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTML 从诞生到 HTML 5 之前几乎没有任何变化，DOM 性能天生缺失。所以才有了 Virtual DOM 这种东西&lt;/li&gt;
&lt;li&gt;CSS 只是一门描述型的语言，没有变量、逻辑控制、语句。所以才出现了 Sass, Less 这种预编译工具&lt;/li&gt;
&lt;li&gt;JavaScript 号称「高阶的（high-level）、动态的（dynamic）、弱类型的（untyped）解释型（interpreted）编程语言，适合面向对象（oop）和函数式的（functional）编程风格」的编程语言，但是语言本身有很多问题（ES 6 之前）。不适合大型项目的开发、没有一些高级特性的支持、同时被其它语言诟病的 callback 风格、单线程执行等。所以才出现了像 TypeScript, Babel 这种编译成 JavaScript 代码的语言&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些问题几乎都是历史性的原因和兼容性因素造成的。作为一名好的前端工程师要看清楚现状，然后按自己项目的需求去定制一些前端工程化的方案，而不是随波逐流。&lt;/p&gt;

&lt;h3 id=&#34;选择&#34;&gt;选择&lt;/h3&gt;

&lt;p&gt;其实现在自己开发一套前端工程化/自动化流程的成本已经很低了，你只需要学习一些 NodeJS 的知识，配合 NPM 包管理机制，随手就搞出一个构建工具出来。因为并不需要你去实现什么东西，所有的东西都有现成的包。脚本压缩有 UglifyJS，CSS 优化有 CSS-min，图片压缩优化有 PNG-quant 等等。你只需要想清楚自己要达到什么目的，解决什么问题就可以抄家伙自己写一套工作流出来&lt;/p&gt;

&lt;p&gt;我自己的经历也从 Grunt, GulpJS 到现在自造轮子。自己根据需求开发出来一套集成的打包工具，有兴趣的可以去围观一下 &lt;a href=&#34;https://github.com/keelii/wo&#34;&gt;Wooo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然你也可以不用任何打包工具，自己写一些 NPM Script 来完全定制化项目开发/测试/打包流程。我猜这也是为什么现在类似 Grunt 不再那么火，Gulp 迟迟没有发布 4.0 版本的原因。写一个构建工具的成本太低了，而且这种集成的工具很难满足差异的开发需求。君不知已有人意识到了这一点么&lt;a href=&#34;https://medium.freecodecamp.com/why-i-left-gulp-and-grunt-for-npm-scripts-3d6853dd22b8&#34;&gt;why-i-left-gulp-and-grunt-for-npm-scripts&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;程序-设计-产品&#34;&gt;程序、设计、产品&lt;/h2&gt;

&lt;p&gt;我始终认为程序、设计是为了产品服务的。好的产品是要重视设计的，好的（前端）工程师是要有一些审美素养&lt;/p&gt;

&lt;p&gt;其实很多时候技术解决方案都是要根据产品的定位来设计的，了解产品需求以后才能定制出真正合适的高效的解决方案。好比前面讲到的那个 sprite 案例，如果一开始就和产品讨论好方案后来也不可能有那种失控的情况发生。在产品形成/上线前期能发现问题比上线后发现问题更容易解决&lt;/p&gt;

&lt;p&gt;这部分内容和代码无关，就不多说了。然而早年我还有一次分享关于&lt;a href=&#34;https://speakerdeck.com/keelii/qian-duan-,gai-bian-front%5Bnil%5Dend-makes-change&#34;&gt;前端、改变&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;关于单品页的前端开发本篇文章只是冰山一角，还有很多没有提及，每个小东西都可以单独写一篇文章来分享。随后希望可以有更多的总结和分享&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 14 - Window 对象</title>
      <link>https://keelii.github.io/2016/07/26/javascript-definitive-guide-note-12/</link>
      <pubDate>Tue, 26 Jul 2016 11:35:42 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/07/26/javascript-definitive-guide-note-12/</guid>
      <description>&lt;p&gt;本章介绍 Window 对象的属性和方法&lt;/p&gt;

&lt;h2 id=&#34;计时器&#34;&gt;计时器&lt;/h2&gt;

&lt;p&gt;setTimeout() 和 setInterval() 可以用来注册指定时间之后调用的函数，不同的是 setInterval 会在指定毫秒数的间隔里重复调用。它们都返回一个值，这个值可以传递给 clearInterval/clearTimeout，用于取消后续函数的调用

由于历史原因（通常不建议这么做），setTimeout 和 setInterval 的第一个参数可以作为字符串传入。如果是字符串，当到达指定时间时相当于执行 eval 字符串内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 4 秒后显示 log
var t1 = setTimeout(function () {
    console.log(&#39;show after 4s&#39;);
}, 4000);

function fn() { console.log(&#39;show every 1s&#39;); }
setTimeout(&#39;fn()&#39;, 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;浏览器定位和导航&#34;&gt;浏览器定位和导航&lt;/h2&gt;

&lt;p&gt;Window 对象的 location 属性引用的是 Location 对象，它表示窗口中当前显示的文档 URL。并且定义了方法来使窗口载入新的文档&lt;/p&gt;

&lt;p&gt;Document 对象上的 location 属性也引用到 Location 对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.location = document.location
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Document 对象也有一个 URL 属性，是文档首次载入后保存的该文档的 URL 静态字符串。如果定位到文档中的片段标识符（如#table-of-content，其实就是锚点），Location 对象会做相应的更新，&lt;strong&gt;而 document.URL 属性不会&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;解析-url&#34;&gt;解析 URL&lt;/h2&gt;

&lt;p&gt;Location 对象的 href 属性是一个字符串，后者包含 URL 的完整文本。Location 对象的 toString() 方法返回 href 属性的值，因此会隐式调用 toString() 的情况下，可以使用 location 代替 location.href&lt;/p&gt;

&lt;p&gt;这个对象的其它属性——protocol, host, hostname, port, pathname 和 search 分别表示 URL 的各个部分。它们称为「URL 分解」属性，同时被 link 对象（通过 HTML 文档中的 a 和 area 元素创建）支持&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17127989/2285a748-533c-11e6-946d-a1d129e845c7.gif&#34; alt=&#34;url&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;载入新的文档&#34;&gt;载入新的文档&lt;/h3&gt;

&lt;p&gt;Location 对象的 assign() 方法可以使用窗口载入并显示你指定的 URL 中的文档。replace() 方法也类似，但它在 &lt;strong&gt;载入新文档之前会从浏览器历史中把当前文档删除&lt;/strong&gt;，assign 会产生一个新的历史记录，也就是说可以使用浏览器的返回按钮到上一页，replace 则不行&lt;/p&gt;

&lt;h2 id=&#34;浏览历史&#34;&gt;浏览历史&lt;/h2&gt;

&lt;p&gt;Window 对象的 history 属性用来把窗口的浏览历史用文档和文档状态列表的形式表示。history 对象的 length 属性表示浏览历史列表中的元素数量，但是脚本并不能访问已保存的 URL&lt;/p&gt;

&lt;p&gt;history 对象的 bace() 和 forward() 方法与浏览器的「后退」和「前端」按钮一样。go() 方法接收一个整数参数，可以在历史列表中向前（正数）或向后（负数）跳过任意多个页&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;history.go(-2);     // 后退两个历史记录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果窗口包含多个子窗口（比如 iframe 元素），子窗口的浏览历史也会被记录，这音中着在主窗口调用 history.back() 可能会使子窗口跳转而主窗口不变&lt;/p&gt;

&lt;h2 id=&#34;浏览器和屏幕信息&#34;&gt;浏览器和屏幕信息&lt;/h2&gt;

&lt;h3 id=&#34;navigator-对象&#34;&gt;navigator 对象&lt;/h3&gt;

&lt;p&gt;Window 对象的 navigator 属性引用的是包含浏览器厂商和版本信息的 navigator 对象。navigator 有四个属性用于提供关于运行中的浏览器版本信息，并且可以用来做浏览器嗅探&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;appName&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Web 浏览器的全称。在 IE 中，就是「Microsoft Internet Explorer」，在 Firefox 中就是「Netscape」&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;appVersion&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此属性通常以数字开始，并跟着包含浏览器厂商和版本信息的详细字符串。字符串前面的数字通常是 4.5 或 5.0，表示它是第 4 或 5 代兼容的浏览器&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;userAgent&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;浏览器在它的 USER-AGENT HTTP 头部中发送的字符串。这个属性通常包含 appVersion 中的所有信息，以及其它细节&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;platform&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在其上运行浏览器的操作系统字符串&lt;/p&gt;

&lt;h3 id=&#34;screen-对象&#34;&gt;screen 对象&lt;/h3&gt;

&lt;p&gt;screen 对象提供有关窗口显示的大小和可用的颜色数量信息，属性 width 和 height 指定的是以像素为单位的窗口大小。属性 avilWidth 和 avilHeight 指定的是实际可用的显示大小，它们排除了像浏览器任务栏这样的特性所占用的屏幕空间&lt;/p&gt;

&lt;h2 id=&#34;对话框&#34;&gt;对话框&lt;/h2&gt;

&lt;p&gt;Window 对象提供了 3 个方法来向用户显示简单的对话框。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;alert()&lt;/strong&gt; 向用户显示一条消息并等待用户关闭
&lt;strong&gt;confirm()&lt;/strong&gt; 也显示一条消息并要求用户单击「确定」或「取消」，并返回一个布尔值
&lt;strong&gt;prompt()&lt;/strong&gt; 也显示一条消息并等待用户输入字符串，并返回那个字符串&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;do {
    var name = prompt(&#39;What is your name?&#39;);
    var correct = confirm(&#39;You entered: &#39; + name + &#39;\n\
                            Click OK to processed or Cancel to re-enter&#39;)
} while(!correct)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三个方法都会产生阻塞，也就是说，在用户关掉它们所显示的对话框之前，它们不会返回，这就意味着在弹出一个对话框前，代码就会停止运行。如果当前正在载入文档，也会停止载入。直到用户用要求的输入进行响应为止&lt;/p&gt;

&lt;h2 id=&#34;错误处理&#34;&gt;错误处理&lt;/h2&gt;

&lt;p&gt;Window 对象的 onerror 属性是一个事件处理程序，当未捕获的异常传播到调用栈上的时候就会触发它，并把错误消息输出到浏览器的 JavaScript 控制台上，onerror 事件处理函数调用通过三个字符串参数，而不是事件对象。分别是&lt;code&gt;错误信息&lt;/code&gt;、&lt;code&gt;产生错误的页面地址&lt;/code&gt;、&lt;code&gt;错误源代码的行号&lt;/code&gt;，onerror 的返回值也很重要，如果 onerror 处理程序返回 false，表示它通知浏览器事件处理程序已经处理错误了，不需要其它操作。Firefox 则刚好相反&lt;/p&gt;

&lt;h2 id=&#34;作为-window-对象属性的文档元素&#34;&gt;作为 Window 对象属性的文档元素&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如果 HTML 文档中用 id 属性来为元素命名，并且如果 Window 对象没有此名字的属性（并且这个id是个合法的标识符），Window 对象会赋予一个属性，它的名字就是 id 属性的值&lt;/strong&gt;，而它的值指向表示文档元素的 HTMLElement 对象&lt;/p&gt;

&lt;p&gt;元素 ID 作为全局变量的隐式应用是 Web 浏览器进化过程中遗留的问题，主要是出于兼容性的考虑。&lt;strong&gt;但并不推荐使用这种做法&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;多窗口和窗体&#34;&gt;多窗口和窗体&lt;/h2&gt;

&lt;p&gt;Web 浏览器的窗口中每一个标签页都是独立的「浏览上下文」（browsing context），每一个上下文都有独立的 Window 对象，而且相互之间不干扰，也不知道其他标签页的存在&lt;/p&gt;

&lt;p&gt;但是窗口并不总是和其它窗口完全没关系，因为可以通过脚本打开新的窗口或标签页。如果这么做就可以通过脚本跨窗口进行操作（参照之前的 &lt;a href=&#34;https://keelii.github.io/2016/07/14/javascript-definitive-guide-note-11/#TOC-16&#34;&gt;同源策略&lt;/a&gt;）&lt;/p&gt;

&lt;h3 id=&#34;打开和关闭窗口&#34;&gt;打开和关闭窗口&lt;/h3&gt;

&lt;p&gt;使用 Window 对象的 open() 方法可以打开一个新的浏览器窗口&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;var windowObjectReference = window.open(url, name, [features]);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第一个参数 &lt;code&gt;url&lt;/code&gt; 是要在新窗口中显示文档的 URL，如果参数省略，默认会使用空页面的 URL about:blank&lt;/p&gt;

&lt;p&gt;第二个参数 &lt;code&gt;name&lt;/code&gt; 表示打开窗口的名字，如果指定的是一个已经存在的窗口名字（并且脚本允许跳转到那个窗口），会直接用已存在的窗口。否则，会打开新的窗口，并将这个指定的名字赋值给它。如果省略此参数，会使用指定的名字「_blank」打开一个新的未命名窗口&lt;/p&gt;

&lt;p&gt;第三个参数 &lt;code&gt;features&lt;/code&gt;（非标准）是一个以逗号分隔的列表，包含表示打开窗口的大小和各种属性&lt;/p&gt;

&lt;p&gt;open() 也可以有第四个参数，且只在第二个参数命名的是一个存在的窗口时才有用。它是一个布尔值，𡔬了由第一个参数指定的 URL 是应用替换掉窗口浏览器历史的当前条目（true），还是应该在窗口浏览历史中创建一个新的条目（false），后者是默认设置&lt;/p&gt;

&lt;p&gt;open() 的返回值是代表命名或新创建的窗口的 Window 对象。可以在自己的 JavaScript 代码中使用这个 windows 对象来引用新创建的窗口，就像用隐式的 Window 对象 window 来引用运行代码的窗口一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var w = window.open();
w.alert(&#39;About to visit http://jd.com&#39;);
w.location = &#39;http://jd.com&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由 window.open() 方法创建的窗口中，opener 属性引用的是打开它的脚本的 Window 对象，在其它窗口中，opener 为 null&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;w.opener !== null;      // =&amp;gt; true
w.open().opener === w   // =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;关闭窗口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;像 open() 方法一样，close() 用来关闭一个（脚本打开的）窗口，注意，&lt;strong&gt;大多数浏览器只允许自己关闭自己的 JavaScript 代码创建的窗口&lt;/strong&gt;，要关闭其它窗口，可以用一个对话框提示用户，要求他关闭窗口的请求进行确认。在表示窗体而不是顶级窗口或者标签页上的 Window 对象上执行 close() 方法不会有任何效果，它不能关闭一个窗体&lt;/p&gt;

&lt;p&gt;即使一个窗口关闭了，代表它的 Window 对象 &lt;strong&gt;仍然存在&lt;/strong&gt;。已关闭的窗口会有一个值为 true 的 closed 属性，它的 document 会是 null， 它的方法通常也不会再工作&lt;/p&gt;

&lt;h3 id=&#34;窗体之间的关系&#34;&gt;窗体之间的关系&lt;/h3&gt;

&lt;p&gt;任何窗口中的 JavaScript 代码都可以将自己的窗口引用为 window 或 self。窗体可以用 parent 属性引用包含它的窗口的 Window 对象。如果一个窗口是顶级窗口或标签，那么其 parent 属性引用的就是这个窗口本身：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;parent.history.back();
parent == self;            // 只有顶级窗口才会返回 true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个窗体包含在另一个窗体中，而后者又包含在顶级窗口中，那么该窗体就可以使用 parent.parent 来引用顶级窗口。top 属性是一个通用的快捷方式，无论一个窗体被嵌套几层，它的 top 属性引用的都是指向包含它的顶级窗口。如果一个 Window 对象代表的是一个顶级窗口，那么它的 top 属性就是窗口本身。对于那些顶级窗口的直接子窗体，top 属性就等价于 parent 属性&lt;/p&gt;

&lt;p&gt;parent 和 top 属性允许脚本引用它的窗体的祖先。有不止一种方法可以引用窗口的子孙窗体。窗口是通过 iframe 元素创建的，可以获取其他元素的方法来获取一个表示 iframe 的元素对象，iframe 元素有 contentWindow 属性，引用该窗体的 Window 对象。也可以反向操作，使用 Window 对象的 frameElement 属性来引用被包含的 iframe 元素，对于顶级窗口来说 Window 对象的 frameElement 属性为 null&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 假设页面有一个 id=&amp;quot;f1&amp;quot; 的 iframe 元素
var iframeElement = document.getElementById(&#39;f1&#39;);
var iframeWindowObject = iframeElement.contentWindow;
// 对于 iframe 来说永远是 true
iframeWindowObject.frameElement === iframeElement
// 对于顶级窗口来说 frameElement 永远是 null
window.frameElement === null;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个 window 上都会有一个 frames 属性，表示当前窗口里面引用的窗口。frames 是个类数组对象，并可以通过数字或者窗体名称（如 iframe name 属性）进行索引。注意 frames 元素引用的是窗口的 Window 对象，而不是 iframe 元素&lt;/p&gt;

&lt;h3 id=&#34;交互窗口中的-javascript&#34;&gt;交互窗口中的 JavaScript&lt;/h3&gt;

&lt;p&gt;每个窗口都是它自身的 JavaScript 执行上下文，以 window 做为全局对象&lt;/p&gt;

&lt;p&gt;设想一个 Web 页面里面有两个 iframe 元素，分别叫「A」和「B」，并假设这些窗体所包含的文档来自于相同的一个服务器，并且包含交互脚本。我们在窗体 A 里的脚本定义了一个变量 i：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个变量只是全局对象的一个属性，也是 Window 对象的一个属性。窗体 A 中的代码可以用标识符 i 来引用变量，或者用 Window 对象显示地引用这个变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;i           // =&amp;gt; 3
window.i    // =&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于窗体 B 中的脚本可以引用窗体 A 的 Window 对象，因此它也可以引用那个 Window 对象的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;parent.A.i = 4;             // 修改窗体 A 中的变量
parent.A.fun();             // 调用 A 窗体中的全局函数
var s = new parent.Set();   // 甚至可以构造父窗口中的对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和用户定义的类不同，内置类（比如 String, Date 和 RegExp）都会在所有的窗口中自动预定义。但是要注意，&lt;strong&gt;每个窗口都有构造函数的一个独立副本和构造函数对应的原型对象的一个独立副本&lt;/strong&gt;。例如，每个窗口都有自己的 String() 构造函数和 String.prototype 对象副本。因此，如果编写一个操作 JavaScript 字符串的新方法，并且通过把它赋值给当前窗口中的 String.prototype 对象而使它成为 String 类的一个方法，那么该窗口中的所有字符串就可以使用这个新方法。但是，&lt;strong&gt;别的窗口中定义的字符串不能使用这个新方法&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 13 - Web 浏览器中的 JavaScript</title>
      <link>https://keelii.github.io/2016/07/14/javascript-definitive-guide-note-11/</link>
      <pubDate>Thu, 14 Jul 2016 14:11:08 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/07/14/javascript-definitive-guide-note-11/</guid>
      <description>&lt;h2 id=&#34;客户端的-javascript&#34;&gt;客户端的 JavaScript&lt;/h2&gt;

&lt;p&gt;Window 对象是所有客户端 JavaScript 特性和 API 的主要接入点。它表示 Web 浏览器的一个窗口或者窗体，并且可以用标识符 window 来引用它。Window 对象定义了一些属性，比如:
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 页面跳转
window.location = &#39;http://www.oreilly.com/&#39;;
// 页面圣诞框
alert(&#39;Hello World&#39;)
setTimeout(function () { alert(&#39;Hello later World&#39;) }, 1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;window 对象也是全局对象。可以省略「window.」来调用上面的方法。这意味着 windows 对象牌作用域链的顶部，它的属性和方法实际上是全局变量和全局函数。window 对象有一个引用自己的属性，叫做 window。如果需要引用窗口对象本身可以用这个属性，但是如果只想要引用全局窗口对象的属性，通常并不需要用 window&lt;/p&gt;

&lt;p&gt;windows 对象还定义了很多其他重要的属性、方法和构造函数。其中最重要的一个属性是 document，它引用 Document 对象，后者表示显示在窗口中的文档。document 对象有一些重要方法，比如 getElementById() 获取一个 DOM 元素，它返回一个 Element 对象也有其他重要属性和方法，比如，给元素绑定点击事件 onclick&lt;/p&gt;

&lt;h2 id=&#34;在-html-里嵌入-javascript&#34;&gt;在 HTML 里嵌入 JavaScript&lt;/h2&gt;

&lt;p&gt;在 HTML 里嵌入 客户端 JavaScript 有 4 种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内联，放置在 &amp;lt;script&amp;gt; 和 &amp;lt;/script&amp;gt; 标签之间&lt;/li&gt;
&lt;li&gt;外链，放置在由 script 标签的 src 属性指定的外部文件中&lt;/li&gt;
&lt;li&gt;放置在 HTML 事件处理程序中，该事件处理程序由 onclick 或 on[eventType] 这样的 HTML 属性指定&lt;/li&gt;
&lt;li&gt;放在一个 URL 里，这个 URL 使用特殊的「javascript:」协议&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!--html 中的事件处理程序--&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; onchange=&amp;quot;any_javascript_statement&amp;quot; /&amp;gt;
&amp;lt;!--url 中的javascript--&amp;gt;
&amp;lt;a href=&amp;quot;javascript: new Date().toLocaleTimeString();&amp;quot;&amp;gt;What time is it?&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用外链 src 文件方式有一些优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以把 JavaScript 代码从 HTML 文件中删除，这有助于保持内容和行为的分离，从而简化 HTML 文件&lt;/li&gt;
&lt;li&gt;如果多个 Web 页面共用相同的 JavaScript 代码，用 src 属性可以让你只管理一份代码，而不用在代码变更时每个页面都更新&lt;/li&gt;
&lt;li&gt;如果一个 JavaScript 文件由多个页面共享，就只需要下载一次，以后的页面只要引用过就可以使用缓存检索它&lt;/li&gt;
&lt;li&gt;src 属性值可以是任意的 URL，因此来自一个 Web 服务器的 JavaScript 程序或 Web 页面可以使用由 &lt;strong&gt;另外一个&lt;/strong&gt; Web 服务器输出的代码，很多广告依赖与些&lt;/li&gt;
&lt;li&gt;从其它网站载入脚本的能力，可以让我们更好地利用缓存，使用 CDN&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;脚本的类型&#34;&gt;脚本的类型&lt;/h3&gt;

&lt;p&gt;script 标签默认的类型「type」是「text/javascript」，如果要使用不标准的脚本语言，如 Microsoft 的 VBScript（只有 IE 支持），就必须用 type 属性指定脚本的 MIME 类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/vbscript&amp;quot;&amp;gt;
// 这里是 VBScript 代码
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外很多老的浏览器还支持 language 属性，作用和 type 一样，不过已经废弃了，不应该再使用了&lt;/p&gt;

&lt;p&gt;当 Web 浏览器遇到 &amp;lt;script&amp;gt; 元素，并且这个元素包含其值不之前能点浏览器识别的 type 属性时，它会解析这个元素但不会尝试显示或执行它的内容。这意味着可以使用 &amp;lt;script&amp;gt; 来嵌入任意的文件数据到文档里，比如 &lt;a href=&#34;http://handlebarsjs.com/&#34;&gt;handlebars&lt;/a&gt; 模板引擎，通常把模板放在自定义 type 的 script 标签中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script id=&amp;quot;entry-template&amp;quot; type=&amp;quot;text/x-handlebars-template&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;entry&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;{{title}}&amp;lt;/h1&amp;gt;
        &amp;lt;div class=&amp;quot;body&amp;quot;&amp;gt;
            {{body}}
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;同步-异步和延迟的脚本&#34;&gt;同步、异步和延迟的脚本&lt;/h3&gt;

&lt;p&gt;JavaScript 第一次添加到 Web 浏览器时，还没有 API 可以用来遍历和操作文档的结构和内容。当文档还在载入时，JavaScript 影响文档内容的唯一方法是使用 document.write() 方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h1&amp;gt;Table of Factorials&amp;lt;/h1&amp;gt;
&amp;lt;script&amp;gt;
function factorial(n) {
    if ( n &amp;lt;= 1 ) return n;
    else return n * factorial(n - 1);
}
document.write(&#39;&amp;lt;table&amp;gt;&#39;);
document.write(&#39;&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;n&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;n!&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&#39;);
for (var i = 1; i &amp;lt;= 10; i++) {
    document.write(&#39;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&#39;+ i +&#39;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&#39;+ factorial(i) +&#39;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&#39;)
}
document.write(&#39;&amp;lt;/table&amp;gt;&#39;);
document.write(&#39;Generated ad &#39; + new Date());
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当脚本把文本传递给 document.write() 时，这个文本被添加到文档输入流中，HTML 解析器会在当前位置创建一个文本节点，将文本插入这个文本节点后面。我们并不推荐使用 document.write()，但在某些场景下它有很重要的用途。当 HTML 解析器遇到 script 元素时，它默认 &lt;strong&gt;必须先执行脚本&lt;/strong&gt;，然后恢复文档的解析和渲染。这对于内联脚本没什么问题，但如果脚本源代码是一个由 src 属性指定的外部文件，这意味着脚本后面的文档部分在下载和执行脚本之间，都不会出现在浏览器中&lt;/p&gt;

&lt;p&gt;脚本的执行只在默认情况下是同步和阻塞的。script 标签可以有 defer 和 async 属性，这可以改变脚本的执行方式。HTML 5 说这些属性只在和 src 属性联合使用时才有效，但有些浏览器还支持延迟的内联脚本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;a.js&amp;quot; defer&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;b.js&amp;quot; async&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;defer 和 async 属性都在告诉浏览器链接进来的脚本不会使用 document.write()，也不会生成文档内容，因此不蜂鸣器可以在下载脚本时继续解析和渲染文档，defer 属性使得浏览器延迟脚本的执行，直到文档的载入和解析完成，并可以操作。async 属性使得浏览器可以尽快地挂靠脚本，而不用在下载脚本时阻塞文档解析。如果 script 标签同时有两个属性，同时支持两者的浏览器会 &lt;strong&gt;遵从 async 属性并忽略 defer 属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意，延迟的脚本会按它们在文档里的 &lt;strong&gt;出现顺序执行&lt;/strong&gt;。而异步脚本在它们载入后执行，这意味着它们可能会 &lt;strong&gt;无序执行&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;事件驱动的-javascript&#34;&gt;事件驱动的 JavaScript&lt;/h3&gt;

&lt;p&gt;上面的打印斐波那契数列程序在页面载入时开始挂靠，生成一些输出，这种程序今天已经不沉凶了。通常我们使用注册事件处理程序函数来写程序。之后在注册的事件发生时 &lt;strong&gt;异步&lt;/strong&gt; 调用这些函数。&lt;/p&gt;

&lt;p&gt;事件都有名字，比如 click, change, load, mouseover, keypress, readystatechange 等，如果想要程序响应一个事件，就需要注册一个事件处理函数&lt;/p&gt;

&lt;p&gt;事件处理程序的属性名字一般都以「on」开始，后面跟着事件的名字。大部分浏览器中的事件会把一个对象传递给事件处理程序作为参数，那个对象的属性提供了事件的详细信息。比如，传递给点击事件的对象，会有一个属性说明鼠标的哪个按钮被点击了。（在 IE 里，这些事件信息被存储在全局 event 对象里，而不是传给处理程序的函数）&lt;/p&gt;

&lt;p&gt;有些事件的目标是文档元素，它们会经常往上传递事件给文档树。这个过程叫做「&lt;strong&gt;冒泡&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;关于事件传播顺序可以参考 ppk 的 &lt;a href=&#34;http://www.quirksmode.org/js/events_order.html&#34;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;客户端-javascript-线程模型&#34;&gt;客户端 JavaScript 线程模型&lt;/h3&gt;

&lt;p&gt;JavaScript 语言核心并不包含任何线程机制，并且客户端 JavaScript 传统上也没有定义任何线程机制。HTML 5 定义了一种作为后台线程的「WebWorker」，但是客户端 JavaScript 还像严格的单线程一样工作。甚至当可能并发执行的时候，客户端 JavaScript 也不会知道是否真的的有并行逻辑执行&lt;/p&gt;

&lt;p&gt;单线程执行是𧫂让编程更加简单。编写代码时可以确保两个事件处理程序不会同一时刻运行，操作文档的内容时也不必操心会有其它线程试图同时修改应该没配，并且永远不需要在写 JavaScript 代码的时候操心锁、死锁和竟态条件（race condition）&lt;/p&gt;

&lt;p&gt;单线程执行意味着浏览器 &lt;strong&gt;必须在脚本和事件处理程序运行的时候停止响应用户输入&lt;/strong&gt;。这为 JavaScript 程序员带来了负担，它意味着 JavaScript 脚本和事件处理程序不能运行太长时间。如果一个脚本执行 &lt;strong&gt;计算密集&lt;/strong&gt; 的任务，它将会使文档载入带来延迟，用户无法在脚本执行完成前看到内容。浏览器可能变得无法响应甚至崩溃&lt;/p&gt;

&lt;h3 id=&#34;客户端-javascript-时间线&#34;&gt;客户端 JavaScript 时间线&lt;/h3&gt;

&lt;p&gt;JavaScript 程序执行的时间线&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Web 浏览器创建 Document 对象，并且开始解析 Web 页面，解析 HTML 元素和它们的文本内容后添加 Element 对象和 Text 节点到文档中。在这个阶段 document.readystate 属性的值是「loading」&lt;/li&gt;
&lt;li&gt;当 HTML 解析器遇到没有 async 和 defer 属性的 script 元素时，它把这些元素添加到文档中，然后执行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样脚本就可以用 document.write() 来把文本插入到输入流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为在它们执行时已经存在了。这样，同步脚本可以看到它自己的 script 元素和它们之前的文档内容&lt;/li&gt;
&lt;li&gt;当解析器遇到设置了 async 属性的 script 元素时，它开始下载脚本文本，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下载。异步脚本禁止使用 document.write() 方法。它们可以看到自己的 script 元素和它之前的所有文档元素，并且可能或干脆不可能访问其它的文档内容&lt;/li&gt;
&lt;li&gt;当文档完成解析，document.readyState 属性变成「interactive」&lt;/li&gt;
&lt;li&gt;所有有 defer 属性的脚本，会按它们在文档里出现的顺序执行。异步脚本可能也会在这个时间执行。延迟脚本能访问完整的文档树，禁止使用 document.write() 方法&lt;/li&gt;
&lt;li&gt;浏览器在 Document 对象上触发 DOMContentLoaded 事件。这标志着程序执行 &lt;strong&gt;从同步脚本执行阶段转换到了异步事件驱动阶段&lt;/strong&gt;。但要注意，这时可能还胡异步脚本没有执行完成&lt;/li&gt;
&lt;li&gt;这时，文档已经完全解析完成，但是浏览器可能还在等待其它内容载入，如图片。当所有这些内容完成时，并且所有异步脚本完成载入和执行，document.readyState 属性改变为「complete」，Web 浏览器触发 window 对象上的 load 事件&lt;/li&gt;
&lt;li&gt;从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是一条理想的时间线，但是所有浏览器都没支持它的全部细节，所有浏览器普遍都支持 load 事件，都会触发它，它是决定文档完全载入并可以操作最通用的技术，除了 IE 之外，document.readyState 属性已被大部分浏览器实现，但是属性的值在浏览器之间有细微的差别&lt;/p&gt;

&lt;h2 id=&#34;兼容性和互用性&#34;&gt;兼容性和互用性&lt;/h2&gt;

&lt;p&gt;客户端 JavaScript 兼容性和互用性的问题可以归纳为以下三类：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;演化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Web 平台一直在演变和发展当中。一个标准规范会倡导一个新的特性或 API。如果特性看起来有用，浏览器开发商实现它。如果足够多的开发商实现，开发者开始试用这个特性。有时新浏览器支持一些特性老的却不支持&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比如，IE 8 不支持 convas 元素，虽然其它浏览器已经实现了它。IE 也没有对 DOM Level 2 Event 规范实现，即使这个规范在十年前就是标准化了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;bug&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每个浏览器都有 bug，并且没有按照规范准确地实现所有客户端 JavaScript API。有时候编写能兼容各个浏览器的 JavaScript 程序是个很麻烦的工作，必须要研究各种浏览器的兼容性问题&lt;/p&gt;

&lt;h3 id=&#34;处理兼容性问题的类库&#34;&gt;处理兼容性问题的类库&lt;/h3&gt;

&lt;p&gt;比如有的浏览器客户端不支持 canvas 元素，可以使用开源的「explorer canvas」项目，引用 excanvas.js 即可模拟 canvas 元素的功能&lt;/p&gt;

&lt;h3 id=&#34;分级浏览器支持&#34;&gt;分级浏览器支持&lt;/h3&gt;

&lt;p&gt;分级浏览器支持（graded browser support）是由 Yahoo! 率先提出的一种测试技术。从某种维度对浏览器厂商/版本/操作系统进行分级。根据分级来确定哪些特性在哪些浏览器需要支持的程度&lt;/p&gt;

&lt;h3 id=&#34;功能测试&#34;&gt;功能测试&lt;/h3&gt;

&lt;p&gt;功能测试（capability testing）是解决不兼容性问题的一种技术。比如添加事件 API，在标准浏览器里面是 addEventListener 而低版浏览器里面是 attachEvent，我们就可以通过特性检测来给一个添加事件的公共方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
if (element.addEventListener) {
    element.addEventListener(&amp;quot;keydown&amp;quot;, handler, false);
} else if (element.attachEvent) {
    element.attachEvent(&amp;quot;keydown&amp;quot;, handler);
} else {
    element.onkeydown = handler
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;怪异模式和标准模式&#34;&gt;怪异模式和标准模式&lt;/h3&gt;

&lt;p&gt;doctype 可以触发浏览器的渲染模式，IE 浏览器有怪异模式，可以通过 document.compatMode 属性判断是否是标准模式。如果返回值为「CSS1Compat」则说明浏览器工作在标准模式；如果值是「BackCompat」或者 「undefined」则说明工作在怪异模式&lt;/p&gt;

&lt;h3 id=&#34;浏览器测试&#34;&gt;浏览器测试&lt;/h3&gt;

&lt;p&gt;通常我们用功能测试来处理兼容性问题，但有时候可能需要在某种浏览器中解决个别的 bug，同时又没有可用的特性 API，这里只能通过判断浏览器来做兼容性处理，通常可以使用浏览器 UA（user agent）来解析浏览器版本、类型等&lt;/p&gt;

&lt;h3 id=&#34;ie-里的条件注释&#34;&gt;IE 里的条件注释&lt;/h3&gt;

&lt;p&gt;IE 浏览器中可以通过在 HTML 中添加特殊的注释来告诉浏览器代码在哪个浏览器中作用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!--[if IE 6]&amp;gt;
这里面的内容只会显示在 IE 6 浏览器中
&amp;lt;![endif]--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IE 的 JavaScript 解释器也支持条件注释，以文本 &lt;code&gt;/*@cc_on&lt;/code&gt; 开头，以文本 &lt;code&gt;@*/&lt;/code&gt;结束。下面的条件注释包含了只在 IE 中执行的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;script&amp;gt;&amp;lt;!--忽略 script 标签系统解析有问题--&amp;gt;
/*@cc_on
 @if (@_jscript)
    alert(&amp;quot;in IE&amp;quot;)
 @end
 @*/
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安全性&#34;&gt;安全性&lt;/h2&gt;

&lt;h3 id=&#34;javascript-不能做什么&#34;&gt;JavaScript 不能做什么&lt;/h3&gt;

&lt;p&gt;Web 浏览器针对恶意代码的第一条防线就是它们不支持某些功能。例如，客户端的 JavaScript 没有权限来写入或删除计算机上的文件/目录，这意味着 JavaScript 不能删除数据或者植入病毒&lt;/p&gt;

&lt;p&gt;类似地，客户端 JavaScript 没有任何通用的网络能力。HTML 5 有一个附属标准叫 WebSockets 定义了一个类套接字的 API，用于和指定的服务器通信。但是这些 API 都不允许对于范围更广的网络进行直接访问&lt;/p&gt;

&lt;p&gt;浏览器针对恶意代码的第二条防线是在自己支持的某些功能上施加限制。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript 程序可以打开一个新的浏览器窗口，但是为了防止广告商滥用弹出窗口，很多浏览器限制了这一功能，使得只有为了响应鼠标单击这样的用户触发事件的时候，才能用它&lt;/li&gt;
&lt;li&gt;JavaScript 程序可以关闭 &lt;strong&gt;自己打开的&lt;/strong&gt; 浏览器窗口，但是不允许不经过用户确认就关闭其它窗口&lt;/li&gt;
&lt;li&gt;HTML FileUpload 元素的 value 属性是只读的。如果可以设置这个属性，脚本就能设置它为任意期望的文件名，从而导致表单上传指定的文件（比如密码文件）内容到服务器&lt;/li&gt;
&lt;li&gt;脚本不能读取从不同服务器载入的文档内容，除非这个就是包含该脚本的文档。类似地，一个脚本不能在来自不同服务器的文档上注册事件监听器。这就防止脚本窃取其他页面的用户输入&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;同源策略&#34;&gt;同源策略&lt;/h3&gt;

&lt;p&gt;同源策略是对 JavaScript 代码能够操作哪些 Web 内容的一条完整的安全限制。当 Web 页面使用多个 iframe 元素或者打开其它浏览器窗口的时候，这一策略通常就会发挥作用。在这情况下，同源策略负责管理窗口或窗体中的 JavaScript 代码以及和其它窗口或帧的交互&lt;/p&gt;

&lt;p&gt;文档的来源包含协议、主机、以及载入文档的 URL 商品。从不同 Web 服务器载入的文档具有不同的来源。通过同一主机不同商品载入的文档具有不同来源。使用 &lt;code&gt;http:&lt;/code&gt; 协议载入的文档和使用 &lt;code&gt;https:&lt;/code&gt; 协议载入的文档具有不同的来源，&lt;strong&gt;即使它们来自同一个服务器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;脚本本身的来源和同源策略并不相关&lt;/strong&gt;，相关的是脚本所嵌入文档的来源。例如，来自主机 A 的脚本被包含到宿主 B 的一个 Web 页面中。这个脚本的 &lt;strong&gt;来源（origin）&lt;/strong&gt; 是主机 B，并且可以完整地访问包含它的文档的内容。如果脚本打开一个新的窗口并载入来自主机 B 的另一个文档，脚本对这个文档的内容也具有完全的访问权限。但是如果脚本打开第三个窗口并载入一个来自主机 C 的文档（或者来自主机 A），同源策略就会发挥作用，阻止脚本访问这个文档&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A 页面包含一个 B 脚本，B 脚本对 A 页面有完全的访问权限，如果 B 脚本控制打开一个 A 服务器上另外一个页面 C，那么脚本也可以访问这个 C 页面，如果 B 脚本控制打开了一个 D 页面，这时就会触发同源策略，即 B 脚本不可以访问 D 页面，&lt;strong&gt;因为 A 和 C 同源，A 和 D 不同源&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;不严格的同源策略&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在某些情况下，同源策略就显得太过严格了，常常表现在多个子域名站点的场景中。比如：来自 A.yourdomain.com 的文档里脚本无法直接读取 B.yourdomain.com 页面的文档，不过可以通过设置 document.domain 为同一个主域来获取访问权限，即给两个域名下的页面都设置 &lt;code&gt;document.domain=&amp;quot;yourdomain.com&amp;quot;&lt;/code&gt;，这样以来两个文档就有了同源性可以相互访问&lt;/p&gt;

&lt;p&gt;还有一项已经标准化的技术：&lt;strong&gt;跨域资源共享&lt;/strong&gt;（Cross-Origin Resource Sharing）这个标准草案用新的「Origin:」请求头和新的 Access-Control-Allow-Origin 响应头来扩展 HTTP，它允许服务器用头信息显式地列出源，或使用能本符来匹配所有的源并允许由任何地址请求文件，这样就可以实现跨域的 HTTP 请求， XMLHttpRequest 也不会被同源策略所限制了&lt;/p&gt;

&lt;p&gt;还有一种新技术，叫做跨文档消息（cross-document messaging），允许来自一个文档的脚本可以传递文本消息到另一个文档的脚本，而不管脚本的来源是否不同。调用 window 对象上的 postMessage() 方法，可以异步传递消息事件&lt;/p&gt;

&lt;h3 id=&#34;跨站脚本&#34;&gt;跨站脚本&lt;/h3&gt;

&lt;p&gt;跨站脚本（Cross-site scripting），或者叫 XXS，这个术语表示一类安全问题。攻击者向目标 Web 站点注入 HTML 标签或者脚本&lt;/p&gt;

&lt;p&gt;如果 Web 页面动态地产生文档内容，并且这些文档内容是用户提交的，如果没有过滤用户提交内容的话，这个页面很容易遭到跨站脚本攻击，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
var name = decodeURIComponent(window.location.search.substring(1) || &amp;quot;&amp;quot;);
document.write(&amp;quot;hello &amp;quot; + name)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当页面的 url 被手动拼成恶意参数提交时就会产生 XXS 攻击，比如：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://example.com/greet.html?%3Cscript%3Ealert(%22XXS%20attack%22)%3C%2Fscript%3E&#34;&gt;http://example.com/greet.html?%3Cscript%3Ealert(%22XXS%20attack%22)%3C%2Fscript%3E&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;打开这个 url 就会弹出「XXS attack」，解决办法通过是对接收参数进行标签屏蔽&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
name = name.replace(/&amp;lt;/g, &amp;quot;&amp;amp;lt;&amp;quot;).replace(/&amp;gt;/g, &amp;quot;&amp;amp;gt;&amp;quot;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;客户端框架&#34;&gt;客户端框架&lt;/h2&gt;

&lt;p&gt;从某种意义上讲类库也是框架，它们对 Web 浏览器提供的标准和专用 API 进行封闭，向上提供更高级别的 API，用以更高效地进行客户端编程开发。一但使用就要用框架定义的 API 来写代码，后面有专门的章节讲 jQuery，除了这个常用的类库还有一些其它广泛使用的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://prototypejs.org/&#34;&gt;Prototype&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dojotoolkit.org/&#34;&gt;Dojo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yuilibrary.com/&#34;&gt;YUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/closure/&#34;&gt;Closure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.gwtproject.org/&#34;&gt;GWT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 11 - 服务器端的 JavaScript</title>
      <link>https://keelii.github.io/2016/07/10/javascript-definitive-guide-note-10/</link>
      <pubDate>Sun, 10 Jul 2016 19:47:18 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/07/10/javascript-definitive-guide-note-10/</guid>
      <description>&lt;h2 id=&#34;用-node-实现异步-i-o&#34;&gt;用 Node 实现异步 I/O&lt;/h2&gt;

&lt;p&gt;Node 是基于 C++ 的调整 JavaScript 解释器，绑定了用于进程、文件和网络套接字等底层 Unix API，还绑定了 HTTP 客户端和服务器 API。除了一些专门命名的同步方法外，Node 的绑定是异步的，且 Node 程序默认绝不阻塞，这意味着它们通过具备强大的可伸缩能力并能有效地处理高负荷。由于 API 是异步的，因此 Node 依赖事件处理程序，其通常使用嵌套函数和闭包来实现&lt;/p&gt;

&lt;p&gt;
Node 在其全局对象中实现了所有标准的 ECMAScript 5 构造函数、属性和函数。除此之外，它也支持客户端講器函数集 setTimeout(), setInterval()&lt;/p&gt;

&lt;p&gt;Node 在 process 名字空间中定义了其它重要的 &lt;strong&gt;全局&lt;/strong&gt; 属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;process.version         // Node 的版本字符串信息
process.argv            // &#39;node&#39; 命令行数组参数，argv[0] 是 &amp;quot;node&amp;quot;
process.pid             // 进程 id
process.getuid()        // 返回用户 id
process.cwd()           // 返回当前的工作目录
process.chdir()         // 改变当目录
process.exit()          // 退出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在有的情况下，可以使用 Node 的事件机制。Node 对象产生事件（称为事件触发器(event emitter)），定义 on() 方法来注册处理程序。当传入参数时，将事件类型（一个字符串）作为第一参数，处理程序函数作为第二参数。不同的事件类型传递给处理程序函数的参数不同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;emitter.on(name, f)
emitter.addListener(name, f)
emitter.once(name, f)
emitter.removeListener(name, f)
emitter.removeListeners(name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 process 全局对象也是一个事件触发器，它继承了 EventEmitter 类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;process.on(&#39;exit&#39;, function () { console.log(&#39;Goodbye&#39;); });
process.on(&#39;uncaughException&#39;, function (e) { console.log(Exception, e); });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node 的文件和文件系统 API 位于「fs」模块中，这个模块提供了大部分方法的「同步版本」。任何名字以「Sync」结尾的方法都是一个 &lt;strong&gt;阻塞方法&lt;/strong&gt;，它返回一个值或抛出一个异常，不以「Sync」结尾的文件系统方法都是非阻塞的，它们会把结果或者错误传给指定的回调函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 同步读取文件，指定编码获取文本而不是字节
var text = fs.readFileSync(&#39;config.json&#39;, &#39;utf8&#39;);
// 异步读取二进制文件，通过传递函数获得数据
fs.readFile(&#39;image.png&#39;, function (err, buffer) {
    if (err) throw err;
    process(buffer);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似地，存在用来写文件的 writeFile() 和 writeFileSync() 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fs.writeFile(&#39;config.json&#39;, JSON.stringify(json))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「net」模块是用于基于 TCP 网络的 API，下面是 Node 中一个非常简单的 TCP 服务器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var net = require(&#39;net&#39;);
var server = net.createServer();
server.listen(2000, function() { console.log(&#39;Listening on port 2000&#39;); });
server.on(&#39;connection&#39;, function (stream) {
    console.log(&#39;Accepting connection from&#39;, stream.remoteAddress);
    stream.on(&#39;data&#39;, function (data) {
        stream.write(data)
    });
    stream.on(&#39;end&#39;, function(data) {
        console.log(&#39;Connection closed&#39;);
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;node-示例-http-服务器&#34;&gt;Node 示例：HTTP 服务器&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var http = require(&#39;http&#39;);

var hostname = &#39;127.0.0.1&#39;;
var port = 3000;

var server = http.createServer(function(req, res) {
    res.statusCode = 200;
    res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);
    res.end(&#39;Hello World\n&#39;);
});

server.listen(port, hostname, function() {
    console.log(&#39;Server running at http://$s:%s/&#39;, hostname, port);
});
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>