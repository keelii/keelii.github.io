<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>臨池不輟</title>
    <link>https://keelii.com/</link>
    <description>Recent content on 臨池不輟</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 25 Aug 2019 18:33:57 +0800</lastBuildDate>
    
        <atom:link href="https://keelii.com/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>漫谈哲学与编程</title>
      <link>https://keelii.com/2019/08/25/philosophy-and-programming/</link>
      <pubDate>Sun, 25 Aug 2019 18:33:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/08/25/philosophy-and-programming/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://i.v2ex.co/nfs1f0Yn.jpeg&#34; alt=&#34;philosophy and programming&#34; /&gt;&lt;/p&gt;

&lt;p&gt;谈到哲学，多数人都会直觉性的认为它是很高深的一门学问。实际上大多数情况并非如此，哲学研究的往往是非常简单的一些命题，而这些命题在常人看来可能并没有现实意义。&lt;/p&gt;

&lt;p&gt;比如说：到底是先有鸡还是先有蛋的问题；比如说：一个号称只给不能给自己理发的人理发的理发师到底能不能给自己理发的问题。当然本文的目的并不在于讨论这两个问题，我们来聊聊几个稍微简单一些的概念：&lt;/p&gt;

&lt;h3 id=&#34;哲学中的理性与感性&#34;&gt;哲学中的理性与感性&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;理性是超越的，本质在于追求无限&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;超越&lt;/strong&gt;的意思是说理性本身不依赖任何现实或者经验社会中的任何对象，&lt;strong&gt;无限&lt;/strong&gt;实际上就是说理性本身需要达到的某种理想状态。&lt;/p&gt;

&lt;p&gt;比方说：「&lt;strong&gt;100%的金」&lt;/strong&gt; 就是一种无限状态。我们不使用任何经验就可以判断出 100% 的金是必然有的，概念上没人能否定这一点。&lt;/p&gt;

&lt;p&gt;但是运用在经验社会中的知识来判断，这个命题就是不正确的，或者说不具有*普遍*的正确性。因为我们知道无论人类的技术如何高超也无法制造出来 100% 的金。即使到 99.99% 逻辑上也没到达 100%。&lt;/p&gt;

&lt;p&gt;这个时候人们对于类似的事情就会产生了不同的反应。有的人会因为理想状态达不到而&lt;strong&gt;反向&lt;/strong&gt;地认为原来的命题是错误的；有的人内心则有一种说不清道不明的东西指引着他，不会因为到达不到无限状态而肯定整个命题。&lt;/p&gt;

&lt;p&gt;这个问题也一直困扰了我很久，因为在现实生活中在你看来很多明显正确的事情忽出现了一个反例，结果就会有一堆人来告诉你你错了。&lt;/p&gt;

&lt;p&gt;德国哲学家康德在《&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BA%AF%E7%B2%B9%E7%90%86%E6%80%A7%E6%89%B9%E5%88%A4&#34;&gt;纯粹理性批判&lt;/a&gt;》这本书中给出了一种解释：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;理性的调节性是引导经验去追求无限，追求绝对，但是永远也达不到。达不到也有作用 — 它使得经验科学不断的前进，并且有了明确的目的和方向…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;类似的哲学观点好就好在一但明白了其中的本质和它阐述的真理以后，它就可以在某种层次上解释经验世界的各种现象。这或许就是大家说的哲学是任何其它学科的奠基，是第一学科的原因。&lt;/p&gt;

&lt;p&gt;对应的在编程领域也有一些无限的概念，对于多数前端工程师来讲「实现一个无限级的下拉菜单」似乎也在表达着一种无限状态。当然用户在使用的时候根本不可能用到无限级的菜单，无限级的菜单在交互方面也也是极其反人类的，一步可以做到的事情没人愿意多增加一步。但是为什么程序员们热衷于实现这种类似的无限状态。实际上这就是理性的力量，总有一种说不清楚的力量在引导着你，你也没法解释。&lt;/p&gt;

&lt;p&gt;理解了这一点你就会有一个很简单的评判程序好坏的论点，即：程序或者代码是否表现了某种&lt;strong&gt;无限&lt;/strong&gt;状态？如果你的程序函数里面只是几个简单的 if else，那你有没有考虑过如果当输入不断的增加或者变化时，原来的代码是否还可以正常返回。或者说在不考虑硬件等客观条件的前提下，你的程序是否存在极限状态。&lt;/p&gt;

&lt;p&gt;我们经常在知乎或者其它论坛上争论一些问题，本质上讲大家都没有区分清楚自己对于一个论点的&lt;strong&gt;逻辑认知&lt;/strong&gt;和&lt;strong&gt;情感认知&lt;/strong&gt;。太多人喜欢用自己的感情认知去否定逻辑事实，以至于争来争去谁也没能说服谁，试图用唯心观点去解释唯物的现象或者相反，这是极其不正确的。&lt;/p&gt;

&lt;p&gt;一个典型的问题是我不久之前在知乎上回答的一个问题：&lt;a href=&#34;https://www.zhihu.com/question/309891718&#34;&gt;谁能大致说下vue和react的最大区别之处&lt;/a&gt;？我的回答简单总结就两句话：Vue 有一种设计层面追求的简洁感性之美，React 则是一种数学层面的逻辑一致之美。本质上讲没有什么好坏之分。但是诸如些类的一些前端框架问题正在变成一种帮派化的「站队」风气。&lt;/p&gt;

&lt;h3 id=&#34;编程中的低阶-low-level-与高阶-hight-level&#34;&gt;编程中的低阶（low-level）与高阶（hight-level）&lt;/h3&gt;

&lt;p&gt;注意这里讲的 low/hight level 并不是计算机术语中特定的某种形式。&lt;/p&gt;

&lt;p&gt;有个笑话是这么讲的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个程序员去相亲，程序员自己介绍说「我是做嵌入式C语言底层开发的」，妹子反问「那啥时候做到高层开发呢」？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;程序员们内心都有一个做底层开发的梦，因为这才是一个真正的程序员的追求与理想。&lt;/p&gt;

&lt;p&gt;但是现实往往相反，大多数程序员每天都在写业务代码（重复的 CRUD）。所以很多程序员得出来一个结论就是：越底层的东西越重要，越高层的东西越肤浅。通常这也会行成一条鄙视链，他们会不由自主地忽略高层的东西。&lt;/p&gt;

&lt;p&gt;注意这里有两个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;业务代码有没有价值？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然有了，业务部分的代码是系统的最终结果。从结果导向上讲底层代码如何优雅、实现如何科学我们根本不关心，我们更关心整个系统层面的稳定与健壮。这是一种领导的高层次视角。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;底层的东西就一定重要？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;并不一定，这里说的不一定不是要完全否定底层的重要性。恰恰相反，软件领域一些特别优秀或者说伟大的软件底层并不是那么的如人意。比方说微软开发的 VSCode 代码编辑器。要是从底层去讨论它的构架合理性那确实挺像一个笑话的。因为本质上讲 VSCode 基于 electron，它把编辑器放在了一个 webview 中去运行，但是 webview 是用来浏览网页的，而且 electron 居然把 NodeJS 运行时也整合进去，以至于最小的一个应用解压完也有上百兆。&lt;/p&gt;

&lt;p&gt;这感觉就像是上学的时候你很期待一个数学教授教你数学课，但是实际上你的数学课却是一个体育老师带的，这不是可不可以的问题对吧。&lt;/p&gt;

&lt;p&gt;然而 VSCode 这样做的结果是：它还真的成功了，而且编辑器的性能比很多原生软件做的都要好，以至于周围所有人都在使用它，VSCode 在 Github 上名列前茅，也改变了很多程序员对于微软的刻板印象。&lt;/p&gt;

&lt;p&gt;如果我们再回过头从哲学的角度去思考这个问题，实际上计算机中的&lt;strong&gt;底层&lt;/strong&gt;与&lt;strong&gt;高层&lt;/strong&gt;正好对应着哲学中的&lt;strong&gt;理性&lt;/strong&gt;与&lt;strong&gt;感性&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;底层更注重逻辑严谨，因为这是构建高层建筑的基础，它面向的是理论&lt;/li&gt;
&lt;li&gt;高层更注重表现形式，因为高层的部分呈现出来的是一个完整的系统，它面向的对象是人。是人，那需求就是多样化的，因为人的想法总是特别的感性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理性的认知是有对错可以批判的，但是感性的直观是没有对错的，因为即使是同一种声音、颜色对不同人观感都是不一样的。&lt;/p&gt;

&lt;p&gt;比如说你在火车上看书，对面的人说话声音太大吵到了你。你说：你们说话小声点可以吗？对方会说：车上这么多人说话为啥就我们吵到你了？你说：因为就你们声音最大。对方说：我咋没觉得？&lt;/p&gt;

&lt;h3 id=&#34;现实中的主观与客观&#34;&gt;现实中的主观与客观&lt;/h3&gt;

&lt;p&gt;现实生活中我们经常会遇到一些对于论点的评价：主观还是客观。但是很多人没搞清楚这两个词的关系。多数人都觉得客观的观点就是好的，主观的就是臆断的。&lt;/p&gt;

&lt;p&gt;主观和客观的关系就像是主人与客人的关系一样，有的人会认为应该主随客便，有的人则认为应该是客随主便。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果一个人表达的观点全是主观的，那我们会认为这些观点是不可以讨论与评判的，不经过讨论批判的观点是站不住脚的。&lt;/li&gt;
&lt;li&gt;如果一个人表达的观点全是客观的，那似乎也不对，因为这些观点全是别人的，你可能忽略了自己的意识，最终只能游走在别人的规则中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任何语言中都有那么一些词语是成对儿出现的，像因果、主客、高低，这些词在被造出来的时候就是成对出现的，缺一不可。没有前者，后者将不会单独存在。它们之间没有绝对性的对于错。如果有，那对方就没有了存在的意义，反过来自己也将不存在。&lt;/p&gt;

&lt;p&gt;当有人抛出一个观点的时候我的经验是一定要听清楚对方说的是「我觉得」还是「我认为」。「我觉得」那必然就是人家的主观感受，这种观点我们就没必要讨论了。你应该回复：「嗯，没错，确实是这样的。」。如果对方说「我认为」那你要是有不同的观点就完全可以和他讨论，因为说「我认为」的观点必然是有一些客观事实做为依据的，有事实有逻辑，那就可以有对错。&lt;/p&gt;

&lt;h3 id=&#34;结语&#34;&gt;结语&lt;/h3&gt;

&lt;p&gt;哲学中的知识并不能完全解释现实中的事物，因为哲学研究的终点是一些没有结论的东西：上帝、自由、灵魂不朽。这些东西并非常人能理解的，但是人们对于无限真理的追求驱使着大家去研究它，很多人会觉得既然研究不出来结果那是不是就没意义了，当然不是。事实恰恰相反，如果我们把所有的事物本质都研究清楚了，那我们的存在也将失去意义。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>法布里斯·贝拉 — 一个真正的程序员</title>
      <link>https://keelii.com/2019/07/13/a-real-programmer-fabrice-bellard/</link>
      <pubDate>Sat, 13 Jul 2019 18:33:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/13/a-real-programmer-fabrice-bellard/</guid>
      <description>&lt;p&gt;&lt;strong&gt;法布里斯·贝拉&lt;/strong&gt;是一位法国著名的计算机程序员，在7月9日前我对他几乎一无所知。也就在这一天他发布了 &lt;a href=&#34;https://bellard.org/quickjs/&#34;&gt;QuickJS&lt;/a&gt; 引擎的首个公开发行版。这个名字才进入了很多和我一样无知的前端工程师的世界里。&lt;/p&gt;

&lt;p&gt;官网中是这么介绍 QuickJS 的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;QuickJS 是一个精巧可嵌入的 JavaScript 引擎。它支持 &lt;a href=&#34;https://tc39.es/ecma262/&#34;&gt;ES2019&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:JavaScript&#34;&gt;&lt;a href=&#34;#fn:JavaScript&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 中的很多特性 — 模块、异步生成器和代理。可选支持数学扩展 — 大整型，大浮点型数和操作符重载。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;主要的功能特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;轻量级很方便嵌入：源代码也只有几个 C 文件，没有外部依赖，一个简单的 hello world 程序会被编译成190Kb 的 x86 代码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;超快的解释器及启动时间：在一个普通的桌面 PC 上跑 ECMAScript 测试套件中的 56000 个用例只需要 100 秒&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;几乎完成的 ES2019 新特性支持，模块、异常生成器和完整的 Annex B&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Hypothetical-Ref&#34;&gt;&lt;a href=&#34;#fn:Hypothetical-Ref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 支持&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以将 JavaScript 源代码编译成无任何外部依赖的可执行程序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;垃圾回收使用引用计数机制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数学扩展支持：大整型，大浮点型数、操作符重载、大整型模式、数学模式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 JavaScript 实现的具有色彩支持的命令行解释器&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内置的微型标准库（C语言包装而成）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript 引擎在这之前只有主流的 Google V8，忽然出现这么一个项目，还是非常令人震惊的，尤其是它上面的这些特性，某种程度上让前端看到了新希望。&lt;/p&gt;

&lt;p&gt;QuickJS 发布后不久后，便在 Hack news、Twitter 上引发了大量的讨论，我也不由得起了八卦之心。下面引用一些网友的讨论：&lt;/p&gt;

&lt;p&gt;HN 上有网友回复到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is there anything that Fabrice can&amp;rsquo;t do? I mean, FFMpeg is almost a PhD thesis in and of itself, and he still manages to find time to make TinyC, QEMU, and now this. To say I&amp;rsquo;m jealous of his skills would be an understatement.&lt;/p&gt;

&lt;p&gt;还有什么事情是&lt;strong&gt;法布里斯&lt;/strong&gt;不能做的吗？我的意思是，FFMpeg 几乎是一个 PhD 论文级别的项目，但是他仍然有时间写 TinyC、QEMU 现在又是 QuickJS。我对他的佩服之情已经远超「嫉妒」之心。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;后面的网友也是八卦之心作祟：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I have two question in my mind. 我有两个问题&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Are there anyone on HN knows him in real life? HN 上有了解法布里斯在现实生活中的样子吗？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Does anyone have other people in their mind who is in the same league as this man? — 大家心目中与法布里斯类似的人有哪些？&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;++第一个问题++：根据几个（有机会见到过本人）网友的描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I know Fabrice a little. He&amp;rsquo;s definitely real, smart and humble. — 我知道一点关于&lt;strong&gt;法布里斯&lt;/strong&gt;。他是肯定是一个实际存在的、聪明且谦逊人。&lt;/p&gt;

&lt;p&gt;He is definitely very humble and a very good listener. — 他绝对是一个非常谦逊、内敛人，是一个非常好的倾听者。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;++第二个问题++：简单来说就是有没有和法布里斯一样利害的程序员，网友纷纷回复了自己眼中最利害的程序员名字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dan Bernstein&lt;/strong&gt; — 德裔美国数学家，密码学家和程序员。埃因霍温理工大学数学与计算机科学系的个人教授。发明了chacha20算法（几乎所有的现在加密算法都在使用它）。1995年，伯恩斯坦将&lt;strong&gt;伯恩斯坦诉合众国案&lt;/strong&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:-&#34;&gt;&lt;a href=&#34;#fn:-&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;件提起诉讼。该案的裁决宣称软件是第一修正案下的受保护言论。此前加密算法是高度机密的，受到国家/政府管制的，而伯恩斯坦自己认为写的 Snuffle 加密算法及相关的源代码是某种意义上的言论自由，因此与美国政府打官司最后还赢了，在那之后发表自由/开源软件才被视为一种言论自由。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Richard Stallman&lt;/strong&gt; — 理查德·马修·斯托曼，美国程序员，自由软件活动家。&lt;a href=&#34;https://zh.wikipedia.org/wiki/GCC&#34; title=&#34;GCC&#34;&gt;GCC&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/GNU%E4%BE%A6%E9%94%99%E5%99%A8&#34; title=&#34;GNU调试器&#34;&gt;GDB&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/Emacs&#34; title=&#34;Emacs&#34;&gt;GNU Emacs&lt;/a&gt; 都是他的作品&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linus Torvalds&lt;/strong&gt; — 芬兰程序员，Linux内核的最早作者，是当今世界最著名的计算机程序员、黑客之一。他的作品 Linux、Git 或许是开源软件领域最成功的两个项目。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;John Carmack&lt;/strong&gt; — 约翰·卡马克，美国的电玩游戏程序员、id Software 的创始人之一。卡马克创造的游戏引擎被用来制作其他的第一人称射击游戏，比如《半条命》和《荣誉勋章》&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rob Pike and Ken Thompson&lt;/strong&gt; — 肯·汤普逊，他创造了Go 语言、&lt;a href=&#34;https://zh.wikipedia.org/wiki/B%E8%AF%AD%E8%A8%80&#34; title=&#34;B语言&#34;&gt;B语言&lt;/a&gt;（&lt;a href=&#34;https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80&#34; title=&#34;C语言&#34;&gt;C语言&lt;/a&gt;的前身）。与&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87&#34; title=&#34;丹尼斯·里奇&#34;&gt;丹尼斯·里奇&lt;/a&gt;同为1983年&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96&#34; title=&#34;图灵奖&#34;&gt;图灵奖&lt;/a&gt;得主。&lt;/p&gt;

&lt;p&gt;后面还有有提到前端比较熟悉的 TJ 大神等。&lt;/p&gt;

&lt;p&gt;法布里斯与其它程序员不同的是他似乎很少有网络社交，平常人想与他沟通只能用 email，他没有任何社交账号。如果提到 Linus，你脑海里面一定会出现那些他说过的名言：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Talk is cheap. Show me the code, I am linus i&amp;rsquo;m your god.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linus 的利害之处在于他说他是你的上帝，一般人连否定这句话的资格都没有。从前我也一直很崇拜 Linus，因为它比较高调，语出惊人又无法否定。法布里斯则不一样，相比而言更低调，更有传统程序员的特点。但是朴实的外表怎么能遮住人家的才华呢。&lt;/p&gt;

&lt;p&gt;法布里斯的每个作品都是那么惊艳：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开源软件 FFmpeg，几乎被现在所有主流的媒体播放器使用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;发明了贝拉公式—最快圆周率算法，这个计算 N 位 PI 的公式比传统的 BBQ 算法要快 47%&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在PC上用软件实现 4G LTE 基站&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 JavaScript 写了一个 PC 虚拟机 &lt;a href=&#34;https://zh.wikipedia.org/wiki/Jslinux&#34; title=&#34;Jslinux&#34;&gt;Jslinux&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;QuickJS 问世后，JavaScript 之父 Brendan Eich 也坐不住了，称赞法布里斯是&lt;strong&gt;超级黑客&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/13/5d297b8fad00320486.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;实际上我觉得不应该给这些利害的程序员以程序员的「分类」，因为写代码/编程对于他们来说只是一种手段或者方法，最重要的是他们创造出来的东西会让世界上所有的人受益。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:JavaScript&#34;&gt;JavaScript 语言最新的标准规范 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:JavaScript&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Hypothetical-Ref&#34;&gt;Hypothetical Reference Decoder  &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Hypothetical-Ref&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:-&#34;&gt;伯恩斯坦诉合众国案 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:-&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>我想要 AOP — 使用 AOP 分离关注点</title>
      <link>https://keelii.com/2019/07/06/i-want-my-aop-cn/</link>
      <pubDate>Sat, 06 Jul 2019 18:33:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/06/i-want-my-aop-cn/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&#34;https://www.javaworld.com/article/2073918/i-want-my-aop---part-1.html&#34;&gt;I want my AOP&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;关注点&lt;/strong&gt;表示人们的一种特殊的意愿、理念或是某个感兴趣的领域。从技术角度来讲：软件系统包括若干&lt;strong&gt;核心的&lt;/strong&gt;、&lt;strong&gt;系统级别的&lt;/strong&gt;关注点。比方说：信用卡处理系统的&lt;strong&gt;核心&lt;/strong&gt;关注点是处理交易，同时系统级别的关注点或许应该是处理日志、事务、一致性、授权、安全、性能等。许多这种关注点被叫做&lt;strong&gt;横切关注点&lt;/strong&gt; — 往往会影响许多模块的实现。&lt;/p&gt;

&lt;p&gt;使用目前的编程方法，跨越多个模块横切关注点会导致系统更难设计、理解、实现和迭代。&lt;/p&gt;

&lt;p&gt;阅读完全的「我想要 AOP」系列文章：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第一部分&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二部分&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第三部分&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;面向切面的编程相比之前的方法更简单的分享了关注点，从而提供横切关注点的模块化。&lt;/p&gt;

&lt;p&gt;在本系列文章中，第一篇涉及 AOP 的概念，我首先解释了在一般复杂的软件系统中由横切关注点引起的问题。然后，我引入了 AOP 核心概念，并展示了 AOP 是如何通过横切关注点解决问题的。&lt;/p&gt;

&lt;p&gt;这个系列的第二篇文章将介绍 AspectJ，Xerox PARC 基于 Java 实现的 AOP 框架。最后一篇文章将以几个示例的方式向你展示 AOP 的概念，并基于建立更易懂、易实现、易迭代的软件系统。&lt;/p&gt;

&lt;h2 id=&#34;软件编程方法的演进&#34;&gt;软件编程方法的演进&lt;/h2&gt;

&lt;p&gt;早些年的计算机科学领域，开发者直接使用机器码进行编程。不幸的是，程序员花了更多时间去考虑特定机器的指令集而不是手头的问题。慢慢地，我们迁移到高级编程语言，高级编程语言允许对底层机器码进行一些抽象。然后结构化的语言出现了；我们现在可以根据任务的执行过程来分解我们的问题。然而，随着复杂度的增长，我们需要更好的技术。面向对象的编程让我们可以把系统看成一系列的合作对象。类可以让我们隐藏接口背后的实现细节。多态提供了通用行的为和接口，并允许更特殊的组件更改指定定行为，而无需接触基本概念的实现。&lt;/p&gt;

&lt;p&gt;编程方法和语言定义了我们与机器交流的方式。每一种新方法都提供某种分解问题的方式：机器码、独立于机器的代码、过程、类等等。每种方法都在建立某种&lt;strong&gt;系统需求&lt;/strong&gt;与&lt;strong&gt;程序结构&lt;/strong&gt;之间的对应关系。这些编程方法的演进让我们可以创建越来越复杂的系统。反过来复杂的系统使得我们又必须使用更先进的技术去解决这些复杂度。&lt;/p&gt;

&lt;p&gt;目前来讲，放多新的软件项目开发都使用面向对象的编程模式。的确，面向对象的编程模式能模拟常见行为方面表现出了强大的能力。然而，我们很快将会看见，或许你已经有所体验了，面向对象的编程模式没能充分地解决许多跨区的行为的问题 — 那种通常不相关的模块。相比而言，面向切面的编程方法填补了这个空白。AOP 很可能代表了编程方法演进的下一个重要方向。&lt;/p&gt;

&lt;h2 id=&#34;将系统看做一系列的关注点&#34;&gt;将系统看做一系列的关注点&lt;/h2&gt;

&lt;p&gt;我们可以将复杂系统看做是多个关注点的联合实现。典型的系统可能包含多种关注点，包括业务逻辑、性能、数据持久化 、日志，以及调试、授权、安全、线程安全 、错误检查等等。而且你还会遇到开发流程中的关注点，比如说：可理解、可维护，可追溯、更易迭代。图1描绘出了一个系统中不同模块关注点的实现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/05/5d1f0bb5278bd31387.gif&#34; alt=&#34;&#34; /&gt;图1&lt;/p&gt;

&lt;p&gt;图2展示了一系列的需求（一个光束）通过关注点识别器（棱镜）分离各种关注点成为独立模块。这个过程就对应着我们开发过程的关注点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/05/5d1f0d071673b46919.gif&#34; alt=&#34;&#34; /&gt;图2&lt;/p&gt;

&lt;h2 id=&#34;在系统中进行横切&#34;&gt;在系统中进行横切&lt;/h2&gt;

&lt;p&gt;开发者建立一个系统并且负责实现多个需求。我们可以把这些需求大体上从&lt;strong&gt;核心模块&lt;/strong&gt;级别需求与&lt;strong&gt;系统级别&lt;/strong&gt;需求两个维度进行分类。许多系统级别的需求相互之间（或与模块级别的需求）是正交的（相互依赖）。系统级别的需求倾向于横切许多核心模块，比如，一个个典型的企业应用包含的横切关注点有：身份验证，日志记录，资源池，管理，性能和存储管理。每个都被横切成多个子系统。比如，存储管理会影响每个业务对象。&lt;/p&gt;

&lt;p&gt;让我们举个简单的例子，比如有一个单例实现封装了一些业务逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SomeBusinessClass extends OtherBusinessClass {
    // 核心数据成员
    // 其它数据成员：比如日志，数据一致性标识
    // 重写基类中的方法
    public void performSomeOperation(OperationInformation info) {
        // 保证授权正常
        // 保证条件正常满足
        // 锁定对象保证数据一致性
        // 线程进入threads access it
        // 保证缓存正常
        // 打印操作启动日志
        // ==== 进行具体的操作 ====
        // 打印操作完成日志
        // 解锁对象
    }
    // 与上面类似的其它操作
    public void save(PersitanceStorage ps) {
    }
    public void load(PersitanceStorage ps) {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中我们必须考虑至少三个问题，首先，&lt;strong&gt;其它数据成员&lt;/strong&gt;不属于这个类所关心的内容。其次，performSomeOperation 的实现似乎比核心操作执行了更多的逻辑；它处理了日志、授权、线程安全以及其它&lt;strong&gt;外部&lt;/strong&gt;关注点。重要的是，似乎这些许多外围关注点其它类也会用到。最后，save() 和 load() 方法操作存储层，这两个方法放在这个类中比较合适还是放在其它类中比较合适，这个问题并不是很清楚。&lt;/p&gt;

&lt;h2 id=&#34;横切关注的问题&#34;&gt;横切关注的问题&lt;/h2&gt;

&lt;p&gt;虽然会跨模块横切关注点，但是现在的技术实现倾向于使用一维的方式实现，把问题聚焦在需求与实现的单一维度。这个单一维度的实现将变成&lt;strong&gt;核心模块&lt;/strong&gt;级别的实现。其余的需求围绕着这个主导维度被分类。换句话说，需求空间是多维的，然而实现空间是单维的。这种不匹配会导致需求与实现之间的映射难以做到。&lt;/p&gt;

&lt;h3 id=&#34;症状&#34;&gt;症状&lt;/h3&gt;

&lt;p&gt;使用目前的方法实现横切关注点会出现一些问题/症状，大体上分两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码纠缠&lt;/strong&gt;：系统中的模块可能会同时地与多个需求交互。比如，开发者经常同时考虑业务逻辑、性能、同步、日志和安全等问题。大量的并行需求导致需要许多关注点的实现同时存在，最终导致代码纠缠。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码分散&lt;/strong&gt;：由于横切关注点，按定义，很多模块都需要分离，甚至是相关的实现都需要分离。比如，一个使用数据库的系统，性能问题可能会影响所有访问数据库的模块&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;暗示&#34;&gt;暗示&lt;/h3&gt;

&lt;p&gt;代码纠缠与代码分散对软件设计和开发有以下影响：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不可追溯&lt;/strong&gt;：同时分离多个关注点会&lt;strong&gt;掩盖&lt;/strong&gt;关注点与实现之间的对应关系，导致关系不清楚&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;低效的&lt;/strong&gt;：同时实现多个关注点会打乱开发者的注意力，将注意力分散到外围问题上，这将导致低效&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码复用性低&lt;/strong&gt;：由于模块实现了多个需求，其它系统将无法很容易地复用这个模块，进一步导致低效&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码质量低&lt;/strong&gt;：代码纠缠会产生一些不易查觉的问题。此外，一次关注太多问题，某些关注点可能没有被真正关注到&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;难于迭代&lt;/strong&gt;：有限的视界和受限的资源通常会产生仅解决当前关注点的设计。解决未来问题通常需要重新实现。由于这个实现并不是模块化的，这表示触摸许多模块。为了实现新需求需要修改每个子系统可能会引起不一致的问题。它还需要大量的测试工作来保证实现做出的变更没有引入新问题。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;目前的解决方式&#34;&gt;目前的解决方式&lt;/h3&gt;

&lt;p&gt;由于大多数系统都可以横切关注点，因此出现模块化实现的一些技术就不足为奇了。这些技术包括混入（mix-in）类，设计模式和领域特定的解决方案。&lt;/p&gt;

&lt;p&gt;使用混入类可以让你延迟分离关注点到最终的实现。主类包含混入类实例，并允许系统的其他部分设置该实例。例如，上面的信用卡处理例子，将一个实现了业务逻辑的类组合成混入类，系统的其它模块可以通过配置来获取适合自身的日志器。例如，日志器可以设置成使用文件系统或者消息中间件。发送日志的被延后了，但是各个消息发送点（调用的地方）还是需要加入相关的代码。&lt;/p&gt;

&lt;p&gt;基于行为的设计模式，比如说访问者、模板方法，可以让你延迟实现。但是就像混入类一样，控制操作—调用访问逻辑或者模板方法—仍然在主类中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;领域特定&lt;/strong&gt;的解决方案，比如说框架和应用服务，让开发者可以用模块化的方式实现横切关注点。比如 EJB 架构，在安全、管理、性能和持久容器管理方面实现横切关注点。Bean 的开发者专注于业务逻辑，部署工程师专注于部署相关问题，比如 bean-data 与数据库的对应关系。对于 Bean 开发者来讲其余需要关注的就只有存储的问题了。在这个例子中你可以使用基于 XML 的映射描述符来实现横切关注点。&lt;/p&gt;

&lt;p&gt;领域特定的解决方案提供了一种特殊的办法来解决指定的问题。它的缺点是，开发者必须为它学习新的技术。然后由于这些解决方案都是领域特定的，它并不能直接有效地横切关注点。&lt;/p&gt;

&lt;h2 id=&#34;构架设计的窘境&#34;&gt;构架设计的窘境&lt;/h2&gt;

&lt;p&gt;好的系统架构会考眼前与未来的一些需求，从而避免打补丁式的实现。但是这有一个问题，预测未来是一件非常困难的事情。如果你没有搞清楚未来的需求，那就需要改变、或者将系统的很多地方重新实现。另外一方面，将精力聚焦在低可能性的一些需求会导致过度的设计、混乱和臃肿的系统。因此系统构架的一个困境是：应该设计到什么程度？我应该保守式的设计还是盈余式的设计。&lt;/p&gt;

&lt;p&gt;比方说，构架中是否应该追念一个初始化时并不需要的日志系统？如果是，日志打点的地方应该在哪里，什么样的信息应该被记录？这个是一个类似的出现在优化相关需求过程中的困境—我们很少提前知道瓶颈，常归的做法是构建一个系统，对其进行分析，并通过优化进行改进以提高性能。这种方法会潜在引导我们根据分析结果去修改系统很多部分。过不了多久，一个新的瓶颈又会出现，而这个瓶颈很可能就是上一步的改进引起的。设计可复用库架构的任务会变得非常困难，因为找到库的所有的使用场景并非易事。&lt;/p&gt;

&lt;p&gt;总之，架构师很少知道系统所有可能需要解决的问题。即使提前了解了需求，一个实现的具体细节可能并没有被考虑到。因此，架构师面临着究竟应该保守设计还是盈余设计的困境。&lt;/p&gt;

&lt;h2 id=&#34;aop-的基本概念&#34;&gt;AOP 的基本概念&lt;/h2&gt;

&lt;p&gt;到这里我们主要讨论了模块化的横切关注点会有很大益处。研究人员已经研究了在「关注点分离」这一更为泛化的主题下完成该任务的各种方法。 AOP 就是这样的一种方法。AOP 力争将关注点彻底分离，以克服上述问题。&lt;/p&gt;

&lt;p&gt;AOP 的核心在于，以松散耦合的方式让你实现一个独立的关注点，然后结合这些实现成为一个最终的系统。确实，AOP 使用松散耦合、模块化的&lt;strong&gt;分离关注点&lt;/strong&gt;的方式来创建系统。相反，OOP，则使用松散耦合、模块化的实现&lt;strong&gt;共同关注点&lt;/strong&gt;方式来创建系统。AOP 中模块化的单位叫做*横切面*（aspect），好比 OOP 中共同的关注点是*类*（class）。&lt;/p&gt;

&lt;p&gt;AOP涉及三个不同的开发步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;切面分解&lt;/strong&gt;：将需求分解并识别出横切关注点与共同关注点。你可以将系统级别的关注点与模块级别关注点分离。比如说，上面提到的信用卡模块，你需要识别三种关注点：信用卡核心流程，日志和授权。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;关注点实现&lt;/strong&gt;：分离的实现各个关注点。像上面的例子一样，你可以单独实现核心流程、日志和授权三个单元。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;切面重组&lt;/strong&gt;：在这个步骤中，切面集成器通过创建模块化单元来指定重组规则 — 切面。重组过程（也称为&lt;strong&gt;编织&lt;/strong&gt;或集成）使用此信息来组合成最终系统。比如上面的信用卡例子，你得使用一种 AOP 实现的*语言*具体/规范化操作中哪一步需要打日志。还得指定每个操作在被前都需要清除授权。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/06/5d207ff77b21c16740.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;AOP 实现横切关注点的方法与 OOP 不一样。对于 AOP 来讲，每个关注点的实现并不会意识到其它关注点下在横切它。比如上面的信用卡例子，信用止处理模块并不知道其它的关注点是日志、授权操作。这对于 OOP 来讲意味着很大的范式转换。&lt;/p&gt;

&lt;p&gt;注意：一个 AOP 的实现可以采用其它编程方法作为它的基本方法。因此可以保证基础系统非常完善。比如说，一个 AOP 的实现可以选择 OOP 做为基础系统，这样就可以获得 OOP 共同关注点的优势。每个独立的关注点可以采用 OOP 技术识别关注点。这类似于过程式的语言可以做为许多 OOP 语言的基础语言。&lt;/p&gt;

&lt;h2 id=&#34;编织的例子&#34;&gt;编织的例子&lt;/h2&gt;

&lt;p&gt;编织器是一个将独立的关注点纺织起来的过程。换句话说，编织器根据提供给它的某些标准将不同的执行逻辑片段编织起来。&lt;/p&gt;

&lt;p&gt;为了能够演示编织过程，让我们回到之前的信用卡处理系统的例子。为了看起来更简单，我们只考虑两个操作：信用卡和借记卡。并且已经有一个合适的日志器了。&lt;/p&gt;

&lt;p&gt;考虑下面的信用卡处理模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CreditCardProcessor {
    public void debit(CreditCard card, Currency amount) 
       throws InvalidCardException, NotEnoughAmountException,
              CardExpiredException {
        // Debiting logic
    }
    
    public void credit(CreditCard card, Currency amount) 
        throws InvalidCardException {
        // Crediting logic
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样还有一个日志接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Logger {
    public void log(String message);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们想要的组合需要以下编织规则，这些规则以自然语言表示（稍后将提供这些编织规则的编程语言版本）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打印每个公共操作的开始&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打印每个公共操作完成&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打印每个公共操作的异常&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;编织器随后将使用这些规则，并关注每个实现以产生等价于以下代码的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CreditCardProcessorWithLogging {
    Logger _logger;
    public void debit(CreditCard card, Money amount) 
        throws InvalidCardException, NotEnoughAmountException,
               CardExpiredException {
        _logger.log(&amp;quot;Starting CreditCardProcessor.credit(CreditCard,
Money) &amp;quot;
                    + &amp;quot;Card: &amp;quot; + card + &amp;quot; Amount: &amp;quot; + amount);
        // Debiting logic
        _logger.log(&amp;quot;Completing CreditCardProcessor.credit(CreditCard,
Money) &amp;quot;
                    + &amp;quot;Card: &amp;quot; + card + &amp;quot; Amount: &amp;quot; + amount);
    }
    
    public void credit(CreditCard card, Money amount) 
        throws InvalidCardException {
        System.out.println(&amp;quot;Debiting&amp;quot;);
        _logger.log(&amp;quot;Starting CreditCardProcessor.debit(CreditCard,
Money) &amp;quot;
                    + &amp;quot;Card: &amp;quot; + card + &amp;quot; Amount: &amp;quot; + amount);
        // Crediting logic
        _logger.log(&amp;quot;Completing CreditCardProcessor.credit(CreditCard,
Money) &amp;quot;
                    + &amp;quot;Card: &amp;quot; + card + &amp;quot; Amount: &amp;quot; + amount);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;分解-aop-语言&#34;&gt;分解 AOP 语言&lt;/h2&gt;

&lt;p&gt;就像其它编程语言方法的实现，AOP 实现包括两个部分：一种语言规范和一种实现。语言规范描述语言的构成与语法。实现则根据语言规范去论证代码的正确性，然后转换成机器码然后执行。在这小节中，我将解释 AOP 语言的不同组成部分。&lt;/p&gt;

&lt;h4 id=&#34;aop-语言的规范&#34;&gt;AOP 语言的规范&lt;/h4&gt;

&lt;p&gt;在一个高层次上，AOP 语言有两种组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;关注点的实现&lt;/strong&gt;：创建一个独立的需求与代码之间的对应关系，这样编译器才能翻译成可执行代码。由于关注点的实现需要通过具体的过程，你可以使用传统的语言，比如 C，C++ 或者 Java&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;编织规则的规范&lt;/strong&gt;：如何将独立的关注点实现结合成最终的系统。为了达到这个目标，实现需要使用或者创建一种语言来具体说明结合的规则。具体化编织规则的语言可以是实现语言的一种扩展，或者其它完全不同的东西。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;aop-语言的实现&#34;&gt;AOP 语言的实现&lt;/h4&gt;

&lt;p&gt;AOP 语言编译器有以下两个逻辑步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;结合独立的关注点&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;转换最终结果成可执行代码&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;AOP 语言实现编织器的方法有很多，包括源码到源码的翻译。你可以预处理独立切面的源码，然后将它加工成编织过的源码。然后 AOP 编译器将这些源码转交给基本语言编译器用来生成最终可执行代码，最后让 Java 编译器把代码编译成子节码。同样的，编织过程可以是子节码级别的；毕竟，子节码也是一种源代码。引外底层系统—VM虚拟机，是可以感知到切面的。使用这种基于 Java 的 AOP 实现，比如，VM虚拟机将首先加载编织规则，然后将这些规则应用到随后加载的类中。换句话说，它表现得像是 JIT 化的切面编织。&lt;/p&gt;

&lt;h2 id=&#34;aop-的益处&#34;&gt;AOP 的益处&lt;/h2&gt;

&lt;p&gt;AOP 有助于克服由代码纠缠和代码分散引起的上述问题。以下是 AOP 提供的其他优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;模块化地横切关注点&lt;/strong&gt;：AOP 使得每个独立的关注点有最小化的耦合，最终产出模块化的实现。这样的一种实现会产生很少的重复代码。由于每个关注点的实现是分离的，也将减少无用代码，更重要的模块化的实现让最终系统更易于理解与维护。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;更便于系统迭代&lt;/strong&gt;：由于切面模块对于横切关注点是无感知的，添加新功能、新切面将变得简单。而且当你在系统中添加新模块时，现有的切面将横切它们，这有助于你构建一系列连贯的迭代演进。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;延迟设计目标的绑定&lt;/strong&gt;：回顾下架构师的困境，有了 AOP，架构师对于将来的需求就可以推迟做出设计上的决定，因为他可以用分离的切面来实现。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;更高的代码复用性&lt;/strong&gt;：由于 AOP 分离的实现每个切面，每个独立模块之间的耦合更加的松散。比如说，你可以使用不同的日志器来记录你模块与数据库的操作。通常来讲，松散耦合的实现是代码高复用性的关键点。 AOP 的实现比 OOP 的实现更加松散耦合。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;aspectj-一种-java-的-aop-实现&#34;&gt;AspectJ：一种 Java 的 AOP 实现&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第三篇：控制器）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-3/</link>
      <pubDate>Wed, 03 Jul 2019 18:33:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-3/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;控制器&lt;/strong&gt;（Controller）负责处理客户端请求并发送响应内容，在传统的 MVC 架构中控制器就是负责处理指定请求与应用程序的对应关系，路由则决定具体处理哪个请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/30/5d18c461b3cb641859.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;路由&#34;&gt;路由&lt;/h3&gt;

&lt;p&gt;得益于 TypeScript，在 Nest 中我们可以使用类来实现控制器的功能，使用装饰器来实现路由功能。它们分别需要配合 @Controller 和 @Get 饰器来使用，前者是控制器类的装饰，后者是具体方法的装饰器。&lt;/p&gt;

&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Controller, Get } from &#39;@nestjs/common&#39;;

@Controller(&#39;cats&#39;)
export class CatsController {
  @Get()
  findAll(): string {
    return &#39;This action returns all cats&#39;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码声明了一个猫咪控制器类，实现了 findAll 方法，当你在浏览器中发送请求到 /cates 时程序就返回给你 This action returns all cats&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;++小提示++：可以使用 Nest-cli 工具来自动生成上面的代码：$ nest g controller cats&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;@Get()&lt;/code&gt; 表示 HTTP 请求装饰器。控制器类的装饰器和 HTTP 方法的装饰器共同决定了一个路由规则。findAll 将返回一个状态码为 200 的响应，当然你有两种方法来指定返回的状态码：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;标准模式（建议的）&lt;/td&gt;
&lt;td&gt;使用内置方法时，如果返回一个 JavaScript 对象或者数据，将自动序列化成 JSON，如果是字符串将默认不会序列化，响应的返回状态码 &lt;strong&gt;默认&lt;/strong&gt; 总是 200，除非是 POST 请求会默认设置成 201。可以使用 @HttpCode() 装饰器来改变它&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;指定框架&lt;/td&gt;
&lt;td&gt;也可以使用指定框架的请求处理方法，比如 Express 的响应对象。可以使用 @Res() 装饰器来装饰响应对象使用，这样以来你就可以使用类 Express API 的方式处理响应了：&lt;code&gt;response.status(200).send()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;++警告++&lt;/strong&gt;：你可以同时使用上面两种方法，但是 Nest 会检测到，同时标准模式会在这个路由上被禁用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;请求对象&#34;&gt;请求对象&lt;/h3&gt;

&lt;p&gt;处理器一般需要访问到请求对象。一般配合 @Req() 装饰器来使用，请求对象包含查询字符串、参数、HTTP 头，请求体等。但是大多数情况只用到其中某个，我们可以单独使用指定的装饰器来装饰请求。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;装饰器&lt;/th&gt;
&lt;th&gt;参数值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Request()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;req&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Response()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;res&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Next()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;next&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Session()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;req.session&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Param(key?: string)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;req.params&lt;/code&gt; / &lt;code&gt;req.params[key]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Body(key?: string)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;req.body&lt;/code&gt; / &lt;code&gt;req.body[key]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Query(key?: string)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;req.query&lt;/code&gt; / &lt;code&gt;req.query[key]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Headers(name?: string)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;req.headers&lt;/code&gt; / &lt;code&gt;req.headers[name]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;举个例子：比如我们只需要处理请求的查询字符串（query string），就可以使用 @Query 来装饰入参，这样取到的值就自然是一个 query string 的字典了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get()
getHello(@Query() q: String): string {
    console.log(q)
    return this.appService.getHello();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们的请求是：&lt;a href=&#34;http://localhost:3000/?test=a&#34;&gt;http://localhost:3000/?test=a&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么控制台将打印一个 &lt;code&gt;{ test: &#39;a&#39; }&lt;/code&gt; 字典&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;++小提示++&lt;/strong&gt;：建议安装 @types/express 包来获取 Request 的相关类型提示&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;资源&#34;&gt;资源&lt;/h3&gt;

&lt;p&gt;除了使用 @Get 装饰器，我们还可以使用其它 HTTP 方法装饰器。比如：&lt;code&gt;@Put()&lt;/code&gt;, &lt;code&gt;@Delete()&lt;/code&gt;, &lt;code&gt;@Patch()&lt;/code&gt;, &lt;code&gt;@Options()&lt;/code&gt;, &lt;code&gt;@Head()&lt;/code&gt;, and &lt;code&gt;@All()&lt;/code&gt;，注意 All 并不是 HTTP 的方法，而是 Nest 提供的一个快捷方式，表示接收任何类型的 HTTP 请求。&lt;/p&gt;

&lt;h3 id=&#34;路由通配符&#34;&gt;路由通配符&lt;/h3&gt;

&lt;p&gt;Nest 支持基于模式的路由规则匹配，比如：星号（*）表示匹配任意的字母组合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get(&#39;ab*cd&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;&#39;ab*cd&#39;&lt;/code&gt; 路由将匹配 &lt;code&gt;abcd&lt;/code&gt;, &lt;code&gt;ab_cd&lt;/code&gt;, &lt;code&gt;abecd&lt;/code&gt; 等规则。同时：&lt;code&gt;?&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;()&lt;/code&gt; 通配符（wildcard）都可以使用&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;通配符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;匹配&lt;/th&gt;
&lt;th&gt;不匹配&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配任意数量的任意字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Law*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Law&lt;/code&gt;, &lt;code&gt;Laws&lt;/code&gt;, or &lt;code&gt;Lawyer&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;GrokLaw&lt;/code&gt;, &lt;code&gt;La&lt;/code&gt;, or &lt;code&gt;aw&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*Law*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Law&lt;/code&gt;, &lt;code&gt;GrokLaw&lt;/code&gt;, or &lt;code&gt;Lawyer&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;code&gt;La&lt;/code&gt;, or &lt;code&gt;aw&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配任意&lt;strong&gt;单个&lt;/strong&gt;字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;?at&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Cat&lt;/code&gt;, &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;Bat&lt;/code&gt; or &lt;code&gt;bat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;at&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[abc]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配方括号中的任意&lt;strong&gt;一个&lt;/strong&gt;字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[CB]at&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Cat&lt;/code&gt; or &lt;code&gt;Bat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;bat&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[a-z]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配字母、数字区间&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Letter[0-9]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Letter0&lt;/code&gt;, &lt;code&gt;Letter1&lt;/code&gt;, &lt;code&gt;Letter2&lt;/code&gt; up to &lt;code&gt;Letter9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Letters&lt;/code&gt;, &lt;code&gt;Letter&lt;/code&gt; or &lt;code&gt;Letter10&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;状态码&#34;&gt;状态码&lt;/h3&gt;

&lt;p&gt;响应的默认状态码是 200，POST 则是 201，我们可以使用装饰器 &lt;code&gt;@HttpCode(204)&lt;/code&gt; 来指定&lt;strong&gt;处理器&lt;/strong&gt;级别的 默认 HttpCode 为 204&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@HttpCode(204)
create() {
  return &#39;This action adds a new cat&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想动态指定状态码，就要使用 @Res() 装饰器来注入响应对象，同时调用响应的状态码设置方法。&lt;/p&gt;

&lt;h3 id=&#34;请求头&#34;&gt;请求头&lt;/h3&gt;

&lt;p&gt;同样的我们可以使用 &lt;code&gt;@Header()&lt;/code&gt; 来设置自定义的请求头，也可以使用 &lt;code&gt;response.header()&lt;/code&gt; 设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@Header(&#39;Cache-Control&#39;, &#39;none&#39;)
create() {
  return &#39;This action adds a new cat&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;路由参数&#34;&gt;路由参数&lt;/h3&gt;

&lt;p&gt;通常我们需要设置一些动态的路由来接收一些客户端的查询参数，通过指定路由参数可以很方便的捕获到 URL 上的动态参数到控制器中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get(&#39;:id&#39;)
findOne(@Param() params): string {
  console.log(params.id);
  return `This action returns a #${params.id} cat`;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过使用 @Param() 装饰器可以在方法中直接访问到路由装饰器 &lt;code&gt;@Get()&lt;/code&gt; 中的的参数字典，:id 就表示匹配到所有的字符串，可以通过引用 params.id 在方法中访问到。&lt;/p&gt;

&lt;p&gt;当然，就像前面学到的参数装饰器也可以指定到具体的某个参数值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get(&#39;:id&#39;)
findOne(@Param(&#39;id&#39;) id): string {
  return `This action returns a #${id} cat`;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;路由顺序&#34;&gt;路由顺序&lt;/h3&gt;

&lt;p&gt;路由的注册顺序与控制器类中的&lt;strong&gt;方法&lt;/strong&gt;顺序相关，如果你先装饰了一个 cats/:id 的路由，后面又装饰了一个 cats 路由，那么当用户访问到 GET /cats 时，后面的路由将不会被捕获，因为参数才都是&lt;strong&gt;非必选&lt;/strong&gt;的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第二篇：入门）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-2/</link>
      <pubDate>Wed, 03 Jul 2019 18:32:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-2/</guid>
      <description>

&lt;p&gt;这篇教程起，你将会学习到 Nest 的几个核心点。为了更好的了解 Nest 应用中的模块，我们将开发一个有基本 CRUD&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Create-Read-Upda&#34;&gt;&lt;a href=&#34;#fn:Create-Read-Upda&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 功能的入门级应用。&lt;/p&gt;

&lt;h2 id=&#34;实现语言&#34;&gt;实现语言&lt;/h2&gt;

&lt;p&gt;Nest 是 TypeScript 写的，所以天生就很好的并且渐进地支持 JavaScript。&lt;/p&gt;

&lt;h2 id=&#34;依赖&#34;&gt;依赖&lt;/h2&gt;

&lt;p&gt;保证你的操作系统上安装的 Node.js 版本大于 8.9.0 即可。&lt;/p&gt;

&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;

&lt;p&gt;就像上节讲到的直接用 nest new project-name 就可以了。我们来回顾下目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;src
├── app.controller.spec.ts
├── app.controller.ts
├── app.module.ts
├── app.service.ts
└── main.ts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别对应的功能如下表：&lt;/p&gt;

&lt;p&gt;| app.controller.ts | 只有一个路由的控制器（controller）示例 |
| app.module.ts | 应用程序的根模块（root module） |
| main.ts | 应用程序的入口文件，使用 &lt;code&gt;NestFactory&lt;/code&gt; 方法创建应用实例 |
在 main.ts 中我们可以看到，默认使用了 NestFactory 的 create() 静态方法返回创建的应用对象，此对应会实现 INestApplication 接口。&lt;/p&gt;

&lt;h2 id=&#34;平台&#34;&gt;平台&lt;/h2&gt;

&lt;p&gt;Nest 的目标是一个平台无关的框架。这个意思就是说 Nest 本身并不造某个细分领域的轮子，他只构建一套构架体系，然后把一些好用的库或者平台融合进来。所以 Nest 可以衔接任何 HTTP 框架，默认支持 express 和 fastify 两个 web 框架。&lt;/p&gt;

&lt;p&gt;| &lt;code&gt;platform-express&lt;/code&gt; | &lt;strong&gt;&lt;a href=&#34;https://expressjs.com/&#34;&gt;Express&lt;/a&gt;&lt;/strong&gt; 是一个 Node web 框架，有很多社区成熟的资源。@nestjs/platform-express 默认会被引入，大家都很熟悉了，用起来会容易上手 |
| &lt;code&gt;platform-fastify&lt;/code&gt; | &lt;strong&gt;&lt;a href=&#34;https://www.fastify.io/&#34;&gt;Fastify&lt;/a&gt;&lt;/strong&gt; 是一个高能低耗的框架，致力于最大化效率与速度 |
无论使用哪个平台，都要暴露自己的应用接口。上面两个平台暴露了对应的两个变量 &lt;code&gt;NestExpressApplication&lt;/code&gt; and &lt;code&gt;NestFastifyApplication&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如下的代码会创建一个 app 对象，并且指定了使用 NestExpressApplication 平台：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const app = await NestFactory.create&amp;lt;NestExpressApplication&amp;gt;(ApplicationModule);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过一般情况下不需要指定这个类型。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:Create-Read-Upda&#34;&gt;Create, Read, Update, Delete 通常对应于数据的增删改查功能 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Create-Read-Upda&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第一篇：简介）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-1/</link>
      <pubDate>Wed, 03 Jul 2019 18:31:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-1/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/30/5d185dfb87f5e21948.png&#34; alt=&#34;Nestjs&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;教程目录&#34;&gt;++教程目录++&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;请注意：本教程结合官方文档内容并添加了许多我自己学习过种中的理解，存在许多个人观点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;Nestjs 框架教程（第一篇：&lt;a href=&#34;https://wtdf.io/nestjs-framework-tutorial-1-6-30&#34;&gt;简介&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第二篇：&lt;a href=&#34;https://wtdf.io/nestjs-framework-tutorial-2-6-30&#34;&gt;入门&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第三篇：&lt;a href=&#34;https://wtdf.io/nestjs-framework-tutorial-3-6-30&#34;&gt;控制器&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第四篇：&lt;a href=&#34;https://wtdf.io/nestjs-framework-tutorial-4-6-30&#34;&gt;Providers&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第五篇：&lt;a href=&#34;https://wtdf.io/nestjs-framework-tutorial-5-6-30&#34;&gt;模块&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第六篇：&lt;a href=&#34;https://wtdf.io/nestjs-framework-tutorial-6-6-30&#34;&gt;中间件&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第七篇：&lt;a href=&#34;https://wtdf.io/nestjs-framework-tutorial-7-6-30&#34;&gt;异常过滤器&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第八篇：&lt;a href=&#34;https://wtdf.io/nestjs-framework-tutorial-8-6-30&#34;&gt;管道&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第九篇：&lt;a href=&#34;https://wtdf.io/nestjs-framework-tutorial-9-6-30&#34;&gt;守卫&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第十篇：&lt;a href=&#34;https://wtdf.io/nestjs-framework-tutorial-10-6-30&#34;&gt;拦截器&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第十一篇：自定义装饰器）&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;Nest 是一个用于构建高效、可扩展的 Node.js 服务端应用框架，基于 TypeScript 编写并且结合了 OOP&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Object-Oriented&#34;&gt;&lt;a href=&#34;#fn:Object-Oriented&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;、FP&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Functional-Progr&#34;&gt;&lt;a href=&#34;#fn:Functional-Progr&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;、FRP&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Functional-React&#34;&gt;&lt;a href=&#34;#fn:Functional-React&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; 的相关理念。并且设计上很多灵感来自于 Angular&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Angular-is-a-pla&#34;&gt;&lt;a href=&#34;#fn:Angular-is-a-pla&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;Angular 的很多模式又来自于 Java 中的 Spring 框架，依赖注入、面向切面编程等，所以你可以认为： &lt;strong&gt;Nest 是 Node.js 版的 Spring 框架&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;或许很多前端工程师看到这里就自动劝退了，事实上我以前也挺讨厌 Java 的（现在也不怎么喜欢），后来由于工作原因学习到了一些 Java 相关的知识后才发现自己的认识很片面。现在 WEB 后端主流的技术栈都基于 Spring 框架，框架必然是解决了很多实际问题，能学习到它的思想比它自己的出身、派系更重要。同时建议那些没有学习或者接触过 Java 的前端可以了解一些相关概念，不要拒绝，因为这可能会为你打开另一扇门。&lt;/p&gt;

&lt;p&gt;可能在很多伪 FP 爱好者来看 OOP 是臃肿无用的东西。但是从使用角度讲：&lt;strong&gt;FP 小而美，OOP 大而全&lt;/strong&gt;，如果不关注场景去讨论好坏没有任何意义。而且事实上这两者完全是不冲突的，可以结合得非常完美。不要被那些所谓的&lt;strong&gt;纯&lt;/strong&gt;函数、&lt;strong&gt;纯&lt;/strong&gt;面向对象的概念误导，能写出真正的好代码才是重要的。&lt;/p&gt;

&lt;p&gt;如果你以前在使用 Node.js 开发后端应用时常常不知道如何规划代码关系，搞不清楚控制器、服务、模型和数据的关系，或者是你打算使用 Node.js 构建大型应用，那就建议你了解一下 Nest。&lt;/p&gt;

&lt;h3 id=&#34;框架的哲学&#34;&gt;框架的哲学&lt;/h3&gt;

&lt;p&gt;在开始体验前，有必要简单介绍下 Nest 框架的的设计理念，我结合我自己的理解大概梳理下。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;近几年由于 Node.js 的出现，JavaScript 成为了前端和后端的「lingua franca&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:-&#34;&gt;&lt;a href=&#34;#fn:-&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;」，前端方面出现了 Angular, React, Vue 等众多的 UI 框架，后端方面也有像 Express, Koa 这样优秀的框架出现，但这些框架都没有高效地解决一个核心问题 — &lt;strong&gt;架构&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;官方的这段介绍和我看到的非常一致，注意作者说是&lt;strong&gt;高效地&lt;/strong&gt;解决，我的理解是现在 Node.js 或者说 JavaScript 框架都是各做各的，都是些点，可能确实有做的很不错的，但是整体而言并没有一个把各种好东西串链起来做成一种通用模式的框架，或者说是架构。&lt;/p&gt;

&lt;p&gt;这个问题主要有三方面原因：其一，现在大多前端工程师的工作范围还是局限于前端 UI 层，或者说视图层，后端一般都由更加成熟的一技术栈来实现；其二，Node.js 诞生于 2009 年，相比于 2002 就发第一版的 Spring 差的很远；其三，Node.js 实际上就是 JavaScript，这门语言本身也有很多缺陷，以至于无法胜任大型应用的架构场景。&lt;/p&gt;

&lt;p&gt;虽然有这些问题但是我始终认为 Nest 是个很好的开端，或者说对于所谓的「全栈」工程师来讲是个好事。因为我认为在大型项目中构架层面的复用比代码层面的复用更重要。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;安装 Nest 最方便的方法就是使用它额外提供的一个 CLI 工具（需要安装 Node.js &amp;gt; 8.9 版本），使用下面的命令它可以帮你自己生成项目的目录结构和预定义的最小模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm i -g @nestjs/cli
nest new project-name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后命令行可以看见它自动生成的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  github.com nest new project-name
⚡  We will scaffold your app in a few seconds..

CREATE /project-name/.prettierrc (51 bytes)
CREATE /project-name/README.md (3370 bytes)
CREATE /project-name/nest-cli.json (84 bytes)
CREATE /project-name/nodemon-debug.json (163 bytes)
CREATE /project-name/nodemon.json (67 bytes)
CREATE /project-name/package.json (1808 bytes)
CREATE /project-name/tsconfig.build.json (97 bytes)
CREATE /project-name/tsconfig.json (325 bytes)
CREATE /project-name/tslint.json (426 bytes)
CREATE /project-name/src/app.controller.spec.ts (617 bytes)
CREATE /project-name/src/app.controller.ts (274 bytes)
CREATE /project-name/src/app.module.ts (249 bytes)
CREATE /project-name/src/app.service.ts (142 bytes)
CREATE /project-name/src/main.ts (208 bytes)
CREATE /project-name/test/app.e2e-spec.ts (561 bytes)
CREATE /project-name/test/jest-e2e.json (183 bytes)

? Which package manager would you ❤️  to use? yarn
▹▸▹▹▹ Installation in progress... ☕
🚀  Successfully created project project-name
👉  Get started with the following commands:

$ cd project-name
$ yarn run start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时可以按提示，进入到 &lt;code&gt;project-name&lt;/code&gt; 运行项目。如果看到下面的输出就表示成功了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  github.com cd project-name
➜  project-name git:(master) ✗ yarn run start
yarn run v1.10.1
$ ts-node -r tsconfig-paths/register src/main.ts
[Nest] 26470   - 2019/06/30 下午8:58   [NestFactory] Starting Nest application...
[Nest] 26470   - 2019/06/30 下午8:58   [InstanceLoader] AppModule dependencies initialized +11ms
[Nest] 26470   - 2019/06/30 下午8:58   [RoutesResolver] AppController {/}: +5ms
[Nest] 26470   - 2019/06/30 下午8:58   [RouterExplorer] Mapped {/, GET} route +3ms
[Nest] 26470   - 2019/06/30 下午8:58   [NestApplication] Nest application successfully started +3ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们访问 &lt;code&gt;http://localhost:3000&lt;/code&gt; 就可以看到 &lt;code&gt;Hello World!&lt;/code&gt; 了。用编辑器打开目录结构如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/30/5d18b3033825c45837.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;自动生成的配置文件还是挺多的，我们现在暂不用关注这些，只需要知道大概是做什么的就行了。&lt;/p&gt;

&lt;p&gt;从上面的命令行中可以看出来整个项目是用 ts-node 跑起来的，这样的目的就是在开发环境节去了编译 .ts 的过程（实际上是 ts-node 在背后做了这个事情）。我们只需要关注 &lt;code&gt;src/main.ts&lt;/code&gt; 这个入口文件即可。&lt;/p&gt;

&lt;p&gt;整个 main.ts 文件就 8 行代码，使用 Nest 的工厂函数创建了一个应用实例，并且监听 3000 端口。注意，Nest 默认会使用 ES 的 async/await 语法，所以你再也不用怕嵌套回调函数了，以同步的编码方式获取异步的效率。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:Object-Oriented&#34;&gt;Object Oriented Programming — 面向对象的编程 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Object-Oriented&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Functional-Progr&#34;&gt;Functional Programming — 函数式的编程 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Functional-Progr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Functional-React&#34;&gt;Functional Reactive Programming — 函数式响应工式编程 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Functional-React&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Angular-is-a-pla&#34;&gt;Angular is a platform for building mobile and desktop web applications. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Angular-is-a-pla&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:-&#34;&gt;一种术语，表示通用语言 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:-&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>复联4是一集电视剧，3才是一部电影</title>
      <link>https://keelii.com/2019/06/20/why-avengers-3-is-better-6-7/</link>
      <pubDate>Thu, 20 Jun 2019 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2019/06/20/why-avengers-3-is-better-6-7/</guid>
      <description>

&lt;p&gt;相信复联4的热度也应该过了，今天我来聊天复联4的观影感受以及我对漫威系列电影的一些看法。&lt;/p&gt;

&lt;p&gt;当然我并不是一名合格的漫威迷，对漫威系列电影的一些细节也不是很了解，更没看过漫画。我只想说说做为一名普通的观电影者的感受。&lt;/p&gt;

&lt;h2 id=&#34;我是如何喜欢上漫威电影的&#34;&gt;我是如何喜欢上漫威电影的&lt;/h2&gt;

&lt;p&gt;我看的第一部温威电影就是《钢铁侠》，记得还是在上大学的时候。那种感觉就像是小时候看的变形金刚变成真人了。人与机器居然能结合的那么天衣无缝，简直酷毙了。这全要归功于托尼这个角色的设计。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;托尼·史塔克是一名&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BC%81%E4%B8%9A%E5%AE%B6&#34; title=&#34;企业家&#34;&gt;企业家&lt;/a&gt;、天才发明家兼极度自恋的花花公子&lt;/em&gt; — 单是这描述就能让大多数人惊叹不已了。但是他身上却有着更重要的一样东西，反复看过几遍钢铁侠后你会发现托尼身上有一种&lt;strong&gt;人类理性&lt;/strong&gt;的闪光点。&lt;/p&gt;

&lt;p&gt;回顾每次托尼面临困境时，他似乎总是能像计算机一样进行精确计算从而得出问题的最佳解决方法。即：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;用最少的代价，获取最大的收益&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所有的逻辑分支他都会考虑进去。为了达到最终目标，他可以忍气吞声，放下牵挂。而且他还有很强大的意志力，这种能力可能就来自于「with great power comes great responsibility」。因为他自视甚高，他相信自己是天才，自己是被选中的。&lt;/p&gt;

&lt;p&gt;当然他也是普通人，有爱、有恨也有罪过。你很难想像这样一个有有血有肉的常人同时结合了机器的优点。有了飞行、攻击、防御这些特殊技能后，托尼就可以完全放飞自己，因为他想到的东西立马就可以做到，随着顶尖科学技术的进化与探究，时间/空间这些以前限制人类的东西都有可能都会被打破。&lt;/p&gt;

&lt;p&gt;从托尼身上你能看到人类思想的一种无限状态，在不受物理限制情况下人类的思维创意能达到什么样的高度？&lt;/p&gt;

&lt;p&gt;在钢铁侠系列影片中我最喜欢的一个片部分就是钢铁侠盘旋冲上天空的那个片段，这远比看着航天飞机升空的感觉更加震撼。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa2db8ddded25755.png&#34; alt=&#34;iron-man-0.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这仿佛就是冲破规则的束缚自由超越的一种象征&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa2db1a24ec48688.png&#34; alt=&#34;iron-man-03.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/08/5cfb11d89aefc93562.png&#34; alt=&#34;iron-man-01.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同时他也是个正常人类，有感情，有爱恨&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa2db5eeebe76397.png&#34; alt=&#34;iron-man-04.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;如何评价复联3&#34;&gt;如何评价复联3&lt;/h2&gt;

&lt;p&gt;复联3是继钢铁侠系列之后我最喜欢的一部漫威电影。实际上我在评价一部电影的时候并不会太在意之前几部的质量。&lt;/p&gt;

&lt;p&gt;因为我认为衡量一部好电影的标准应该是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;给任何一个人看完之后都有所受益就是一部好电影。这个受益可能是娱乐八卦，可能是爱恨情仇，也可能是角色创意或者影片本身要表达的某种哲理思想&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;并且我认为最重要的一点就是&lt;strong&gt;影片要表达的某种思想或者哲理&lt;/strong&gt;，因为这是最能引发人反思的东西。&lt;/p&gt;

&lt;p&gt;毫无疑问，复联3中灭霸这个角色是有史以来众多反派角色中最出色的一个。灭霸被设计成了一个外在与内在都很强大的角色。&lt;/p&gt;

&lt;p&gt;外形上灭霸有着比普通从大的多的尺寸用以艺术上的对比效果。他的手可以轻松抓住一个人的头部（开头抓雷神的头），小物件放在他手里有很强的视觉冲击：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa2f1262fbc14384.png&#34; alt=&#34;thanos-2.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这让我想起了《三国志》中对典韦的一段描写：「形貌魁梧，旅力过人，有志节任侠。一手执定旗杆，立于风中，巍然不动…」&lt;/p&gt;

&lt;p&gt;同时灭霸的声音也非常有特色，沉稳，冷酷中透着死一般的坚定。虽然女性观众可能更喜欢雷神或者洛基的声音。&lt;/p&gt;

&lt;p&gt;内在方面主要由感情和信念理想两条主线：&lt;/p&gt;

&lt;h3 id=&#34;与卡魔拉的父女亲情-感情线&#34;&gt;与卡魔拉的父女亲情（感情线）&lt;/h3&gt;

&lt;p&gt;这一段是全剧中我最喜欢的一段，几乎没有任何瑕疵。这个不到5分钟的片段，好就好在无论你有没有看过前几部甚至是单看这一段，每个人都会理解到「中心思想」，当然这个中心思想因人而异。下面我就简单解析下我对这段剧情理解。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;++Red Skull++（红骷髅）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What you seek lies front of you — 你想要的东西就在前面&lt;/p&gt;

&lt;p&gt;as does what you fear — 就像你恐惧的一样&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa376783bf274270.png&#34; alt=&#34;Red-Skull.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为什么说「你想要的东西就在前面，就像你恐惧的一样」，我的理解是当一个人想要一样东西的欲望到极致的时候，就会有一种矛盾恐惧 — 怕得不到，同时也怕得到。得不到意味着自己的所有努力和牺牲就白费了，同时越不容易得到的东西总会给人一种越容易丢失错觉。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;美好的东西都在一瞬间，不容易得到的东西一旦拥有失去也会很快。当你经历过这个轮回才会发现没有什么东西是美好的，美好的背后可能是你看不见的丑陋的牺牲，没有这些丑陋的牺牲美好也失去了意义。这一切都在于你是否准备好了拿等价的牺牲去交换…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;++Gamora++（卡魔拉）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What’s this — 这是什么&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;++Red Skull++（红骷髅）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The price — 代价&lt;/p&gt;

&lt;p&gt;Soul holds a special place among the infinity stones, you might say it has a certain wisdom — 灵魂宝石在众多无限宝石中有特殊的地位，或者说有一种特殊的智慧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;++Thanos++（灭霸）这里灭霸还没意识到代价是什么&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tall me what it needs — 告诉我它需要什么&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;++Red Skull++（红骷髅）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;to ensure that whoever possesses it understands its power… 为了保证持拥有它的人明白它的威力&lt;/p&gt;

&lt;p&gt;the stone demands a sacrifice — 宝石需要一样「牺牲」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;++Thanos++（灭霸）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;of what — 什么&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;++Red Skull++（红骷髅）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;in order to take the stone, you must lose that which you love — 为了得到宝石，你必须牺牲一件你的至爱&lt;/p&gt;

&lt;p&gt;a soul for a soul — 一个灵魂换一个灵魂&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意此时灭霸和卡魔拉的心理状态的不同：&lt;/p&gt;

&lt;p&gt;灭霸陷入了沉思，他可能在思考什么才算得上是自己的&lt;strong&gt;至爱&lt;/strong&gt;，他一生做的事情太多，但回想起来似乎连自己都找不到哪件事情能表现出他的&lt;strong&gt;爱&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa30753119d16205.png&#34; alt=&#34;thanos-3.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此时卡魔拉内心窃喜，因为在她看来灭霸没有半点人性，更谈不上&lt;strong&gt;爱&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa3a0ab768b68906.png&#34; alt=&#34;gemera.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;于是他说了下面这段现在看来很残忍的话：&lt;/p&gt;

&lt;p&gt;++Gamora++（卡魔拉）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;all my life, i dreamed of a day… a moment… — 我一生都梦想有一天，此刻…&lt;/p&gt;

&lt;p&gt;when you got what you deserved. and i always so disappointed. — 每当你如尝所愿，我就对你恨之入骨&lt;/p&gt;

&lt;p&gt;But now… — 但是现在…&lt;/p&gt;

&lt;p&gt;you kill and torture… and you call it mercy. — 你暴虐滥杀无辜… 你自许仁慈.&lt;/p&gt;

&lt;p&gt;The universe has judged you. — 现在老天终于要惩罚你.&lt;/p&gt;

&lt;p&gt;You asked it for a prize, and it told you no. — 你想用一个条件换宝石，但是你不会特呈的.&lt;/p&gt;

&lt;p&gt;You failed. — 而且你已经输了.&lt;/p&gt;

&lt;p&gt;And do you wanna know why? — 想知道为什么吗？&lt;/p&gt;

&lt;p&gt;Because you love nothing, no one — 因为你从来没有爱过，一次都没有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa3def13d1785925.png&#34; alt=&#34;thanos-5.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这段话字字珠玑，开始或许灭霸还没有意思到自己至爱到底是什么，但是没过多久他就开始意识到自己的至爱就是卡魔拉，此时眼角已经有泪痕。&lt;/p&gt;

&lt;p&gt;此时剧情已到了关键的转折点，灭霸的背影则暗喻着一位父亲的高大形象&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa3e3c5f93082010.png&#34; alt=&#34;thanos-6.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;++Thanos++（灭霸）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;No. — 不.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意此刻的灭霸说 No 的语气，绝对不是想去否定些什么，而像是一种安慰。充满爱意的「No」，如果他是其它角色相信后面的台词都出自动出现在我们脑子里「No, my litter gril, i love you more than i can say…」&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa3e3c25fb821207.png&#34; alt=&#34;thanos-7.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;灭霸实际上是非常的孤独，所有他的想法都不被周围的人认可，虽然他强大的内心可以完全不在意外人的评判，但是他还做不到不在乎自己的女儿对他的评价。所以反射性的去否定卡魔拉，他非常坚定的相信自己是爱自己女儿的，同时也表露出了即将要失去女儿的真挚情感。&lt;/p&gt;

&lt;p&gt;++Gamora++（卡魔拉）此时的卡魔拉还没有反应过来，她认为灭霸是因为自己的计划无法得逞而为自己流泪。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Really, tears? — 真的吗，你也会为自己流泪？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;她还没有发现自己在恨父亲的同时实际上对灭霸也是有感情的，正所谓爱之深、恨之切…&lt;/p&gt;

&lt;p&gt;++Red Skull++（红骷髅）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;They’are not for him. — 他并不是为自己&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa427e13e4589803.png&#34; alt=&#34;thanos-10.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;还没来得及反应，红骷髅的话惊醒了她，同时她似乎也感受到了她与灭霸之间的那份父女之情（脸色表情也开始变化，赞演技），真正的爱恰恰是只能通过感觉而来，不用任何语言来表达的。&lt;/p&gt;

&lt;p&gt;内心已经感觉到了自己与灭霸之间的亲情，这是无法否定的，此时她也陷入了无助&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa43e0b722a29444.png&#34; alt=&#34;thanos-11.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;虽然是这样理智还是让她不肯相信这个事实，于是卡魔拉也开始否定。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;No, this isn’t love — 不，这不是爱&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;++Thanos++（灭霸）很难想像灭霸在这一小段时间内，内心情绪有多么的复杂。他终其一生想要完成的事业却要让他失去至爱。他是一个无比理想化的存在，为了自己的理想可以放弃任何东西，而且他已经错过一次命运，所以这次他选择了完成自己的宿命。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I ignored my destiny once, i can&amp;rsquo;t do that again, Even for you — 我已经错过一次命运了，不能再错一次，即使以失去你为代价&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa4998da76121144.png&#34; alt=&#34;thanos-12.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此时灭霸的脸上完成没有了恶霸的冷酷表情，而是一种对于将要失去至爱的无助与失落…&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa4a2cdcbce18508.png&#34; alt=&#34;thanos-13.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着他亲手将自己的女儿仍下悬崖，但此刻灭霸的表情似乎呆住了，可能他自己也不能相信他自己的所做所为&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa4a56d1b2f91572.png&#34; alt=&#34;thanos-14.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/07/5cfa4aed84ed566262.png&#34; alt=&#34;thanos-15.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;自己的信念-理想线&#34;&gt;自己的信念（理想线）&lt;/h3&gt;

&lt;p&gt;一个从不说谎的人只有一种可能，就是及其的理想主义，在他们的认知里面只有真理、对错以及自己的信念。从灭霸和卡魔拉的对话就能看出。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You are strong — me&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;re generous — me&lt;/p&gt;

&lt;p&gt;But i never taought you to lie&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然外在的的强大只是陪衬，他身上最能感染人的是那种不惜一切代价追求自己理想的一种信仰&lt;/p&gt;

&lt;p&gt;从这个层面来讲，钢铁侠和灭霸的信仰是平等的。在这个层面他们之间没有矛盾，没有正义/邪恶 之分。理由很简单：&lt;strong&gt;你认为拯救更多的人类是你的正确信仰，那我认为通过随机消灭一半生命可以让宇宙达到一种平衡也是我的正确信仰&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;托尼和灭霸想要维护的东西不在一个层面上，所以无法判断对方是否正确。我觉得复联3留给观众的一个最大的问题就是&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;托尼拯救地球的理想是理想，那灭霸要维护宇宙的平衡的理想算不算是理想？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;人类看待这个问题会受限于自身的环境，理性上受制于时间空间，感性上受制于感情。所以在这个问题上多数人连判断的资格都没有&lt;/p&gt;

&lt;p&gt;第3部在我看来是这一个巨大的切入点，并期待第4部能有所解释&lt;/p&gt;

&lt;h2 id=&#34;回头再看复联4&#34;&gt;回头再看复联4&lt;/h2&gt;

&lt;p&gt;仅过了一年，我带着期待去看了复联4，但并没有达到我的预期。因为大家都了把复联当成了一部电视剧在看。电影本身也几乎没有了电影的元素，除了各种超级英雄的梗外我实在没看出来有什么亮点。&lt;/p&gt;

&lt;p&gt;这可能也符合了事物发展的规律，当有太多人喜欢一样东西、追求一样东西的时候事情就变味儿了，毕竟电影公司做为商业机构是要维护自己的品牌，要照顾多数人的情感。就好比电视剧演久了观众就会有了心理预期，很难创新一样。&lt;/p&gt;

&lt;p&gt;但是复联4做为 MCU 电影的标致性阶段，也算是一个好的结尾，毕竟要照顾到多数的人喜好，同时要融合各种英雄人物的离场，还要演的不那么生硬确实太难了。&lt;/p&gt;

&lt;p&gt;总的来说，复联3杂而不乱，主线支线明显，影片整体有层次感，剧情紧凑连续演员的演技也非常棒。复联4则是让所有普通的每一个人（类）都享受到了一种胜利的喜悦。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>也许 Markdown 并不是一个好选择</title>
      <link>https://keelii.com/2019/06/06/md-maybe-not-good-enough/</link>
      <pubDate>Thu, 06 Jun 2019 18:31:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/06/06/md-maybe-not-good-enough/</guid>
      <description>

&lt;p&gt;我经常会使用 markdown 来写一些东西。比如：博客文章、技术文档什么的。但是时间长了总是会觉得编辑 Markdown 源码的方式太容易让人分心了。&lt;/p&gt;

&lt;p&gt;Markdown 确实是一个非常好的&lt;strong&gt;通用&lt;/strong&gt;排版格式，因为它很简单，学习使用起来没有门槛。但是随着人们越来越多的使用 Markdown 创作，Markdown 本身的一些问题也显露出来。比如：当你需要一些高级排版格式的时候 Markdown 是无能为力的，更不用说表格编辑这类重排版的工作在 Markdown 中的编辑体验了。&lt;/p&gt;

&lt;p&gt;当然开源社区会有一些开源项目来扩展 Markdown 的功能，甚至是用 Markdown 来画流程图。这且没有什么问题，问题是当你使用了一些扩展的高级功能时又想把他扩展到其它系统（比如博客），这时你又不得不改造博客来适配这些功能，Markdown 也就丧失了它的便携性。所以说使用 Markdown 的关键问题在于：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如何能更简单方便的使用 Markdown，同时又不失一些好用的功能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;如何解决编辑的体验问题&#34;&gt;如何解决编辑的体验问题&lt;/h4&gt;

&lt;p&gt;编辑排版最佳的体验毫无疑问是「&lt;strong&gt;所见即所得&lt;/strong&gt;」的模式。因为人们总是喜欢改完东西立即看见效果。目前常用的 Markdown 编辑器通常分左右两列：++源码++ ｜ ++预览++。实际上我认为这种模式并不好，甚至是错的。因为整个编辑过程会非常痛苦，你不得不既关注源码里面的格式，如：空格、Markdown 符号，还得关注预览出来的效果是不是满意然后再调整。&lt;/p&gt;

&lt;p&gt;相比之下 &lt;a href=&#34;https://typora.io/&#34;&gt;Typora&lt;/a&gt; 给出了稍好一些的体验方案 — &lt;strong&gt;富文本的编辑模式 +&lt;/strong&gt; &lt;strong&gt;Markdown 源格式&lt;/strong&gt;。这应该也是目前 Markdown 最好的编辑方式了，但是在我看来还是不够好。&lt;/p&gt;

&lt;p&gt;我自己在书写 Markdown 文件的时间会非常注意格式排版，比如：标点符号，中英文空格，分行留白等，Typora 的编辑模式并不能让我免于这样的困扰，我还是不得不关注 Markdown 的那些符号，这些符号就像听音乐时的耳机里面的「杂音」一样。当你专注于写作，一口气写下上千字的时候，很容易就会被这种杂音打断，灵感转瞬即逝…&lt;/p&gt;

&lt;h4 id=&#34;如何添加一些功能特性&#34;&gt;如何添加一些功能特性&lt;/h4&gt;

&lt;p&gt;这个问题我认为不应该给 Markdown 扩展功能，因为扩展 Markdonw 只能通过&lt;strong&gt;添加更多符号&lt;/strong&gt;的形式实现。而这会增加它的复杂度，最终让 Markdown 格式变的&lt;strong&gt;不可交换&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;各种编辑方式按功能强大的排序应该是：Makrdown &amp;lt; 富文本 &amp;lt; Word。复杂的功能应该由后面两种工具来胜任，Markdown 可以做为一种格式上的约定。重功能不需要它来实现，比如编辑表格的体验在 Markdown 里简直就是灾难，但是在富文本或者 Word 中却异常简单。这就像是 Markdown 应该做为++接口++来定义一些规范，而不应该让它去关心具体++实现++。&lt;/p&gt;

&lt;h4 id=&#34;结论&#34;&gt;结论&lt;/h4&gt;

&lt;p&gt;既然如此那有没有更好的解决方案呢（广告预警）。我正在开发一款基于网页的 WYSIWYG&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:What-You-See-Is&#34;&gt;&lt;a href=&#34;#fn:What-You-See-Is&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 富文本编辑器应用，并试着解决上面的这些问题，解决 Markdown 问题的同时又能获得富文本编辑的优质体验，主要面向有写作和编辑文章/笔记需求的用户。如果你也刚好有这个需求，不妨试试：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;//wtdf.io&#34;&gt;wtdf.io&lt;/a&gt; — 基于网页的所见即所得 Markdown 写作应用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:What-You-See-Is&#34;&gt;What You See Is What You Get — 中译「所见所得」 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:What-You-See-Is&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>选择太多所以迷失方向</title>
      <link>https://keelii.com/2019/03/24/choice-leads-lose/</link>
      <pubDate>Sun, 24 Mar 2019 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2019/03/24/choice-leads-lose/</guid>
      <description>&lt;p&gt;前几天无意在微博上看见了《流浪汉沈巍自述》一文，此文来自一个上海的流浪汉语录。&lt;/p&gt;

&lt;p&gt;不同的是他并不是为了生计而流浪捡破烂，沈巍从小喜欢捡破烂，捡完破烂换了钱买书看。家庭环境不理解更不支持，到了社会上，他本来可以按大多数人眼中的 &lt;strong&gt;正常&lt;/strong&gt; 人一样工作，一辈子当公务员。&lt;/p&gt;

&lt;p&gt;但是他还是改不了自己捡破烂的习惯，这样以来单位也容不下他。想法完全不与主流融合，只能被流浪。可以即便是这样，在看它的文字里，你仍然能感受到字里行间都散发着对生活的无限向往，对信念的追求，以及对残酷现实的一丝温柔。&lt;/p&gt;

&lt;p&gt;有人说故事分两种：一种开始就讲给你最美好的东西，最完美无缺的事物，人性最善良的部分。后来慢慢的什么都变了，以前那些看似美好的东西都有了瑕疵，人性也没能经得住时间的考验，所有的认识都支离破碎；还有一种一开始就告诉你最丑恶的东西，最让人恶心、难受的事物，人性最黑暗的一面。后来慢慢的也似乎变了，不经意的发现好像还有那么一丝光明的东西，一点点能让人感动的事情。&lt;/p&gt;

&lt;p&gt;前一种更像是从教科书到现实的一种过程，可能很多人慢慢的都受不了这种落差，逐渐没有了精神支柱，厌恶了生活。后一种则看似悲观、反面，实则能激发出人们本能善良的一面。&lt;/p&gt;

&lt;p&gt;这让我想起了一句话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;人不是活一辈子，不是活几年几月几天，而是活那么几个瞬间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于沈巍来说，社会和家庭给他的都是排斥、否认和异样的眼光。但是可能他就只能从书中找到了那么一丝光明，一些让自己感动的瞬间吧。&lt;/p&gt;

&lt;p&gt;我们可以反思下我们的现实生活。现实中我们总是说「自己没有选择，我不得不这样、没有退路…」。但事实上真的是这样吗？或许正是因为我们拥有的太多才让自己没法选择。&lt;/p&gt;

&lt;p&gt;人是很奇怪的，当你某天没有加班，工作完成后早早回家后突然发现居然还有很多时间可以安排。这时候你会想做很多事情：玩手机、睡觉、好好做顿饭、看部电影…&lt;/p&gt;

&lt;p&gt;但当你真正的面临很多种选择时，自己会去权衡。可能自己精神上很需要放松一下，需要娱乐一下。但是理智又告诉你应该做一些「有意义」的事情。最终可能一件事都没做好。&lt;/p&gt;

&lt;p&gt;这时候其实你需要用 &lt;strong&gt;肉体操纵精神&lt;/strong&gt;，不要想，先去做。因为实际上当你持续专注的做一件事情的时候，精神上会特别放松，你不需要再考虑那么多的选择，只需要 *像机器* 一样去做好一件事情。&lt;/p&gt;

&lt;p&gt;人总是可以通过做事情来让自己的 &lt;strong&gt;内心变的安稳&lt;/strong&gt;。我曾经无意中听到两人女生聊天，其中一个女生说&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我特别喜欢洗衣服，因为当我特别专注的把衣服洗干净的时候，那种感觉特别安静，虽然需要你耗费一些体力，但是洗完后你的内心会有一种解脱，一种如释重负的感觉…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我听到这段聊天的时候是特别惊讶的，原话特别有感染力。后来我发现了这种感觉就像是我平常写代码一样，一写起代码，就很专注，似乎能忘记时间。当你解决了一个问题，完成了一个功能模块的时候长呼一口吸、伸个懒腰，瞬间感觉特别满足。即使回到现实中你还得面临很多复杂的事情，但在这一时刻你是自由的。&lt;/p&gt;

&lt;p&gt;后来我也理解了那句 Nike 经典广告语「Just do it」的深刻涵义，当然这和我选择做 IT 行业是两码事。&lt;/p&gt;

&lt;p&gt;图：&lt;a href=&#34;https://www.pexels.com/photo/abstract-bright-color-dark-397998/&#34;&gt;https://www.pexels.com/photo/abstract-bright-color-dark-397998/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Pixi.js 构建一个视差滚动器（第三篇）</title>
      <link>https://keelii.com/2019/03/19/building-a-parallax-scroller-with-pixijs-cn-3/</link>
      <pubDate>Tue, 19 Mar 2019 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2019/03/19/building-a-parallax-scroller-with-pixijs-cn-3/</guid>
      <description>

&lt;h2 id=&#34;翻译对照&#34;&gt;翻译对照&lt;/h2&gt;

&lt;p&gt;原文：
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5226&#34;&gt;PART 1&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5666&#34;&gt;PART 2&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=6496&#34;&gt;PART 3&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=7046&#34;&gt;PART 4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译文：
&lt;a href=&#34;https://keelii.com/2019/03/16/building-a-parallax-scroller-with-pixijs-cn-1/&#34;&gt;第一篇&lt;/a&gt;・
&lt;a href=&#34;https://keelii.com/2019/03/17/building-a-parallax-scroller-with-pixijs-cn-2/&#34;&gt;第二篇&lt;/a&gt;・
&lt;a href=&#34;https://keelii.com/2019/03/19/building-a-parallax-scroller-with-pixijs-cn-3/&#34;&gt;第三篇&lt;/a&gt;・
第四篇&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;关注 &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=chriscaleb&#34;&gt;@chriscaleb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个系列的教程已经更新到了 &lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PixiJS v4&lt;/a&gt; 版本。&lt;/p&gt;

&lt;p&gt;欢迎再次来到这个系列教程的第三部分，这一节将会涉及到如何使用 pixi.js 制作视差滚动游戏的地图。整个教程到目前为止已经涵盖了很多内容。在第一个教程中，我们学习了一些 pixi.js 基础知识，并将视差滚动应用于几个层上。在第二部分，通过代码重构将一些面向对象的概念应用到实践中。这一节我们将把重点放在第三个更复杂的视差层上，它将代表玩家角色在游戏时将会穿越的地图。&lt;/p&gt;

&lt;h3 id=&#34;你将学到什么&#34;&gt;你将学到什么…&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如何处理纹理（textures）和精灵表（sprites sheet）&lt;/li&gt;
&lt;li&gt;对象池 的基础&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;预备知识&#34;&gt;预备知识…&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;pixi.js 基础&lt;/li&gt;
&lt;li&gt;了解 JavaScript 或者 ActionScript 的基础知识&lt;/li&gt;
&lt;li&gt;对面向对象有基本的概念&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们将继续从上一个教程结束的地方开始。你可以使用前两个教程编写的代码，也可以从 &lt;a href=&#34;https://github.com/ccaleb/pixi-parallax-scroller/tree/master/tutorial-2&#34;&gt;GitHub&lt;/a&gt; 下载第二个教程的源代码。也可以在 GitHub上 找到第三节完整教程的 &lt;a href=&#34;https://github.com/ccaleb/pixi-parallax-scroller/tree/master/tutorial-3&#34;&gt;源代码&lt;/a&gt;，即使你遇到了问题，我也鼓励你完成本教程，有疑问可以请仅参考源代码。&lt;/p&gt;

&lt;p&gt;这个系列的教程非常受到 &lt;a href=&#34;http://www.adamatomic.com/canabalt/&#34;&gt;Canabalt&lt;/a&gt; 和 &lt;a href=&#34;https://chrome.google.com/webstore/detail/monster-dash/cknghehebaconkajgiobncfleofebcog?hl=en&#34;&gt;Monster Dash&lt;/a&gt; 游戏的启发，当玩家的英雄在平台之间奔跑和跳跃时，这些游戏都能很好地利用视差滚动来提供花哨的视觉效果。&lt;/p&gt;

&lt;p&gt;在接下来的两节教程中，我们将构建一个非常类似于 Monster Dash 中的滚动游戏地图。 Monster Dash 的游戏地图是由一系列不同宽度和高度的砖块儿构建而成。游戏的目的是通过在砖块儿之间跳跃来尽可能长地生存。游戏地图的滚动速度随着时间的推移而增加。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yeahbutisitflash.com/pixi-parallax-scroller/final/index.html&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/25206/13/10616/142679/5c887df7E7c1fa38a/eab39f5f7ab1cc6d.png&#34; alt=&#34;ps-tut1-screenshot1&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面就是你这一节将要完成的示例。单击图片即可查看包含砖块儿和间隙的滚动地图。&lt;/p&gt;

&lt;h2 id=&#34;起步&#34;&gt;起步&lt;/h2&gt;

&lt;p&gt;如果你还没有看过第一节和第一节教程，我建议你应该先看完这两节。&lt;/p&gt;

&lt;p&gt;在本节教程中，我们将使用一些新的图片素材。可以直接从 &lt;a href=&#34;www.yeahbutisitflash.com/pixi-parallax-scroller/tutorial-3/resources.zip&#34;&gt;这里&lt;/a&gt; 下载，并将其内容解压缩到项目的 resource 文件夹中。&lt;/p&gt;

&lt;p&gt;下面就是你的 &lt;code&gt;resource&lt;/code&gt; 文件夹的样子（Windows）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t1/31697/16/6353/53328/5c8e01e2E14bc1c7b/d5701c262078bc35.png&#34; alt=&#34;ps-tut3-screenshot1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;macOS 下则是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/25309/3/11322/64214/5c8e01f7Ed95812be/fa19f72e6cc3b5e7.png&#34; alt=&#34;ps-tut3-screenshot2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此外，如果你还没有建立一个本地的 web 服务器，请参考第一节的内容。&lt;/p&gt;

&lt;p&gt;值得注意的是，本教程比前两篇长。你可能需要大约两个小时才能完成所有工作。&lt;/p&gt;

&lt;h2 id=&#34;游戏地图&#34;&gt;游戏地图&lt;/h2&gt;

&lt;p&gt;正如上面的演示中展示的那样，我们的游戏地图有很多种展示形式。如砖块儿的宽度和高度各不相同。每个跨度还包括一系列窗户和墙壁装饰元素。墙壁装饰本身由管道和通风口组成。&lt;/p&gt;

&lt;p&gt;那么墙跨度是如何构建的？每个跨度都是由一系列拼接在一起的垂直切片构成的。每个切片的大小为 64 x 256 像素。下图显示了示例砖块儿。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/11199/10/12039/18165/5c8e031aE2a8746ce/c51ef91aeebd739b.png&#34; alt=&#34;diagram-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过垂直移动每个切片的位置来处理砖块儿的高度。下面的示意图中我们可以看到，第二个面墙的切片部分位于视口的可见区域下方（译者：超出视口），使其看起来低于第一面墙。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/28702/23/11291/23279/5c8e047aE0dc68c77/08ba190fd4f5f08b.png&#34; alt=&#34;diagram-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;大多数情况，一而墙内的每个切片将会是水平对齐的。但有一个例外。 Monster Dash 有一个阶梯式的跨度，让玩家可以直接跌落到下一个水平线上。以下是它的构造方式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/14544/9/11325/22909/5c8e0484E33aa7b33/c2b3b720df1d69a1.png&#34; alt=&#34;diagram-3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果你仔细观察上面的示意图，你应该注意到这里真正的是墙面有两个（第一个跨度高于第二个），它们通过中间的一个切片（台阶）连接起来。&lt;/p&gt;

&lt;p&gt;你可能会惊讶地发现我们的整个游戏地图只由八种不同类型的垂直切片构成：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t1/18163/12/11214/22059/5c8e053aE742a81ce/3fe250596cbb7bab.png&#34; alt=&#34;diagram-4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这些切片的顺序很重要。我们再来谈谈这个问题。&lt;/p&gt;

&lt;h2 id=&#34;分解砖块墙&#34;&gt;分解砖块墙&lt;/h2&gt;

&lt;p&gt;一面砖块墙包括三个主要部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;前边缘&lt;/li&gt;
&lt;li&gt;中间部分&lt;/li&gt;
&lt;li&gt;后边缘&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前/后边缘都只由一个垂直切片表示。然而，中间部分可以由一个或多个切片制成。切片越多，墙跨度就越长。我们将制作一面有 30 个切片的砖块墙。下图可以解释砖块墙的三大部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/26701/4/11364/142241/5c8e0660E36cd06e7/61bb2ce4e0f7b003.png&#34; alt=&#34;diagram-5&#34; /&gt;&lt;/p&gt;

&lt;p&gt;墙的中间部分只有下面两种切片：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;窗口（window）&lt;/li&gt;
&lt;li&gt;装饰（decoration）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此整个墙的中间部分长度为 6，结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window, decoration, window, decoration, window, decoration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，通常情况下，砖块墙的中间部分是非偶数个切片才能保证出现的容器即有亮灯的也有灭的。所以我们使用 7 个切片来制作中间部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window, decoration, window, decoration, window, decoration, window
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了保证砖块墙尽可能看起来有趣，窗户可以点亮或不点亮，我们可以随机选择三种装饰切片。因此，墙的中间部分将由五种不同类型的切片构成。&lt;/p&gt;

&lt;p&gt;为了增加更多的切片种类，我们从砖块墙的边缘素材中（两个）选择两个切片做为前后边缘（译者：边缘素材有两个，可以随机选一个做前边缘，然后翻转它做成后边缘，但是不能一个做前一个做后，示意图中的 front &amp;amp; back 和图片没有对应关系），后边缘也可以使用同样的前边缘，因为我们只需要把它（前边缘）水平翻转然后正确地拼接到后边缘即可。台阶切片很少会出现，所以我们只需要用一个切片。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/26044/20/11490/360476/5c8f0047Ec7d99a6b/b226b682c6da3a9f.png&#34; alt=&#34;diagram-6-1024x531&#34; /&gt;&lt;/p&gt;

&lt;p&gt;打开上面的素材，单独放在一个浏览器 tab 里面，可以方便制作时查看它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;不要将切片 &lt;strong&gt;类型&lt;/strong&gt; 与用于构建指定砖块墙的切片数混淆。例如，一面砖块墙可以有 30 个垂直切片，但实际上只由 8 类切片构建。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在你已经了解了砖块墙是如何构建的，我们可以开始实现它了。&lt;/p&gt;

&lt;h2 id=&#34;精灵表-sprite-sheet&#34;&gt;精灵表（Sprite sheet）&lt;/h2&gt;

&lt;p&gt;如上所述，我们的砖块墙由八种不同类型的砖块构成。表示这些切片的最简单方法是为每个切片提供单独的 PNG文件。虽然这是一种办法，但我们实际上会将所有切片添加到一个称为 &lt;strong&gt;精灵表&lt;/strong&gt; 的大型 PNG 文件中。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;精灵表通常也称为 &lt;strong&gt;纹理图集（texture atlas&lt;/strong&gt;） 。我们将在本教程中使用 &lt;strong&gt;精灵表&lt;/strong&gt; 这个术语。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我在本教程的 resources.zip 文件中提供了精灵表。这是一个名为 &lt;code&gt;wall.png&lt;/code&gt; 的文件，如下所示。所有八个切片都已打包到一个位图上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/16841/31/11340/23788/5c8f02ecEcdd940cb/a38fb14d2958229f.png&#34; alt=&#34;sprite-sheet&#34; /&gt;&lt;/p&gt;

&lt;p&gt;资源文件夹中还有一个与精灵表对应的 &lt;code&gt;wall.json&lt;/code&gt; 文件。可以直接用文本编辑器打开。此文件使用 JSON 数据格式来定义精灵表中单独位图切片的名称和位置。使用精灵表时，表中的每个单独的位图称为 &lt;strong&gt;帧&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我们的整个精灵表将作为纹理加载到代码中（中间层和远景图层也这么加载过）。因此，有时会将框架视为子纹理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;并不需要完全理解 JSON 文件，因为 Pixi 将处理它。但是，我们可以探索一下正在使用的这个文件。下面这段是来自 JSON 数据中的一段，表示第一个墙边切片的框架。我已经为高亮了一些代码行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;edge_01&amp;quot;: // 高亮
{
  &amp;quot;frame&amp;quot;: {&amp;quot;x&amp;quot;:128,&amp;quot;y&amp;quot;:0,&amp;quot;w&amp;quot;:64,&amp;quot;h&amp;quot;:256},// 高亮
  &amp;quot;rotated&amp;quot;: false,
  &amp;quot;trimmed&amp;quot;: false,
  &amp;quot;spriteSourceSize&amp;quot;: {&amp;quot;x&amp;quot;:0,&amp;quot;y&amp;quot;:0,&amp;quot;w&amp;quot;:64,&amp;quot;h&amp;quot;:256},
  &amp;quot;sourceSize&amp;quot;: {&amp;quot;w&amp;quot;:64,&amp;quot;h&amp;quot;:256}
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行包含与框架关联的 &lt;strong&gt;唯一名称&lt;/strong&gt;（&lt;code&gt;edge_01&lt;/code&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;edge_01&amp;quot;:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每当我们想要从精灵表中直接获取这个墙切片的图像时，我们将使用此名称。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你不熟悉 JSON 数据格式，则可以在此 &lt;a href=&#34;https://zh.wikipedia.org/zh-cn/JSON&#34;&gt;Wikipedia 条目&lt;/a&gt; 中找到更多信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下一个高亮行代码定义了框架的矩形区域：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;frame&amp;quot;: {&amp;quot;x&amp;quot;:128,&amp;quot;y&amp;quot;:0,&amp;quot;w&amp;quot;:64,&amp;quot;h&amp;quot;:256},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本质上，它用于在精灵表中定位帧的位图。&lt;/p&gt;

&lt;p&gt;JSON 文件中还有其他七种类型的切片。每个切片将由唯一的帧名称表示。使用精灵表时，你只需要知道 &lt;strong&gt;唯一名称&lt;/strong&gt; 即可。下面我还提供了一张标有每个切片类型的图片。也可以单独打开这个图片，方便回顾。&lt;/p&gt;

&lt;p&gt;wall.json 的后面，有一些元数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;meta&amp;quot;: {
  &amp;quot;app&amp;quot;: &amp;quot;http://www.codeandweb.com/texturepacker &amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0&amp;quot;,
  &amp;quot;image&amp;quot;: &amp;quot;wall.png&amp;quot;,
  &amp;quot;format&amp;quot;: &amp;quot;RGBA8888&amp;quot;,
  &amp;quot;size&amp;quot;: {&amp;quot;w&amp;quot;:256,&amp;quot;h&amp;quot;:512},
  &amp;quot;scale&amp;quot;: &amp;quot;1&amp;quot;,
  &amp;quot;smartupdate&amp;quot;: &amp;quot;$TexturePacker:SmartUpdate:fc102f6475bdd4d372c...&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该数据表示精灵表的实际文件的相对路径。 Pixi 将使用该数据加载正确的 PNG 文件。&lt;/p&gt;

&lt;h2 id=&#34;纹理打包器-texturepacker&#34;&gt;纹理打包器（TexturePacker）&lt;/h2&gt;

&lt;p&gt;我使用了一个工具来生成本教程的精灵表和 JSON 文件。它的名字叫 &lt;a href=&#34;http://www.codeandweb.com/texturepacker&#34;&gt;TexturePacker&lt;/a&gt;，可用于Windows，Mac OS X 和 Linux。它可以导出许多精灵表格式，包括 pixi.js 使用的JSON（哈希）格式。我不会在本教程中介绍如何使用 TexturePacker，但它非常容易掌握。付费版本也物超所值，还有一个免费版本，适合那些想先学习基础知识的人。&lt;/p&gt;

&lt;h2 id=&#34;加载精灵表&#34;&gt;加载精灵表&lt;/h2&gt;

&lt;p&gt;既然我们对精灵表有一点了解了，就让我们继续把它加载进程序。我们首先将一些代码添加到项目的 Main 类中。用文本编辑器中打开 Main.js。&lt;/p&gt;

&lt;p&gt;在文件的末尾，添加以下方法来加载精灵表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.loadSpriteSheet = function() {
  var loader = PIXI.loader;
  loader.add(&amp;quot;wall&amp;quot;, &amp;quot;resources/wall.json&amp;quot;);
  loader.once(&amp;quot;complete&amp;quot;, this.spriteSheetLoaded.bind(this));
  loader.load();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了 &lt;code&gt;PIXI.loaders.Loader&lt;/code&gt; 类，它可用于加载图像，精灵表和位图字体文件。我们直接从 &lt;code&gt;PIXI.loader&lt;/code&gt; 属性获取加载器的预定义的实例来使用加载器，所有资源都可以人这里加载。所以，只需把 &lt;code&gt;wall.json&lt;/code&gt; 文件也添加进去。我们传递一个与文件关联的唯一 ID 作为第一个参数，并将资源的实际相对路径作为第二个参数传递。&lt;/p&gt;

&lt;p&gt;加载精灵表后，PIXI.loaders.Loader 类会触发一个 &lt;code&gt;complete&lt;/code&gt; 事件。为了响应该事件，我们只需要绑定 complete 方法到自定义函数 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 中，这个函数我们稍后实现。&lt;/p&gt;

&lt;p&gt;最后，调用我们的 PIXI.loaders.Loader 实例的 &lt;code&gt;load()&lt;/code&gt; 方法来真正加载我们的精灵表。加载完后，Pixi 将提取所有帧并将其存储在内部的纹理缓存中以便后续使用。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;目前，远景层和中间层图像在其构造函数中加载。但是，我们实际上可以预先加载这些图像，并避免在实例化远景层和中间类时出现短暂的延迟。将它们添加到我们的 Loader 实例中：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;loader.add(&amp;quot;wall&amp;quot;, &amp;quot;resources/wall.json&amp;quot;);
loader.add(&amp;quot;bg-mid&amp;quot;, &amp;quot;resources/bg-mid.png&amp;quot;); // 添加
loader.add(&amp;quot;bg-far&amp;quot;, &amp;quot;resources/bg-far.png&amp;quot;); // 添加
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;无需对 Far 或 Mid 类进行任何更改，因为在尝试从文件系统加载纹理之前，对  &lt;code&gt;PIXI.Texture.fromImage()&lt;/code&gt; 的调用将优先查询内部纹理缓存。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在让我们编写 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 方法。在文件末尾添加以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要编写这个空方法。之前我们创建了一个 Scroller 类的实例，并在 Main 类的构造函数中启动了我们的主循环。但是，我们现在要等到精灵表加载完成后再进行所有操作。让我们将该代码移动到我们的 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 方法中。&lt;/p&gt;

&lt;p&gt;向上滚动到构造函数并删除以下两行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Main() {
  this.stage = new PIXI.Container();
  this.renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  this.scroller = new Scroller(this.stage); // 删除

  requestAnimationFrame(this.update.bind(this)); // 删除
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再回到你的 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 方法并在那里添加删除的两行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
  this.scroller = new Scroller(this.stage);
  requestAnimationFrame(this.update.bind(this));
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，返回构造函数并调用 &lt;code&gt;loadSpriteSheet()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Main() {
  this.stage = new PIXI.Container();
  this.renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  this.loadSpriteSheet(); // 添加
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在保存代码并刷新浏览器。在 Chrome 的 JavaScript 控制台中查看没有错误。&lt;/p&gt;

&lt;h2 id=&#34;测试精灵表&#34;&gt;测试精灵表&lt;/h2&gt;

&lt;p&gt;虽然我们已经成功加载了精灵表，但我们并不知道帧（我们的八个垂直壁切片类型）是否已真正地存储在 Pixi 的纹理缓存中。所以让我们继续创建一些使用其中一些精灵来使用这使用帧。&lt;/p&gt;

&lt;p&gt;我们将在 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 方法中执行我们的测试。将以下代码添加到其中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
  this.scroller = new Scroller(this.stage);
  requestAnimationFrame(this.update.bind(this));

  var slice1 = PIXI.Sprite.fromFrame(&amp;quot;edge_01&amp;quot;); // 高亮
  slice1.position.x = 32; // 高亮
  slice1.position.y = 64; // 高亮
  this.stage.addChild(slice1); // 高亮
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的代码中，我们利用了 PIXI.Sprite 类的 &lt;code&gt;fromFrame()&lt;/code&gt; 静态方法。它使用纹理缓存中与指定帧 ID 匹配的纹理创建一个新的精灵。我们指定 &lt;code&gt;edge_01&lt;/code&gt; 帧用来表示砖块墙前边缘的切片。&lt;/p&gt;

&lt;p&gt;保存代码并刷新浏览器以查看切片。不用担心它展示的位置，位置现在还不重要。&lt;/p&gt;

&lt;p&gt;让我们添加第二个垂直切片。这次我们将使用砖块墙中间的切片类型。为了更精确，我们将使用精灵表中名为&lt;code&gt;decoration_03&lt;/code&gt; 的帧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
  this.scroller = new Scroller(this.stage);
  requestAnimationFrame(this.update.bind(this));

  var slice1 = PIXI.Sprite.fromFrame(&amp;quot;edge_01&amp;quot;);
  slice1.position.x = 32;
  slice1.position.y = 64;
  this.stage.addChild(slice1);

  var slice2 = PIXI.Sprite.fromFrame(&amp;quot;decoration_03&amp;quot;); // 添加
  slice2.position.x = 128; // 添加
  slice2.position.y = 64; // 添加
  this.stage.addChild(slice2); // 添加
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次保存并测试。现在应该看到两个垂直墙切片位于舞台上，类似于下面的这个屏幕截图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/14918/30/11267/98749/5c8f0dd7Ee4736269/d06820174522e100.png&#34; alt=&#34;tut3-testing-sprite-sheet&#34; /&gt;&lt;/p&gt;

&lt;p&gt;希望你现在对精灵表的框架已成功加载并缓存产生了一些成就感。从 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 方法中删除测试代码。方法应再次如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
  this.scroller = new Scroller(this.stage);
  requestAnimationFrame(this.update.bind(this));
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存你的修改&lt;/p&gt;

&lt;h2 id=&#34;一些-gpu-理论&#34;&gt;一些 GPU 理论&lt;/h2&gt;

&lt;p&gt;我还没有解释为什么我们选择将切片打包成一个精灵表而不是单独加载八个 PNG 到内存中。原因和性能相关。 Pixi 的 WebGL 渲染器利用计算机的图形处理单元（GPU）来加速图形性能。但是为了保证最佳性能，我们必须至少了解一点 GPU 的工作原理。&lt;/p&gt;

&lt;p&gt;GPU 更擅长一次处理大数据量的场景。 Pixi 会迎合 GPU 的这个特点，把数据对象批量发送给 GPU。但是，它只能批量处理具有相似状态的展示对象。当遇到具有不同状态的显示对象时，表示已经发生状态改变并且 GPU 会停止以绘制当前批次。程序中发生的状态更改越少，GPU 需要执行的绘制操作就越少，以便呈现展示列表。 GPU 执行的绘制操作越少，渲染性能就越快。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;刚刚提到的 &lt;strong&gt;绘制&lt;/strong&gt;（draw） 操作和我们平常绘画意思差不多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不幸的是，每当遇到具有不同纹理的展示对象时，状态就会发生改变。精灵表可以帮助避免状态更改，因为所有图像都存储在单个纹理中。 GPU 可以非常愉快地从精灵表中绘制每个帧（或子纹理），而无需单独的调用绘制。&lt;/p&gt;

&lt;p&gt;但是，可以存储在 GPU 上的纹理存在大小限制。大多数现代 GPU 可以存储大小为 2048×2048 像素的纹理。因此，如果你要使用精灵表，请确保其尺寸不超过 GPU 纹理的限制。值得庆幸的是，我们的精灵表很小。&lt;/p&gt;

&lt;p&gt;因此，与将每个墙切片的图像存储在单独的纹理上相比，我们的精灵表可以帮助显着提高滚动器的性能。&lt;/p&gt;

&lt;h2 id=&#34;展示游戏地图&#34;&gt;展示游戏地图&lt;/h2&gt;

&lt;p&gt;所以我们已经成功加载了精灵表并且还设法显示了一些帧，但是我们如何真正地构建一个包含砖块墙的大地图？&lt;/p&gt;

&lt;p&gt;我想最简单的方法是创建一个精灵数组，其中每个精灵代表我们地图中的垂直墙切片。然而，考虑到每个切片的宽度比较短，我们的整个地图将很容易由数千个精灵组成。这是很多精灵都将存储在内存中。另外，如果我们只是将所有这些精灵转储到我们的展示列表上，那么它会给渲染器带来很大的压力，可能会影响游戏的帧速率。&lt;/p&gt;

&lt;p&gt;另一种方法是实例化并仅显示将在视口中可见的精灵。当地图滚动时，最左边的精灵最终将离开屏幕。当发生这种情况时，我们可以从显示列表中删除该精灵，并在视口最右边的外部添加一个新的精灵。通过这种方法，我们可以向用户提供滚动整个地图的错觉，而实际上只需要处理视口中当前可见的地图部分。&lt;/p&gt;

&lt;p&gt;虽然第二种方法肯定比第一种方法更好，但它需要为我们的精灵进行不断的内存分配和释放：为进入的每个新精灵分配内存，为离开的精灵释放内存。为什么这么做比较糟糕呢？因为分配内存需要宝贵的 CPU 周期，这可能会影响游戏的性能。如果你必须不断地分配内存，那将避免不了这个问题。&lt;/p&gt;

&lt;p&gt;释放之前对象使用的内存也是潜在的 CPU 性能损耗。 JavaScript 运行时利用垃圾收集器释放以前被不再需要的对象使用的内存。但是，你无法直接控制何时进行垃圾收集，假如需要释放大量内存，该过程可能需要几毫秒。因此，不断实例化精灵再从展示列表中删除精灵将导致频繁的垃圾收集，这会影响游戏的性能。&lt;/p&gt;

&lt;p&gt;第三种方法可以避免前两种问题。它被称为 &lt;strong&gt;对象池&lt;/strong&gt;，它能在不触发 JavaScript 的垃圾收集器的情况下更加智能地使用内存。&lt;/p&gt;

&lt;h2 id=&#34;对象池-object-pooling&#34;&gt;对象池（Object Pooling）&lt;/h2&gt;

&lt;p&gt;想理解对象池，请考虑一个简单的游戏场景。在射击游戏中，玩家的船可能会在游戏过程中发射数十万枚射弹，但由于船的射速，任何时候都只能有 20 枚射弹进入屏幕。因此，仅在游戏代码中创建 20 个射弹实例并在游戏过程中重新使用这些射弹是更好的。&lt;/p&gt;

&lt;p&gt;20 个射弹可以存放在一个阵列中。每次玩家开火时，我们从阵列中移除一个射弹并将其添加到屏幕上。当射弹离开屏幕（或击中敌人）时，我们将其添加回阵列以便稍后再次使用。重要的是我们永远不需要创建新的射弹实例。相反，我们只使用预先创建的 20 个实例池。在我们的示例中，数组将是我们的对象池。这样合理吗？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你想了解有关对象池的更多信息，请查看此 &lt;a href=&#34;https://zh.wikipedia.org/zh-cn/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F&#34;&gt;Wikipedia条目&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以将对象池应用到游戏地图中，并具有以下内容：一个窗口（window）切片池；一幢墙面装饰（decoration）切片；一层前边缘；一层后边缘；还有一个台阶。&lt;/p&gt;

&lt;p&gt;因此，虽然我们的游戏地图最终可能包含数百个窗口，但实际上我们只需要创建足够的窗口精灵来覆盖视口的宽度。当一个窗口即将在我们的视口中显示时，我们只需从 windows 对象池中检索一个窗口精灵。当该窗口滚出视图时，我们将其从显示列表中删除并将其返回到对象池。我们将这个原则应用于边缘，装饰和台阶。&lt;/p&gt;

&lt;p&gt;知道这就足够了。让我们开始构建一个对象池类来保存我们的切片精灵。&lt;/p&gt;

&lt;h2 id=&#34;创建一个对象池类&#34;&gt;创建一个对象池类&lt;/h2&gt;

&lt;p&gt;由于我们的游戏地图代表了一系列砖块墙，我们将创建一个名为 &lt;code&gt;WallSpritesPool&lt;/code&gt; 的类，作为我们各种墙壁部件的池子。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;更通用的类名可能是 &lt;code&gt;MapSpritesPool&lt;/code&gt;，也可以是 &lt;code&gt;ObjectPool&lt;/code&gt;。但是，就本教程而言，&lt;code&gt;WallSpritesPool&lt;/code&gt; 是比较合适的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在文本编辑器中创建一个新文件并添加以下构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.windows = [];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存文件并将其命名为 &lt;code&gt;WallSpritesPool.js&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在构造函数中，我们定义了一个名为 windows 的空数组。此数组将充当我们地图中所有的窗口精灵的对象池。&lt;/p&gt;

&lt;h2 id=&#34;给-windows-池子添加元素&#34;&gt;给 windows 池子添加元素&lt;/h2&gt;

&lt;p&gt;我们的数组需要预先填充一些窗口精灵。请记住，我们的砖块墙可以支持两种类型的窗户 — 一个开灯的窗户和一个没有开灯的窗户 - 所以我们需要确保我们添加两种类型足够多。通过将以下代码添加到构造函数来填充数组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.windows = [];

  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码为对象池添加了 12 个窗口精灵。前 6 个精灵代表我们亮灯的窗口（&lt;code&gt;window_01&lt;/code&gt;），而余他 6 个精灵代表未亮灯的窗口（&lt;code&gt;window_02&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;从对象池中检索精灵时，它们将从数组的前面获取。根据我们在填充时将精灵添加到数组中的顺序，对窗口精灵的前 6 个请求将始终返回一个亮灯的窗口，而接下来的 6 个请求将始终返回一个未亮灯的窗口。我们从池中获得的窗口切片类型需要 &lt;strong&gt;随机&lt;/strong&gt; 出现。这可以通过在填充数组后数组元素进行打乱来实现。&lt;/p&gt;

&lt;p&gt;以下方法将把传递给它的数组打乱。添加方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.shuffle = function(array) {
  var len = array.length;
  var shuffles = len * 3;
  for (var i = 0; i &amp;lt; shuffles; i++)
  {
    var wallSlice = array.pop();
    var pos = Math.floor(Math.random() * (len-1));
    array.splice(pos, 0, wallSlice);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在从构造函数调用 &lt;code&gt;shuffle()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.windows = [];

  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  
  this.shuffle(this.windows); // 调用
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在让我们做一些重构，因为有一个更简洁的方法来填充我们的数组。由于我们实际上是在数组中添加两组精灵（亮灯和不亮灯的窗口），我们可以替换以下代码行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.windows = [];

  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;)); // 删除
  
  this.shuffle(this.windows);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用下面的代替：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.windows = [];

  this.addWindowSprites(6, &amp;quot;window_01&amp;quot;); // 添加
  this.addWindowSprites(6, &amp;quot;window_02&amp;quot;); // 添加
  
  this.shuffle(this.windows);
}

 // 添加
WallSpritesPool.prototype.addWindowSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = PIXI.Sprite.fromFrame(frameId);
    this.windows.push(sprite);
  }
};

WallSpritesPool.prototype.shuffle = function(array) {
  var len = array.length;
  var shuffles = len * 3;
  for (var i = 0; i &amp;lt; shuffles; i++)
  {
    var wallSlice = array.pop();
    var pos = Math.floor(Math.random() * (len-1));
    array.splice(pos, 0, wallSlice);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存更改。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;addWindowSprites()&lt;/code&gt; 方法允许我们向 windows 数组中添加一些在精灵表中指定的精灵帧。因此，它可以很容易地为我们的池子添加一组 6 个亮灯精灵和一组 6 个未亮灯精灵。&lt;/p&gt;

&lt;p&gt;在继续之前，我们应该再做一次重构。将构造函数中的代码移动到单独的方法中。删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.windows = []; // 删除

  this.addWindowSprites(6, &amp;quot;window_01&amp;quot;); // 删除
  this.addWindowSprites(6, &amp;quot;window_02&amp;quot;); // 删除
  
  this.shuffle(this.windows); // 删除
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用一个新方法替换：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.createWindows = function() {
  this.windows = [];

  this.addWindowSprites(6, &amp;quot;window_01&amp;quot;);
  this.addWindowSprites(6, &amp;quot;window_02&amp;quot;);

  this.shuffle(this.windows);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，从构造函数中调用 &lt;code&gt;createWindows()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.createWindows();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好的，我们目前用代码创建了窗口精灵，将它们添加到一个数组，并打乱该数组。继续之前保存文件。&lt;/p&gt;

&lt;h2 id=&#34;为什么使用十二个窗口精灵&#34;&gt;为什么使用十二个窗口精灵&lt;/h2&gt;

&lt;p&gt;从技术上讲，我们可以在池中使用少于 12 个窗口精灵。毕竟，我们只需要足够的精灵来覆盖视口的宽度。我选择十二个的原因是为了让砖块墙的亮灯和不亮灯窗户具有一些随机性。然而值得注意的是，我可以在合理范围内使用任意数量的精灵，只要它为我提供足够的窗口精灵以在视口内生成砖块墙。&lt;/p&gt;

&lt;h2 id=&#34;借用-borrow-和归还-return-精灵&#34;&gt;借用（borrow）和归还（return）精灵&lt;/h2&gt;

&lt;p&gt;我们的对象池有一组窗口精灵，但是我们还没有提供从池中获取精灵或返回池的公共方法。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;所有方法和属性都可以在 JavaScript 中公开访问。这可能使你难以识别属于你的类 API 的方法和属性以及处理实现细节的方法和属性。当我把某些东西称为“公开”时，我的意思是说我打算在类的外部使用它。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们将提供以下两种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;borrowWindow()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;returnWindow()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;borrowWindow()&lt;/code&gt; 方法将从 windows 池中删除一个窗口精灵，并返回对它的引用供你使用。完成后，可以通过调用 &lt;code&gt;returnWindow()&lt;/code&gt; 将精灵作为参数传递回游戏池。&lt;/p&gt;

&lt;p&gt;好的，我们在类的构造函数之后添加 &lt;code&gt;borrowWindow()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.createWindows();
}
// 添加
WallSpritesPool.prototype.borrowWindow = function() {
  return this.windows.shift();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如你所看到的，这是一个相当简单的方法，它只是从 windows 数组的前面删除第一个精灵并返回它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;borrowWindow()&lt;/code&gt; 方法不会检查池中是否还有精灵。我们在这一系列教程中都不会太在意这种异常情况，但在尝试从中返回内容之前，检查一下精灵池是否为空是一个好习惯。有多种策略可用于处理空池子。一个常见的方法是在干燥（没有元素）时动态增加池的大小。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在直接在其下面添加 &lt;code&gt;returnWindow()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.borrowWindow = function() {
  return this.windows.shift();
};
// 添加	
WallSpritesPool.prototype.returnWindow = function(sprite) {
  this.windows.push(sprite);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就像 &lt;code&gt;borrowWindow()&lt;/code&gt; 一样，&lt;code&gt;returnWindow()&lt;/code&gt; 方法很简单。它将精灵作为参数并将该精灵压入到 windows 数组的末尾。&lt;/p&gt;

&lt;p&gt;我们现在有一种从对象池中借用窗口精灵的方法，一旦我们完成它就将精灵返回给（归还）对象池的方法。&lt;/p&gt;

&lt;p&gt;保存更改。&lt;/p&gt;

&lt;h2 id=&#34;快速回顾&#34;&gt;快速回顾&lt;/h2&gt;

&lt;p&gt;查看一下 &lt;code&gt;WallSpritesPool&lt;/code&gt; 类。并没有很多代码，但重要的是你要了解在添加之前发生了什么。以下是类的当前版本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.createWindows();
}

WallSpritesPool.prototype.borrowWindow = function() {
  return this.windows.shift();
};
	
WallSpritesPool.prototype.returnWindow = function(sprite) {
  this.windows.push(sprite);
};

WallSpritesPool.prototype.createWindows = function() {
  this.windows = [];

  this.addWindowSprites(6, &amp;quot;window_01&amp;quot;);
  this.addWindowSprites(6, &amp;quot;window_02&amp;quot;);

  this.shuffle(this.windows);
};

WallSpritesPool.prototype.addWindowSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = PIXI.Sprite.fromFrame(frameId);
    this.windows.push(sprite);
  }
};

WallSpritesPool.prototype.shuffle = function(array) {
  var len = array.length;
  var shuffles = len * 3;
  for (var i = 0; i &amp;lt; shuffles; i++)
  {
    var wallSlice = array.pop();
    var pos = Math.floor(Math.random() * (len-1));
    array.splice(pos, 0, wallSlice);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该类只创建一个包含 6 个亮灯窗口精灵和 6个未亮灯窗口精灵数组。该数组充当窗口的精灵池，并且被打乱以确保随机混合两种状态。提供了两个公共方法 — &lt;code&gt;borrowWindow()&lt;/code&gt; 和 &lt;code&gt;returnWindow()&lt;/code&gt; - 它们允许从精灵池中借用一个窗口精灵，然后归还到池中。&lt;/p&gt;

&lt;p&gt;这就是它要做的所有事情了。当然，我们仍然需要考虑其他切片类型（前边缘，后边缘，墙面装饰和墙壁台阶），但我们很快就会将它们添加到我们的 WallSpritesPool 类中。首先让我们把将精灵池的代码引用到页面，保证正常运行。&lt;/p&gt;

&lt;h2 id=&#34;测试你的对象池&#34;&gt;测试你的对象池&lt;/h2&gt;

&lt;p&gt;转到你的 index.html 文件并引用 &lt;code&gt;WallSpritesPool&lt;/code&gt; 类的源文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Far.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Mid.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Scroller.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;WallSpritesPool.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- 添加 --&amp;gt;
&amp;lt;script src=&amp;quot;Main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存代码。&lt;/p&gt;

&lt;p&gt;现在打开 Main.js。我们将对 Main 类进行一些临时更改，以便测试对象池。&lt;/p&gt;

&lt;p&gt;我们首先在 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 方法中创建我们的对象池的实例，创建将用于保存从池中获取的切片精灵数组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
  this.scroller = new Scroller(this.stage);
  requestAnimationFrame(this.update.bind(this));

  this.pool = new WallSpritesPool(); // 添加
  this.wallSlices = []; // 添加
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的代码中，我们将对象池实例存储在名为 pool 的成员变量中，而我们的数组的成员变量名为 &lt;code&gt;wallSlices&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;现在让我们编写一些代码来从池中获取指定数量的窗口并将它们连续地添加到舞台上。添加以下测试方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.borrowWallSprites = function(num) {
  for (var i = 0; i &amp;lt; num; i++)
  {
    var sprite = this.pool.borrowWindow();
    sprite.position.x = -32 + (i * 64);
    sprite.position.y = 128;

    this.wallSlices.push(sprite);

    this.stage.addChild(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了将窗口精灵添加到舞台，上面的 &lt;code&gt;borrowWallSprites()&lt;/code&gt; 方法还将每个精灵添加到我们的 &lt;code&gt;wallSlices&lt;/code&gt; 成员变量中。这样做的原因是我们需要能够从第二个测试方法中访问（删除、移除、归还）这些窗口精灵，我们现在将编写它们。添加以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.returnWallSprites = function() {
  for (var i = 0; i &amp;lt; this.wallSlices.length; i++)
  {
    var sprite = this.wallSlices[i];
    this.stage.removeChild(sprite);
    this.pool.returnWindow(sprite);
  }

  this.wallSlices = [];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 &lt;code&gt;returnWallSprites()&lt;/code&gt; 方法删除添加到舞台的所有窗口切片，并将这些精灵归还到对象池。&lt;/p&gt;

&lt;p&gt;通过这两种方法，我们可以验证我们是否可以从对象池中借用窗口精灵，并将这些精灵归还给池子。我们将使用Chrome 的 JavaScript 控制台窗口：&lt;/p&gt;

&lt;p&gt;刷新浏览器并打开JavaScript控制台。手动执行如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.borrowWallSprites(9);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;请记住，我们的 Main 类可以通过主全局变量 main 访问，我们可以使用它来调用 &lt;code&gt;borrowWallSprites()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就像下面的截图一样，你应该看到舞台上有九个窗口精灵。都是从你的对象池中 &lt;strong&gt;借&lt;/strong&gt; 来的，然后被添加到舞台上。还要注意，亮灯和亮灯的窗口序列可能是随机出现的。这是因为池中的窗口数组在创建后被打乱了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t1/31720/25/6450/27075/5c8f20c3E419f8f9b/1c176082df00c88d.png&#34; alt=&#34;tut3-testing-object-pool&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在让我们验证是否可以将这些精灵归还给对象池。在控制台中输入以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.returnWallSprites();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;精灵墙应该从舞台上消失，并将返回到对象池。&lt;/p&gt;

&lt;p&gt;这还不能满足我们的实际需示。最简单的方法是从池中请求更多窗口并检查它们是否也出现在屏幕上。让我们从游泳池中再借用九个窗口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.borrowWallSprites(9);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再归还：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.returnWallSprites();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们现在从对象池中获得了总共18个精灵。请记住，池中只包含 12 个窗口精灵（6个开灯的，6 个不开灯的）。因此，精灵正在从池中借用并在我们完成后成功返回。如果没有被返还，那么当对象池的内部数组变空时，会报运行时错误。&lt;/p&gt;

&lt;p&gt;JavaScript 中的所有内容都可以公开访问，我们可以在任何时候轻松检查对象池的内部数组。尝试从控制台检查数组的大小：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.pool.windows.length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这么做应该返回长度 12。现在使用以下方法从池中借用四个窗口精灵：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.borrowWallSprites(4);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次查看池子中的精灵个数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.pool.windows.length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它现在应该只包含 8 个精灵。最后通过调用 &lt;code&gt;returnWallSprites()&lt;/code&gt; 将精灵集返回池中。再次检查对象池的大小，并确认其长度为 12。&lt;/p&gt;

&lt;p&gt;我对咱们的对象池能正常运行感到满意。让我们继续，但保留你添加到 Main 类的测试代码，因为我们很快就会再次使用它。&lt;/p&gt;

&lt;h2 id=&#34;向对象池中添加墙面装饰&#34;&gt;向对象池中添加墙面装饰&lt;/h2&gt;

&lt;p&gt;目前我们的对象池仅提供窗口精灵，但我们还需要添加对前边缘，后边缘，墙面装饰切片和台阶的支支持。让我们从三个墙面装饰切片开始。&lt;/p&gt;

&lt;p&gt;如果你还记得，我们的一些墙上装饰着管道和通风口。这些切片安插在在每个窗口之间。让我们更新我们的 &lt;code&gt;WallSpritesPool&lt;/code&gt; 类以包含墙面装饰切片。代码与口的对象池非常相似，所以它们看起来都应该很熟悉。&lt;/p&gt;

&lt;p&gt;打开 &lt;code&gt;WallSpritesPool.js&lt;/code&gt; 并在构造函数中进行以下调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.createWindows();
  this.createDecorations(); // 添加
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在真正来实现 &lt;code&gt;createDecorations()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.createWindows = function() {
  this.windows = [];

  this.addWindowSprites(6, &amp;quot;window_01&amp;quot;);
  this.addWindowSprites(6, &amp;quot;window_02&amp;quot;);

  this.shuffle(this.windows);
};
// 实现
WallSpritesPool.prototype.createDecorations = function() {
  this.decorations = [];

  this.addDecorationSprites(6, &amp;quot;decoration_01&amp;quot;);
  this.addDecorationSprites(6, &amp;quot;decoration_02&amp;quot;);
  this.addDecorationSprites(6, &amp;quot;decoration_03&amp;quot;);

  this.shuffle(this.decorations);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码通过调用 &lt;code&gt;addDecorationSprites()&lt;/code&gt; 方法将 18 个装饰精灵添加到对象池中（稍后我们将实现这个方法）。前六个精灵使用我们的精灵表中的 &lt;code&gt;decoration_01&lt;/code&gt; 帧。接下来的六个使用 &lt;code&gt;decoration_02&lt;/code&gt;，最后六个使用 &lt;code&gt;decoration_03&lt;/code&gt;。然后调用 &lt;code&gt;shuffle()&lt;/code&gt; 确保精灵随机放置在我们的装饰数组中，我们已将其声明为此类的成员变量，并用于存储墙面装饰精灵。&lt;/p&gt;

&lt;p&gt;现在让我们来编写 &lt;code&gt;addDecorationSprites()&lt;/code&gt; 方法。在 &lt;code&gt;addWindowSprites()&lt;/code&gt; 方法之后直接添加以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.addWindowSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
    this.windows.push(sprite);
  }
};
// 实现
WallSpritesPool.prototype.addDecorationSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
    this.decorations.push(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在剩下要做的就是添加两个新方法，允许从对象池借用装饰精灵并返还。方法名称将遵循用于窗口精灵的命名约定。添加 &lt;code&gt;borrowDecoration()&lt;/code&gt; 和 &lt;code&gt;returnDecoration()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.borrowWindow = function() {
  return this.windows.shift();
};
	
WallSpritesPool.prototype.returnWindow = function(sprite) {
  this.windows.push(sprite);
};
// 实现
WallSpritesPool.prototype.borrowDecoration = function() {
  return this.decorations.shift();
};
	
WallSpritesPool.prototype.returnDecoration = function(sprite) {
  this.decorations.push(sprite);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存代码。&lt;/p&gt;

&lt;p&gt;我们的对象池现在支持窗口和装饰两种切片类型。让我们回到之前添加到 Main类中的测试方法，并测试一切是否正常。&lt;/p&gt;

&lt;h2 id=&#34;对象池的测试&#34;&gt;对象池的测试&lt;/h2&gt;

&lt;p&gt;前面我们建造了一面粗糙墙，完全由我们的对象池中的窗口组成。让我们稍微改变我们的测试代码，在每个窗口之间放置装饰切片。这将可以测试到是否真的可以从对象池中借用到窗口切片和装饰切片。&lt;/p&gt;

&lt;p&gt;打开 Main.js 并从 &lt;code&gt;borrowWallSprites()&lt;/code&gt; 方法中删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.borrowWallSprites = function(num) {
  for (var i = 0; i &amp;lt; num; i++)
  {
    var sprite = this.pool.borrowWindow(); // 删除
    sprite.position.x = -32 + (i * 64);
    sprite.position.y = 128;

    this.wallSlices.push(sprite);

    this.stage.addChild(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用下面几行代替：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.borrowWallSprites = function(num) {
  for (var i = 0; i &amp;lt; num; i++)
  {
    if (i % 2 == 0) { // 添加
      var sprite = this.pool.borrowWindow(); // 添加
    } else { // 添加
      var sprite = this.pool.borrowDecoration(); // 添加
    } // 添加
    sprite.position.x = -32 + (i * 64);
    sprite.position.y = 192;

    this.wallSlices.push(sprite);

    this.stage.addChild(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码使用模运算符（％）来确保我们在循环的奇数次迭代借用一个窗口精灵，偶数次迭代时借用一个装饰精灵。这个简单的更改允许我们现在生成具有以下模式的测试砖块墙：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window, decoration, window, decoration, window, decoration, window
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在转到 &lt;code&gt;returnWallSprites()&lt;/code&gt; 方法并删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.returnWallSprites = function() {
  for (var i = 0; i &amp;lt; this.wallSlices.length; i++)
  {
    var sprite = this.wallSlices[i]; // 删除
    this.stage.removeChild(sprite);
    this.pool.returnWindow(sprite);
  }

  this.wallSlices = [];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用下面几行代替：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.returnWallSprites = function() {
  for (var i = 0; i &amp;lt; this.wallSlices.length; i++)
  {
    var sprite = this.wallSlices[i];
    this.stage.removeChild(sprite);

    if (i % 2 == 0) { // 添加
      this.pool.returnWindow(sprite); // 添加
    } else { // 添加
      this.pool.returnDecoration(sprite); // 添加
    } // 添加
  }

  this.wallSlices = [];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再次使用了模运算符，这次确保我们将正确的精灵（窗口或装饰）返回给对象池。&lt;/p&gt;

&lt;p&gt;保存代码。&lt;/p&gt;

&lt;p&gt;刷新浏览器，然后使用 Chrome 的 JavaScript 控制台测试我们的对象池。通过在控制台窗口中输入以下内容来生成测试墙：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.borrowWallSprites(9);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不出意外，那么你应该看到一个由窗户构成的测试墙，其间插有各种墙壁装饰，如管道和通风口。实际上，你的砖块墙应该类似于下面的图片，它是从我的开发机上截取的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t1/14835/23/11449/35081/5c8f948eE577f4c48/924d41b53e1f6ded.png&#34; alt=&#34;tut3-more-object-pool-testing&#34; /&gt;&lt;/p&gt;

&lt;p&gt;虽然我们目前只编写了一些简单的测试，但我们所做的并不是为了生成整个游戏地图。&lt;/p&gt;

&lt;p&gt;使用以下调用将精灵返还到对象池：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.returnWallSprites();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过对 &lt;code&gt;borrowWallSprites()&lt;/code&gt; 和 &lt;code&gt;returnWallSprites()&lt;/code&gt; 进行一些手动调用来验证对象池是否完全正常工作（译者：建议多调用几次验证程序是否正常）。此外，使用控制台检查对象池的窗口和装饰数组的长度是否正常。&lt;/p&gt;

&lt;h2 id=&#34;给你的对象池添加边缘&#34;&gt;给你的对象池添加边缘&lt;/h2&gt;

&lt;p&gt;我们正一步步走向成功。精灵池目前使得我们可以创建一个原始的砖块墙，但它还没有墙的前后边缘。让我们继续添加这些切片类型。&lt;/p&gt;

&lt;p&gt;在文本编辑器中打开 &lt;code&gt;WallSpritesPool.js&lt;/code&gt; 并将以下两行添加到其构造函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.createWindows();
  this.createDecorations();
  this.createFrontEdges(); // 添加
  this.createBackEdges(); // 添加
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在添加一个 &lt;code&gt;createFrontEdges()&lt;/code&gt; 和一个 &lt;code&gt;createBackEdges()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.createDecorations = function() {
  this.decorations = [];

  this.addDecorations(6, &amp;quot;decoration_01&amp;quot;);
  this.addDecorations(6, &amp;quot;decoration_02&amp;quot;);
  this.addDecorations(6, &amp;quot;decoration_03&amp;quot;);

  this.shuffle(this.decorations);
};
// 添加
WallSpritesPool.prototype.createFrontEdges = function() {
  this.frontEdges = [];

  this.addFrontEdgeSprites(2, &amp;quot;edge_01&amp;quot;);
  this.addFrontEdgeSprites(2, &amp;quot;edge_02&amp;quot;);

  this.shuffle(this.frontEdges);
};
// 添加
WallSpritesPool.prototype.createBackEdges = function() {
  this.backEdges = [];

  this.addBackEdgeSprites(2, &amp;quot;edge_01&amp;quot;);
  this.addBackEdgeSprites(2, &amp;quot;edge_02&amp;quot;);

  this.shuffle(this.backEdges);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你应该能够轻松地看出来两种方法在干什么。第一个方法创建四个前边缘切片，其中两个使用精灵表的 &lt;code&gt;edge_01&lt;/code&gt; 帧，另外两个使用 &lt;code&gt;edge_02&lt;/code&gt;。第二个方法创建四个后边缘切片，并使用精灵表中与前边缘完全相同的帧。&lt;/p&gt;

&lt;p&gt;四个前壁边缘可能看起来相当少，但它会绰绰有余，因为即使砖块墙长度很短也至少会占视口一半宽度。换句话说，我们在任何时候都不会使用超过四个前壁边缘。后墙边缘也是如此。&lt;/p&gt;

&lt;p&gt;现在继续添加 &lt;code&gt;addFrontEdgeSprites()&lt;/code&gt; 和 &lt;code&gt;addBackEdgeSprites()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.addDecorationSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
    this.decorations.push(sprite);
  }
};
// 添加
WallSpritesPool.prototype.addFrontEdgeSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
    this.frontEdges.push(sprite);
  }
};
// 添加
WallSpritesPool.prototype.addBackEdgeSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
    sprite.anchor.x = 1;
    sprite.scale.x = -1;
    this.backEdges.push(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码没什么特殊的地方，但 &lt;code&gt;addBackEdgeSprites()&lt;/code&gt; 方法中有几行值得注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
sprite.anchor.x = 1; // 高亮行
sprite.scale.x = -1;// 高亮行
this.backEdges.push(sprite);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们使用的是前边缘所使用的相同的精灵帧，我们需要水平翻转后边缘精灵，以便它们适当地贴合在砖块墙的的末端。下图能说明我的意思。它在翻转之前显示后边缘。它与墙跨没有正确连接，看起来不对。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t1/11227/6/11995/56141/5c8f9805E1ad7c9c8/fd79415b5830ed29.png&#34; alt=&#34;flipping-wall-edges-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然而，在翻转后的后边缘精灵，会紧贴着砖块墙的末端。如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t1/20989/3/11470/60426/5c8f984bEf542d99e/fa35da3c1aed568a.png&#34; alt=&#34;flipping-wall-edges-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;翻转精灵很容易。我们只需使用 &lt;code&gt;PIXI.Sprite&lt;/code&gt; 类的 &lt;code&gt;scale&lt;/code&gt; 属性即可。 &lt;code&gt;scale&lt;/code&gt; 属性具有 x 和 y 值，可以调整该值以更改 sprite 的大小。但是，将 &lt;code&gt;scale.x&lt;/code&gt; 值设置为 -1，我们可以强制精灵水平翻转而不是缩放。&lt;/p&gt;

&lt;p&gt;Pixi 的 &lt;code&gt;PIXI.Sprite&lt;/code&gt; 类还提供了一个 &lt;code&gt;anchor&lt;/code&gt; 属性，用于定义 &lt;code&gt;sprite&lt;/code&gt; 的锚点（轴心点）。默认情况下，精灵的锚点在左上角。你可以设置锚点的 x 和 y 位置以调整精灵的锚。&lt;code&gt;anchor.set()&lt;/code&gt; 方法设置用于 x 和 y 位置的 &lt;strong&gt;比率值&lt;/strong&gt;，&lt;code&gt;0,0&lt;/code&gt; 表示精灵的左上角，&lt;code&gt;1,1&lt;/code&gt; 表示其右下角。&lt;/p&gt;

&lt;p&gt;在我们的教程中只使用默认值，这意味着所有定位都在精灵的左上角。然而，通过水平翻转边缘精灵，我们也翻转了它们的锚点的位置。换句话说，在水平翻转精灵之后，它的原点会改变到它的右上角，这不是我们想要的。为了解决这个问题，我们在将它们水平翻转之前将精灵的原点设置为右上角。这样，翻转后，它将被正确设置到左上角。&lt;/p&gt;

&lt;p&gt;好的，现在让我们来编写可以借用边缘并返还给对象池的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.returnDecoration = function(sprite) {
  this.decorations.push(sprite);
};
// 添加
WallSpritesPool.prototype.borrowFrontEdge = function() {
  return this.frontEdges.shift();
};

WallSpritesPool.prototype.returnFrontEdge = function(sprite) {
  this.frontEdges.push(sprite);
};

WallSpritesPool.prototype.borrowBackEdge = function() {
  return this.backEdges.shift();
};

WallSpritesPool.prototype.returnBackEdge = function(sprite) {
  this.backEdges.push(sprite);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存你的代码。&lt;/p&gt;

&lt;h2 id=&#34;构建第一个完整的砖块墙&#34;&gt;构建第一个完整的砖块墙&lt;/h2&gt;

&lt;p&gt;我们的精灵池现在支持足够多的垂切片类型，可以用来构建完整的砖块墙了。记住，一块完整的砖块墙包括 &lt;strong&gt;前边缘&lt;/strong&gt;，&lt;strong&gt;中间部分&lt;/strong&gt; 和 &lt;strong&gt;后边缘&lt;/strong&gt;。中间部分至少应包括 &lt;strong&gt;窗户&lt;/strong&gt; 和墙壁 &lt;strong&gt;装饰&lt;/strong&gt;。一些砖块墙也可能包括一个 &lt;strong&gt;台阶&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;让我们回到 Main 类，并编写一些测试代码，在我们的视口中绘制一个完整的砖块墙。&lt;/p&gt;

&lt;p&gt;首先，删除以前的测试方法。打开 Main.js 并删除 &lt;code&gt;borrowWallSprites()&lt;/code&gt; 和 &lt;code&gt;returnWallSprites()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们将实现一个名为 &lt;code&gt;generateTestWallSpan()&lt;/code&gt; 的新方法，用它来生成七个切片宽度的砖块墙。我们将把所有切片存放在一张表里面。首先添加以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.generateTestWallSpan = function() {
  var lookupTable = [
    this.pool.borrowFrontEdge,  // 第一个切片
    this.pool.borrowWindow,     // 第二个切片
    this.pool.borrowDecoration, // 第三个切片
    this.pool.borrowWindow,     // 第四个切片
    this.pool.borrowDecoration, // 第五个切片
    this.pool.borrowWindow,     // 第六个切片
    this.pool.borrowBackEdge    // 第七个切片
  ];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这张表是一个存放函数引用的数组。数组中的每个索引代表七个切片中的一个。第一个索引表示墙的前边缘，最后一个表示后边缘。中间的指数代表代表墙壁中段的五个切片。&lt;/p&gt;

&lt;p&gt;每个索引都包含对构建砖块墙所需的对象池中对应的引用。例如，第一个索引包含对池的 &lt;code&gt;borrowFrontEdge()&lt;/code&gt; 方法的引用。第二个索引包含对 &lt;code&gt;borrowWindow()&lt;/code&gt; 的引用，第三个索引包含对 &lt;code&gt;borrowDecoration()&lt;/code&gt; 的引用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.generateTestWallSpan = function() {
  var lookupTable = [
    this.pool.borrowFrontEdge,  // 1st slice
    this.pool.borrowWindow,     // 2nd slice
    this.pool.borrowDecoration, // 3rd slice
    this.pool.borrowWindow,     // 4th slice
    this.pool.borrowDecoration, // 5th slice
    this.pool.borrowWindow,     // 6th slice
    this.pool.borrowBackEdge    // 7th slice
  ];
  // 添加
  for (var i = 0; i &amp;lt; lookupTable.length; i++)
  {
    var func = lookupTable[i];

    var sprite = func.call(this.pool);
    sprite.position.x = 32 + (i * 64);
    sprite.position.y = 128;

    this.wallSlices.push(sprite);

    this.stage.addChild(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在循环内部，我们的代码获取对应切片的借用方法的引用，并将其存储在名为 &lt;code&gt;func&lt;/code&gt; 的局部变量中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var func = lookupTable[i];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦我们有了这个正确的引用，就使用以下方法调用它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var sprite = func.call(this.pool);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;call()&lt;/code&gt; 是一种原生的 JavaScript 方法，可用来从函数引用调用函数。例如，在循环的第一次迭代中，&lt;code&gt;func&lt;/code&gt; 变量将指向精灵池的 &lt;code&gt;borrowFrontEdge()&lt;/code&gt; 方法。因此，调用 &lt;code&gt;func&lt;/code&gt; 的 &lt;code&gt;call()&lt;/code&gt; 方法与下面的代码等价：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.pool.borrowFrontEdge()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了生成测试墙的方法，我们也需要编写另一个名为 &lt;code&gt;clearTestWallSpan()&lt;/code&gt; 的清除墙的方法。此方法将从舞台移除砖块墙并将切片返还到对象池中。&lt;/p&gt;

&lt;p&gt;在你的文件中加入下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.clearTestWallSpan = function() {
  var lookupTable = [
    this.pool.returnFrontEdge,  // 1st slice
    this.pool.returnWindow,     // 2nd slice
    this.pool.returnDecoration, // 3rd slice
    this.pool.returnWindow,     // 4th slice
    this.pool.returnDecoration, // 5th slice
    this.pool.returnWindow,     // 6th slice
    this.pool.returnBackEdge    // 7th slice
  ];

  for (var i = 0; i &amp;lt; lookupTable.length; i++)
  {
    var func = lookupTable[i];
    var sprite = this.wallSlices[i];

    this.stage.removeChild(sprite);
    func.call(this.pool, sprite);
  }

  this.wallSlices = [];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再一次使用了一张表。但是这次我们存储的是对应的切片返还方法的引用。例如，我们知道砖块墙的第一个切片是墙的前边缘。因此，存储在表中的第一个方法是 &lt;code&gt;returnFrontEdge()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;另外，请注意，这次使用原生 JavaScript &lt;code&gt;call()&lt;/code&gt; 方法时，我们将第二个参数传递给它。第二个参数是我们想要返还给池子的精灵。&lt;/p&gt;

&lt;p&gt;保存更改并刷新浏览器。让我们看看完整的砖块墙是什么样的。&lt;/p&gt;

&lt;p&gt;打开 Chrome 的 JavaScript 控制台并执行生成砖块墙的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.generateTestWallSpan();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你应该会看到七个切片宽的砖块墙。还有前后边缘。你的浏览器窗口应类似于下面的屏幕截图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/31494/17/6527/54099/5c904c26E4099c026/3b44cd4397cdfbee.png&#34; alt=&#34;wall-span-screenshot-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;七个切片都是从我们的对象池中借来的。让我们通过在控制台中输入以下内容来返还它们：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.clearTestWallSpan();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切片精灵应该会被从舞台上移除并返回到你的对象池中。&lt;/p&gt;

&lt;p&gt;再次生成砖块墙：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.generateTestWallSpan();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会再次看到砖块墙，但这次你看到墙壁上的装饰与上次不同，窗口类型也可能会有所不同，甚至前后边缘的外观也会发生变化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t1/20076/19/11507/48534/5c904d00E4af6178d/7fc329522b49ae99.png&#34; alt=&#34;wall-span-screenshot-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这些差异是由于我们这次借用了不同的墙片造成的。我们之前的切片返回到了每个对象池的数组 &lt;strong&gt;最后面&lt;/strong&gt;，而借用的精灵总是来自我们数组的 &lt;strong&gt;前面&lt;/strong&gt;。这样效果会比较好，因为玩家很难准确预测从池中获取每个切片类型的样子。它会让我们游戏地图的墙块随机出现，这正是我们想要的。&lt;/p&gt;

&lt;h2 id=&#34;给砖块墙添加台阶&#34;&gt;给砖块墙添加台阶&lt;/h2&gt;

&lt;p&gt;希望你能从上面的实现代码中得到成就感。我们能够使用对象池构建完整的砖块墙。现在剩下要做的就是为对象池添加台阶的支持。让我们继续吧。&lt;/p&gt;

&lt;p&gt;返回文本编辑器并确保 &lt;code&gt;WallSpritesPool.js&lt;/code&gt; 已打开。&lt;/p&gt;

&lt;p&gt;添加下面一行到构造函数中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.createWindows();
  this.createDecorations();
  this.createFrontEdges();
  this.createBackEdges();
  this.createSteps(); // 添加
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在来实现 &lt;code&gt;createSteps()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.createSteps = function() {
  this.steps = [];
  this.addStepSprites(2, &amp;quot;step_01&amp;quot;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且添加一个 &lt;code&gt;addStepSprites()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.addStepSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
    sprite.anchor.y = 0.25;
    this.steps.push(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;台阶很少会出现，虽然我们将在精灵池中只使用两个。但说实话，但已经足够了。&lt;/p&gt;

&lt;p&gt;此外，就像后边缘切片类型一样，我们使用了 anchor 属性来改变精灵的锚点。这次我们通过向下移动 64 像素来改变锚点的垂直位置。请记住，使用锚属性的值是比率。每个切片的高度为 256 像素，将锚点的 y 位置向下移动 64 个像素对应的比率为 0.25。&lt;/p&gt;

&lt;p&gt;那么为什么要改变锚属性呢？好吧，当我们最终实际生成游戏地图时，一定范围的所有切片将使用相同的 y 位置以确保正确对齐。但是，台阶切片位图的设计使其成为特例 — 它将无法与砖块墙的其他切片正确对齐。你可以在下图中发现这种情况，其中所有切片（包括台阶）具有相同的 y 位置并且其锚点设置在左上角。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/10525/31/15123/56353/5c905364E8be71317/cf32228b28880ba4.png&#34; alt=&#34;wall-step-anchor-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如你所见，台阶的垂直位置显然是不正确的。但是，通过将其锚点向下移动 64 像素，我们可以强制它在砖块墙内正确展示。下图中就是设置过的，其中每个切片（包括台阶）仍然 &lt;strong&gt;共享&lt;/strong&gt; 相同的 y 位置，但由于其锚点已被移动，步骤切片现在正确地位于砖块墙内。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t1/24325/19/11530/56607/5c905406Ea283c26c/180e08debc8d1226.png&#34; alt=&#34;wall-step-anchor-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在我们需要做的就是提供允许我们从对象池借用并返回一个步骤的方法。添加以下 &lt;code&gt;borrowStep()&lt;/code&gt; 和 &lt;code&gt;returnStep()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.borrowStep = function() {
  return this.steps.shift();
};

WallSpritesPool.prototype.returnStep = function(sprite) {
  this.steps.push(sprite);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将更改保存到文件。对象池类现已完成了。&lt;/p&gt;

&lt;h2 id=&#34;测试砖块墙的台阶&#34;&gt;测试砖块墙的台阶&lt;/h2&gt;

&lt;p&gt;这一节的教程即将完成。让我们通过生成包含台阶的测试砖块墙来结束它。&lt;/p&gt;

&lt;p&gt;打开 Main.js 并删除 &lt;code&gt;generateTestWallSpan()&lt;/code&gt; 方法中的代码。将其替换为以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.generateTestWallSpan = function() {
  var lookupTable = [
    this.pool.borrowFrontEdge,  // 1st slice
    this.pool.borrowWindow,     // 2nd slice
    this.pool.borrowDecoration, // 3rd slice
    this.pool.borrowStep,       // 4th slice
    this.pool.borrowWindow,     // 5th slice
    this.pool.borrowBackEdge    // 6th slice
  ];

  var yPos = [
    128, // 1st slice
    128, // 2nd slice
    128, // 3rd slice
    192, // 4th slice
    192, // 5th slice
    192  // 6th slice
  ];

  for (var i = 0; i &amp;lt; lookupTable.length; i++)
  {
    var func = lookupTable[i];

    var sprite = func.call(this.pool);
    sprite.position.x = 64 + (i * 64);
    sprite.position.y = yPos[i];

    this.wallSlices.push(sprite);

    this.stage.addChild(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;generateTestWallSpan()&lt;/code&gt; 几乎与前一版相同。这次墙只有六个切片宽，我们还添加了第二个名为 &lt;code&gt;yPos&lt;/code&gt; 的数组。&lt;/p&gt;

&lt;p&gt;如果查看这张表，你将发现第 4 个索引表示台阶切片。请记住，该步骤可让玩家直接跌落到正下方的墙面上。如果你回想一下教程的开头，你应该记住，当我们处理一个步骤时，我们实际处理的是两个连接在一起的独立砖块墙。第一个砖块墙将高于第二个，台阶切片本身将属于第二个砖块墙。&lt;/p&gt;

&lt;p&gt;两个砖块墙之间的高度差异由我们的 yPos 数组处理。它对于我们的每个切片都有一个 y 位置。前三个切片 y 都是 128 个像素，而剩余的切片是 192个像素。&lt;/p&gt;

&lt;p&gt;让我们转到我们的 &lt;code&gt;clearTestWallSpan()&lt;/code&gt; 方法。从现有版本的方法中删除代码，并将其替换为以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.clearTestWallSpan = function() {
  var lookupTable = [
    this.pool.returnFrontEdge,  // 1st slice
    this.pool.returnWindow,     // 2nd slice
    this.pool.returnDecoration, // 3rd slice
    this.pool.returnStep,       // 4th slice
    this.pool.returnWindow,     // 5th slice
    this.pool.returnBackEdge    // 6th slice
  ];

  for (var i = 0; i &amp;lt; lookupTable.length; i++)
  {
    var func = lookupTable[i];
    var sprite = this.wallSlices[i];

    this.stage.removeChild(sprite);
    func.call(this.pool, sprite);
  }

  this.wallSlices = [];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如你所见，表中包含对将每个切片返还到对象池所需的所有方法的引用，包括台阶。&lt;/p&gt;

&lt;p&gt;保存更改并刷新浏览器。&lt;/p&gt;

&lt;p&gt;在 JavaScript 控制台中输入以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.generateTestWallSpan();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你应该会在屏幕上看到一个带有台阶的墙。它应该看起来像这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/24246/9/11462/69686/5c905719E86dbd531/38dfad19122dfe1f.png&#34; alt=&#34;wall-step-screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再返还整个砖块墙给对象池：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.clearTestWallSpan();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多试几次生成砖块墙然后返还到对象池，确保一切都正常。&lt;/p&gt;

&lt;h2 id=&#34;整理代码&#34;&gt;整理代码&lt;/h2&gt;

&lt;p&gt;我们不断地测试对象池，现在它已经成型。为了准备本系列的最后一个教程，我们现在从 Main 类中删除测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
  this.scroller = new Scroller(this.stage);
  requestAnimationFrame(this.update.bind(this));

  this.pool = new WallSpritesPool();
  this.wallSlices = [];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还要完全删除 &lt;code&gt;generateTestWallSpan()&lt;/code&gt; 和 &lt;code&gt;clearTestWallSpan()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;现在保存你的更改。&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;感谢你能坚持到这里。本教程已经涉及到了大量的内容。我们已经讨论了滚动游戏地图的各种技术点，并了解了为什么选择使用对象池。&lt;/p&gt;

&lt;p&gt;虽然本教程很长，但对象池的概念实际上相当简单。不过有人可能会很容易陷入到一些实现细节中，但记住最重要的一点对象池只一个非常简单的 API：有一组从池中借用精灵，另一组返还这些精灵。&lt;/p&gt;

&lt;p&gt;我们还学到了更多关于 pixi.js 的知识，包括精灵表和 PIXI.Sprite 类的其它功能。此外，我们也介绍了 GPU 加速的好处，以及为什么使用精灵表可以带来巨大的性能提升。&lt;/p&gt;

&lt;p&gt;虽然我们还没有真正地开始构建滚动游戏地图，但我们已经编写了一些代码来生成一些测试砖块墙。这应该有助于你了解如何使用对象池，也可以帮助你熟悉砖块墙的结构和游戏地图。&lt;/p&gt;

&lt;h2 id=&#34;下期预告&#34;&gt;下期预告&lt;/h2&gt;

&lt;p&gt;下一节中我们将真正的添加流动游戏中的第三层。和前两层不一样，第三层将组成整个游戏地图所需要的砖块墙。这些切片都将从我们的对象池中借取。&lt;/p&gt;

&lt;p&gt;与往常一样，GitHub上提供了本系列和之前教程的 &lt;a href=&#34;https://github.com/ccaleb/pixi-parallax-scroller&#34;&gt;源代码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;很快你将开始教程的的 第四部分，也是最后一部分。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>