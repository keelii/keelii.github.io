<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>臨池不輟</title>
    <link>https://keelii.com/</link>
    <description>Recent content on 臨池不輟</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 06 Jun 2019 18:31:57 +0800</lastBuildDate>
    
        <atom:link href="https://keelii.com/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>也许 Markdown 并不是一个好选择</title>
      <link>https://keelii.com/2019/06/06/md-maybe-not-good-enough/</link>
      <pubDate>Thu, 06 Jun 2019 18:31:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/06/06/md-maybe-not-good-enough/</guid>
      <description>

&lt;p&gt;我经常会使用 markdown 来写一些东西。比如：博客文章、技术文档什么的。但是时间长了总是会觉得编辑 Markdown 源码的方式太容易让人分心了。&lt;/p&gt;

&lt;p&gt;Markdown 确实是一个非常好的&lt;strong&gt;通用&lt;/strong&gt;排版格式，因为它很简单，学习使用起来没有门槛。但是随着人们越来越多的使用 Markdown 创作，Markdown 本身的一些问题也显露出来。比如：当你需要一些高级排版格式的时候 Markdown 是无能为力的，更不用说表格编辑这类重排版的工作在 Markdown 中的编辑体验了。&lt;/p&gt;

&lt;p&gt;当然开源社区会有一些开源项目来扩展 Markdown 的功能，甚至是用 Markdown 来画流程图。这且没有什么问题，问题是当你使用了一些扩展的高级功能时又想把他扩展到其它系统（比如博客），这时你又不得不改造博客来适配这些功能，Markdown 也就丧失了它的便携性。所以说使用 Markdown 的关键问题在于：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如何能更简单方便的使用 Markdown，同时又不失一些好用的功能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;如何解决编辑的体验问题&#34;&gt;如何解决编辑的体验问题&lt;/h4&gt;

&lt;p&gt;编辑排版最佳的体验毫无疑问是「&lt;strong&gt;所见即所得&lt;/strong&gt;」的模式。因为人们总是喜欢改完东西立即看见效果。目前常用的 Markdown 编辑器通常分左右两列：++源码++ ｜ ++预览++。实际上我认为这种模式并不好，甚至是错的。因为整个编辑过程会非常痛苦，你不得不既关注源码里面的格式，如：空格、Markdown 符号，还得关注预览出来的效果是不是满意然后再调整。&lt;/p&gt;

&lt;p&gt;相比之下 &lt;a href=&#34;https://typora.io/&#34;&gt;Typora&lt;/a&gt; 给出了稍好一些的体验方案 — &lt;strong&gt;富文本的编辑模式 +&lt;/strong&gt; &lt;strong&gt;Markdown 源格式&lt;/strong&gt;。这应该也是目前 Markdown 最好的编辑方式了，但是在我看来还是不够好。&lt;/p&gt;

&lt;p&gt;我自己在书写 Markdown 文件的时间会非常注意格式排版，比如：标点符号，中英文空格，分行留白等，Typora 的编辑模式并不能让我免于这样的困扰，我还是不得不关注 Markdown 的那些符号，这些符号就像听音乐时的耳机里面的「杂音」一样。当你专注于写作，一口气写下上千字的时候，很容易就会被这种杂音打断，灵感转瞬即逝…&lt;/p&gt;

&lt;h4 id=&#34;如何添加一些功能特性&#34;&gt;如何添加一些功能特性&lt;/h4&gt;

&lt;p&gt;这个问题我认为不应该给 Markdown 扩展功能，因为扩展 Markdonw 只能通过&lt;strong&gt;添加更多符号&lt;/strong&gt;的形式实现。而这会增加它的复杂度，最终让 Markdown 格式变的&lt;strong&gt;不可交换&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;各种编辑方式按功能强大的排序应该是：Makrdown &amp;lt; 富文本 &amp;lt; Word。复杂的功能应该由后面两种工具来胜任，Markdown 可以做为一种格式上的约定。重功能不需要它来实现，比如编辑表格的体验在 Markdown 里简直就是灾难，但是在富文本或者 Word 中却异常简单。这就像是 Markdown 应该做为++接口++来定义一些规范，而不应该让它去关心具体++实现++。&lt;/p&gt;

&lt;h4 id=&#34;结论&#34;&gt;结论&lt;/h4&gt;

&lt;p&gt;既然如此那有没有更好的解决方案呢（广告预警）。我正在开发一款基于网页的 WYSIWYG&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:What-You-See-Is&#34;&gt;&lt;a href=&#34;#fn:What-You-See-Is&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 富文本编辑器应用，并试着解决上面的这些问题，解决 Markdown 问题的同时又能获得富文本编辑的优质体验，主要面向有写作和编辑文章/笔记需求的用户。如果你也刚好有这个需求，不妨试试：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;//wtdf.io&#34;&gt;wtdf.io&lt;/a&gt; — 基于网页的所见即所得 Markdown 写作应用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:What-You-See-Is&#34;&gt;What You See Is What You Get — 中译「所见所得」 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:What-You-See-Is&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>选择太多所以迷失方向</title>
      <link>https://keelii.com/2019/03/24/choice-leads-lose/</link>
      <pubDate>Sun, 24 Mar 2019 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2019/03/24/choice-leads-lose/</guid>
      <description>&lt;p&gt;前几天无意在微博上看见了《流浪汉沈巍自述》一文，此文来自一个上海的流浪汉语录。&lt;/p&gt;

&lt;p&gt;不同的是他并不是为了生计而流浪捡破烂，沈巍从小喜欢捡破烂，捡完破烂换了钱买书看。家庭环境不理解更不支持，到了社会上，他本来可以按大多数人眼中的 &lt;strong&gt;正常&lt;/strong&gt; 人一样工作，一辈子当公务员。&lt;/p&gt;

&lt;p&gt;但是他还是改不了自己捡破烂的习惯，这样以来单位也容不下他。想法完全不与主流融合，只能被流浪。可以即便是这样，在看它的文字里，你仍然能感受到字里行间都散发着对生活的无限向往，对信念的追求，以及对残酷现实的一丝温柔。&lt;/p&gt;

&lt;p&gt;有人说故事分两种：一种开始就讲给你最美好的东西，最完美无缺的事物，人性最善良的部分。后来慢慢的什么都变了，以前那些看似美好的东西都有了瑕疵，人性也没能经得住时间的考验，所有的认识都支离破碎；还有一种一开始就告诉你最丑恶的东西，最让人恶心、难受的事物，人性最黑暗的一面。后来慢慢的也似乎变了，不经意的发现好像还有那么一丝光明的东西，一点点能让人感动的事情。&lt;/p&gt;

&lt;p&gt;前一种更像是从教科书到现实的一种过程，可能很多人慢慢的都受不了这种落差，逐渐没有了精神支柱，厌恶了生活。后一种则看似悲观、反面，实则能激发出人们本能善良的一面。&lt;/p&gt;

&lt;p&gt;这让我想起了一句话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;人不是活一辈子，不是活几年几月几天，而是活那么几个瞬间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于沈巍来说，社会和家庭给他的都是排斥、否认和异样的眼光。但是可能他就只能从书中找到了那么一丝光明，一些让自己感动的瞬间吧。&lt;/p&gt;

&lt;p&gt;我们可以反思下我们的现实生活。现实中我们总是说「自己没有选择，我不得不这样、没有退路…」。但事实上真的是这样吗？或许正是因为我们拥有的太多才让自己没法选择。&lt;/p&gt;

&lt;p&gt;人是很奇怪的，当你某天没有加班，工作完成后早早回家后突然发现居然还有很多时间可以安排。这时候你会想做很多事情：玩手机、睡觉、好好做顿饭、看部电影…&lt;/p&gt;

&lt;p&gt;但当你真正的面临很多种选择时，自己会去权衡。可能自己精神上很需要放松一下，需要娱乐一下。但是理智又告诉你应该做一些「有意义」的事情。最终可能一件事都没做好。&lt;/p&gt;

&lt;p&gt;这时候其实你需要用 &lt;strong&gt;肉体操纵精神&lt;/strong&gt;，不要想，先去做。因为实际上当你持续专注的做一件事情的时候，精神上会特别放松，你不需要再考虑那么多的选择，只需要 *像机器* 一样去做好一件事情。&lt;/p&gt;

&lt;p&gt;人总是可以通过做事情来让自己的 &lt;strong&gt;内心变的安稳&lt;/strong&gt;。我曾经无意中听到两人女生聊天，其中一个女生说&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我特别喜欢洗衣服，因为当我特别专注的把衣服洗干净的时候，那种感觉特别安静，虽然需要你耗费一些体力，但是洗完后你的内心会有一种解脱，一种如释重负的感觉…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我听到这段聊天的时候是特别惊讶的，原话特别有感染力。后来我发现了这种感觉就像是我平常写代码一样，一写起代码，就很专注，似乎能忘记时间。当你解决了一个问题，完成了一个功能模块的时候长呼一口吸、伸个懒腰，瞬间感觉特别满足。即使回到现实中你还得面临很多复杂的事情，但在这一时刻你是自由的。&lt;/p&gt;

&lt;p&gt;后来我也理解了那句 Nick 经典广告语「Just do it」的深刻涵义，当然这和我选择做 IT 行业是两码事。&lt;/p&gt;

&lt;p&gt;图：&lt;a href=&#34;https://www.pexels.com/photo/abstract-bright-color-dark-397998/&#34;&gt;https://www.pexels.com/photo/abstract-bright-color-dark-397998/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Pixi.js 构建一个视差滚动器（第三篇）</title>
      <link>https://keelii.com/2019/03/19/building-a-parallax-scroller-with-pixijs-cn-3/</link>
      <pubDate>Tue, 19 Mar 2019 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2019/03/19/building-a-parallax-scroller-with-pixijs-cn-3/</guid>
      <description>

&lt;h2 id=&#34;翻译对照&#34;&gt;翻译对照&lt;/h2&gt;

&lt;p&gt;原文：
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5226&#34;&gt;PART 1&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5666&#34;&gt;PART 2&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=6496&#34;&gt;PART 3&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=7046&#34;&gt;PART 4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译文：
&lt;a href=&#34;https://keelii.com/2019/03/16/building-a-parallax-scroller-with-pixijs-cn-1/&#34;&gt;第一篇&lt;/a&gt;・
&lt;a href=&#34;https://keelii.com/2019/03/17/building-a-parallax-scroller-with-pixijs-cn-2/&#34;&gt;第二篇&lt;/a&gt;・
&lt;a href=&#34;https://keelii.com/2019/03/19/building-a-parallax-scroller-with-pixijs-cn-3/&#34;&gt;第三篇&lt;/a&gt;・
第四篇&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;关注 &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=chriscaleb&#34;&gt;@chriscaleb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个系列的教程已经更新到了 &lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PixiJS v4&lt;/a&gt; 版本。&lt;/p&gt;

&lt;p&gt;欢迎再次来到这个系列教程的第三部分，这一节将会涉及到如何使用 pixi.js 制作视差滚动游戏的地图。整个教程到目前为止已经涵盖了很多内容。在第一个教程中，我们学习了一些 pixi.js 基础知识，并将视差滚动应用于几个层上。在第二部分，通过代码重构将一些面向对象的概念应用到实践中。这一节我们将把重点放在第三个更复杂的视差层上，它将代表玩家角色在游戏时将会穿越的地图。&lt;/p&gt;

&lt;h3 id=&#34;你将学到什么&#34;&gt;你将学到什么…&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如何处理纹理（textures）和精灵表（sprites sheet）&lt;/li&gt;
&lt;li&gt;对象池 的基础&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;预备知识&#34;&gt;预备知识…&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;pixi.js 基础&lt;/li&gt;
&lt;li&gt;了解 JavaScript 或者 ActionScript 的基础知识&lt;/li&gt;
&lt;li&gt;对面向对象有基本的概念&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们将继续从上一个教程结束的地方开始。你可以使用前两个教程编写的代码，也可以从 &lt;a href=&#34;https://github.com/ccaleb/pixi-parallax-scroller/tree/master/tutorial-2&#34;&gt;GitHub&lt;/a&gt; 下载第二个教程的源代码。也可以在 GitHub上 找到第三节完整教程的 &lt;a href=&#34;https://github.com/ccaleb/pixi-parallax-scroller/tree/master/tutorial-3&#34;&gt;源代码&lt;/a&gt;，即使你遇到了问题，我也鼓励你完成本教程，有疑问可以请仅参考源代码。&lt;/p&gt;

&lt;p&gt;这个系列的教程非常受到 &lt;a href=&#34;http://www.adamatomic.com/canabalt/&#34;&gt;Canabalt&lt;/a&gt; 和 &lt;a href=&#34;https://chrome.google.com/webstore/detail/monster-dash/cknghehebaconkajgiobncfleofebcog?hl=en&#34;&gt;Monster Dash&lt;/a&gt; 游戏的启发，当玩家的英雄在平台之间奔跑和跳跃时，这些游戏都能很好地利用视差滚动来提供花哨的视觉效果。&lt;/p&gt;

&lt;p&gt;在接下来的两节教程中，我们将构建一个非常类似于 Monster Dash 中的滚动游戏地图。 Monster Dash 的游戏地图是由一系列不同宽度和高度的砖块儿构建而成。游戏的目的是通过在砖块儿之间跳跃来尽可能长地生存。游戏地图的滚动速度随着时间的推移而增加。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yeahbutisitflash.com/pixi-parallax-scroller/final/index.html&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/25206/13/10616/142679/5c887df7E7c1fa38a/eab39f5f7ab1cc6d.png&#34; alt=&#34;ps-tut1-screenshot1&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面就是你这一节将要完成的示例。单击图片即可查看包含砖块儿和间隙的滚动地图。&lt;/p&gt;

&lt;h2 id=&#34;起步&#34;&gt;起步&lt;/h2&gt;

&lt;p&gt;如果你还没有看过第一节和第一节教程，我建议你应该先看完这两节。&lt;/p&gt;

&lt;p&gt;在本节教程中，我们将使用一些新的图片素材。可以直接从 &lt;a href=&#34;www.yeahbutisitflash.com/pixi-parallax-scroller/tutorial-3/resources.zip&#34;&gt;这里&lt;/a&gt; 下载，并将其内容解压缩到项目的 resource 文件夹中。&lt;/p&gt;

&lt;p&gt;下面就是你的 &lt;code&gt;resource&lt;/code&gt; 文件夹的样子（Windows）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t1/31697/16/6353/53328/5c8e01e2E14bc1c7b/d5701c262078bc35.png&#34; alt=&#34;ps-tut3-screenshot1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;macOS 下则是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/25309/3/11322/64214/5c8e01f7Ed95812be/fa19f72e6cc3b5e7.png&#34; alt=&#34;ps-tut3-screenshot2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此外，如果你还没有建立一个本地的 web 服务器，请参考第一节的内容。&lt;/p&gt;

&lt;p&gt;值得注意的是，本教程比前两篇长。你可能需要大约两个小时才能完成所有工作。&lt;/p&gt;

&lt;h2 id=&#34;游戏地图&#34;&gt;游戏地图&lt;/h2&gt;

&lt;p&gt;正如上面的演示中展示的那样，我们的游戏地图有很多种展示形式。如砖块儿的宽度和高度各不相同。每个跨度还包括一系列窗户和墙壁装饰元素。墙壁装饰本身由管道和通风口组成。&lt;/p&gt;

&lt;p&gt;那么墙跨度是如何构建的？每个跨度都是由一系列拼接在一起的垂直切片构成的。每个切片的大小为 64 x 256 像素。下图显示了示例砖块儿。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/11199/10/12039/18165/5c8e031aE2a8746ce/c51ef91aeebd739b.png&#34; alt=&#34;diagram-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过垂直移动每个切片的位置来处理砖块儿的高度。下面的示意图中我们可以看到，第二个面墙的切片部分位于视口的可见区域下方（译者：超出视口），使其看起来低于第一面墙。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/28702/23/11291/23279/5c8e047aE0dc68c77/08ba190fd4f5f08b.png&#34; alt=&#34;diagram-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;大多数情况，一而墙内的每个切片将会是水平对齐的。但有一个例外。 Monster Dash 有一个阶梯式的跨度，让玩家可以直接跌落到下一个水平线上。以下是它的构造方式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/14544/9/11325/22909/5c8e0484E33aa7b33/c2b3b720df1d69a1.png&#34; alt=&#34;diagram-3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果你仔细观察上面的示意图，你应该注意到这里真正的是墙面有两个（第一个跨度高于第二个），它们通过中间的一个切片（台阶）连接起来。&lt;/p&gt;

&lt;p&gt;你可能会惊讶地发现我们的整个游戏地图只由八种不同类型的垂直切片构成：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t1/18163/12/11214/22059/5c8e053aE742a81ce/3fe250596cbb7bab.png&#34; alt=&#34;diagram-4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这些切片的顺序很重要。我们再来谈谈这个问题。&lt;/p&gt;

&lt;h2 id=&#34;分解砖块墙&#34;&gt;分解砖块墙&lt;/h2&gt;

&lt;p&gt;一面砖块墙包括三个主要部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;前边缘&lt;/li&gt;
&lt;li&gt;中间部分&lt;/li&gt;
&lt;li&gt;后边缘&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前/后边缘都只由一个垂直切片表示。然而，中间部分可以由一个或多个切片制成。切片越多，墙跨度就越长。我们将制作一面有 30 个切片的砖块墙。下图可以解释砖块墙的三大部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/26701/4/11364/142241/5c8e0660E36cd06e7/61bb2ce4e0f7b003.png&#34; alt=&#34;diagram-5&#34; /&gt;&lt;/p&gt;

&lt;p&gt;墙的中间部分只有下面两种切片：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;窗口（window）&lt;/li&gt;
&lt;li&gt;装饰（decoration）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此整个墙的中间部分长度为 6，结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window, decoration, window, decoration, window, decoration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，通常情况下，砖块墙的中间部分是非偶数个切片才能保证出现的容器即有亮灯的也有灭的。所以我们使用 7 个切片来制作中间部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window, decoration, window, decoration, window, decoration, window
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了保证砖块墙尽可能看起来有趣，窗户可以点亮或不点亮，我们可以随机选择三种装饰切片。因此，墙的中间部分将由五种不同类型的切片构成。&lt;/p&gt;

&lt;p&gt;为了增加更多的切片种类，我们从砖块墙的边缘素材中（两个）选择两个切片做为前后边缘（译者：边缘素材有两个，可以随机选一个做前边缘，然后翻转它做成后边缘，但是不能一个做前一个做后，示意图中的 front &amp;amp; back 和图片没有对应关系），后边缘也可以使用同样的前边缘，因为我们只需要把它（前边缘）水平翻转然后正确地拼接到后边缘即可。台阶切片很少会出现，所以我们只需要用一个切片。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/26044/20/11490/360476/5c8f0047Ec7d99a6b/b226b682c6da3a9f.png&#34; alt=&#34;diagram-6-1024x531&#34; /&gt;&lt;/p&gt;

&lt;p&gt;打开上面的素材，单独放在一个浏览器 tab 里面，可以方便制作时查看它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;不要将切片 &lt;strong&gt;类型&lt;/strong&gt; 与用于构建指定砖块墙的切片数混淆。例如，一面砖块墙可以有 30 个垂直切片，但实际上只由 8 类切片构建。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在你已经了解了砖块墙是如何构建的，我们可以开始实现它了。&lt;/p&gt;

&lt;h2 id=&#34;精灵表-sprite-sheet&#34;&gt;精灵表（Sprite sheet）&lt;/h2&gt;

&lt;p&gt;如上所述，我们的砖块墙由八种不同类型的砖块构成。表示这些切片的最简单方法是为每个切片提供单独的 PNG文件。虽然这是一种办法，但我们实际上会将所有切片添加到一个称为 &lt;strong&gt;精灵表&lt;/strong&gt; 的大型 PNG 文件中。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;精灵表通常也称为 &lt;strong&gt;纹理图集（texture atlas&lt;/strong&gt;） 。我们将在本教程中使用 &lt;strong&gt;精灵表&lt;/strong&gt; 这个术语。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我在本教程的 resources.zip 文件中提供了精灵表。这是一个名为 &lt;code&gt;wall.png&lt;/code&gt; 的文件，如下所示。所有八个切片都已打包到一个位图上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/16841/31/11340/23788/5c8f02ecEcdd940cb/a38fb14d2958229f.png&#34; alt=&#34;sprite-sheet&#34; /&gt;&lt;/p&gt;

&lt;p&gt;资源文件夹中还有一个与精灵表对应的 &lt;code&gt;wall.json&lt;/code&gt; 文件。可以直接用文本编辑器打开。此文件使用 JSON 数据格式来定义精灵表中单独位图切片的名称和位置。使用精灵表时，表中的每个单独的位图称为 &lt;strong&gt;帧&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我们的整个精灵表将作为纹理加载到代码中（中间层和远景图层也这么加载过）。因此，有时会将框架视为子纹理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;并不需要完全理解 JSON 文件，因为 Pixi 将处理它。但是，我们可以探索一下正在使用的这个文件。下面这段是来自 JSON 数据中的一段，表示第一个墙边切片的框架。我已经为高亮了一些代码行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;edge_01&amp;quot;: // 高亮
{
  &amp;quot;frame&amp;quot;: {&amp;quot;x&amp;quot;:128,&amp;quot;y&amp;quot;:0,&amp;quot;w&amp;quot;:64,&amp;quot;h&amp;quot;:256},// 高亮
  &amp;quot;rotated&amp;quot;: false,
  &amp;quot;trimmed&amp;quot;: false,
  &amp;quot;spriteSourceSize&amp;quot;: {&amp;quot;x&amp;quot;:0,&amp;quot;y&amp;quot;:0,&amp;quot;w&amp;quot;:64,&amp;quot;h&amp;quot;:256},
  &amp;quot;sourceSize&amp;quot;: {&amp;quot;w&amp;quot;:64,&amp;quot;h&amp;quot;:256}
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行包含与框架关联的 &lt;strong&gt;唯一名称&lt;/strong&gt;（&lt;code&gt;edge_01&lt;/code&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;edge_01&amp;quot;:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每当我们想要从精灵表中直接获取这个墙切片的图像时，我们将使用此名称。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你不熟悉 JSON 数据格式，则可以在此 &lt;a href=&#34;https://zh.wikipedia.org/zh-cn/JSON&#34;&gt;Wikipedia 条目&lt;/a&gt; 中找到更多信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下一个高亮行代码定义了框架的矩形区域：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;frame&amp;quot;: {&amp;quot;x&amp;quot;:128,&amp;quot;y&amp;quot;:0,&amp;quot;w&amp;quot;:64,&amp;quot;h&amp;quot;:256},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本质上，它用于在精灵表中定位帧的位图。&lt;/p&gt;

&lt;p&gt;JSON 文件中还有其他七种类型的切片。每个切片将由唯一的帧名称表示。使用精灵表时，你只需要知道 &lt;strong&gt;唯一名称&lt;/strong&gt; 即可。下面我还提供了一张标有每个切片类型的图片。也可以单独打开这个图片，方便回顾。&lt;/p&gt;

&lt;p&gt;wall.json 的后面，有一些元数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;meta&amp;quot;: {
  &amp;quot;app&amp;quot;: &amp;quot;http://www.codeandweb.com/texturepacker &amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0&amp;quot;,
  &amp;quot;image&amp;quot;: &amp;quot;wall.png&amp;quot;,
  &amp;quot;format&amp;quot;: &amp;quot;RGBA8888&amp;quot;,
  &amp;quot;size&amp;quot;: {&amp;quot;w&amp;quot;:256,&amp;quot;h&amp;quot;:512},
  &amp;quot;scale&amp;quot;: &amp;quot;1&amp;quot;,
  &amp;quot;smartupdate&amp;quot;: &amp;quot;$TexturePacker:SmartUpdate:fc102f6475bdd4d372c...&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该数据表示精灵表的实际文件的相对路径。 Pixi 将使用该数据加载正确的 PNG 文件。&lt;/p&gt;

&lt;h2 id=&#34;纹理打包器-texturepacker&#34;&gt;纹理打包器（TexturePacker）&lt;/h2&gt;

&lt;p&gt;我使用了一个工具来生成本教程的精灵表和 JSON 文件。它的名字叫 &lt;a href=&#34;http://www.codeandweb.com/texturepacker&#34;&gt;TexturePacker&lt;/a&gt;，可用于Windows，Mac OS X 和 Linux。它可以导出许多精灵表格式，包括 pixi.js 使用的JSON（哈希）格式。我不会在本教程中介绍如何使用 TexturePacker，但它非常容易掌握。付费版本也物超所值，还有一个免费版本，适合那些想先学习基础知识的人。&lt;/p&gt;

&lt;h2 id=&#34;加载精灵表&#34;&gt;加载精灵表&lt;/h2&gt;

&lt;p&gt;既然我们对精灵表有一点了解了，就让我们继续把它加载进程序。我们首先将一些代码添加到项目的 Main 类中。用文本编辑器中打开 Main.js。&lt;/p&gt;

&lt;p&gt;在文件的末尾，添加以下方法来加载精灵表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.loadSpriteSheet = function() {
  var loader = PIXI.loader;
  loader.add(&amp;quot;wall&amp;quot;, &amp;quot;resources/wall.json&amp;quot;);
  loader.once(&amp;quot;complete&amp;quot;, this.spriteSheetLoaded.bind(this));
  loader.load();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了 &lt;code&gt;PIXI.loaders.Loader&lt;/code&gt; 类，它可用于加载图像，精灵表和位图字体文件。我们直接从 &lt;code&gt;PIXI.loader&lt;/code&gt; 属性获取加载器的预定义的实例来使用加载器，所有资源都可以人这里加载。所以，只需把 &lt;code&gt;wall.json&lt;/code&gt; 文件也添加进去。我们传递一个与文件关联的唯一 ID 作为第一个参数，并将资源的实际相对路径作为第二个参数传递。&lt;/p&gt;

&lt;p&gt;加载精灵表后，PIXI.loaders.Loader 类会触发一个 &lt;code&gt;complete&lt;/code&gt; 事件。为了响应该事件，我们只需要绑定 complete 方法到自定义函数 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 中，这个函数我们稍后实现。&lt;/p&gt;

&lt;p&gt;最后，调用我们的 PIXI.loaders.Loader 实例的 &lt;code&gt;load()&lt;/code&gt; 方法来真正加载我们的精灵表。加载完后，Pixi 将提取所有帧并将其存储在内部的纹理缓存中以便后续使用。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;目前，远景层和中间层图像在其构造函数中加载。但是，我们实际上可以预先加载这些图像，并避免在实例化远景层和中间类时出现短暂的延迟。将它们添加到我们的 Loader 实例中：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;loader.add(&amp;quot;wall&amp;quot;, &amp;quot;resources/wall.json&amp;quot;);
loader.add(&amp;quot;bg-mid&amp;quot;, &amp;quot;resources/bg-mid.png&amp;quot;); // 添加
loader.add(&amp;quot;bg-far&amp;quot;, &amp;quot;resources/bg-far.png&amp;quot;); // 添加
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;无需对 Far 或 Mid 类进行任何更改，因为在尝试从文件系统加载纹理之前，对  &lt;code&gt;PIXI.Texture.fromImage()&lt;/code&gt; 的调用将优先查询内部纹理缓存。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在让我们编写 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 方法。在文件末尾添加以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要编写这个空方法。之前我们创建了一个 Scroller 类的实例，并在 Main 类的构造函数中启动了我们的主循环。但是，我们现在要等到精灵表加载完成后再进行所有操作。让我们将该代码移动到我们的 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 方法中。&lt;/p&gt;

&lt;p&gt;向上滚动到构造函数并删除以下两行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Main() {
  this.stage = new PIXI.Container();
  this.renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  this.scroller = new Scroller(this.stage); // 删除

  requestAnimationFrame(this.update.bind(this)); // 删除
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再回到你的 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 方法并在那里添加删除的两行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
  this.scroller = new Scroller(this.stage);
  requestAnimationFrame(this.update.bind(this));
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，返回构造函数并调用 &lt;code&gt;loadSpriteSheet()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Main() {
  this.stage = new PIXI.Container();
  this.renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  this.loadSpriteSheet(); // 添加
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在保存代码并刷新浏览器。在 Chrome 的 JavaScript 控制台中查看没有错误。&lt;/p&gt;

&lt;h2 id=&#34;测试精灵表&#34;&gt;测试精灵表&lt;/h2&gt;

&lt;p&gt;虽然我们已经成功加载了精灵表，但我们并不知道帧（我们的八个垂直壁切片类型）是否已真正地存储在 Pixi 的纹理缓存中。所以让我们继续创建一些使用其中一些精灵来使用这使用帧。&lt;/p&gt;

&lt;p&gt;我们将在 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 方法中执行我们的测试。将以下代码添加到其中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
  this.scroller = new Scroller(this.stage);
  requestAnimationFrame(this.update.bind(this));

  var slice1 = PIXI.Sprite.fromFrame(&amp;quot;edge_01&amp;quot;); // 高亮
  slice1.position.x = 32; // 高亮
  slice1.position.y = 64; // 高亮
  this.stage.addChild(slice1); // 高亮
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的代码中，我们利用了 PIXI.Sprite 类的 &lt;code&gt;fromFrame()&lt;/code&gt; 静态方法。它使用纹理缓存中与指定帧 ID 匹配的纹理创建一个新的精灵。我们指定 &lt;code&gt;edge_01&lt;/code&gt; 帧用来表示砖块墙前边缘的切片。&lt;/p&gt;

&lt;p&gt;保存代码并刷新浏览器以查看切片。不用担心它展示的位置，位置现在还不重要。&lt;/p&gt;

&lt;p&gt;让我们添加第二个垂直切片。这次我们将使用砖块墙中间的切片类型。为了更精确，我们将使用精灵表中名为&lt;code&gt;decoration_03&lt;/code&gt; 的帧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
  this.scroller = new Scroller(this.stage);
  requestAnimationFrame(this.update.bind(this));

  var slice1 = PIXI.Sprite.fromFrame(&amp;quot;edge_01&amp;quot;);
  slice1.position.x = 32;
  slice1.position.y = 64;
  this.stage.addChild(slice1);

  var slice2 = PIXI.Sprite.fromFrame(&amp;quot;decoration_03&amp;quot;); // 添加
  slice2.position.x = 128; // 添加
  slice2.position.y = 64; // 添加
  this.stage.addChild(slice2); // 添加
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次保存并测试。现在应该看到两个垂直墙切片位于舞台上，类似于下面的这个屏幕截图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/14918/30/11267/98749/5c8f0dd7Ee4736269/d06820174522e100.png&#34; alt=&#34;tut3-testing-sprite-sheet&#34; /&gt;&lt;/p&gt;

&lt;p&gt;希望你现在对精灵表的框架已成功加载并缓存产生了一些成就感。从 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 方法中删除测试代码。方法应再次如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
  this.scroller = new Scroller(this.stage);
  requestAnimationFrame(this.update.bind(this));
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存你的修改&lt;/p&gt;

&lt;h2 id=&#34;一些-gpu-理论&#34;&gt;一些 GPU 理论&lt;/h2&gt;

&lt;p&gt;我还没有解释为什么我们选择将切片打包成一个精灵表而不是单独加载八个 PNG 到内存中。原因和性能相关。 Pixi 的 WebGL 渲染器利用计算机的图形处理单元（GPU）来加速图形性能。但是为了保证最佳性能，我们必须至少了解一点 GPU 的工作原理。&lt;/p&gt;

&lt;p&gt;GPU 更擅长一次处理大数据量的场景。 Pixi 会迎合 GPU 的这个特点，把数据对象批量发送给 GPU。但是，它只能批量处理具有相似状态的展示对象。当遇到具有不同状态的显示对象时，表示已经发生状态改变并且 GPU 会停止以绘制当前批次。程序中发生的状态更改越少，GPU 需要执行的绘制操作就越少，以便呈现展示列表。 GPU 执行的绘制操作越少，渲染性能就越快。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;刚刚提到的 &lt;strong&gt;绘制&lt;/strong&gt;（draw） 操作和我们平常绘画意思差不多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不幸的是，每当遇到具有不同纹理的展示对象时，状态就会发生改变。精灵表可以帮助避免状态更改，因为所有图像都存储在单个纹理中。 GPU 可以非常愉快地从精灵表中绘制每个帧（或子纹理），而无需单独的调用绘制。&lt;/p&gt;

&lt;p&gt;但是，可以存储在 GPU 上的纹理存在大小限制。大多数现代 GPU 可以存储大小为 2048×2048 像素的纹理。因此，如果你要使用精灵表，请确保其尺寸不超过 GPU 纹理的限制。值得庆幸的是，我们的精灵表很小。&lt;/p&gt;

&lt;p&gt;因此，与将每个墙切片的图像存储在单独的纹理上相比，我们的精灵表可以帮助显着提高滚动器的性能。&lt;/p&gt;

&lt;h2 id=&#34;展示游戏地图&#34;&gt;展示游戏地图&lt;/h2&gt;

&lt;p&gt;所以我们已经成功加载了精灵表并且还设法显示了一些帧，但是我们如何真正地构建一个包含砖块墙的大地图？&lt;/p&gt;

&lt;p&gt;我想最简单的方法是创建一个精灵数组，其中每个精灵代表我们地图中的垂直墙切片。然而，考虑到每个切片的宽度比较短，我们的整个地图将很容易由数千个精灵组成。这是很多精灵都将存储在内存中。另外，如果我们只是将所有这些精灵转储到我们的展示列表上，那么它会给渲染器带来很大的压力，可能会影响游戏的帧速率。&lt;/p&gt;

&lt;p&gt;另一种方法是实例化并仅显示将在视口中可见的精灵。当地图滚动时，最左边的精灵最终将离开屏幕。当发生这种情况时，我们可以从显示列表中删除该精灵，并在视口最右边的外部添加一个新的精灵。通过这种方法，我们可以向用户提供滚动整个地图的错觉，而实际上只需要处理视口中当前可见的地图部分。&lt;/p&gt;

&lt;p&gt;虽然第二种方法肯定比第一种方法更好，但它需要为我们的精灵进行不断的内存分配和释放：为进入的每个新精灵分配内存，为离开的精灵释放内存。为什么这么做比较糟糕呢？因为分配内存需要宝贵的 CPU 周期，这可能会影响游戏的性能。如果你必须不断地分配内存，那将避免不了这个问题。&lt;/p&gt;

&lt;p&gt;释放之前对象使用的内存也是潜在的 CPU 性能损耗。 JavaScript 运行时利用垃圾收集器释放以前被不再需要的对象使用的内存。但是，你无法直接控制何时进行垃圾收集，假如需要释放大量内存，该过程可能需要几毫秒。因此，不断实例化精灵再从展示列表中删除精灵将导致频繁的垃圾收集，这会影响游戏的性能。&lt;/p&gt;

&lt;p&gt;第三种方法可以避免前两种问题。它被称为 &lt;strong&gt;对象池&lt;/strong&gt;，它能在不触发 JavaScript 的垃圾收集器的情况下更加智能地使用内存。&lt;/p&gt;

&lt;h2 id=&#34;对象池-object-pooling&#34;&gt;对象池（Object Pooling）&lt;/h2&gt;

&lt;p&gt;想理解对象池，请考虑一个简单的游戏场景。在射击游戏中，玩家的船可能会在游戏过程中发射数十万枚射弹，但由于船的射速，任何时候都只能有 20 枚射弹进入屏幕。因此，仅在游戏代码中创建 20 个射弹实例并在游戏过程中重新使用这些射弹是更好的。&lt;/p&gt;

&lt;p&gt;20 个射弹可以存放在一个阵列中。每次玩家开火时，我们从阵列中移除一个射弹并将其添加到屏幕上。当射弹离开屏幕（或击中敌人）时，我们将其添加回阵列以便稍后再次使用。重要的是我们永远不需要创建新的射弹实例。相反，我们只使用预先创建的 20 个实例池。在我们的示例中，数组将是我们的对象池。这样合理吗？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你想了解有关对象池的更多信息，请查看此 &lt;a href=&#34;https://zh.wikipedia.org/zh-cn/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F&#34;&gt;Wikipedia条目&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以将对象池应用到游戏地图中，并具有以下内容：一个窗口（window）切片池；一幢墙面装饰（decoration）切片；一层前边缘；一层后边缘；还有一个台阶。&lt;/p&gt;

&lt;p&gt;因此，虽然我们的游戏地图最终可能包含数百个窗口，但实际上我们只需要创建足够的窗口精灵来覆盖视口的宽度。当一个窗口即将在我们的视口中显示时，我们只需从 windows 对象池中检索一个窗口精灵。当该窗口滚出视图时，我们将其从显示列表中删除并将其返回到对象池。我们将这个原则应用于边缘，装饰和台阶。&lt;/p&gt;

&lt;p&gt;知道这就足够了。让我们开始构建一个对象池类来保存我们的切片精灵。&lt;/p&gt;

&lt;h2 id=&#34;创建一个对象池类&#34;&gt;创建一个对象池类&lt;/h2&gt;

&lt;p&gt;由于我们的游戏地图代表了一系列砖块墙，我们将创建一个名为 &lt;code&gt;WallSpritesPool&lt;/code&gt; 的类，作为我们各种墙壁部件的池子。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;更通用的类名可能是 &lt;code&gt;MapSpritesPool&lt;/code&gt;，也可以是 &lt;code&gt;ObjectPool&lt;/code&gt;。但是，就本教程而言，&lt;code&gt;WallSpritesPool&lt;/code&gt; 是比较合适的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在文本编辑器中创建一个新文件并添加以下构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.windows = [];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存文件并将其命名为 &lt;code&gt;WallSpritesPool.js&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在构造函数中，我们定义了一个名为 windows 的空数组。此数组将充当我们地图中所有的窗口精灵的对象池。&lt;/p&gt;

&lt;h2 id=&#34;给-windows-池子添加元素&#34;&gt;给 windows 池子添加元素&lt;/h2&gt;

&lt;p&gt;我们的数组需要预先填充一些窗口精灵。请记住，我们的砖块墙可以支持两种类型的窗户 — 一个开灯的窗户和一个没有开灯的窗户 - 所以我们需要确保我们添加两种类型足够多。通过将以下代码添加到构造函数来填充数组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.windows = [];

  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码为对象池添加了 12 个窗口精灵。前 6 个精灵代表我们亮灯的窗口（&lt;code&gt;window_01&lt;/code&gt;），而余他 6 个精灵代表未亮灯的窗口（&lt;code&gt;window_02&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;从对象池中检索精灵时，它们将从数组的前面获取。根据我们在填充时将精灵添加到数组中的顺序，对窗口精灵的前 6 个请求将始终返回一个亮灯的窗口，而接下来的 6 个请求将始终返回一个未亮灯的窗口。我们从池中获得的窗口切片类型需要 &lt;strong&gt;随机&lt;/strong&gt; 出现。这可以通过在填充数组后数组元素进行打乱来实现。&lt;/p&gt;

&lt;p&gt;以下方法将把传递给它的数组打乱。添加方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.shuffle = function(array) {
  var len = array.length;
  var shuffles = len * 3;
  for (var i = 0; i &amp;lt; shuffles; i++)
  {
    var wallSlice = array.pop();
    var pos = Math.floor(Math.random() * (len-1));
    array.splice(pos, 0, wallSlice);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在从构造函数调用 &lt;code&gt;shuffle()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.windows = [];

  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;));
  
  this.shuffle(this.windows); // 调用
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在让我们做一些重构，因为有一个更简洁的方法来填充我们的数组。由于我们实际上是在数组中添加两组精灵（亮灯和不亮灯的窗口），我们可以替换以下代码行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.windows = [];

  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_01&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;)); // 删除
  this.windows.push(PIXI.Sprite.fromFrame(&amp;quot;window_02&amp;quot;)); // 删除
  
  this.shuffle(this.windows);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用下面的代替：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.windows = [];

  this.addWindowSprites(6, &amp;quot;window_01&amp;quot;); // 添加
  this.addWindowSprites(6, &amp;quot;window_02&amp;quot;); // 添加
  
  this.shuffle(this.windows);
}

 // 添加
WallSpritesPool.prototype.addWindowSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = PIXI.Sprite.fromFrame(frameId);
    this.windows.push(sprite);
  }
};

WallSpritesPool.prototype.shuffle = function(array) {
  var len = array.length;
  var shuffles = len * 3;
  for (var i = 0; i &amp;lt; shuffles; i++)
  {
    var wallSlice = array.pop();
    var pos = Math.floor(Math.random() * (len-1));
    array.splice(pos, 0, wallSlice);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存更改。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;addWindowSprites()&lt;/code&gt; 方法允许我们向 windows 数组中添加一些在精灵表中指定的精灵帧。因此，它可以很容易地为我们的池子添加一组 6 个亮灯精灵和一组 6 个未亮灯精灵。&lt;/p&gt;

&lt;p&gt;在继续之前，我们应该再做一次重构。将构造函数中的代码移动到单独的方法中。删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.windows = []; // 删除

  this.addWindowSprites(6, &amp;quot;window_01&amp;quot;); // 删除
  this.addWindowSprites(6, &amp;quot;window_02&amp;quot;); // 删除
  
  this.shuffle(this.windows); // 删除
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用一个新方法替换：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.createWindows = function() {
  this.windows = [];

  this.addWindowSprites(6, &amp;quot;window_01&amp;quot;);
  this.addWindowSprites(6, &amp;quot;window_02&amp;quot;);

  this.shuffle(this.windows);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，从构造函数中调用 &lt;code&gt;createWindows()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.createWindows();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好的，我们目前用代码创建了窗口精灵，将它们添加到一个数组，并打乱该数组。继续之前保存文件。&lt;/p&gt;

&lt;h2 id=&#34;为什么使用十二个窗口精灵&#34;&gt;为什么使用十二个窗口精灵&lt;/h2&gt;

&lt;p&gt;从技术上讲，我们可以在池中使用少于 12 个窗口精灵。毕竟，我们只需要足够的精灵来覆盖视口的宽度。我选择十二个的原因是为了让砖块墙的亮灯和不亮灯窗户具有一些随机性。然而值得注意的是，我可以在合理范围内使用任意数量的精灵，只要它为我提供足够的窗口精灵以在视口内生成砖块墙。&lt;/p&gt;

&lt;h2 id=&#34;借用-borrow-和归还-return-精灵&#34;&gt;借用（borrow）和归还（return）精灵&lt;/h2&gt;

&lt;p&gt;我们的对象池有一组窗口精灵，但是我们还没有提供从池中获取精灵或返回池的公共方法。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;所有方法和属性都可以在 JavaScript 中公开访问。这可能使你难以识别属于你的类 API 的方法和属性以及处理实现细节的方法和属性。当我把某些东西称为“公开”时，我的意思是说我打算在类的外部使用它。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们将提供以下两种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;borrowWindow()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;returnWindow()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;borrowWindow()&lt;/code&gt; 方法将从 windows 池中删除一个窗口精灵，并返回对它的引用供你使用。完成后，可以通过调用 &lt;code&gt;returnWindow()&lt;/code&gt; 将精灵作为参数传递回游戏池。&lt;/p&gt;

&lt;p&gt;好的，我们在类的构造函数之后添加 &lt;code&gt;borrowWindow()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.createWindows();
}
// 添加
WallSpritesPool.prototype.borrowWindow = function() {
  return this.windows.shift();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如你所看到的，这是一个相当简单的方法，它只是从 windows 数组的前面删除第一个精灵并返回它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;borrowWindow()&lt;/code&gt; 方法不会检查池中是否还有精灵。我们在这一系列教程中都不会太在意这种异常情况，但在尝试从中返回内容之前，检查一下精灵池是否为空是一个好习惯。有多种策略可用于处理空池子。一个常见的方法是在干燥（没有元素）时动态增加池的大小。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在直接在其下面添加 &lt;code&gt;returnWindow()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.borrowWindow = function() {
  return this.windows.shift();
};
// 添加	
WallSpritesPool.prototype.returnWindow = function(sprite) {
  this.windows.push(sprite);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就像 &lt;code&gt;borrowWindow()&lt;/code&gt; 一样，&lt;code&gt;returnWindow()&lt;/code&gt; 方法很简单。它将精灵作为参数并将该精灵压入到 windows 数组的末尾。&lt;/p&gt;

&lt;p&gt;我们现在有一种从对象池中借用窗口精灵的方法，一旦我们完成它就将精灵返回给（归还）对象池的方法。&lt;/p&gt;

&lt;p&gt;保存更改。&lt;/p&gt;

&lt;h2 id=&#34;快速回顾&#34;&gt;快速回顾&lt;/h2&gt;

&lt;p&gt;查看一下 &lt;code&gt;WallSpritesPool&lt;/code&gt; 类。并没有很多代码，但重要的是你要了解在添加之前发生了什么。以下是类的当前版本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.createWindows();
}

WallSpritesPool.prototype.borrowWindow = function() {
  return this.windows.shift();
};
	
WallSpritesPool.prototype.returnWindow = function(sprite) {
  this.windows.push(sprite);
};

WallSpritesPool.prototype.createWindows = function() {
  this.windows = [];

  this.addWindowSprites(6, &amp;quot;window_01&amp;quot;);
  this.addWindowSprites(6, &amp;quot;window_02&amp;quot;);

  this.shuffle(this.windows);
};

WallSpritesPool.prototype.addWindowSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = PIXI.Sprite.fromFrame(frameId);
    this.windows.push(sprite);
  }
};

WallSpritesPool.prototype.shuffle = function(array) {
  var len = array.length;
  var shuffles = len * 3;
  for (var i = 0; i &amp;lt; shuffles; i++)
  {
    var wallSlice = array.pop();
    var pos = Math.floor(Math.random() * (len-1));
    array.splice(pos, 0, wallSlice);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该类只创建一个包含 6 个亮灯窗口精灵和 6个未亮灯窗口精灵数组。该数组充当窗口的精灵池，并且被打乱以确保随机混合两种状态。提供了两个公共方法 — &lt;code&gt;borrowWindow()&lt;/code&gt; 和 &lt;code&gt;returnWindow()&lt;/code&gt; - 它们允许从精灵池中借用一个窗口精灵，然后归还到池中。&lt;/p&gt;

&lt;p&gt;这就是它要做的所有事情了。当然，我们仍然需要考虑其他切片类型（前边缘，后边缘，墙面装饰和墙壁台阶），但我们很快就会将它们添加到我们的 WallSpritesPool 类中。首先让我们把将精灵池的代码引用到页面，保证正常运行。&lt;/p&gt;

&lt;h2 id=&#34;测试你的对象池&#34;&gt;测试你的对象池&lt;/h2&gt;

&lt;p&gt;转到你的 index.html 文件并引用 &lt;code&gt;WallSpritesPool&lt;/code&gt; 类的源文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Far.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Mid.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Scroller.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;WallSpritesPool.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- 添加 --&amp;gt;
&amp;lt;script src=&amp;quot;Main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存代码。&lt;/p&gt;

&lt;p&gt;现在打开 Main.js。我们将对 Main 类进行一些临时更改，以便测试对象池。&lt;/p&gt;

&lt;p&gt;我们首先在 &lt;code&gt;spriteSheetLoaded()&lt;/code&gt; 方法中创建我们的对象池的实例，创建将用于保存从池中获取的切片精灵数组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
  this.scroller = new Scroller(this.stage);
  requestAnimationFrame(this.update.bind(this));

  this.pool = new WallSpritesPool(); // 添加
  this.wallSlices = []; // 添加
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的代码中，我们将对象池实例存储在名为 pool 的成员变量中，而我们的数组的成员变量名为 &lt;code&gt;wallSlices&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;现在让我们编写一些代码来从池中获取指定数量的窗口并将它们连续地添加到舞台上。添加以下测试方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.borrowWallSprites = function(num) {
  for (var i = 0; i &amp;lt; num; i++)
  {
    var sprite = this.pool.borrowWindow();
    sprite.position.x = -32 + (i * 64);
    sprite.position.y = 128;

    this.wallSlices.push(sprite);

    this.stage.addChild(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了将窗口精灵添加到舞台，上面的 &lt;code&gt;borrowWallSprites()&lt;/code&gt; 方法还将每个精灵添加到我们的 &lt;code&gt;wallSlices&lt;/code&gt; 成员变量中。这样做的原因是我们需要能够从第二个测试方法中访问（删除、移除、归还）这些窗口精灵，我们现在将编写它们。添加以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.returnWallSprites = function() {
  for (var i = 0; i &amp;lt; this.wallSlices.length; i++)
  {
    var sprite = this.wallSlices[i];
    this.stage.removeChild(sprite);
    this.pool.returnWindow(sprite);
  }

  this.wallSlices = [];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 &lt;code&gt;returnWallSprites()&lt;/code&gt; 方法删除添加到舞台的所有窗口切片，并将这些精灵归还到对象池。&lt;/p&gt;

&lt;p&gt;通过这两种方法，我们可以验证我们是否可以从对象池中借用窗口精灵，并将这些精灵归还给池子。我们将使用Chrome 的 JavaScript 控制台窗口：&lt;/p&gt;

&lt;p&gt;刷新浏览器并打开JavaScript控制台。手动执行如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.borrowWallSprites(9);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;请记住，我们的 Main 类可以通过主全局变量 main 访问，我们可以使用它来调用 &lt;code&gt;borrowWallSprites()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就像下面的截图一样，你应该看到舞台上有九个窗口精灵。都是从你的对象池中 &lt;strong&gt;借&lt;/strong&gt; 来的，然后被添加到舞台上。还要注意，亮灯和亮灯的窗口序列可能是随机出现的。这是因为池中的窗口数组在创建后被打乱了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t1/31720/25/6450/27075/5c8f20c3E419f8f9b/1c176082df00c88d.png&#34; alt=&#34;tut3-testing-object-pool&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在让我们验证是否可以将这些精灵归还给对象池。在控制台中输入以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.returnWallSprites();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;精灵墙应该从舞台上消失，并将返回到对象池。&lt;/p&gt;

&lt;p&gt;这还不能满足我们的实际需示。最简单的方法是从池中请求更多窗口并检查它们是否也出现在屏幕上。让我们从游泳池中再借用九个窗口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.borrowWallSprites(9);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再归还：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.returnWallSprites();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们现在从对象池中获得了总共18个精灵。请记住，池中只包含 12 个窗口精灵（6个开灯的，6 个不开灯的）。因此，精灵正在从池中借用并在我们完成后成功返回。如果没有被返还，那么当对象池的内部数组变空时，会报运行时错误。&lt;/p&gt;

&lt;p&gt;JavaScript 中的所有内容都可以公开访问，我们可以在任何时候轻松检查对象池的内部数组。尝试从控制台检查数组的大小：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.pool.windows.length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这么做应该返回长度 12。现在使用以下方法从池中借用四个窗口精灵：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.borrowWallSprites(4);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次查看池子中的精灵个数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.pool.windows.length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它现在应该只包含 8 个精灵。最后通过调用 &lt;code&gt;returnWallSprites()&lt;/code&gt; 将精灵集返回池中。再次检查对象池的大小，并确认其长度为 12。&lt;/p&gt;

&lt;p&gt;我对咱们的对象池能正常运行感到满意。让我们继续，但保留你添加到 Main 类的测试代码，因为我们很快就会再次使用它。&lt;/p&gt;

&lt;h2 id=&#34;向对象池中添加墙面装饰&#34;&gt;向对象池中添加墙面装饰&lt;/h2&gt;

&lt;p&gt;目前我们的对象池仅提供窗口精灵，但我们还需要添加对前边缘，后边缘，墙面装饰切片和台阶的支支持。让我们从三个墙面装饰切片开始。&lt;/p&gt;

&lt;p&gt;如果你还记得，我们的一些墙上装饰着管道和通风口。这些切片安插在在每个窗口之间。让我们更新我们的 &lt;code&gt;WallSpritesPool&lt;/code&gt; 类以包含墙面装饰切片。代码与口的对象池非常相似，所以它们看起来都应该很熟悉。&lt;/p&gt;

&lt;p&gt;打开 &lt;code&gt;WallSpritesPool.js&lt;/code&gt; 并在构造函数中进行以下调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.createWindows();
  this.createDecorations(); // 添加
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在真正来实现 &lt;code&gt;createDecorations()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.createWindows = function() {
  this.windows = [];

  this.addWindowSprites(6, &amp;quot;window_01&amp;quot;);
  this.addWindowSprites(6, &amp;quot;window_02&amp;quot;);

  this.shuffle(this.windows);
};
// 实现
WallSpritesPool.prototype.createDecorations = function() {
  this.decorations = [];

  this.addDecorationSprites(6, &amp;quot;decoration_01&amp;quot;);
  this.addDecorationSprites(6, &amp;quot;decoration_02&amp;quot;);
  this.addDecorationSprites(6, &amp;quot;decoration_03&amp;quot;);

  this.shuffle(this.decorations);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码通过调用 &lt;code&gt;addDecorationSprites()&lt;/code&gt; 方法将 18 个装饰精灵添加到对象池中（稍后我们将实现这个方法）。前六个精灵使用我们的精灵表中的 &lt;code&gt;decoration_01&lt;/code&gt; 帧。接下来的六个使用 &lt;code&gt;decoration_02&lt;/code&gt;，最后六个使用 &lt;code&gt;decoration_03&lt;/code&gt;。然后调用 &lt;code&gt;shuffle()&lt;/code&gt; 确保精灵随机放置在我们的装饰数组中，我们已将其声明为此类的成员变量，并用于存储墙面装饰精灵。&lt;/p&gt;

&lt;p&gt;现在让我们来编写 &lt;code&gt;addDecorationSprites()&lt;/code&gt; 方法。在 &lt;code&gt;addWindowSprites()&lt;/code&gt; 方法之后直接添加以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.addWindowSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
    this.windows.push(sprite);
  }
};
// 实现
WallSpritesPool.prototype.addDecorationSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
    this.decorations.push(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在剩下要做的就是添加两个新方法，允许从对象池借用装饰精灵并返还。方法名称将遵循用于窗口精灵的命名约定。添加 &lt;code&gt;borrowDecoration()&lt;/code&gt; 和 &lt;code&gt;returnDecoration()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.borrowWindow = function() {
  return this.windows.shift();
};
	
WallSpritesPool.prototype.returnWindow = function(sprite) {
  this.windows.push(sprite);
};
// 实现
WallSpritesPool.prototype.borrowDecoration = function() {
  return this.decorations.shift();
};
	
WallSpritesPool.prototype.returnDecoration = function(sprite) {
  this.decorations.push(sprite);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存代码。&lt;/p&gt;

&lt;p&gt;我们的对象池现在支持窗口和装饰两种切片类型。让我们回到之前添加到 Main类中的测试方法，并测试一切是否正常。&lt;/p&gt;

&lt;h2 id=&#34;对象池的测试&#34;&gt;对象池的测试&lt;/h2&gt;

&lt;p&gt;前面我们建造了一面粗糙墙，完全由我们的对象池中的窗口组成。让我们稍微改变我们的测试代码，在每个窗口之间放置装饰切片。这将可以测试到是否真的可以从对象池中借用到窗口切片和装饰切片。&lt;/p&gt;

&lt;p&gt;打开 Main.js 并从 &lt;code&gt;borrowWallSprites()&lt;/code&gt; 方法中删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.borrowWallSprites = function(num) {
  for (var i = 0; i &amp;lt; num; i++)
  {
    var sprite = this.pool.borrowWindow(); // 删除
    sprite.position.x = -32 + (i * 64);
    sprite.position.y = 128;

    this.wallSlices.push(sprite);

    this.stage.addChild(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用下面几行代替：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.borrowWallSprites = function(num) {
  for (var i = 0; i &amp;lt; num; i++)
  {
    if (i % 2 == 0) { // 添加
      var sprite = this.pool.borrowWindow(); // 添加
    } else { // 添加
      var sprite = this.pool.borrowDecoration(); // 添加
    } // 添加
    sprite.position.x = -32 + (i * 64);
    sprite.position.y = 192;

    this.wallSlices.push(sprite);

    this.stage.addChild(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码使用模运算符（％）来确保我们在循环的奇数次迭代借用一个窗口精灵，偶数次迭代时借用一个装饰精灵。这个简单的更改允许我们现在生成具有以下模式的测试砖块墙：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window, decoration, window, decoration, window, decoration, window
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在转到 &lt;code&gt;returnWallSprites()&lt;/code&gt; 方法并删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.returnWallSprites = function() {
  for (var i = 0; i &amp;lt; this.wallSlices.length; i++)
  {
    var sprite = this.wallSlices[i]; // 删除
    this.stage.removeChild(sprite);
    this.pool.returnWindow(sprite);
  }

  this.wallSlices = [];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用下面几行代替：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.returnWallSprites = function() {
  for (var i = 0; i &amp;lt; this.wallSlices.length; i++)
  {
    var sprite = this.wallSlices[i];
    this.stage.removeChild(sprite);

    if (i % 2 == 0) { // 添加
      this.pool.returnWindow(sprite); // 添加
    } else { // 添加
      this.pool.returnDecoration(sprite); // 添加
    } // 添加
  }

  this.wallSlices = [];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再次使用了模运算符，这次确保我们将正确的精灵（窗口或装饰）返回给对象池。&lt;/p&gt;

&lt;p&gt;保存代码。&lt;/p&gt;

&lt;p&gt;刷新浏览器，然后使用 Chrome 的 JavaScript 控制台测试我们的对象池。通过在控制台窗口中输入以下内容来生成测试墙：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.borrowWallSprites(9);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不出意外，那么你应该看到一个由窗户构成的测试墙，其间插有各种墙壁装饰，如管道和通风口。实际上，你的砖块墙应该类似于下面的图片，它是从我的开发机上截取的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t1/14835/23/11449/35081/5c8f948eE577f4c48/924d41b53e1f6ded.png&#34; alt=&#34;tut3-more-object-pool-testing&#34; /&gt;&lt;/p&gt;

&lt;p&gt;虽然我们目前只编写了一些简单的测试，但我们所做的并不是为了生成整个游戏地图。&lt;/p&gt;

&lt;p&gt;使用以下调用将精灵返还到对象池：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.returnWallSprites();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过对 &lt;code&gt;borrowWallSprites()&lt;/code&gt; 和 &lt;code&gt;returnWallSprites()&lt;/code&gt; 进行一些手动调用来验证对象池是否完全正常工作（译者：建议多调用几次验证程序是否正常）。此外，使用控制台检查对象池的窗口和装饰数组的长度是否正常。&lt;/p&gt;

&lt;h2 id=&#34;给你的对象池添加边缘&#34;&gt;给你的对象池添加边缘&lt;/h2&gt;

&lt;p&gt;我们正一步步走向成功。精灵池目前使得我们可以创建一个原始的砖块墙，但它还没有墙的前后边缘。让我们继续添加这些切片类型。&lt;/p&gt;

&lt;p&gt;在文本编辑器中打开 &lt;code&gt;WallSpritesPool.js&lt;/code&gt; 并将以下两行添加到其构造函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.createWindows();
  this.createDecorations();
  this.createFrontEdges(); // 添加
  this.createBackEdges(); // 添加
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在添加一个 &lt;code&gt;createFrontEdges()&lt;/code&gt; 和一个 &lt;code&gt;createBackEdges()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.createDecorations = function() {
  this.decorations = [];

  this.addDecorations(6, &amp;quot;decoration_01&amp;quot;);
  this.addDecorations(6, &amp;quot;decoration_02&amp;quot;);
  this.addDecorations(6, &amp;quot;decoration_03&amp;quot;);

  this.shuffle(this.decorations);
};
// 添加
WallSpritesPool.prototype.createFrontEdges = function() {
  this.frontEdges = [];

  this.addFrontEdgeSprites(2, &amp;quot;edge_01&amp;quot;);
  this.addFrontEdgeSprites(2, &amp;quot;edge_02&amp;quot;);

  this.shuffle(this.frontEdges);
};
// 添加
WallSpritesPool.prototype.createBackEdges = function() {
  this.backEdges = [];

  this.addBackEdgeSprites(2, &amp;quot;edge_01&amp;quot;);
  this.addBackEdgeSprites(2, &amp;quot;edge_02&amp;quot;);

  this.shuffle(this.backEdges);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你应该能够轻松地看出来两种方法在干什么。第一个方法创建四个前边缘切片，其中两个使用精灵表的 &lt;code&gt;edge_01&lt;/code&gt; 帧，另外两个使用 &lt;code&gt;edge_02&lt;/code&gt;。第二个方法创建四个后边缘切片，并使用精灵表中与前边缘完全相同的帧。&lt;/p&gt;

&lt;p&gt;四个前壁边缘可能看起来相当少，但它会绰绰有余，因为即使砖块墙长度很短也至少会占视口一半宽度。换句话说，我们在任何时候都不会使用超过四个前壁边缘。后墙边缘也是如此。&lt;/p&gt;

&lt;p&gt;现在继续添加 &lt;code&gt;addFrontEdgeSprites()&lt;/code&gt; 和 &lt;code&gt;addBackEdgeSprites()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.addDecorationSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
    this.decorations.push(sprite);
  }
};
// 添加
WallSpritesPool.prototype.addFrontEdgeSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
    this.frontEdges.push(sprite);
  }
};
// 添加
WallSpritesPool.prototype.addBackEdgeSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
    sprite.anchor.x = 1;
    sprite.scale.x = -1;
    this.backEdges.push(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码没什么特殊的地方，但 &lt;code&gt;addBackEdgeSprites()&lt;/code&gt; 方法中有几行值得注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
sprite.anchor.x = 1; // 高亮行
sprite.scale.x = -1;// 高亮行
this.backEdges.push(sprite);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们使用的是前边缘所使用的相同的精灵帧，我们需要水平翻转后边缘精灵，以便它们适当地贴合在砖块墙的的末端。下图能说明我的意思。它在翻转之前显示后边缘。它与墙跨没有正确连接，看起来不对。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t1/11227/6/11995/56141/5c8f9805E1ad7c9c8/fd79415b5830ed29.png&#34; alt=&#34;flipping-wall-edges-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然而，在翻转后的后边缘精灵，会紧贴着砖块墙的末端。如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t1/20989/3/11470/60426/5c8f984bEf542d99e/fa35da3c1aed568a.png&#34; alt=&#34;flipping-wall-edges-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;翻转精灵很容易。我们只需使用 &lt;code&gt;PIXI.Sprite&lt;/code&gt; 类的 &lt;code&gt;scale&lt;/code&gt; 属性即可。 &lt;code&gt;scale&lt;/code&gt; 属性具有 x 和 y 值，可以调整该值以更改 sprite 的大小。但是，将 &lt;code&gt;scale.x&lt;/code&gt; 值设置为 -1，我们可以强制精灵水平翻转而不是缩放。&lt;/p&gt;

&lt;p&gt;Pixi 的 &lt;code&gt;PIXI.Sprite&lt;/code&gt; 类还提供了一个 &lt;code&gt;anchor&lt;/code&gt; 属性，用于定义 &lt;code&gt;sprite&lt;/code&gt; 的锚点（轴心点）。默认情况下，精灵的锚点在左上角。你可以设置锚点的 x 和 y 位置以调整精灵的锚。&lt;code&gt;anchor.set()&lt;/code&gt; 方法设置用于 x 和 y 位置的 &lt;strong&gt;比率值&lt;/strong&gt;，&lt;code&gt;0,0&lt;/code&gt; 表示精灵的左上角，&lt;code&gt;1,1&lt;/code&gt; 表示其右下角。&lt;/p&gt;

&lt;p&gt;在我们的教程中只使用默认值，这意味着所有定位都在精灵的左上角。然而，通过水平翻转边缘精灵，我们也翻转了它们的锚点的位置。换句话说，在水平翻转精灵之后，它的原点会改变到它的右上角，这不是我们想要的。为了解决这个问题，我们在将它们水平翻转之前将精灵的原点设置为右上角。这样，翻转后，它将被正确设置到左上角。&lt;/p&gt;

&lt;p&gt;好的，现在让我们来编写可以借用边缘并返还给对象池的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.returnDecoration = function(sprite) {
  this.decorations.push(sprite);
};
// 添加
WallSpritesPool.prototype.borrowFrontEdge = function() {
  return this.frontEdges.shift();
};

WallSpritesPool.prototype.returnFrontEdge = function(sprite) {
  this.frontEdges.push(sprite);
};

WallSpritesPool.prototype.borrowBackEdge = function() {
  return this.backEdges.shift();
};

WallSpritesPool.prototype.returnBackEdge = function(sprite) {
  this.backEdges.push(sprite);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存你的代码。&lt;/p&gt;

&lt;h2 id=&#34;构建第一个完整的砖块墙&#34;&gt;构建第一个完整的砖块墙&lt;/h2&gt;

&lt;p&gt;我们的精灵池现在支持足够多的垂切片类型，可以用来构建完整的砖块墙了。记住，一块完整的砖块墙包括 &lt;strong&gt;前边缘&lt;/strong&gt;，&lt;strong&gt;中间部分&lt;/strong&gt; 和 &lt;strong&gt;后边缘&lt;/strong&gt;。中间部分至少应包括 &lt;strong&gt;窗户&lt;/strong&gt; 和墙壁 &lt;strong&gt;装饰&lt;/strong&gt;。一些砖块墙也可能包括一个 &lt;strong&gt;台阶&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;让我们回到 Main 类，并编写一些测试代码，在我们的视口中绘制一个完整的砖块墙。&lt;/p&gt;

&lt;p&gt;首先，删除以前的测试方法。打开 Main.js 并删除 &lt;code&gt;borrowWallSprites()&lt;/code&gt; 和 &lt;code&gt;returnWallSprites()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们将实现一个名为 &lt;code&gt;generateTestWallSpan()&lt;/code&gt; 的新方法，用它来生成七个切片宽度的砖块墙。我们将把所有切片存放在一张表里面。首先添加以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.generateTestWallSpan = function() {
  var lookupTable = [
    this.pool.borrowFrontEdge,  // 第一个切片
    this.pool.borrowWindow,     // 第二个切片
    this.pool.borrowDecoration, // 第三个切片
    this.pool.borrowWindow,     // 第四个切片
    this.pool.borrowDecoration, // 第五个切片
    this.pool.borrowWindow,     // 第六个切片
    this.pool.borrowBackEdge    // 第七个切片
  ];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这张表是一个存放函数引用的数组。数组中的每个索引代表七个切片中的一个。第一个索引表示墙的前边缘，最后一个表示后边缘。中间的指数代表代表墙壁中段的五个切片。&lt;/p&gt;

&lt;p&gt;每个索引都包含对构建砖块墙所需的对象池中对应的引用。例如，第一个索引包含对池的 &lt;code&gt;borrowFrontEdge()&lt;/code&gt; 方法的引用。第二个索引包含对 &lt;code&gt;borrowWindow()&lt;/code&gt; 的引用，第三个索引包含对 &lt;code&gt;borrowDecoration()&lt;/code&gt; 的引用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.generateTestWallSpan = function() {
  var lookupTable = [
    this.pool.borrowFrontEdge,  // 1st slice
    this.pool.borrowWindow,     // 2nd slice
    this.pool.borrowDecoration, // 3rd slice
    this.pool.borrowWindow,     // 4th slice
    this.pool.borrowDecoration, // 5th slice
    this.pool.borrowWindow,     // 6th slice
    this.pool.borrowBackEdge    // 7th slice
  ];
  // 添加
  for (var i = 0; i &amp;lt; lookupTable.length; i++)
  {
    var func = lookupTable[i];

    var sprite = func.call(this.pool);
    sprite.position.x = 32 + (i * 64);
    sprite.position.y = 128;

    this.wallSlices.push(sprite);

    this.stage.addChild(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在循环内部，我们的代码获取对应切片的借用方法的引用，并将其存储在名为 &lt;code&gt;func&lt;/code&gt; 的局部变量中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var func = lookupTable[i];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦我们有了这个正确的引用，就使用以下方法调用它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var sprite = func.call(this.pool);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;call()&lt;/code&gt; 是一种原生的 JavaScript 方法，可用来从函数引用调用函数。例如，在循环的第一次迭代中，&lt;code&gt;func&lt;/code&gt; 变量将指向精灵池的 &lt;code&gt;borrowFrontEdge()&lt;/code&gt; 方法。因此，调用 &lt;code&gt;func&lt;/code&gt; 的 &lt;code&gt;call()&lt;/code&gt; 方法与下面的代码等价：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.pool.borrowFrontEdge()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了生成测试墙的方法，我们也需要编写另一个名为 &lt;code&gt;clearTestWallSpan()&lt;/code&gt; 的清除墙的方法。此方法将从舞台移除砖块墙并将切片返还到对象池中。&lt;/p&gt;

&lt;p&gt;在你的文件中加入下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.clearTestWallSpan = function() {
  var lookupTable = [
    this.pool.returnFrontEdge,  // 1st slice
    this.pool.returnWindow,     // 2nd slice
    this.pool.returnDecoration, // 3rd slice
    this.pool.returnWindow,     // 4th slice
    this.pool.returnDecoration, // 5th slice
    this.pool.returnWindow,     // 6th slice
    this.pool.returnBackEdge    // 7th slice
  ];

  for (var i = 0; i &amp;lt; lookupTable.length; i++)
  {
    var func = lookupTable[i];
    var sprite = this.wallSlices[i];

    this.stage.removeChild(sprite);
    func.call(this.pool, sprite);
  }

  this.wallSlices = [];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再一次使用了一张表。但是这次我们存储的是对应的切片返还方法的引用。例如，我们知道砖块墙的第一个切片是墙的前边缘。因此，存储在表中的第一个方法是 &lt;code&gt;returnFrontEdge()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;另外，请注意，这次使用原生 JavaScript &lt;code&gt;call()&lt;/code&gt; 方法时，我们将第二个参数传递给它。第二个参数是我们想要返还给池子的精灵。&lt;/p&gt;

&lt;p&gt;保存更改并刷新浏览器。让我们看看完整的砖块墙是什么样的。&lt;/p&gt;

&lt;p&gt;打开 Chrome 的 JavaScript 控制台并执行生成砖块墙的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.generateTestWallSpan();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你应该会看到七个切片宽的砖块墙。还有前后边缘。你的浏览器窗口应类似于下面的屏幕截图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/31494/17/6527/54099/5c904c26E4099c026/3b44cd4397cdfbee.png&#34; alt=&#34;wall-span-screenshot-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;七个切片都是从我们的对象池中借来的。让我们通过在控制台中输入以下内容来返还它们：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.clearTestWallSpan();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切片精灵应该会被从舞台上移除并返回到你的对象池中。&lt;/p&gt;

&lt;p&gt;再次生成砖块墙：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.generateTestWallSpan();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会再次看到砖块墙，但这次你看到墙壁上的装饰与上次不同，窗口类型也可能会有所不同，甚至前后边缘的外观也会发生变化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t1/20076/19/11507/48534/5c904d00E4af6178d/7fc329522b49ae99.png&#34; alt=&#34;wall-span-screenshot-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这些差异是由于我们这次借用了不同的墙片造成的。我们之前的切片返回到了每个对象池的数组 &lt;strong&gt;最后面&lt;/strong&gt;，而借用的精灵总是来自我们数组的 &lt;strong&gt;前面&lt;/strong&gt;。这样效果会比较好，因为玩家很难准确预测从池中获取每个切片类型的样子。它会让我们游戏地图的墙块随机出现，这正是我们想要的。&lt;/p&gt;

&lt;h2 id=&#34;给砖块墙添加台阶&#34;&gt;给砖块墙添加台阶&lt;/h2&gt;

&lt;p&gt;希望你能从上面的实现代码中得到成就感。我们能够使用对象池构建完整的砖块墙。现在剩下要做的就是为对象池添加台阶的支持。让我们继续吧。&lt;/p&gt;

&lt;p&gt;返回文本编辑器并确保 &lt;code&gt;WallSpritesPool.js&lt;/code&gt; 已打开。&lt;/p&gt;

&lt;p&gt;添加下面一行到构造函数中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function WallSpritesPool() {
  this.createWindows();
  this.createDecorations();
  this.createFrontEdges();
  this.createBackEdges();
  this.createSteps(); // 添加
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在来实现 &lt;code&gt;createSteps()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.createSteps = function() {
  this.steps = [];
  this.addStepSprites(2, &amp;quot;step_01&amp;quot;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且添加一个 &lt;code&gt;addStepSprites()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.addStepSprites = function(amount, frameId) {
  for (var i = 0; i &amp;lt; amount; i++)
  {
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(frameId));
    sprite.anchor.y = 0.25;
    this.steps.push(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;台阶很少会出现，虽然我们将在精灵池中只使用两个。但说实话，但已经足够了。&lt;/p&gt;

&lt;p&gt;此外，就像后边缘切片类型一样，我们使用了 anchor 属性来改变精灵的锚点。这次我们通过向下移动 64 像素来改变锚点的垂直位置。请记住，使用锚属性的值是比率。每个切片的高度为 256 像素，将锚点的 y 位置向下移动 64 个像素对应的比率为 0.25。&lt;/p&gt;

&lt;p&gt;那么为什么要改变锚属性呢？好吧，当我们最终实际生成游戏地图时，一定范围的所有切片将使用相同的 y 位置以确保正确对齐。但是，台阶切片位图的设计使其成为特例 — 它将无法与砖块墙的其他切片正确对齐。你可以在下图中发现这种情况，其中所有切片（包括台阶）具有相同的 y 位置并且其锚点设置在左上角。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/10525/31/15123/56353/5c905364E8be71317/cf32228b28880ba4.png&#34; alt=&#34;wall-step-anchor-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如你所见，台阶的垂直位置显然是不正确的。但是，通过将其锚点向下移动 64 像素，我们可以强制它在砖块墙内正确展示。下图中就是设置过的，其中每个切片（包括台阶）仍然 &lt;strong&gt;共享&lt;/strong&gt; 相同的 y 位置，但由于其锚点已被移动，步骤切片现在正确地位于砖块墙内。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t1/24325/19/11530/56607/5c905406Ea283c26c/180e08debc8d1226.png&#34; alt=&#34;wall-step-anchor-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在我们需要做的就是提供允许我们从对象池借用并返回一个步骤的方法。添加以下 &lt;code&gt;borrowStep()&lt;/code&gt; 和 &lt;code&gt;returnStep()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WallSpritesPool.prototype.borrowStep = function() {
  return this.steps.shift();
};

WallSpritesPool.prototype.returnStep = function(sprite) {
  this.steps.push(sprite);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将更改保存到文件。对象池类现已完成了。&lt;/p&gt;

&lt;h2 id=&#34;测试砖块墙的台阶&#34;&gt;测试砖块墙的台阶&lt;/h2&gt;

&lt;p&gt;这一节的教程即将完成。让我们通过生成包含台阶的测试砖块墙来结束它。&lt;/p&gt;

&lt;p&gt;打开 Main.js 并删除 &lt;code&gt;generateTestWallSpan()&lt;/code&gt; 方法中的代码。将其替换为以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.generateTestWallSpan = function() {
  var lookupTable = [
    this.pool.borrowFrontEdge,  // 1st slice
    this.pool.borrowWindow,     // 2nd slice
    this.pool.borrowDecoration, // 3rd slice
    this.pool.borrowStep,       // 4th slice
    this.pool.borrowWindow,     // 5th slice
    this.pool.borrowBackEdge    // 6th slice
  ];

  var yPos = [
    128, // 1st slice
    128, // 2nd slice
    128, // 3rd slice
    192, // 4th slice
    192, // 5th slice
    192  // 6th slice
  ];

  for (var i = 0; i &amp;lt; lookupTable.length; i++)
  {
    var func = lookupTable[i];

    var sprite = func.call(this.pool);
    sprite.position.x = 64 + (i * 64);
    sprite.position.y = yPos[i];

    this.wallSlices.push(sprite);

    this.stage.addChild(sprite);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;generateTestWallSpan()&lt;/code&gt; 几乎与前一版相同。这次墙只有六个切片宽，我们还添加了第二个名为 &lt;code&gt;yPos&lt;/code&gt; 的数组。&lt;/p&gt;

&lt;p&gt;如果查看这张表，你将发现第 4 个索引表示台阶切片。请记住，该步骤可让玩家直接跌落到正下方的墙面上。如果你回想一下教程的开头，你应该记住，当我们处理一个步骤时，我们实际处理的是两个连接在一起的独立砖块墙。第一个砖块墙将高于第二个，台阶切片本身将属于第二个砖块墙。&lt;/p&gt;

&lt;p&gt;两个砖块墙之间的高度差异由我们的 yPos 数组处理。它对于我们的每个切片都有一个 y 位置。前三个切片 y 都是 128 个像素，而剩余的切片是 192个像素。&lt;/p&gt;

&lt;p&gt;让我们转到我们的 &lt;code&gt;clearTestWallSpan()&lt;/code&gt; 方法。从现有版本的方法中删除代码，并将其替换为以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.clearTestWallSpan = function() {
  var lookupTable = [
    this.pool.returnFrontEdge,  // 1st slice
    this.pool.returnWindow,     // 2nd slice
    this.pool.returnDecoration, // 3rd slice
    this.pool.returnStep,       // 4th slice
    this.pool.returnWindow,     // 5th slice
    this.pool.returnBackEdge    // 6th slice
  ];

  for (var i = 0; i &amp;lt; lookupTable.length; i++)
  {
    var func = lookupTable[i];
    var sprite = this.wallSlices[i];

    this.stage.removeChild(sprite);
    func.call(this.pool, sprite);
  }

  this.wallSlices = [];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如你所见，表中包含对将每个切片返还到对象池所需的所有方法的引用，包括台阶。&lt;/p&gt;

&lt;p&gt;保存更改并刷新浏览器。&lt;/p&gt;

&lt;p&gt;在 JavaScript 控制台中输入以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.generateTestWallSpan();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你应该会在屏幕上看到一个带有台阶的墙。它应该看起来像这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/24246/9/11462/69686/5c905719E86dbd531/38dfad19122dfe1f.png&#34; alt=&#34;wall-step-screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再返还整个砖块墙给对象池：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.clearTestWallSpan();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多试几次生成砖块墙然后返还到对象池，确保一切都正常。&lt;/p&gt;

&lt;h2 id=&#34;整理代码&#34;&gt;整理代码&lt;/h2&gt;

&lt;p&gt;我们不断地测试对象池，现在它已经成型。为了准备本系列的最后一个教程，我们现在从 Main 类中删除测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.spriteSheetLoaded = function() {
  this.scroller = new Scroller(this.stage);
  requestAnimationFrame(this.update.bind(this));

  this.pool = new WallSpritesPool();
  this.wallSlices = [];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还要完全删除 &lt;code&gt;generateTestWallSpan()&lt;/code&gt; 和 &lt;code&gt;clearTestWallSpan()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;现在保存你的更改。&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;感谢你能坚持到这里。本教程已经涉及到了大量的内容。我们已经讨论了滚动游戏地图的各种技术点，并了解了为什么选择使用对象池。&lt;/p&gt;

&lt;p&gt;虽然本教程很长，但对象池的概念实际上相当简单。不过有人可能会很容易陷入到一些实现细节中，但记住最重要的一点对象池只一个非常简单的 API：有一组从池中借用精灵，另一组返还这些精灵。&lt;/p&gt;

&lt;p&gt;我们还学到了更多关于 pixi.js 的知识，包括精灵表和 PIXI.Sprite 类的其它功能。此外，我们也介绍了 GPU 加速的好处，以及为什么使用精灵表可以带来巨大的性能提升。&lt;/p&gt;

&lt;p&gt;虽然我们还没有真正地开始构建滚动游戏地图，但我们已经编写了一些代码来生成一些测试砖块墙。这应该有助于你了解如何使用对象池，也可以帮助你熟悉砖块墙的结构和游戏地图。&lt;/p&gt;

&lt;h2 id=&#34;下期预告&#34;&gt;下期预告&lt;/h2&gt;

&lt;p&gt;下一节中我们将真正的添加流动游戏中的第三层。和前两层不一样，第三层将组成整个游戏地图所需要的砖块墙。这些切片都将从我们的对象池中借取。&lt;/p&gt;

&lt;p&gt;与往常一样，GitHub上提供了本系列和之前教程的 &lt;a href=&#34;https://github.com/ccaleb/pixi-parallax-scroller&#34;&gt;源代码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;很快你将开始教程的的 第四部分，也是最后一部分。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Pixi.js 构建一个视差滚动器（第二篇）</title>
      <link>https://keelii.com/2019/03/17/building-a-parallax-scroller-with-pixijs-cn-2/</link>
      <pubDate>Sun, 17 Mar 2019 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2019/03/17/building-a-parallax-scroller-with-pixijs-cn-2/</guid>
      <description>

&lt;h2 id=&#34;翻译对照&#34;&gt;翻译对照&lt;/h2&gt;

&lt;p&gt;原文：
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5226&#34;&gt;PART 1&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5666&#34;&gt;PART 2&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=6496&#34;&gt;PART 3&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=7046&#34;&gt;PART 4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译文：
&lt;a href=&#34;https://keelii.com/2019/03/16/building-a-parallax-scroller-with-pixijs-cn-1/&#34;&gt;第一篇&lt;/a&gt;・
&lt;a href=&#34;https://keelii.com/2019/03/17/building-a-parallax-scroller-with-pixijs-cn-2/&#34;&gt;第二篇&lt;/a&gt;・
&lt;a href=&#34;https://keelii.com/2019/03/19/building-a-parallax-scroller-with-pixijs-cn-3/&#34;&gt;第三篇&lt;/a&gt;・
第四篇&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;关注 &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=chriscaleb&#34;&gt;@chriscaleb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个系列的教程已经更新到了 &lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PixiJS v4&lt;/a&gt; 版本。&lt;/p&gt;

&lt;p&gt;在这个系列教程中我们将探索如何构建一个类似 &lt;a href=&#34;http://www.adamatomic.com/canabalt/&#34;&gt;Canabalt&lt;/a&gt; 和 &lt;a href=&#34;https://chrome.google.com/webstore/detail/monster-dash/cknghehebaconkajgiobncfleofebcog?hl=en&#34;&gt;Monster Dash&lt;/a&gt; 的视差滚动地图游戏界面。第一篇介绍了 pixi.js 的渲染引擎并且涉及到了视差滚动的基础知识。现在我们将在上一篇的基础之上添加 &lt;strong&gt;视口&lt;/strong&gt; 的概念。&lt;/p&gt;

&lt;h3 id=&#34;你将学到什么&#34;&gt;你将学到什么…&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如何扩展 pixi.js 的 &lt;strong&gt;展示对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;JavaScript 中的面向对象基础（译者使用 ES 6 Class 重构了这个游戏 &lt;a href=&#34;https://github.com/keelii/parallax-scroller-cn&#34;&gt;源代码&lt;/a&gt;，看起来更直观）&lt;/li&gt;
&lt;li&gt;如何在你的滚动器中添加 &lt;strong&gt;视口&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;预备知识&#34;&gt;预备知识…&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;对面向对象有基本的概念&lt;/li&gt;
&lt;li&gt;pixi.js 基础&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你将以第一篇教程中的代码为基础，或者直接下载上篇教程中的 &lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5226&#34;&gt;源代码&lt;/a&gt;，另外整个教程的完全源代码也在 &lt;a href=&#34;https://github.com/ccaleb/pixi-parallax-scroller/tree/master/tutorial-2&#34;&gt;github&lt;/a&gt; 上可以找到。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yeahbutisitflash.com/pixi-parallax-scroller/tutorial-1/index.html&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/25206/13/10616/142679/5c887df7E7c1fa38a/eab39f5f7ab1cc6d.png&#34; alt=&#34;ps-tut1-screenshot1&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作为提示，点击上面的图片，将会加载当前版本的视差滚动，目前来说只有两个层，我们将添加每三个更复杂的层。与此同时，我们将通过添加视口的概念来添加第三层。我们还会执行一些重要代码重构，以便将滚动器封装在类中。&lt;/p&gt;

&lt;p&gt;虽然本教程非常针对那些对面向对象有基础概念的初学者级别，如这些概念让你感到不舒服，也不用担心，因为我仍然会为那些不熟悉这些枞的的人提供足够的指导。&lt;/p&gt;

&lt;h2 id=&#34;起步&#34;&gt;起步&lt;/h2&gt;

&lt;p&gt;如果你还没有看过第一篇教程，我建议你应该从那篇开始。&lt;/p&gt;

&lt;p&gt;还有一点值得提醒的是，为了能够测试你的代码，你需要开启一个本地的 web 服务器。如果你还没有做这一步，那么可能参考上一篇教程中的章节建立好自己的 web 服务器。&lt;/p&gt;

&lt;h2 id=&#34;扩展-pixi-js-的-展示对象&#34;&gt;扩展 pixi.js 的 &lt;strong&gt;展示对象&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;正如我们之前发现的，pixi.js 提供了几种可使用的 &lt;strong&gt;展示对象&lt;/strong&gt; 类型。如果你还记得的话，我们在使用 &lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt; 来满足我们的需求之前，先简单地使用了 &lt;code&gt;PIXI.Sprite&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这两个类共享许多公用的功能。例如，它们都为你提供位置（position），宽度（width），高度（height）和 alpha 属性。此外，两者都可以通过 &lt;code&gt;addChild()&lt;/code&gt; 方法添加到容器中。事实上，&lt;code&gt;PIXI.Container&lt;/code&gt; 类本身就是一个 &lt;strong&gt;展示对象&lt;/strong&gt;，它还提供了许多 Sprite 和 TilingSprite 类都能使用的属性。&lt;/p&gt;

&lt;p&gt;所有这些公用的功能都来自于 &lt;strong&gt;继承（inheritance）&lt;/strong&gt; 的魔力。它使得类可以继承和扩展功能到其它类上。为了让你能理解它，可以参考下面的示意图，它将为你展示 pixi.js 中提供的大多数展示对象&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/32241/35/6163/21482/5c8c93a6E0674998d/e778a3262a7f0f86.png&#34; alt=&#34;ps-tut2-screenshot1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从上面的示意图中，我们可以看出最基础的类型是 PIXI.DisplayObject 类，所有其它类都从它继承而来。这个类是将对象呈现到屏幕所必须需的元素。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当我说 &lt;strong&gt;展示对象&lt;/strong&gt; 时，并非指 &lt;code&gt;PIXI.DisplayObject&lt;/code&gt; 这个类。而当使用 &lt;code&gt;PIXI.DisplayObject&lt;/code&gt; 这个说法时，却表示所有继承自它的对象。本质上讲，当我使用 &lt;strong&gt;展示对象&lt;/strong&gt; 这一术语时，我指的是可以通过 pixi.js 呈现给屏幕的 &lt;strong&gt;任何对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下一层是 &lt;code&gt;PIXI.Container&lt;/code&gt;，它允许对象充当其他展示对象的 &lt;strong&gt;容器&lt;/strong&gt;。我们在第一个教程中使用的 &lt;code&gt;addChild()&lt;/code&gt; 方法是 &lt;code&gt;PIXI.Container&lt;/code&gt; 这个类提供的实例方法，也可以通过 &lt;code&gt;PIXI.Sprite&lt;/code&gt; 和 &lt;code&gt;PIXI.TilingSpite&lt;/code&gt; 继承获得。&lt;/p&gt;

&lt;p&gt;本质上讲，继承树中的每个类都是它继承的（父）类的 &lt;strong&gt;更特殊&lt;/strong&gt; 版本（译者：面向对象的 &lt;strong&gt;具体化&lt;/strong&gt; 与 &lt;strong&gt;泛化&lt;/strong&gt; 概念）。好的一点是我们可以使用继承来创建我们自己的自定义的展示对象。换而言之，我们可以为每个视差滚动器中的元素编写专用的类，并让 pixi.js 处理它们就像是处理其它展示对象一样。这给使我们封装代码更简单，代码也更多漂亮、整洁。&lt;/p&gt;

&lt;h3 id=&#34;制作远景层展示对象&#34;&gt;制作远景层展示对象&lt;/h3&gt;

&lt;p&gt;让我们开始制作远景层吧。&lt;/p&gt;

&lt;p&gt;打开index.html文件，在 &lt;code&gt;init()&lt;/code&gt; 函数中查找创建和设置图层的代码。这是你要找的东西：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);	
far = new PIXI.extras.TilingSprite(farTexture, 512, 256);
far.position.x = 0;
far.position.y = 0;
far.tilePosition.x = 0;
far.tilePosition.y = 0;
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理想的情况是，我们可以创建一个代表远景层的类，并把大部分实现细节隐藏在类中。因此，我们希望找到以下代码，而不是上面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new Far();
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码量大幅减少了吧？另外，我认为它比我们原来的尝试更具可读性。&lt;/p&gt;

&lt;p&gt;我们通过创建一个代表我们的滚动条远景层的名为 Far 的类来实现这一目标。在项目的根文件夹中创建一个新文件，并将其命名为 &lt;code&gt;Far.js&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;现在定义一个名为 Far 的函数，它将表示我们类的构造函数：&lt;/p&gt;

&lt;p&gt;（译者：原作者使用了 ES 5 和 prototype 来实现 JavaScript 中的继承，看起来可能没那么直观，可以参考我自己实现的 &lt;a href=&#34;https://github.com/keelii/parallax-scroller-cn&#34;&gt;ES 6 版&lt;/a&gt;的代码）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far(texture, width, height) {
  PIXI.extras.TilingSprite.call(this, texture, width, height);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在构造函数下面添加以下行，然后保存文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码继承了 &lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt; 类的功能。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;构造函数是一种特殊类型的函数，用于创建类实例。在 JavaScript 中，构造函数的名称也用于指定类的名称（译者：ES 6 中的类有专门的 construct 方法）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么为什么 Far 类继承自 &lt;code&gt;PIXI.TilingSprite&lt;/code&gt; 呢？好吧，如果你还记得第一个教程，我们使用 &lt;code&gt;TilingSprite&lt;/code&gt; 实例来表示每个视差层。因此，在更具体化的类中使用这些功能是有必要的。本质上讲，我们所说的是：Far 类是 &lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt; 的一个更特殊的版本。&lt;/p&gt;

&lt;p&gt;因为 Far 类继承自 &lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt;，所以我们要记得去初始化&lt;code&gt;TilingSprite&lt;/code&gt; 类的功能。这是通过从构造函数中调用 &lt;code&gt;TilingSprite&lt;/code&gt; 的构造函数来完成的。我高亮显示了以下代码行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far(texture, width, height) {
  PIXI.extras.TilingSprite.call(this, texture, width, height); // 这一行
}

Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做是因为我们希望 Far 类继承 &lt;code&gt;TilingSprite&lt;/code&gt; 的所有功能。由于 &lt;code&gt;TilingSprite&lt;/code&gt; 需要将三个参数传递给它的构造函数，我们需要确保我们自己的类也接受这些参数并使用它们初始化瓦片精灵。以下是高亮显示参数的类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 注意 texture, width, height 三个参数
function Far(texture, width, height) {
  PIXI.extras.TilingSprite.call(this, texture, width, height);
}

Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还有一些额外的功能可以添加 Far 类中，但实际上已经可以开始将它集成到 &lt;code&gt;index.html&lt;/code&gt; 页面中了。&lt;/p&gt;

&lt;h3 id=&#34;实例化你的远景-far-层类&#34;&gt;实例化你的远景（Far）层类&lt;/h3&gt;

&lt;p&gt;返回你的 &lt;code&gt;index.html&lt;/code&gt; 页面。&lt;/p&gt;

&lt;p&gt;要使用 Far 类，你需要引用它的源文件。在页面正文顶部附近添加以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body onload=&amp;quot;init();&amp;quot;&amp;gt;
  &amp;lt;div align=&amp;quot;center&amp;quot;&amp;gt;
    &amp;lt;canvas id=&amp;quot;game-canvas&amp;quot; width=&amp;quot;512&amp;quot; height=&amp;quot;384&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script src=&amp;quot;Far.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;!--这里--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在向下滚动并删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
far = new PIXI.extras.TilingSprite(farTexture, 512, 256);  // 删除此行
far.position.x = 0;
far.position.y = 0;
far.tilePosition.x = 0;
far.tilePosition.y = 0;
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
far = new Far(farTexture, 512, 256);  // 新行
far.position.x = 0;
far.position.y = 0;
far.tilePosition.x = 0;
far.tilePosition.y = 0;
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好吧，我承认。目前这似乎并没有太大的改进，但我们现在可以开始在 Far 类中直接隐藏更多代码，让我们继续吧。&lt;/p&gt;

&lt;h3 id=&#34;封装位置相关代码&#34;&gt;封装位置相关代码&lt;/h3&gt;

&lt;p&gt;在 &lt;code&gt;index.html&lt;/code&gt; 中，我们当前设置了 far 层的 &lt;code&gt;position&lt;/code&gt; 和 &lt;code&gt;tilePosition&lt;/code&gt; 属性。让我们删除它，并将其封装在我们的 Far 类中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
far = new Far(farTexture, 512, 256);
far.position.x = 0;  // 删除
far.position.y = 0;  // 删除
far.tilePosition.x = 0;  // 删除
far.tilePosition.y = 0;  // 删除
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存更改并打开 Far.js 文件。现在直接在类的构造函数中设置图层的位置和tilePosition 属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far(texture, width, height) {
  PIXI.extras.TilingSprite.call(this, texture, width, height);
	
  this.position.x = 0;
  this.position.y = 0;
  this.tilePosition.x = 0;
  this.tilePosition.y = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不熟悉面向对象的 JavaScript 或面向对象编程，那么你可能会好奇 &lt;code&gt;this&lt;/code&gt; 关键字在上面的代码中的用途是什么。基本上可以这么理解，它可以让你引用类的已创建实例。通过 &lt;code&gt;this&lt;/code&gt;，我们可以引用该实例的所有 &lt;strong&gt;属性&lt;/strong&gt; 和 &lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;因为 Far 类继承自 &lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt;，它还具有 &lt;code&gt;TilingSprite&lt;/code&gt; 的所有 &lt;strong&gt;属性&lt;/strong&gt; 和 &lt;strong&gt;方法&lt;/strong&gt;，包括 &lt;code&gt;position&lt;/code&gt; 和 &lt;code&gt;tilePosition&lt;/code&gt;。要访问这些属性，我们只需使用&lt;code&gt;this&lt;/code&gt; 关键字。这是再次设置图层 x 位置的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.position.x = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还应注意，&lt;code&gt;this&lt;/code&gt; 关键字还用于引用新添加到类中的属性或方法。&lt;/p&gt;

&lt;p&gt;现在保存更改并在浏览器中测试代码。一切都应按预期运行。另外，请查看 Chrome 的 JavaScript 控制台，确保没有错误。&lt;/p&gt;

&lt;h3 id=&#34;封装层的纹理&#34;&gt;封装层的纹理&lt;/h3&gt;

&lt;p&gt;好的，我们应该从哪里开始呢。如果你回顾一下 index.html 页面，你应该看到代码好像开始变得更加简洁了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);	
far = new Far(farTexture, 512, 256);
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但仍有改进的余地。毕竟，如果我们可以直接在 Far 类中隐藏我们的定位代码，那么为什么我们不能把纹理的逻辑也放在 Far 类中呢？&lt;/p&gt;

&lt;p&gt;切换到 &lt;code&gt;Far.js&lt;/code&gt; 文件并在构造函数的开头添加一行以创建图层的纹理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far(texture, width, height) {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;); // 添加
  PIXI.extras.TilingSprite.call(this, texture, width, height);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在显式地将纹理的宽度和高度传递给 &lt;code&gt;TilingSprite&lt;/code&gt; 的构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far(texture, width, height) {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
  PIXI.extras.TilingSprite.call(this, texture, 512, 256); // 512, 256
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们现在直接在类中处理纹理，因此实际上不需要将纹理，宽度和高度参数传递给构造函数。删除所有三个参数并保存你的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far(texture, width, height) { // 删除 texture, width, height
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你的构造函数现在应该是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far() {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
  PIXI.extras.TilingSprite.call(this, texture, 512, 256);

  this.position.x = 0;
  this.position.y = 0;
  this.tilePosition.x = 0;
  this.tilePosition.y = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;剩下要做的就是返回到你的 index.html 文件并删除我们之前创建的纹理并传递给 far的构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
far = new Far(farTexture, 512, 256);
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new Far();
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比以前简洁了，对吧？我们所有层的丑陋实现细节现在都安全地隐藏在 Far 类中。&lt;/p&gt;

&lt;p&gt;保存 index.html 和 Far.js ，然后在 Chrome 中测试最新版本的代码。&lt;/p&gt;

&lt;h3 id=&#34;同样的方法重构中间层&#34;&gt;同样的方法重构中间层&lt;/h3&gt;

&lt;p&gt;我花了一些时间引导你完成创建 Far类所需的步骤。该类继承自&lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt;，其行为与任何其他 pixi.js 展示对象相同。虽然我们尚未完成，但我们将暂时停止一下并应用我们学到的知识来创建一个代表视差滚动器中的中间层（Mid）的类。&lt;/p&gt;

&lt;p&gt;创建一个名为 &lt;code&gt;Mid.js&lt;/code&gt; 的新文件，并开始向其添加以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mid() {
}

Mid.prototype = Object.create(PIXI.extras.TilingSprite.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样在构造函数中，创建中间层的纹理并设置其定位属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mid() {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;);
  PIXI.extras.TilingSprite.call(this, texture, 512, 256);

  this.position.x = 0;
  this.position.y = 128;
  this.tilePosition.x = 0;
  this.tilePosition.y = 0;
}

Mid.prototype = Object.create(PIXI.extras.TilingSprite.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存 Mid.js 文件，然后转到 index.html 并引用 Mid 类的源文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Far.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Mid.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!--添加--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成后，向下滚动到 &lt;code&gt;init()&lt;/code&gt; 函数并删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new Far();
stage.addChild(far);

var midTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;); // 删除
mid = new PIXI.extras.TilingSprite(midTexture, 512, 256);// 删除
mid.position.x = 0;// 删除
mid.position.y = 128;// 删除
mid.tilePosition.x = 0;// 删除
mid.tilePosition.y = 0;// 删除
stage.addChild(mid);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用这一行代码替换它们：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new Far();
stage.addChild(far);

mid = new Mid(); // 此行
stage.addChild(mid);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存 Mid.js 文件并在浏览器中测试最新版本。像往常一样，在运行时检查是否有 JavaScript 错误，并确保滚动器仍然按预期执行。&lt;/p&gt;

&lt;h3 id=&#34;实现一个-update-方法&#34;&gt;实现一个 update() 方法&lt;/h3&gt;

&lt;p&gt;我们已经对代码库进行了大量的重构，但仍然有一些事情可以做。返回 index.html 文件，查看动画主更新逻辑。它应该如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.tilePosition.x -= 0.128;
  mid.tilePosition.x -= 0.64;

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;update 方法中的前两行通过更新其 tilePosition 属性来滚动我们的图层。但是，我们的代码目前存在一些问题：通过直接更改 &lt;code&gt;tilePosition&lt;/code&gt; 属性，我们将暴露 Mid 和 Far 类的内部 &lt;strong&gt;实现&lt;/strong&gt;（译者：类的外部不应该知道类的具体实现细节，只需要控制类的行为）。这违背了面向对象的封装原则。&lt;/p&gt;

&lt;p&gt;理想情况下，我们希望在类中隐藏具体细节。如果两个类只有一个实际为我们执行滚动的 &lt;code&gt;update()&lt;/code&gt; 方法，那么我们的代码会更易读。换句话说，对于我们的主循环来说，这样似乎更合适：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.update();
  mid.update();

  renderer.render(stage);

  requestAnimFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得庆幸的是，这样的改变是微不足道的。我们将向 Far 类和 Mid 类添加一个 &lt;code&gt;update()&lt;/code&gt; 方法，每个类都会一点点的滚动。&lt;/p&gt;

&lt;p&gt;从 Far 类开始，打开 Far.js 并向其添加以下方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);

Far.prototype.update = function() {
  this.tilePosition.x -= 0.128;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法（update）的主体应该看起来很熟悉。它只是将纹理的平铺位置移动 0.128 像素，这正是我们在 index.html 的主循环中所做的。&lt;/p&gt;

&lt;p&gt;好的，保存更改并向Mid.js添加类似的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Mid.prototype = Object.create(PIXI.extras.TilingSprite.prototype);

Mid.prototype.update = function() {
  this.tilePosition.x -= 0.64;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两个方法的唯一区别是 Mid 类中的 &lt;code&gt;update()&lt;/code&gt; 方法的滚动量更多。&lt;/p&gt;

&lt;p&gt;保存更改并返回 index.html。现在我们需要做的就是从主循环中调用每个层的 &lt;code&gt;update()&lt;/code&gt; 方法。删除以下两行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.tilePosition.x -= 0.128; // 删除
  mid.tilePosition.x -= 0.64; // 删除

  renderer.render(stage);

  requestAnimFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.update();
  mid.update();

  renderer.render(stage);

  requestAnimFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存更改并测试，保证 Chrome 中按预期正常运行。&lt;/p&gt;

&lt;h3 id=&#34;停下来思考一下&#34;&gt;停下来思考一下&lt;/h3&gt;

&lt;p&gt;虽然视差滚动器和以前一样表现正常，但我们实际上已对代码的整体架构进行了一些重大的更改。我们采用了更加面向对象的设计，利用继承创建了两个代表视差层的特殊展示对象。&lt;/p&gt;

&lt;p&gt;能够编写特殊的展示对象是一个强大的概念，在许多情况下都能派上用场。我们的 Far 类和 Mid 类都像 pixi.js 支持的任何其他展示对象一样。下图说明了我们的两个特殊类位于 Pixi 展示对象类的继承结构中的位置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/27384/39/11126/25797/5c8ca6b2E6fabfee4/0d138469e63570ba.png&#34; alt=&#34;ps-tut2-screenshot2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在继续之前，看看你的代码文件并确保我们迄今为止所做的一切都有意义。实际上并没有很多代码，但如果你是面向对象编程的新手，那么完全消化代码所表示的知识可能需要一些时间。&lt;/p&gt;

&lt;h2 id=&#34;建立滚动器-scroller-类&#34;&gt;建立滚动器（Scroller）类&lt;/h2&gt;

&lt;p&gt;本教程开头概述的目标之一是将我们的视差滚动器包装到一个类中。现在我们已经编写了 Far 类和 Mid 类，现在我们写一个滚动器类。&lt;/p&gt;

&lt;p&gt;这样的话我们就能够从 index.html 中删除 Mid 和 Far &lt;strong&gt;实例&lt;/strong&gt;，将它们封装在一个单独的对象中，以满足我们所有的滚动类需要实现的需求。&lt;/p&gt;

&lt;p&gt;让我们写一个能够实现我们想法的类。创建一个名为 Scroller.js 的新 JavaScript 文件，并通过向其添加以下代码来定义名为 Scroller 的类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Scroller(stage) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于这个类，有两点值得注意。首先，它的构造函数需要引用我们的舞台（Pixi.Container）。其次，它不会继承任何东西。&lt;/p&gt;

&lt;p&gt;与 Far 和 Mid 类不同，我们的 Scroller 类不是特殊的展示对象。相反，它将使用构造函数的 stage 参数添加我们的 远景层和中间层实例。（译者：Scroller 类只起到封装和控制作用，并不用继承任何 Pixi 中的类）&lt;/p&gt;

&lt;p&gt;让我们先在类中添加远景层的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Scroller(stage) {
  this.far = new Far();
  stage.addChild(this.far);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行代码创建了 Far 类的实例。请注意，我们将实例存储在名为 &lt;code&gt;far&lt;/code&gt; 的 &lt;code&gt;成员变量&lt;/code&gt; 中。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;成员变量&lt;/strong&gt; 是通过 this 关键字直接向类添加 &lt;strong&gt;属性&lt;/strong&gt; 来创建的。成员变量具有在类实例的整个生命周期中持久化可见的优点，这意味着类的任何其他方法也可以访问它。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第二行将远景层实例添加到舞台。&lt;/p&gt;

&lt;p&gt;现在让我们为中间层做同样的事情。将以下两行添加到构造函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Scroller(stage) {
  this.far = new Far();
  stage.addChild(this.far);

  this.mid = new Mid();
  stage.addChild(this.mid);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在 Scroller 类中有两个成员变量：&lt;code&gt;far&lt;/code&gt; 和 &lt;code&gt;mid&lt;/code&gt;。这是很有用，因为它允许我们从类中的任何其他方法中访问我们的视差层。这也很方便，因为我们确实需要添加一个额外的方法。它将用于更新两个层的位置。我们现在继续添加此方法（update）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Scroller(stage) {
  this.far = new Far();
  stage.addChild(this.far);

  this.mid = new Mid();
  stage.addChild(this.mid);
}

Scroller.prototype.update = function() {
  this.far.update();
  this.mid.update();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还记得我们为 Mid 和 Far 类编写了 &lt;code&gt;update()&lt;/code&gt; 方法吗？在我们的 Scroller 类自己的 &lt;code&gt;update()&lt;/code&gt; 方法需要做的就是调用这些更新方法。&lt;/p&gt;

&lt;h3 id=&#34;插入-scroller-类&#34;&gt;插入 Scroller 类&lt;/h3&gt;

&lt;p&gt;现在 Scroller 类可以表示我们的视差滚动器了，我们可以回到 index.html 页面并将其插入。&lt;/p&gt;

&lt;p&gt;打开 index.html 并引用 Scroller.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Far.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Mid.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Scroller.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在向下移动到 &lt;code&gt;init()&lt;/code&gt; 函数并删除以下代码行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {
  stage = new PIXI.Stage(0x66FF99);
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  far = new Far(); // 删除
  stage.addChild(far); // 删除

  mid = new Mid(); // 删除
  stage.addChild(mid); // 删除

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请记住，远景层和中间层现在都由 Scroller 类处理。因此，我们需要创建一个Scroller 实例来替换我们刚删除的行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {
  stage = new PIXI.Stage(0x66FF99);
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  scroller = new Scroller(stage); // 实例化 Scroller

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另请注意，我们将 stage 引用传递给 Scroller 类的构造函数。这样做非常重要，因为 Scroller 类需要这个引用才能将 远景层和中间层添加到 &lt;strong&gt;展示列表&lt;/strong&gt; 中。&lt;/p&gt;

&lt;p&gt;现在需要做的就是在主循环中调用 scroller 的 &lt;code&gt;update()&lt;/code&gt; 方法。首先，从主循环中删除以下两行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.update(); // 删除
  mid.update(); // 删除

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在添加以下行来更新滚动器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  scroller.update(); // 添加

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存更改并使用 Chrome 测试所有内容。一如既往地在 JavaScript 控制台中查找是否有错误，如果有，请仔细检查你的代码。&lt;/p&gt;

&lt;p&gt;我们已经成功地重新构建了视差滚动，以便所有内容都包含在一个类中。如果你查看 index.html，你会发现我们已经隐藏了我们上次在第一篇教程中写的所有实现代码。&lt;/p&gt;

&lt;h2 id=&#34;添加视口-viewport&#34;&gt;添加视口（viewport）&lt;/h2&gt;

&lt;p&gt;我们已经取得了巨大的进步，但还有一件事我们做。为了使我们的滚动条完整，需要添加 &lt;strong&gt;视口&lt;/strong&gt; 的概念。将视口视为一个查看游戏地图的窗口。&lt;/p&gt;

&lt;p&gt;你可能会问「我们不是已经有一个视口了吗？」是的，毕竟，当你在浏览器中运行代码时，我们只能看到在舞台边界内可以看到的内容。这是似乎就是一个视口了，但是我们还没有办法知道我们在游戏世界中 &lt;strong&gt;滚动了多远&lt;/strong&gt;（译者：需要实现视口是因为后续会涉及到地图的概念，地图中游戏场景是有长度、距离的概念的，这就方便我们实现一些特殊场景，比如落箱子，障碍物等。因为不引用视口的概念游戏将是无限循环滚动的。这会导致计算距离变得很复杂，而且无法将地图设计成一种具体的抽象）。另外，如果我们可以简单地跳到某个位置并确切地看到我们的图层应该如何看起来，那不是很好吗？一旦我们添加了视口的概念并提供了设置其当前位置的方法，那么一切都将成为可能。&lt;/p&gt;

&lt;h3 id=&#34;给-scroller-类添加-setviewportx-方法&#34;&gt;给 Scroller 类添加 setViewportX 方法&lt;/h3&gt;

&lt;p&gt;目前我们有一个 &lt;code&gt;update()&lt;/code&gt; 方法，我们用它来连续滚动我们的视差层。可以使用一个名为 &lt;code&gt;setViewportX()&lt;/code&gt; 的新方法替换它，我们可以用它来设置视口的水平位置。调用此方法将让我们随意定位我们的游戏地图。&lt;/p&gt;

&lt;p&gt;让我们从 Scroller 类开始。&lt;/p&gt;

&lt;p&gt;打开 Scroller.js 并删除现有的 &lt;code&gt;update()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Scroller(stage) {
  this.far = new Far();
  stage.addChild(this.far);

  this.mid = new Mid();
  stage.addChild(this.mid);
}

Scroller.prototype.update = function() { // 删除
  this.far.update();// 删除
  this.mid.update();// 删除
};// 删除
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们的 &lt;code&gt;setViewportX()&lt;/code&gt; 方法非常简单。它期望将一个数字作为方法的 viewportX 参数传递，然后将该值传递给我们的每个层。显然，我们的图层都需要实现自己的 &lt;code&gt;setViewportX()&lt;/code&gt; 方法。让我们继续吧，现在就去做吧。&lt;/p&gt;

&lt;h3 id=&#34;给-far-类添加-setviewportx-方法&#34;&gt;给 Far 类添加 setViewportX 方法&lt;/h3&gt;

&lt;p&gt;我们首先删除类中的现有 &lt;code&gt;update()&lt;/code&gt; 方法。打开 Far.js 并删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far() {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
  PIXI.extras.TilingSprite.call(this, texture, 512, 256);

  this.position.x = 0;
  this.position.y = 0;
  this.tilePosition.x = 0;
  this.tilePosition.y = 0;
}

Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);

Far.prototype.update = function() { // 删除
  this.tilePosition.x -= 0.128; // 删除
}; // 删除
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要能够跟踪视口的水平位置。为此，我们在类的构造函数中定义新的成员变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far() {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
  PIXI.extras.TilingSprite.call(this, texture, 512, 256);

  this.position.x = 0;
  this.position.y = 0;
  this.tilePosition.x = 0;
  this.tilePosition.y = 0;

  this.viewportX = 0; // 新的成员变量
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再添加一个类的 &lt;strong&gt;静态常量&lt;/strong&gt;（&lt;code&gt;DELTA_X&lt;/code&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);

Far.DELTA_X = 0.128;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DELTA_X 常量的值看起来应该很熟悉。它是我们之前在每次调用 &lt;code&gt;update()&lt;/code&gt; 时移动图层的 tilePosition 的像素数。显然，使用常量会使我们的代码更具可读性和可维护性，这就是我们选择使用常量的原因。基本上，每当我们的视口移动一个单元时，我们将使用常量将远景层移动 0.128 像素。所以现在让我们编写一个 &lt;code&gt;setViewportX()&lt;/code&gt; 方法，添加以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);

Far.DELTA_X = 0.128;

Far.prototype.setViewportX = function(newViewportX) {
  var distanceTravelled = newViewportX - this.viewportX;
  this.viewportX = newViewportX;
  this.tilePosition.x -= (distanceTravelled * Far.DELTA_X);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码并不难理解。首先，我们计算自从上次调用 &lt;code&gt;setViewportX()&lt;/code&gt; 以来的滚动的距离。然后视口的新水平位置存储在我们的 &lt;code&gt;viewportX&lt;/code&gt; 成员变量中。最后，我们乘以 DELTA_X 常数，以确定将图层的瓦片移动了多远。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;应该注意，我们的 x 位置代表视口窗口的左侧。在其他实现中，x 位置代表视口的中心也很常见。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;保存最新版本的 &lt;code&gt;Far.js&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;现在我们需要对 &lt;code&gt;Mid&lt;/code&gt; 类进行相同的更改。&lt;/p&gt;

&lt;h3 id=&#34;给-mid-类添加-setviewportx-方法&#34;&gt;给 Mid 类添加 setViewportX 方法&lt;/h3&gt;

&lt;p&gt;Mid 类的代码几乎与 Far 类相同，所以我们能快速写出来。&lt;/p&gt;

&lt;p&gt;打开 Mid.js 并删除其 &lt;code&gt;update()&lt;/code&gt; 方法、并添加 &lt;code&gt;setViewportX&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mid() {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;);
  PIXI.extras.TilingSprite.call(this, texture, 512, 256);

  this.position.x = 0;
  this.position.y = 128;
  this.tilePosition.x = 0;
  this.tilePosition.y = 0;

  this.viewportX = 0;
}

Mid.prototype = Object.create(PIXI.extras.TilingSprite.prototype);

Mid.DELTA_X = 0.64;

Mid.prototype.setViewportX = function(newViewportX) {
  var distanceTravelled = newViewportX - this.viewportX;
  this.viewportX = newViewportX;
  this.tilePosition.x -= (distanceTravelled * Mid.DELTA_X);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个类之间的唯一区别是 Mid 类的 DELTA_X 常量值为 &lt;code&gt;0.64&lt;/code&gt;，这是为了确保图层的滚动速度比 far 层快。保存更改。&lt;/p&gt;

&lt;h3 id=&#34;测试视口&#34;&gt;测试视口&lt;/h3&gt;

&lt;p&gt;我们应该测试视口并确保设置其位置反映在我们的视差层中。首先，我们需要打开 index.html 并删除 scrolller  的 &lt;code&gt;update()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  scroller.update(); // 删除

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存 index.html 文件并在浏览器中测试更改。你应该注意到你只能看见视差层，但都没有滚动。那是因为我们没有添加任何代码来真正更改视口的水平位置。目前它固定在默认的 x 位置 0。&lt;/p&gt;

&lt;p&gt;在我们添加代码之前，我们可以在 Chrome 的 JavaScript 控制台中测试一下我们的滚动条的 &lt;code&gt;setViewportX()&lt;/code&gt; 实际上是有效的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scroller.setViewportX(50); /// 控制台中调用
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;JavaScript 控制台可以访问程序中的任何全局变量。因此，我们可以通过全局 &lt;code&gt;scroller&lt;/code&gt; 变量访问滚动条并调用其 &lt;code&gt;setViewportX()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你应该看到视差图层向左移动，这表示我们已成功重新定位了视口。&lt;/p&gt;

&lt;p&gt;尝试将视口移动到 x = 7000 的位置 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scroller.setViewportX(7000);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;滚动视口&#34;&gt;滚动视口&lt;/h3&gt;

&lt;p&gt;很明显，我们可以通过不断更新滚动器的视口位置来模拟游戏世界中的移动。我们可以在主循环中执行此操作，但是我们得够获取视口的当前水平位置。让我们继续为 &lt;code&gt;Scroller&lt;/code&gt; 类添加一个新方法。&lt;/p&gt;

&lt;h3 id=&#34;获取视口的位置&#34;&gt;获取视口的位置&lt;/h3&gt;

&lt;p&gt;目前来讲我们的 Scroller 类并没存储当前视口位置，我们需要一个成员变量来实现它。&lt;/p&gt;

&lt;p&gt;打开 Scroller.js 并在构造函数中定义以下成员变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Scroller(stage) {
  this.far = new Far();
  stage.addChild(this.far);

  this.mid = new Mid();
  stage.addChild(this.mid);

  this.viewportX = 0; // 水平滚动量
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并在 &lt;code&gt;setViewportX()&lt;/code&gt; 方法中更新 &lt;code&gt;viewportX&lt;/code&gt; 成员变量的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Scroller.prototype.setViewportX = function(viewportX) {
  this.viewportX = viewportX; // 更新
  this.far.setViewportX(viewportX);
  this.mid.setViewportX(viewportX);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成后，我们可以编写一个 &lt;code&gt;getViewportX()&lt;/code&gt; 方法，该方法将返回视口的当前位置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Scroller.prototype.setViewportX = function(viewportX) {
  this.viewportX = viewportX;
  this.far.setViewportX(viewportX);
  this.mid.setViewportX(viewportX);
};
// 新方法
Scroller.prototype.getViewportX = function() {
  return this.viewportX;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存你的代码。&lt;/p&gt;

&lt;h3 id=&#34;更新主循环&#34;&gt;更新主循环&lt;/h3&gt;

&lt;p&gt;现在要做的就是不断更新滚动器的视口位置。我们将在主循环中执行此操作。&lt;/p&gt;

&lt;p&gt;打开 index.html，只需添加以下两行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  var newViewportX = scroller.getViewportX() + 5; // 添加
  scroller.setViewportX(newViewportX); // 添加
            
  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行获取视口的 x 位置并将其增加 5 个单位。第二行采用新值并更新视口的当前 x 位置。从本质上讲，它会强制视口在每次调用主循环时滚动 5 个单位。&lt;/p&gt;

&lt;p&gt;保存代码并在 Chrome 中运行它。你应该会再一次看到视差层向外滚动。试试不同的滚动速度看。例如，将视口增加 15 个单位而不是 5 个单位。&lt;/p&gt;

&lt;h3 id=&#34;移动视口&#34;&gt;移动视口&lt;/h3&gt;

&lt;p&gt;让我们在 Scroller 类中再添加一个方法 &lt;code&gt;moveViewportXBy&lt;/code&gt;，可以将视口从其当前位置移动指定的距离。这将让主循环看起来更加简洁。&lt;/p&gt;

&lt;p&gt;在保存更改之前，打开 Scroller.js 并添加以下方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Scroller.prototype.getViewportX = function() {
  return this.viewportX;
};
// 添加新方法
Scroller.prototype.moveViewportXBy = function(units) {
  var newViewportX = this.viewportX + units;
  this.setViewportX(newViewportX);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就像我们之前做过的一样，这个新方法不难理解。它只是计算出视口的新位置然后调用类的 &lt;code&gt;setViewportX()&lt;/code&gt; 方法来实际设置视口位置。&lt;/p&gt;

&lt;p&gt;移回 index.html 并删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  var newViewportX = scroller.getViewportX() + 5; // 删除
  scroller.setViewportX(newViewportX); // 删除

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用 &lt;code&gt;moveViewportXBy()&lt;/code&gt; 方法的单行替换它们：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  scroller.moveViewportXBy(5); // 调用新的方法

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存更改并在 Web 浏览器中测试更改。&lt;/p&gt;

&lt;h2 id=&#34;回顾程序的主入口&#34;&gt;回顾程序的主入口&lt;/h2&gt;

&lt;p&gt;本系列教程的第二部分即将结束。在我们完成之前，让我们回顾下 index.html 并做最后一个重构。&lt;/p&gt;

&lt;p&gt;虽然我们已经完成了减少对全局变量的依赖的这样一项令人敬重的工作，但我们的 index.html 文件仍然有一些零散的全局变量。实际上，在大型应用程序中，将尽可能多的 JavaScript 与 HTML 页面分开也是一种很好的做法。虽然我们的 HTML 页面中没有多少 JavaScript，但我们可以做得更好。让我们把代码单独封装在一个与自己类名相同的文件中。这样，我们当前所依赖的全局变量将封装到类的成员变量中。&lt;/p&gt;

&lt;p&gt;创建一个新文件并将其命名为 &lt;code&gt;Main.js&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;为类创建构造函数，并将HTML页面的 &lt;code&gt;init()&lt;/code&gt; 函数中的代码放入其中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Main() {
  this.stage = new PIXI.Container();
  this.renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  this.scroller = new Scroller(this.stage);

  requestAnimationFrame(this.update.bind(this));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面使用 &lt;code&gt;this&lt;/code&gt; 关键字。我们使用它来定义 &lt;code&gt;stage&lt;/code&gt;，&lt;code&gt;renderer&lt;/code&gt; 和 &lt;code&gt;scroller&lt;/code&gt; 作为成员变量。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 关键字也用于调用 JavaScript 函数 &lt;code&gt;requestAnimationFrame()&lt;/code&gt;。代码大概是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;requestAnimationFrame(this.update.bind(this));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用它来指定我们的类名为 &lt;code&gt;update()&lt;/code&gt; 的方法（我们仍然要写这个方法）将在下一次重绘时调用。另外，还调用另一个你可能不熟悉的名为 &lt;code&gt;bind()&lt;/code&gt; 的JavaScript 函数。它用来保证在调用 &lt;code&gt;update()&lt;/code&gt; 时它正确地访问到 Main 类的实例。如果不用 &lt;code&gt;bind()&lt;/code&gt;，&lt;code&gt;update()&lt;/code&gt; 方法将无法访问和使用任何 Main 类的成员变量。&lt;/p&gt;

&lt;p&gt;好吧，让我们实际编写我们的类的 &lt;code&gt;update()&lt;/code&gt; 方法。它将只包含我们原来 HTML 页面的 &lt;code&gt;update()&lt;/code&gt; 函数中的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.update = function() {
  this.scroller.moveViewportXBy(Main.SCROLL_SPEED);
  this.renderer.render(this.stage);
  requestAnimationFrame(this.update.bind(this));
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再次使用了 &lt;code&gt;this&lt;/code&gt; 关键字，而且利用了JavaScript 的 &lt;code&gt;bind()&lt;/code&gt; 函数来确保我们的更新循环始终在正确的作用域下。&lt;/p&gt;

&lt;p&gt;另外，请注意上面的代码在调用 scrolller 的 &lt;code&gt;moveViewportXBy()&lt;/code&gt; 方法时使用了一个名为 &lt;code&gt;SCROLL_SPEED&lt;/code&gt; 的常量。以前我们刚刚传递了一个硬编码值。我们实际可以将该常量添加到 Main 类中做为静态常量。在构造函数后面直接添加以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  requestAnimationFrame(this.update.bind(this));
}

Main.SCROLL_SPEED = 5; // 添加

Main.prototype.update = function() {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好的，保存你的代码。&lt;/p&gt;

&lt;p&gt;现在让我们打开 index.html 并删除以前的老代码。&lt;/p&gt;

&lt;p&gt;删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 全部删除 --&amp;gt;
&amp;lt;script&amp;gt;
  function init() {
    stage = new PIXI.Container();
    renderer = PIXI.autoDetectRenderer(
      512,
      384,
      {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
    );

    scroller = new Scroller(stage);

    requestAnimationFrame(update);
  }

  function update() {
    scroller.moveViewportXBy(5);

    renderer.render(stage);

    requestAnimationFrame(update);
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用一个简单的实例化 Main 类的新 &lt;code&gt;init()&lt;/code&gt; 函数代替：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  function init() {
    main = new Main();
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，通过添加以下行来引用到类 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Far.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Mid.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Scroller.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- 添加 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存你的工作并测试仍在 Google Chrome 中运行的所有内容。&lt;/p&gt;

&lt;p&gt;我们已经成功地将所有内容都移到了一个主应用程序类中，而 index.html中只剩下几行 JavaScript 来解决所有问题。&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;哇哦！我们这一节涉及到了很多内容。虽然最终结果是相同的（我们仍然只有两个滚动视差层），但我希望你能看到重构代码的好处。现在一切都比干净了很多，我们有一个用于管理视差层的 Scroller 类。虽然这次我们的重点不是 pixi.js，但你至少应该体会到扩展 Pixi 展示对象类的好处。&lt;/p&gt;

&lt;h2 id=&#34;下集预告&#34;&gt;下集预告…&lt;/h2&gt;

&lt;p&gt;所有这些变化都处于理想的位置，可以在此基础上开发第三个更复杂的视差层了。这个图层将作为游戏世界的 地图，并将由一系列 &lt;strong&gt;精灵&lt;/strong&gt; 构建，而不是简单的重复纹理。我们将把目标放在 pixi.js 上，将涉及各种各样的好东西，包括精灵表（Spritesheet），纹理帧（texture frames）和对象池（object pooling）。&lt;/p&gt;

&lt;p&gt;记得 &lt;a href=&#34;https://github.com/ccaleb/pixi-parallax-scroller&#34;&gt;GitHub&lt;/a&gt; 上提供了本系列和本系列教程的源代码哦。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://keelii.com&#34;&gt;第三部分&lt;/a&gt; 见。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Pixi.js 构建一个视差滚动器（第一篇）</title>
      <link>https://keelii.com/2019/03/16/building-a-parallax-scroller-with-pixijs-cn-1/</link>
      <pubDate>Sat, 16 Mar 2019 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2019/03/16/building-a-parallax-scroller-with-pixijs-cn-1/</guid>
      <description>

&lt;h2 id=&#34;翻译对照&#34;&gt;翻译对照&lt;/h2&gt;

&lt;p&gt;原文：
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5226&#34;&gt;PART 1&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5666&#34;&gt;PART 2&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=6496&#34;&gt;PART 3&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=7046&#34;&gt;PART 4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译文：
&lt;a href=&#34;https://keelii.com/2019/03/16/building-a-parallax-scroller-with-pixijs-cn-1/&#34;&gt;第一篇&lt;/a&gt;・
&lt;a href=&#34;https://keelii.com/2019/03/17/building-a-parallax-scroller-with-pixijs-cn-2/&#34;&gt;第二篇&lt;/a&gt;・
&lt;a href=&#34;https://keelii.com/2019/03/19/building-a-parallax-scroller-with-pixijs-cn-3/&#34;&gt;第三篇&lt;/a&gt;・
第四篇&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;关注 &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=chriscaleb&#34;&gt;@chriscaleb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个系列的教程已经更新到了 &lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PixiJS v4&lt;/a&gt; 版本。&lt;/p&gt;

&lt;p&gt;曾经玩过 &lt;a href=&#34;http://www.adamatomic.com/canabalt/&#34;&gt;Canabalt&lt;/a&gt; 和 &lt;a href=&#34;https://chrome.google.com/webstore/detail/monster-dash/cknghehebaconkajgiobncfleofebcog?hl=en&#34;&gt;Monster Dash&lt;/a&gt;，好奇他们是如何构建一个滚动游戏地图的？在这个教程中我们将向「构建一个视差滚动器」迈出第一步，我们将使用 JavaScript 和 &lt;a href=&#34;http://www.pixijs.com/&#34;&gt;pixi.js&lt;/a&gt; 这个 2D 渲染引擎。&lt;/p&gt;

&lt;h3 id=&#34;你将学到什么&#34;&gt;你将学到什么…&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Pixi.js 的基础知识&lt;/li&gt;
&lt;li&gt;如何处理纹理（textures）和精灵（sprites）&lt;/li&gt;
&lt;li&gt;如何实现简单的视差滚动&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;预备知识&#34;&gt;预备知识…&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;了解 JavaScript 或者 ActionScript 的基础知识&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript 无处不在，由于浏览器的不断改善和大量的 JavaScript 库，我们真的开始看到 HTML5 游戏领域开发蓬勃发展。但是当有很多库可用的时候，选择合适的并非易事。&lt;/p&gt;

&lt;p&gt;这个系列的教程将向你介绍 JavaScript 游戏开发的基础，我们会聚焦到 pixijs。它是一个支持 WebGL 和 HTML5 Canvas 的渲染框架。教程最后你将完成如下的一个视差滚动地图程序：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yeahbutisitflash.com/pixi-parallax-scroller/final/index.html&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/25206/13/10616/142679/5c887df7E7c1fa38a/eab39f5f7ab1cc6d.png&#34; alt=&#34;ps-tut1-screenshot1&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;点击上面的链接启动最终版的程序，这就是你将要完成的。注意它包含了三个视差层：一个远景（far）层，一个中间（mid）层，一个前景（foreground）层。在第一篇教程中我们将集中精力构建远景层和中间层。当然为了做到这一点教程必须涉及 pixi.js 的基础，当然如果你还是个 JavaScript 新手，这会是个很好的开始学习 HTML5 游戏编程的地方。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yeahbutisitflash.com/pixi-parallax-scroller/tutorial-1/index.html&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/25206/13/10616/142679/5c887df7E7c1fa38a/eab39f5f7ab1cc6d.png&#34; alt=&#34;ps-tut1-screenshot1&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;开始之前，点击上面的链接预览下这篇教程中将做成的效果。你也可以从 github 上下载这个程序的 &lt;a href=&#34;https://github.com/ccaleb/pixi-parallax-scroller&#34;&gt;源代码&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;起步&#34;&gt;起步&lt;/h2&gt;

&lt;p&gt;为了完成编码，你需要一个代码编辑器，我将使用一个体验版的 sublime text，可以在 &lt;a href=&#34;www.sublimetext.com/2&#34;&gt;这里&lt;/a&gt; 下载到。&lt;/p&gt;

&lt;p&gt;还需要一个浏览器来测试你的程序。任何现代浏览器都可以，我将用 Google Chrome，开发过程中将会涉及到一些开始者工具的使用。如果你还没有安装 Chrome，可以去 &lt;a href=&#34;www.google.com/chrome&#34;&gt;这里&lt;/a&gt; 下载。&lt;/p&gt;

&lt;p&gt;为了测试你的程序，你还需要在你的开发机上安装一个 web 服务器。如果你用的是 Window，可以 &lt;a href=&#34;http://www.yeahbutisitflash.com/www.howtogeek.com/howto/windows-vista/how-to-install-iis-on-windows-vista&#34;&gt;安装 IIS&lt;/a&gt;，macOS 用户可以配置下系统默认的 &lt;a href=&#34;http://macdevcenter.com/pub/a/mac/2001/12/07/apache.html&#34;&gt;Apache&lt;/a&gt;，如果你的系统是 OS X Mountain Lion 配置 web 服务器可以会比较麻烦，可以参考这个 &lt;a href=&#34;http://reviews.cnet.com/8301-13727_7-57481978-263/how-to-enable-web-sharing-in-os-x-mountain-lion/&#34;&gt;教程&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你有自己托管的 web 服务器，就可以直接上传所以文件来测试，或者如果你有一个 &lt;a href=&#34;https://www.dropbox.com/&#34;&gt;Dropbox&lt;/a&gt; 账号，你可以通过 &lt;a href=&#34;http://droppages.com/&#34;&gt;DropPages&lt;/a&gt; 服务来托管你的文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;web 服务器建好后，创建一个目录 &lt;code&gt;parallax-scroller&lt;/code&gt; 如果你使用 Windows。你的 web 服务器根目录应该类似 &lt;code&gt;C:\inetpub\parallax-scroller&lt;/code&gt; 。如果你使用 OS X 则应该是 &lt;code&gt;/Users/your_user_name/Sites&lt;/code&gt;，&lt;code&gt;your_user_name&lt;/code&gt; 就是你电脑的用户名。&lt;/p&gt;

&lt;p&gt;最后，在教程中我们将使用几个图片素材，不用你自己去找，我已经为你打包好了一个 &lt;a href=&#34;http://www.yeahbutisitflash.com/pixi-parallax-scroller/tutorial-1/resources.zip&#34;&gt;zip 文件&lt;/a&gt;，下载并解压好你的 &lt;code&gt;parallax-scroller&lt;/code&gt; 目录。&lt;/p&gt;

&lt;p&gt;下面就是你的 &lt;code&gt;parallax-scroller&lt;/code&gt; 文件夹的样子（Windows）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/10162/32/14136/48598/5c8884a8Ee6927d64/153a8f1b6f1b4e97.png&#34; alt=&#34;screenshot3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果你用的是 Mac OS X 则应该如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t1/31876/28/5811/61642/5c8884ccE7e17d248/5c69f80f99e2cb1d.png&#34; alt=&#34;screenshot4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在我们已经准备好开始写代码了，启动 Sublime Text 2 或者你最喜欢的编辑器。&lt;/p&gt;

&lt;h2 id=&#34;创建画布&#34;&gt;创建画布&lt;/h2&gt;

&lt;p&gt;所有的 pixijs 项目都以一个 HTML 文件开始。在这里我们将创建一个 canvas 元素以及引入 pixi.js 库。canvas 元素表示HTML页面上将呈现滚动条的区域。&lt;/p&gt;

&lt;p&gt;在你的项目根目录 &lt;code&gt;parallax-scroller&lt;/code&gt; 下使用编辑器新建一个文件，命名为 &lt;code&gt;index.html&lt;/code&gt;，并写入下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Parallax Scrolling Demo&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在看起来还非常奇怪，我们的 HTML 页面只有一个 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 元素。&lt;/p&gt;

&lt;p&gt;现在让我们在页面上添加 HTML5 Canvas 元素，在 body 元素中添加如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;body&amp;gt;
  &amp;lt;div align=&amp;quot;center&amp;quot;&amp;gt;
    &amp;lt;canvas id=&amp;quot;game-canvas&amp;quot; width=&amp;quot;512&amp;quot; height=&amp;quot;384&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们指定了 canvas 宽度 512 像素，高度 384 像素。这就是 pixi.js 为库渲染游戏的地方。注意我们给 canvas 了一个 id 属性，值为 &lt;code&gt;game-canvas&lt;/code&gt; 这将使我们易于控制它，当 pixi.js 启动时也需要它&lt;/p&gt;

&lt;p&gt;现在启动你的 web 服务器，在 浏览器中打开类似 &lt;a href=&#34;http://localhost/parallax-scroller/index.html&#34;&gt;http://localhost/parallax-scroller/index.html&lt;/a&gt; 或者 &lt;a href=&#34;http://localhost/~**your_user_name**/parallax-scroller/index.html&#34;&gt;http://localhost/~**your_user_name**/parallax-scroller/index.html&lt;/a&gt; 的链接&lt;/p&gt;

&lt;p&gt;你会发现并没有什么东西，我们来给 canvas 加点样式（style 标签）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Endless Runner Game Demo&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      body { background-color: #000000; }
      canvas { background-color: #222222; }
    &amp;lt;/style&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存并刷新，你将会看见一个水平居中的灰色区域出现在页面上。&lt;/p&gt;

&lt;h2 id=&#34;引入-pixi-js-类库&#34;&gt;引入 pixi.js 类库&lt;/h2&gt;

&lt;p&gt;在 &lt;/body&gt; 标签前面加入引用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
  &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pixi.js 库文件托管在 CDN 上，URL 上的 &lt;code&gt;4.0.0&lt;/code&gt; 表示库的版本号，你可以替换成其它的发行版。&lt;/p&gt;

&lt;h2 id=&#34;添加程序的入口&#34;&gt;添加程序的入口&lt;/h2&gt;

&lt;p&gt;给 body 元素添加 &lt;code&gt;onload=&amp;quot;init();&lt;/code&gt; 表示页面加载完成时调用 init 方法。我们在 script 标签中添加一个 init 方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body onload=&amp;quot;init();&amp;quot;&amp;gt;
  &amp;lt;div align=&amp;quot;center&amp;quot;&amp;gt;
    &amp;lt;canvas id=&amp;quot;game-canvas&amp;quot; width=&amp;quot;512&amp;quot; height=&amp;quot;384&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;script src=&amp;quot;pixi.js-master/bin/pixi.dev.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script&amp;gt;
    function init() {
      console.log(&amp;quot;init() successfully called.&amp;quot;);
    }
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开 Chrome Console，Windows 下按 &lt;code&gt;F12&lt;/code&gt;，macOS 下按 &lt;code&gt;Cmd + Opt + i&lt;/code&gt;。正常的话控制台就会有下面的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; init() successfully called.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在这个 init 方法做的事情还很少，最终它将做为入口负责你程序的调用。&lt;/p&gt;

&lt;h2 id=&#34;初始化-pixi-js&#34;&gt;初始化 pixi.js&lt;/h2&gt;

&lt;p&gt;我们在 init 方法中需要做下面两件事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建你的舞台（stage）&lt;/li&gt;
&lt;li&gt;选择并实例化一个渲染器（renderer）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们先来创建一个舞台对象，如果你是个 Flash 开发者，你可能会对舞台的概念比较熟悉了。基本上舞台就是你游戏的图形内容呈现的地方。另一方面，渲染器控制舞台并且把游戏绘制到你的 HTML 页面中的 canvas 元素上，这样你的做的东西才最终呈现给了用户。&lt;/p&gt;

&lt;p&gt;我们来创建一个舞台对象并将它关联到一个名字叫做 &lt;code&gt;stage&lt;/code&gt; 的全局变量上。并且删除之前的 log 语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {
  console.log(&amp;quot;init() successfully called.&amp;quot;);
  stage = new PIXI.Container();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pixi.js 的 API 包含了一些类和函数，并且被保存在 &lt;code&gt;PIXI&lt;/code&gt; 模块命名空间下面。PIXI.Container 类用来表示一些 &lt;strong&gt;展示对象&lt;/strong&gt;（display object） 的集合，同样也可以表示舞台这个根展示对象。&lt;/p&gt;

&lt;p&gt;现在我们已经创建好了一个舞台，我们还需要一个渲染器。Pixi.js 支持两种渲染器：WebGL 和 HTML5 Canvas。你可以通过 &lt;code&gt;PIXI.WebGLRenderer&lt;/code&gt; 或者 &lt;code&gt;PIXI.CanvasRenderer&lt;/code&gt; 来分别创建它们各自的实例。然而，更好的做法是让 Pixi 为你判断浏览器自动检测并使用正确的渲染器。Pixi 默认会尝试使用 WebGL，如果不支持则回滚到  canvas。我们调用用 Pixi 的 &lt;code&gt;PIXI.autoDetectRenderer()&lt;/code&gt; 函数来自动帮我们选择合适的渲染器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {		
  stage = new PIXI.Container();
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;autoDetectRenderer()&lt;/code&gt; 函数需要传入渲染舞台上 cavnas 的宽度和高度，以及 cavnas 元素的引用，它返回 &lt;code&gt;PIXI.WebGLRenderer&lt;/code&gt; 或 &lt;code&gt;PIXI.CanvasRenderer&lt;/code&gt; 的实例，我们将其保存在名为 &lt;code&gt;renderer&lt;/code&gt; 的全局变量中。&lt;/p&gt;

&lt;p&gt;在上面的代码中，我们通过一个包含 &lt;code&gt;view&lt;/code&gt; 属性的 JavaScript 对象来传递给 &lt;code&gt;autoDetectRenderer&lt;/code&gt; 方法，表示 canvas 元素的引用。我们传递这个对象做为函数的第三个参数而不是直接传 canvas 对象的引用。&lt;/p&gt;

&lt;p&gt;我们使用了硬编码的方式指定了宽，高，实际上可以直接通过 canvas 元素取得这两个值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var width = document.getElementById(&amp;quot;game-canvas&amp;quot;).width;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;渲染&#34;&gt;渲染&lt;/h2&gt;

&lt;p&gt;为了能看到舞台上的内容，你得指导你的渲染器把舞台上的内容真正的绘制到 canvas 上。可以通过调用 renderer 的 render 方法，并传入舞台对象的引用来做到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {		
  stage = new PIXI.Container();
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );
  renderer.render(stage);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将成功的把舞台渲染到浏览器中。当然我们还没有给舞台上添加任何东西，所以你还看不出来&lt;/p&gt;

&lt;h2 id=&#34;为你的展示列表-display-list-添加内容&#34;&gt;为你的展示列表（display list）添加内容&lt;/h2&gt;

&lt;p&gt;现在你的舞台已经建成，让我们继续往上面添加一些实际的东西。毕竟我们不想一直只到一个黑色的窗口。&lt;/p&gt;

&lt;p&gt;舞台上的东西被添加到一个 &lt;strong&gt;树型结构&lt;/strong&gt; 的展示列表中。你的舞台扮演着这些展示列表的根元素的角色，同时展示列表也会有栈顺序的问题，这意味着有的对象展示在别的对象上面，这由他们被设计的索引深度决定。&lt;/p&gt;

&lt;p&gt;有很多种类的 &lt;strong&gt;展示对象（display object）&lt;/strong&gt; 可以被添加到 &lt;strong&gt;展示列表&lt;/strong&gt; 中，最常见的是 &lt;code&gt;PIXI.Sprite&lt;/code&gt;，它可以添加图片素材。&lt;/p&gt;

&lt;p&gt;由于这个教程是关于创建视差滚动背景的，让我们来添加一个表示远景层的图片。 我们将以添加一行代码来加载 &lt;code&gt;bg-far.png&lt;/code&gt; 文件，这个文件在 resources 目录中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {		
  stage = new PIXI.Container();
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);

  renderer.render(stage);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图片素材被加载并保存为纹理（textures），这个纹理可以随后被符加到一个或者多个精灵上面。在上面的代码中我们调用了静态 &lt;code&gt;PIXI.Texture.fromImage()&lt;/code&gt; 方法来创建一个&lt;code&gt;PIXI.Texture&lt;/code&gt; 实例并将 &lt;code&gt;bg-far.png&lt;/code&gt; 文件加载到其中。为了方便使用，我们将纹理引用赋值给名为 &lt;code&gt;farTexture&lt;/code&gt; 的局部变量。&lt;/p&gt;

&lt;p&gt;现在让我们创建一个精灵并将纹理附加到它上面。并将精灵定位在舞台的左上角：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {		
  stage = new PIXI.Container();
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
  far = new PIXI.Sprite(farTexture);
  far.position.x = 0;
  far.position.y = 0;

  renderer.render(stage);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;PIXI.Sprite&lt;/code&gt; 类用于创建精灵。它的构造函数将接收一个纹理的引用参数。我们使用了一个名为 far 的全局变量，并将新创建的 sprite 实例存储在其中。&lt;/p&gt;

&lt;p&gt;聪明的你可能已经发现我们是如何使用 position 属性将精灵的 x 和 y 坐标设置到舞台的左上角的。舞台的坐标从左到右，从上到下，这意味着舞台的左上角位置为（0,0），右下角为（512,384）。&lt;/p&gt;

&lt;p&gt;精灵有一个轴心点（pivot），它们可以来回旋转。轴心点也可以用来定位精灵。精灵的默认轴心点设置为左上角（0,0）。这就是为什么当我们的精灵定位在舞台的左上角时，我们将其位置设置为（0,0）。（译者：如果你将轴心点设置到正中央，那位置是（0,0）的精灵就会展示不全）&lt;/p&gt;

&lt;p&gt;最后一步是将精灵添加到舞台上。这是使用 &lt;code&gt;PIXI.Stage&lt;/code&gt; 类的（实例方法） &lt;code&gt;addChild()&lt;/code&gt; 方法完成的。来看看怎么做吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
  far = new PIXI.Sprite(farTexture);
  far.position.x = 0;
  far.position.y = 0;
  stage.addChild(far);

  renderer.render(stage);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好的，保存你的代码并刷新浏览器。你可能已经满坏期望能看到背景图，但实际上可能看不到。为什么呢？在素材纹理被加载完成之前就渲染它可能并不能有任何效果。因为纹理加载是需要一小段时间的。&lt;/p&gt;

&lt;p&gt;我们可以通过简单地等一段时间，然后再次调用 render 方法来解决这个问题。通过 Chrome 的控制台执行下面的代码即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;renderer.render(stage);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;由于我们之前声明的 &lt;code&gt;renderer&lt;/code&gt; 是全局变量，所以你能在 console 中直接使用它。console 中可以使用任何 JavaScript 中声明的全局变量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;恭喜你！现在应该看到紧贴在屏幕顶部的背景图层了。&lt;/p&gt;

&lt;p&gt;现在让我们继续添舞台上的中间层：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
far = new PIXI.Sprite(farTexture);
far.position.x = 0;
far.position.y = 0;
stage.addChild(far);

var midTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;);
mid = new PIXI.Sprite(midTexture);
mid.position.x = 0;
mid.position.y = 128;
stage.addChild(mid);

renderer.render(stage);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存代码并刷新浏览器。你需要再次手动在 Chrome 控制台中调用渲染方法才能看到两个层：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;renderer.render(stage);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为中间层是在远景层 &lt;strong&gt;之后&lt;/strong&gt; 加入的，所以它离我们更进，或者说有更高的层深度。也就是说每次调用 addChild() 方法添加的展示对象都会在上一次添加的对象之上。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我们在这一节的教程中将只会聚焦到远景层和中间层的展示，后面的几节中，我们会实现更复杂的前景层&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;主循环&#34;&gt;主循环&lt;/h2&gt;

&lt;p&gt;现在我们有两个背景图层，我想我们可以尝试实现一些视差滚动，并且还可以找到一种渲染内容的方法，而不用从 JavaScript 控制台中手动执行。&lt;/p&gt;

&lt;p&gt;为了避免疑惑，让我们快速解释下究竟是什么视差滚动。这是一种用于视频游戏的滚动技术，其中背景层在屏幕上移动的速度比前景层慢。这样做会在2D游戏中产生一种幻觉，并让玩家更有沉浸感（更真实）。&lt;/p&gt;

&lt;p&gt;根据上面这些信息，我们可以将它应用于我们的两个精灵层，来生成一个水平视差滚动器，我们将背景层移动到屏幕上的速度比中间层慢一点。为了能让每个层都滚动，我们将创建一个主循环，我们可以不断改变每个层的位置。为了实现这一点，我们将使用 &lt;code&gt;requestAnimationFrame()&lt;/code&gt; 的帮助，这是一个 JavaScript 函数，它能决定浏览器的最佳帧速率，然后在下一次重绘 canvas/stage 时调用指定的函数。我们还将使用这个主循环来 &lt;strong&gt;不断地&lt;/strong&gt; 呈现我们的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var midTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;);
mid = new PIXI.Sprite(midTexture);
mid.position.x = 0;
mid.position.y = 128;
stage.addChild(mid);

renderer.render(stage);

requestAnimationFrame(update);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码，我们指定了一个 update 函数，如果你想连续调用 &lt;code&gt;requestAnimationFrame()&lt;/code&gt; ，这将使得你的 update 方法每秒调用 60 次。或者通常称为每秒 60 帧（FPS）。&lt;/p&gt;

&lt;p&gt;我们还没有 update 函数，但是在实现它之前，先删除渲染方法的调用，因为主循环中会处理这个逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var midTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;);
mid = new PIXI.Sprite(midTexture);
mid.position.x = 0;
mid.position.y = 128;
stage.addChild(mid);

renderer.render(stage); // 删除它

requestAnimationFrame(update);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好吧，让我们来编写主循环并让它稍微改变两个层的位置，然后渲染舞台的内容，这样我们就可以看到每个帧重绘的差异。在 &lt;code&gt;init()&lt;/code&gt; 函数之后直接添加 &lt;code&gt;update()&lt;/code&gt; 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.position.x -= 0.128;
  mid.position.x -= 0.64;

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前两行代码更新了远景层和中间层精灵的水平位置。请注意，我们将远层向左移动0.128 像素，而我们将中间层向左移动 0.64 像素。要向左移动某些东西，我们得使用负值，而正值则会将其移动到右侧。另外请注意，我们将精灵移动了 &lt;strong&gt;小数&lt;/strong&gt; 像素。 Pixi 的渲染器可以存储它们并使用子像素来处理它们位置。当你想要非常缓慢地在屏幕上轻推东西时，这是理想的选择。&lt;/p&gt;

&lt;p&gt;在循环结束时，我们再次调用 &lt;code&gt;requestAnimationFrame()&lt;/code&gt; 函数，以确保在下次再次绘制画布时自动再次调用 &lt;code&gt;update()&lt;/code&gt;。正是它确保了我们的主循环被连续调用，从而能确保我们的视差层在屏幕上稳定移动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/25862/18/10942/84129/5c8b2631E9323cbf6/487b26b72c59b787.png&#34; alt=&#34;ps-tut1-screenshot5&#34; /&gt;&lt;/p&gt;

&lt;p&gt;保存代码并刷新浏览器看看它长什么样子。你应该看到两个图层自动呈现在屏幕上。此外，当两个图层都在移动时，中间层实际上比远景层更快地移动，从而为场景提供深度感。但是你也应该发现有一个明显问题：当每个精灵移出屏幕的左侧时，它会向右边留下一个间隙。换句话说，两个图层的图形都没有循环，以给出连续滚动的错觉。还好，有一个解决方案。&lt;/p&gt;

&lt;h2 id=&#34;使用瓦片-平铺-精灵&#34;&gt;使用瓦片（平铺）精灵&lt;/h2&gt;

&lt;p&gt;到目前为止，我们已经学会使用 &lt;code&gt;PIXI.Sprite&lt;/code&gt; 类来表示展示列表中的对象。然而，pixi.js 还提供了几个其他 &lt;strong&gt;展示对象&lt;/strong&gt; 以满足不同的需求。&lt;/p&gt;

&lt;p&gt;如果你细心的观察一下 bg-far.png 和 bg-mid.png 的话，你应该注意到这两个图像都设计成可以水平平铺的（译：平铺就好比瓦片）。检查每个图像的左右边缘。你可以发现，最右边的边缘完美地匹配连接到最左边的边缘。换句话说，两个图像都被设计成无缝循环的。&lt;/p&gt;

&lt;p&gt;因此，如果有一种方法可以简单地移动每个精灵的纹理以给出他们正在移动的错觉，而不是物理地移动我们的远景层和中间层精灵的位置，这不是很好吗？值得庆幸的是 pixi.js 提供了 PIXI.extras.TilingSprite 类，它就是用来做这个的。&lt;/p&gt;

&lt;p&gt;所以，让我们对代码进行一些调整，来使用瓦片精灵。我们首先关注远景层。继续从建立函数中删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
far = new PIXI.Sprite(farTexture); // 删除它
far.position.x = 0;
far.position.y = 0;
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new PIXI.extras.TilingSprite(farTexture, 512, 256);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后设置他们的位置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far.tilePosition.x = 0;
far.tilePosition.y = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在继续之前，让我们讨论 TilingSprite 类的构造函数及它的 tilePosition 属性。&lt;/p&gt;

&lt;p&gt;和 Sprite 类的单个参数比较，您会注意到 TilingSprite 类的构造函数需要 3 个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new PIXI.extras.TilingSprite(farTexture, 512, 256);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的第一个参数与之前相同：纹理的引用。第二个和第三个参数分别表示瓦片精灵的宽度和高度。通常，将这两个参数设置为 &lt;strong&gt;纹理&lt;/strong&gt; 的宽度和高度，比如 &lt;code&gt;bg-far.png&lt;/code&gt; 为 512 x 256 像素。&lt;/p&gt;

&lt;p&gt;我们又一次的硬编码的传入了两个宽高参数，可以通过下面的方法改善：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new PIXI.extras.TilingSprite(
  farTexture,
  farTexture.baseTexture.width,
  farTexture.baseTexture.height
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还利用了平铺精灵的 tilePosition 属性，该属性用于偏移精灵纹理的位置。换句话说，通过调整偏移量，就可以水平或垂直地移动纹理，并使纹理环绕。本质上，你可以模拟滚动而无需实际更改精灵的位置。&lt;/p&gt;

&lt;p&gt;我们将精灵的 tilePosition 属性默认设置为（0,0），这意味着远景层的外观在初始化的状态下没有变化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far.tilePosition.x = 0;
far.tilePosition.y = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;剩下要做的就是通过不断更新精灵的 tilePosition 属性的水平偏移来模拟滚动。为此，我们将对 &lt;code&gt;update()&lt;/code&gt; 函数进行更改。首先删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.position.x -= 0.128; // 删除它
  mid.position.x -= 0.64;

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换成下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.tilePosition.x -= 0.128;
  mid.position.x -= 0.64;

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在保存 index.html 并再次刷新浏览器。你将看到远景层无缝滚动并一直重复着，这和我们的预期结果的一样。&lt;/p&gt;

&lt;p&gt;好的，让我们继续为中间层做出相同的修改。以下是进行更改后 &lt;code&gt;init()&lt;/code&gt; 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {
  stage = new PIXI.Container();
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);	
  far = new PIXI.extras.TilingSprite(farTexture, 512, 256);
  far.position.x = 0;
  far.position.y = 0;
  far.tilePosition.x = 0;
  far.tilePosition.y = 0;
  stage.addChild(far);

  var midTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;);
  mid = new PIXI.extras.TilingSprite(midTexture, 512, 256);
  mid.position.x = 0;
  mid.position.y = 128;
  mid.tilePosition.x = 0;
  mid.tilePosition.y = 0;
  stage.addChild(mid);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在继续对 &lt;code&gt;update()&lt;/code&gt; 函数进行以下重构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.tilePosition.x -= 0.128;
  mid.tilePosition.x -= 0.64;

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存并测试你的代码。这次你应该看到两个图层完全地滚动，同时环绕屏幕的左右边界。&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;我们已经介绍了pixi.js 的一些基础知识，并了解了 &lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt; 如何用于创建无限滚动图层的。我们还看到了如何使用 &lt;code&gt;addChild()&lt;/code&gt; 将瓦片精灵堆叠在一起以产生真实的视差滚动。&lt;/p&gt;

&lt;p&gt;我建议你继续尝试使用 Pixi 并查看它的文档和代码示例。两者都可以在 PixiJS &lt;a href=&#34;http://www.pixijs.com/&#34;&gt;官方网站&lt;/a&gt; 上找到。&lt;/p&gt;

&lt;h2 id=&#34;下集预告&#34;&gt;下集预告…&lt;/h2&gt;

&lt;p&gt;虽然我们有一个水平视差滚动器并且能运行起来，但它仍然有点简单。下次我们将介绍 &lt;strong&gt;视口&lt;/strong&gt; 和 &lt;strong&gt;世界&lt;/strong&gt; 位置的概念，如果你想最终将你的卷轴添加到游戏中，这两个都很重要。它还将使我们处于添加前景层的良好位置，这将代表一个简单的平台游戏地图。&lt;/p&gt;

&lt;p&gt;我们将花很多时间来重构现有的代码库。我们将采用更加面向对象的架构，摆脱目前对全局变量的依赖。在下一个教程结束时，所有滚动功能都将整齐地包含在一个类中。&lt;/p&gt;

&lt;p&gt;我希望这个教程能帮助到你，也希望下次能在 &lt;strong&gt;第二部分&lt;/strong&gt; 中见到你。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何使用前端技术开发一个桌面跨端应用</title>
      <link>https://keelii.com/2019/03/14/how-to-create-a-real-world-app-based-on-fe-tech/</link>
      <pubDate>Thu, 14 Mar 2019 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2019/03/14/how-to-create-a-real-world-app-based-on-fe-tech/</guid>
      <description>

&lt;p&gt;本文将会讲述一个完整的跨端桌面应用 &lt;a href=&#34;https://code-sketch.com/&#34; title=&#34;代码画板&#34;&gt;&lt;strong&gt;代码画板&lt;/strong&gt;&lt;/a&gt; 的构建，会涉及到整个软件开发流程，从开始的设计、编码、到最后产品成型、包装等。&lt;/p&gt;

&lt;p&gt;本文不仅仅是一篇技术方面的专业文章，更会有很多产品方面的设计思想和将技术转换成生产力的思考，我将结合我自己的使用场景完全的讲解整个开发流程，当然涉及到设计方面的不一定具有普遍实用性，多数情况下都是我自己的一些喜好，我只关心自己的需求。&lt;/p&gt;

&lt;p&gt;同时本文只从整体上讲思路，也会有个别的技术细节和常规套路，有兴趣的也可以直接去 github 上看 &lt;a href=&#34;https://github.com/keelii/code-sketch&#34; title=&#34;code-sketch-source&#34;&gt;源码&lt;/a&gt;，文章会比较长，如果你只想知道一些拿来即用的「干货」，或许这篇文章并不是一个好的选择&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;一-定位需求&#34;&gt;一、定位需求&lt;/h2&gt;

&lt;p&gt;事情的起因是这样的，因为我们内部会有一些培训会议。会经常现场演示一些代码片段。比如说我们讲到 React 的时候会现场写一些组件，让大家能直观的感受到 React 的一些功能。&lt;/p&gt;

&lt;p&gt;但是通常由于条件所所限，会议总会遇到一些意外。比如断网、投影分辨率低看不清文字等&lt;/p&gt;

&lt;p&gt;起初我们用的是在线版的 &lt;a href=&#34;https://codepen.io/&#34; title=&#34;codepen&#34;&gt;codepen&lt;/a&gt;，但是感觉并不是那么好用。比如不能方便的修改字体大小，必须要在连网的情况下才能使用。另外它的 UI 设计不是很紧凑，通常我们展示代码的时候都投影是寸土寸金的，应该有一个简洁又不失功能的 UI 界面，能全屏展示…&lt;/p&gt;

&lt;p&gt;于是我解决自己实现一个这样的轮子，那么大概的需求目标是有了：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;离线可用&lt;/li&gt;
&lt;li&gt;可以改变界面字体大小&lt;/li&gt;
&lt;li&gt;更加简洁的 UI&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;二-整体设计&#34;&gt;二、整体设计&lt;/h2&gt;

&lt;h3 id=&#34;应用风格&#34;&gt;应用风格&lt;/h3&gt;

&lt;p&gt;代码画板解决的是 &lt;strong&gt;临时性&lt;/strong&gt; 的一些 *演示代码* 的需求，所以它的本质属性是一个拿来即用的工具，它不应该有更复杂的功能，比如用户登录、代码片段的管理等。这些需求不是它要解决的。代码画板会提供一个简单的导出成 HTML 文件的功能，可以方便用户存储整个 HTML 文件。&lt;/p&gt;

&lt;p&gt;既然是用来演示代码的，那么它的界面上应该只有两个东西，一个是 &lt;strong&gt;代码&lt;/strong&gt;，一个就是 &lt;strong&gt;预览&lt;/strong&gt;。像代码/控制台切换的功能都做成 tab 的形式，正常情况不需要让他们展示出来。像 codepen 那样把所有的代码编辑器功能都展示出来我认为是不对的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/16250/31/9820/200587/5c81e5f1Ecd4c788e/73e2e8b44c45fd2b.png&#34; alt=&#34;codepen-demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;codepen 的界面给人感觉非常复杂，有很多功能点。当然我并不是在批评它，codepen 做为一个需要商业化运营的软件，势必会做的非常复杂，这样才能满足更多用户的需求。然而程序员写软件则可以完全按照自己的想法来，哪怕这个应用只给自己一个人用呢。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t1/21966/22/9894/223877/5c81e745E5fc64825/1612674f92321245.png&#34; alt=&#34;hello-code-sketch&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;桌面应用的设计&#34;&gt;桌面应用的设计&lt;/h3&gt;

&lt;p&gt;桌面应用的设计和 web 界面的设计还是有些细微区别的，同样的基于 electron 的应用，有的应用会让人感觉很「原生」，有的则一眼就能看出来是用 CSS 画的。我在设计代码画板的时候也尽量向原生靠近，避免产生落差感。比如禁用鼠标手型图标、在按钮或者非可选元素上禁止用户选择：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;cursor: default;
user-select: none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为实际上用户在使用一款应用的时候感性的因素影响占很大一部分，比如说有人不喜欢 electron 可能就是因为看到过 electron 里面嵌一个完整的  web 页面的操作，这就让人很反感。但是这不是 electron 的问题，而是应用设计者的问题。&lt;/p&gt;

&lt;h3 id=&#34;应用标识的设计&#34;&gt;应用标识的设计&lt;/h3&gt;

&lt;p&gt;说实话应用 logo 设计我也是业余水平，但是聊胜于无。既然水平不行，那就尽量设计的不难看就行了。可以参考一些好的设计。我用 sketch 画出 logo 的外形，sketch 有很多 macOS 的模块可以从网上下载下来，直接基于模板修改就可以了。&lt;/p&gt;

&lt;p&gt;代码画板主要的界面是分割开的两个面板，左边是代码，右边是预览。所以我就大概画了一个形状&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/25508/31/10134/47955/5c84b771Efe6319f7/e58c1fb10f4692bb.png&#34; alt=&#34;code-sketch-icon&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个 logo 有个问题就是线条过多，小尺寸的时候看不清楚。这个问题我暂时先忽略了，毕竟我还不是专业的，后续有好的创意可以再改&lt;/p&gt;

&lt;h3 id=&#34;默认设置&#34;&gt;默认设置&lt;/h3&gt;

&lt;p&gt;代码画板也 &lt;strong&gt;不会有&lt;/strong&gt; 设置界面，因为常用的设置都预定义好了，你不需要配置。顶多改变下代码字体的大小。使用编辑器的通用快捷键 &lt;code&gt;command&lt;/code&gt;+&lt;code&gt;+/-&lt;/code&gt; 就解决了，或者插入三方库，直接使用编辑器的通用命令快捷键 &lt;code&gt;command&lt;/code&gt;+&lt;code&gt;p&lt;/code&gt; 调出。我们的思路就是把复杂的东西帮用户隐藏在后台，观众只需要关注演员台上的一分钟，而不必了解其它细节。&lt;/p&gt;

&lt;h3 id=&#34;快捷键-可用性&#34;&gt;快捷键/可用性&lt;/h3&gt;

&lt;p&gt;由于代码画板的界面非常简单，在一些细小的必要功能就得添加一些快捷键。比如：切换 HTML/CSS/JS/Console 代码编辑器，我在每个 tab 上加了数字标号，暗示它是有顺序有快捷键的，而且这个切换方式和 Chrome tab 切换的逻辑一致，使用 &lt;code&gt;command&lt;/code&gt;+&lt;code&gt;数字&lt;/code&gt; 就可以实现，万一还是有人不会用的话，可以去看帮助文档。里面有所有的快捷键。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/29290/34/10809/7022/5c8a01e4E1b50ceff/6c235ce5bfd1c228.png&#34; alt=&#34;cs-tab&#34; /&gt;&lt;/p&gt;

&lt;p&gt;界面中间的分割条可以自定义拖动，双击重置平分界面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/19010/29/10797/101406/5c8a0247Edd9de215/adedbbec61fde586.gif&#34; alt=&#34;cs-spliter&#34; /&gt;&lt;/p&gt;

&lt;p&gt;刚开始的时候我把每个 tab 页签都分割成单独的面板，因为我觉得这个能拖动自定义面板大小的交互实在是太爽了，忍不住想去拖动它。但是后来想想，其实并没有必要，我们写代码时应该更专注于代码本身，如果只有两个面板，那么这个界面无论是认知还是使用起来就没有任何困难。&lt;/p&gt;

&lt;p&gt;因为我们并不需要把一堆的功能的界面摔给用户，让他们自己去选择。&lt;/p&gt;

&lt;h2 id=&#34;三-技术调研&#34;&gt;三、技术调研&lt;/h2&gt;

&lt;h3 id=&#34;实现控制台&#34;&gt;实现控制台&lt;/h3&gt;

&lt;p&gt;通过使用流行的几款在线代码运行工具，我发现他们有一个共同的问题：&lt;strong&gt;控制台很难用&lt;/strong&gt;。无法像 Chrome Console 那样展示任意类型的 JS 值。比如我想 log 一段嵌套的 JS 对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log({ a: { b: 1, c: { d: [1, 2, 3] } }})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大多数都展示成这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[object Object] {
  a: [object Object] {
    b: 1
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chrome 是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t1/20790/15/9802/66920/5c80fc26E0a7def72/a638657b209ea000.gif&#34; alt=&#34;chrome-console&#34; /&gt;&lt;/p&gt;

&lt;p&gt;显然 Chrome 控制台中更直观。所以我们需要在前面的基础上加一个需求，即：&lt;strong&gt;实现一个基于 DOM 的日志展示界面（无限级联选择）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;日志界面应该有下面这些功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;展示任意 JS 类型的数据&lt;/li&gt;
&lt;li&gt;Primitive 类型的数据显示不同的颜色（number - 蓝色，string - 绿色）&lt;/li&gt;
&lt;li&gt;Object 类型默认折叠起来，点击按钮展示子级，属性过多需要展示缩略信息&lt;/li&gt;
&lt;li&gt;数组前应该有长度标记&lt;/li&gt;
&lt;li&gt;能展示 JS 运行时的报错 Error 信息&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;集成现代化的前端框工作流&#34;&gt;集成现代化的前端框工作流&lt;/h3&gt;

&lt;p&gt;现代化的前端写页面肯定不是 HTML/CSS/JS 一把梭了，至少应该有 Sass/Babel 的支持吧。&lt;/p&gt;

&lt;p&gt;Sass 嵌套能让你少写很多选择器，当然 Less 也可以，但是在我们的这个应用里面区别不大，一般来说临时性的写一些代码很少会用到它们的细节功能。有 &lt;strong&gt;变量&lt;/strong&gt; 和 &lt;strong&gt;选择器&lt;/strong&gt; 嵌套就够了&lt;/p&gt;

&lt;p&gt;Babel 主要是解决了写 React 的问题，不用再安装一大堆的构建工具了，直接使用 &lt;code&gt;UMD&lt;/code&gt; 的 &lt;code&gt;React/ReactDOM&lt;/code&gt; 就可以了，而且 electron 内嵌的 chromium 也支持了 es6 的 class 写法，实际上 Babel 主要的目的还是用来转译 JSX&lt;/p&gt;

&lt;p&gt;注意这里是有一个我认为是 &lt;strong&gt;刚性&lt;/strong&gt; 的需求，比如临时忽然有个想法，或者想验证一段代码的话，正常情况是使用你的编辑器，新建 demo.html/demo.css/demo.js 等这些操作。但是这些动作太浪费时间了。有了代码画板以后，直接打应用就可以开始 coding 了，真正能做到开箱即用。&lt;/p&gt;

&lt;h3 id=&#34;提高程序的扩展性&#34;&gt;提高程序的扩展性&lt;/h3&gt;

&lt;p&gt;我们在写 demo 页面时通常是要引用很多第三方类库的，比如：Bootstrp/jQuery 等。我希望有一种方法可以方便的引用到这些库，直接把库文件的 link/script 标签插入到代码画板的 HTML 中，但是前端框架真的是太多了，又不能一个个去扣来写死到页面，就算是写死了随着框架版本的升级，可能就无法满足我们的需求。&lt;/p&gt;

&lt;p&gt;以前写页面时经常会用到 &lt;a href=&#34;https://www.bootcdn.cn/&#34; title=&#34;bootcdn&#34;&gt;bootcdn&lt;/a&gt;，无意中发现它提供了相关 &lt;a href=&#34;https://www.bootcdn.cn/api/&#34; title=&#34;boot cdn API&#34;&gt;API&lt;/a&gt;，可以直接拿来使用。接下来就得想办法让用户通过界面选择即可。&lt;/p&gt;

&lt;p&gt;这个 API 有三层数据结构：&lt;code&gt;库 - 版本 - 资源链接&lt;/code&gt;。这个功能要用界面来实现肯定会非常臃肿，界面上可能会放很多按钮。这就违背了「更简洁」的需求目标。&lt;/p&gt;

&lt;p&gt;这时就得参考下我们经常使用的一些软件是如何解决 &lt;strong&gt;简洁性&lt;/strong&gt; 和 &lt;strong&gt;功能性&lt;/strong&gt; 需求之间的矛盾问题的，我比较喜欢 Sublime Text 的一些界面设计，Command Palette 是我经常使用的，所以我决定再模拟一个 Command Palette 来实现插入第三方库的需求。而且重要的是这个 Command Palette 并不一定只用来实现这一个功能，或者后期会有一些别的功能需要添加，那这个 Command Palette 也是个很好的入口。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t1/28459/10/9844/97920/5c81d765Efd5a0345/50a35821db9f4c52.png&#34; alt=&#34;Command Palette&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用-electron-实现桌面应用&#34;&gt;使用 electron 实现桌面应用&lt;/h3&gt;

&lt;p&gt;实现离线可用很多方法，比如使用 PWA 技术。但是 PWA 并不能给我带来一种原生应用的那种可靠感，相反 &lt;a href=&#34;https://electronjs.org/&#34; title=&#34;el ec tr on&#34;&gt;electron&lt;/a&gt; 刚好可以解决我的顾虑。同时它可以把你的应用打包成各个平台（macOS/Window/Linux）的原生应用。唯一的缺点就是安装包确实很大，一般来讲一个 electron 应用 &lt;strong&gt;安装完&lt;/strong&gt; 至少要 100 多兆，不过我觉得还能接受，毕竟硬盘存储现在已经很廉价了。&lt;/p&gt;

&lt;p&gt;有人可能对 electron 有抗拒，觉得 electron 应用太庞大、占系统资源什么的，不过我们做的这个应用并不需要常驻系统，临时性的使用一下，用完就关闭，正常写生产环境的代码肯定还是要换回 编辑器/IDE 的。同时因为 electron 降低了写桌面应用的门槛，确实有很多人把一个完整的在线的网页直接嵌进去，这也是有问题的。&lt;/p&gt;

&lt;p&gt;electron 还有一个好处，因为它完全基于 HTML/CSS/JS 来实现 UI(可以使用 Chrome only 的一些新功能)，那我们理论上可以在做桌面应用时顺手把 web 应用也做了。这就可以同时支持各个系统下的原生应用，并且有 web 在线版本。如果你不愿意使用原生应用，直接登录 web.code-sketch.com 使用在线版也没是一种选择。这样就使得我们的应用具有真正的 &lt;strong&gt;跨端&lt;/strong&gt; 能力。&lt;/p&gt;

&lt;p&gt;由于我们团队都使用了 macbook，所以我优先支持 macOS 的开发，另外 macOS Mojave 的系统级别的暗色主题我也比较喜欢，刚好实现支持 mojave 暗色主题这个需求也做上。&lt;/p&gt;

&lt;h2 id=&#34;三-框架的选择&#34;&gt;三、框架的选择&lt;/h2&gt;

&lt;p&gt;大方向确定了，像框架选择这个就简单了，基于 electron 的应用，需要你区分开 render/main process 来选择。&lt;/p&gt;

&lt;h3 id=&#34;render-process&#34;&gt;Render process&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;渲染进程&lt;/strong&gt; 就是 electron 中界面的实现部分 ，一般来说就是一个 webview，选自己喜欢的框架即可。我使用 React 来实现界面。样式方面就不再使用框架了，因为我们的界面原则上没有复杂的元素，直接手写 CSS，300 行内基本上就可以解决问题。可能有人会觉得这不可能，实际情况是当你写样式只跑在 Chrome 里面的时候那感觉完全爽到飞起，CSS variable/flex/grid/calc/vh/rem 什么的都可以拿来用，实现一个功能的成本就降低了很多。&lt;/p&gt;

&lt;p&gt;我使用 &lt;a href=&#34;https://codemirror.net/&#34; title=&#34;codemirror&#34;&gt;Codemirror&lt;/a&gt; 来做为主界面的代码编辑器，&lt;a href=&#34;https://microsoft.github.io/monaco-editor/index.html&#34; title=&#34;monaco&#34;&gt;Monaco&lt;/a&gt; 也是一个好选择，但是它有点过于庞大了，而且如果想要自定义功能得自己写很多实现&lt;/p&gt;

&lt;p&gt;主界面上的分割组件，使用了 &lt;a href=&#34;https://split.js.org/&#34; title=&#34;react split&#34;&gt;React-split&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;main-process&#34;&gt;Main process&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;主进程&lt;/strong&gt; 就是 electron 应用程序的进程，主要的区别在于主进程中可以调用一些与原生操作系统交互的 API，比如对话框、系统风格主题等。并且有 node 的运行时，可以引用 NPM 包。当然渲染进程也可以有 node 支持，但是我建议渲染进程中就只放一些纯前端的逻辑，这样的话方便后期把应用分离成 web 版&lt;/p&gt;

&lt;p&gt;因为我们要集成 Sass 编译功能，如果你也经历过 node-sass 的各种问题，那就应该果断选择 &lt;a href=&#34;https://github.com/sass/dart-sass&#34; title=&#34;dart-sass&#34;&gt;dart-sass&lt;/a&gt; — 使用 dart 实现，编译成了原生的 JS，没有依赖问题。dart-sass 我放在了 main process 中，因为我试过放在 render process 中会有各种报错。如果 web 端要实现这个功能就需要其它的解决办法了，比如做成一个 http 服务，让 web 调 http 服务。&lt;/p&gt;

&lt;p&gt;Babel 的话我是放在了 &lt;strong&gt;渲染进程&lt;/strong&gt; 中以 script 标签的方式调用，这样即使在 web 端 Babel 编译也是可用的。&lt;/p&gt;

&lt;p&gt;总之如果你使用 electron 构建应用并且引入的第三方 NPM 包可以 &lt;strong&gt;支持&lt;/strong&gt; 运行在客户端（浏览器）上，那就尽量把包放在渲染进程里面。&lt;/p&gt;

&lt;h3 id=&#34;构建工具&#34;&gt;构建工具&lt;/h3&gt;

&lt;p&gt;我使用 &lt;a href=&#34;https://parceljs.org/&#34; title=&#34;parcel js&#34;&gt;Parcel&lt;/a&gt; 来构建 React 而不是 Create React App。后者用来写个小应用还可以，稍微大一点的，需要定制化一些东西你就得 eject 出来一大堆 webpack 配置文件，即便是我已经用 webpack 开发过几个项目了，但是说实话我还是没用会 webpack。写 webpack 配置的时间足够我自己写 npm script 来满足自己的需求了。&lt;/p&gt;

&lt;h3 id=&#34;原生应用打&#34;&gt;原生应用打&lt;/h3&gt;

&lt;p&gt;使用 &lt;a href=&#34;https://www.electron.build/&#34; title=&#34;electron builder&#34;&gt;electron-builder&lt;/a&gt; 来打包到平台原生应用，并且如果你有 Apple 开发者账号的话应用还可以提交到 AppStore 上去。&lt;/p&gt;

&lt;p&gt;我目前的打包参数是这么配置的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;build&amp;quot;: {
        &amp;quot;productName&amp;quot;: &amp;quot;Code Sketch&amp;quot;,
        &amp;quot;extends&amp;quot;: null,
        &amp;quot;directories&amp;quot;: { &amp;quot;output&amp;quot;: &amp;quot;release&amp;quot; },
        &amp;quot;files&amp;quot;: [
            &amp;quot;icon.icns&amp;quot;,
            &amp;quot;main.js&amp;quot;,
            &amp;quot;src/*.js&amp;quot;,
            &amp;quot;所有需要的文件&amp;quot;,
            &amp;quot;package.json&amp;quot;,
            &amp;quot;node_modules/@babel&amp;quot;,
            &amp;quot;node_modules/sass&amp;quot;
        ],
        &amp;quot;mac&amp;quot;: {
            &amp;quot;icon&amp;quot;: &amp;quot;icon.icns&amp;quot;,
            &amp;quot;category&amp;quot;: &amp;quot;public.app-category.productivity&amp;quot;,
            &amp;quot;target&amp;quot;: [ &amp;quot;dmg&amp;quot; ]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在你的 package.json 中添加 build 字段，productName, directories 这些按自己需要更改即可&lt;/p&gt;

&lt;h2 id=&#34;四-分离开发环境&#34;&gt;四、分离开发环境&lt;/h2&gt;

&lt;h3 id=&#34;区分开开发环境&#34;&gt;区分开开发环境&lt;/h3&gt;

&lt;p&gt;代码画板项目开过过程中涉及两个关键环境&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Parcel 构建环境（渲染进程）&lt;/strong&gt;：Parcel 可以为你提供一些现在 JS 的转译工作，因此你可以放心使用例如 ES6 的 JS 新特性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Node.JS 运行环境（主进程+渲染进程）&lt;/strong&gt;：这个取决于你的 electron 版本中集成的是 node 版本，比如：Node 10 中就没有 ES Module，这意味着你如果要在 electron &lt;strong&gt;主进程&lt;/strong&gt; 是无法识别 &lt;code&gt;import&lt;/code&gt; 这样的语句的，但是渲染进程由于你使用了 Parcel 编译，则无需考虑&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;*这里温馨提示下*：想要做到 electron 中的 渲染进程与主进程之间共享 JS 代码是非常困难的。就算是有办法也会特别的别扭，我的建议是尽量分离这两个进程中的代码，&lt;strong&gt;主进程主要做一些系统级别的 API 调用、事件分发等，业务逻辑尽量放在渲染进程中去做&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果非要共享，那建议单独做成一个 NPM 包分别做为主进程运行时依赖，和渲染进程的 Parcel 编译依赖，唯一的缺点就是实际上共享的代码会有两份。&lt;/p&gt;

&lt;p&gt;渲染进程中调用 node API 可能会和 Parcel 打包工具冲突，一般在调用比如文件模块时，可以加上 &lt;code&gt;window.require(‘fs’)&lt;/code&gt; 这样就可以兼容两个环境：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;get ipc() {
    if (window.require) {
        return window.require(&#39;electron&#39;).ipcRenderer
    } else {
        return { on() {}, send() {}, sendToHost() {} }
    }
}
this.ipc.send(&#39;event&#39;, data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话你在浏览器端调试也不会产生报错。一般情况下，建议当你用渲染进程中的 JS 引用（&lt;code&gt;require&lt;/code&gt;）包的时候都加上 &lt;code&gt;window.&lt;/code&gt; 前缀就可以了。因为渲染进程中 window 是全局变量，调用 &lt;code&gt;require&lt;/code&gt; 和调用 &lt;code&gt;window.require&lt;/code&gt; 是等价的&lt;/p&gt;

&lt;h3 id=&#34;开发流程&#34;&gt;开发流程&lt;/h3&gt;

&lt;p&gt;通常在测试的时候应用会调用一些 electron 内置的系统级别 API，这部分调用通常需要启动 electron，但是有时候只有渲染进程中 UI 界面上的改动，就不用再启动 electron 了，直接在浏览器里面测试即可。使用 Parcel 运行一个本地的服务，这样就可以在浏览器里面调试页面。整个开发过程需要两个命令（NPM Script）：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;启动 Parcel 编译服务器&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;./node_modules/.bin/parcel index.html -p 2044&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*调试 electron 原生功能*，注意设置 &lt;code&gt;ELECTRON_START_URL&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;scripts&amp;quot;: {
    &amp;quot;dev&amp;quot;: &amp;quot;ELECTRON_START_URL=http://localhost:2044 yarn electron&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;技术难点&#34;&gt;技术难点&lt;/h3&gt;

&lt;p&gt;整个应用只有两个功能是需要我们自己写代码实现的：日志控制台，Sublime 命令行。我们分别来分析下这两个模块的难点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;日志控制台&lt;/strong&gt; 的难点在于，我们需要打印任意类型的 JS 值。如果你对 JS 了解比较多的话自然会想到在 JS 中所有的东西都是 &lt;strong&gt;对象&lt;/strong&gt;，即 Object，那么实际上当你想打印一个变量的时候，其实你只要把整个 Object 递归的遍历出来，然后做成一个无限级的下拉菜单就可以了。看起来大概想下面这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/18901/35/10834/23415/5c890f3bE71a4d189/3e2bf8c0a6f5eb0a.png&#34; alt=&#34;logger&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sublime 命令行&lt;/strong&gt; 实际上开发起来还是比较简单的，使用 React 很简单就实现了功能，比较麻烦的是调用 bootcdn 的接口，过程中我发现接口返回数据量还是挺大的，有必要做上一层 localStorage 缓存，加快二次打开速度。&lt;/p&gt;

&lt;p&gt;然而在使用的过程中你会发现当我想插入一个前端库需要很多操作，因为有 &lt;strong&gt;三级选择&lt;/strong&gt;：库-版本-CDN 链接。虽然这个流程解决了 &lt;strong&gt;所有用户&lt;/strong&gt; 的使用问题，但是却损害了 &lt;strong&gt;大部分&lt;/strong&gt; 用户的体验。这个时候插入一个常用库的成本就很高了，所以我们就要加上一些快捷入口，来实现一键插入流行框架。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/15567/2/10960/38060/5c89b038Ebf681113/6c169122ab1eb903.png&#34; alt=&#34;sublime-commend-p&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我们写代码的思路是满足所有用户的使用需求，但是一个好产品的思路是先满足大多数用户（80%）的常规需求，再让其余的用户（20%）可以有选择&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还有一个问题比较典型就是 React 这类框架在渲染大列表并且进行过滤（关键字查询）时性能的问题。注意这个性能问题 &lt;strong&gt;并不是&lt;/strong&gt; 引入框架产生的，真正的原因是当你渲染的 HTML 节点数以千计的时候，批量操作 DOM 会使得 DOM Render 特别慢。&lt;/p&gt;

&lt;p&gt;所以说当我们遇到性能问题的时候应该去查找问题的根源，而不是停留在框架使用上，实际上在 DOM 操作这个层面来讲 jQuery 提供了更多的性能优化，比如自身的缓存系统，以致于当你在使用的时候很难发现有性能问题。但是在类 React 框架中它们框架本身的重点并不在于解决你应用的性能问题。&lt;/p&gt;

&lt;p&gt;类似我们上面讲到的，实际上 jQuery 帮助你屏蔽了很多舞台背后的东西，以致于你可以不用操心技术细节，你甚至可以把 jQuery 当做一个 &lt;strong&gt;产品&lt;/strong&gt; 来使用，而类 React 框架你却要亲力亲为的用他来设计你的代码。&lt;/p&gt;

&lt;p&gt;话题再转回性能问题。这时候需要我们去实现一个类似于 &lt;a href=&#34;https://addyosmani.com/blog/react-window/&#34;&gt;react-window&lt;/a&gt;  的功能，让列表元素根据滚动按需加载。这可能是一种通用的解决大列表加载的方案，但是我的解决方法更粗暴，因为我们的下拉过滤功能使用时用户只关注 &lt;strong&gt;最佳的匹配项&lt;/strong&gt; 即可，后面匹配程度不高的项可以直接限制数量裁剪就行了嘛。很少有用户会一直滚动到下面去查找某个选项，如果有，那就说明我们这个匹配做的有问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice() {
    const idx = (this.props.itemsPerPage || 50) * (this.state.activeFrame + 1)
    return this.props.items.slice(0, idx)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个匹配筛选的状态大概是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.state = {
    // 当前第N步选择
    step: 0,
    // 当前步骤数据
    items: [],
    // 是否显示
    active: false,
    // 当前选中项
    current: {},
    // 过滤关键字
    keyword: &#39;&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 &lt;code&gt;items&lt;/code&gt; 是当前步骤的所有数据，实际上我们这个组件是支持无限级的扩展的，那么我们通过组件的 props 传入所有层级的数据，然后持久存储在内存中。这个 &lt;strong&gt;所有层级的数据&lt;/strong&gt; 是数据结构层面的，实际上它可能是通过异步接口获取的。&lt;/p&gt;

&lt;p&gt;再来看看我们组件提供的所有 &lt;code&gt;props&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static defaultProps = {
    step: 0,
    active: false,
    data: [[]],    // 无限层级数据 [[], [], [], ...]
    // 数据的主键，用于钩子函数返回用户选择的结果集
    pk: &#39;id&#39;,

    autoFocus: true,
    activeCls: &#39;active&#39;,
    delay: 300,
    defaultSelected: 0,
    placeholder: &#39;&#39;,
    async: false,
    alias: [],
    done: () =&amp;gt; {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些数据都可以通过组件的 props 传入，这就意味着我们的这个组件才是真正的组件，别人也可以使用这样的功能，而他们并不用在意里面的细节，使用者只需要做好类似调用自己接口的这种业务逻辑。&lt;/p&gt;

&lt;p&gt;组件的调用大概是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;CommandPalette step={0}
    key=&amp;quot;CommandPalette&amp;quot;
    async={injectData}
    done={this.done.bind(this)}
    alias={alias}
    aliasClick={this.aliasClick.bind(this)}
    data={[ [], [], [] ]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;async&lt;/code&gt; 这个 props 实际上是一个异步调用的钩子方法，它会回传给你组件上当前操作的相关数据状态，通过这些数据使用者就可以按自己的需求在不同的步骤上调用不同的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export const injectData = (step, item, results, cb) =&amp;gt; {
    const API = &#39;https://api.bootcdn.cn/libraries&#39;

    if (step === 0) {
        fetchData(`${API}.min.json`)
            .then(processLibraryData)
            .then(cb)
    } else if (step === 1) {
        // ...
    } else if (step === 2) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外关于 React 这里安利下自己翻译过的一个教程：&lt;a href=&#34;https://github.com/keelii/reactpatterns.cn&#34;&gt;React 模式&lt;/a&gt;，里面讲到 18 种短小精悍的 React 模式案例，非常简单易懂。&lt;/p&gt;

&lt;p&gt;还有一个小窍门，我们在适配暗色主题时，传统的方法是直接写两套主题 CSS 代码，实际上我们要使用 CSS Variable 的话完全没必要生成两套了，背景色，字体都做成 CSS 变量，切换的时候只需要动态往页面插入更新过的 CSS 变量值即可&lt;/p&gt;

&lt;p&gt;系统的一些参数想直接传给渲染进程也是比较麻烦的，我的做法是直接从主进程中的 loadUrl 方法上以 queryString 的方式传到渲染页面的 URL 上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const query = {
    theme: osTheme,
    app_path: app.getAppPath(),
    home_dir: app.getPath(&#39;home&#39;)
}

mainWindow.loadURL(process.env.ELECTRON_START_URL ? url.format({
    slashes: true,
    protocol: &#39;http:&#39;,
    hostname: &#39;localhost&#39;,
    port: 2044,
    query
}) : url.format({
    slashes: true,
    protocol: &#39;file:&#39;,
    pathname: path.resolve(app.getAppPath(), &#39;./dist/index.html&#39;),
    query
}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像程序运行时的一些参数（比如程序的根目录）也可以这么动态传过去，而且还有一个好处就是你甚至可以在渲染进程中测试与这些参数相关的功能。&lt;/p&gt;

&lt;h2 id=&#34;五-宣传&#34;&gt;五、宣传&lt;/h2&gt;

&lt;h3 id=&#34;demo-视频录制&#34;&gt;demo 视频录制&lt;/h3&gt;

&lt;p&gt;我会把最终所有功能的使用方法录制成一个视频，万一有人不不想下载你的软件，只是要了解一下，这就是个很好的方法。我同时上传到了 Youtube 和 bilibili 这两个平台，其它的都有广告就没必要了&lt;/p&gt;

&lt;p&gt;使用 Quicktime Player 即可，录制完使用 iMovie 转码成两倍速率的 mp4。如果你有兴趣还可以加上一段音乐什么的，让视频看起来更灵动&lt;/p&gt;

&lt;h3 id=&#34;域名申请&#34;&gt;域名申请&lt;/h3&gt;

&lt;p&gt;域名是一个能让用户记住你产品的方法，如果你做的是一个成型的产品，那就一定要申请个域名。&lt;/p&gt;

&lt;p&gt;我总是有这样的体验，有的时候看到一个非常不错的产品但由于当时没需求就忽略了，想起来或者突然有需求的时候缺记不起来名字叫什么了。&lt;/p&gt;

&lt;p&gt;事实上代码画板最开始我给他起的名字是 code playground，这个更直观，但是名字太长，而且想用到的一些域名呀、Github 名、NPM 包都被注册了。&lt;/p&gt;

&lt;p&gt;想来想去就换成了 code sketch，这和符合我们的设计初衷，即：一边是代码，一边是效果/草图&lt;/p&gt;

&lt;p&gt;域名申请我一般会上 Godaddy，不用备案，.com 域名一年 ¥65.00，然后 DNS 服务器转到了 cloudflare，后续域名也会直接转到 cloudflare。因为据说以后在 cloudflare 上续费域名最便宜&lt;/p&gt;

&lt;h3 id=&#34;网站搭建&#34;&gt;网站搭建&lt;/h3&gt;

&lt;p&gt;宣传网站直接放在 github pages 上，做个自定义域即可，实在是太方便了。而且还有 SSL 支持，Github 真的是业界良心&lt;/p&gt;

&lt;p&gt;web 版的代码画板，由于我们把渲染进程中的代码分离开发，所以直接把 parcel 打包出来的静态文件也做成 github pages 就可以了，爽歪歪，网站就等于一分钱不花了。后续做一些 web 版的增强功能时，可以做成前后端分离的 http 服务，这就是后话了&lt;/p&gt;

&lt;h3 id=&#34;加入-google-analytics-代码&#34;&gt;加入 Google analytics 代码&lt;/h3&gt;

&lt;p&gt;GA 可以让你了解网站的用户分布情况，清楚的知道网站访问的波动。比如说你把自己的链接放到某个网站上分享了，GA 里面就能看出来所有的推荐来源和波动，对于运营来说是非常有必要的&lt;/p&gt;

&lt;h3 id=&#34;广告语&#34;&gt;广告语&lt;/h3&gt;

&lt;p&gt;这个我还真想了好长时间，基于我对于代码画板的定义，我觉得它应该是一个我们有一个想法的时候需要快速去实现一个 demo 的地方，想来想去就定了一段看起来文邹邹的话，虽然听名字根本不知道它是干啥用的，但是没关系，程序员写东西就是要有个性，因为我的受众只有自己。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;First place where the code was written&amp;hellip;
一个你最初写代码的地方&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;六-汇总使用到的库与工具&#34;&gt;六、汇总使用到的库与工具&lt;/h2&gt;

&lt;p&gt;麻雀虽小，五脏俱全。我们来看下代码画板总共用到了多少东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;框架/库

&lt;ul&gt;
&lt;li&gt;electronjs&lt;/li&gt;
&lt;li&gt;react&lt;/li&gt;
&lt;li&gt;babeljs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;NPM 模块

&lt;ul&gt;
&lt;li&gt;codemirror 及其插件&lt;/li&gt;
&lt;li&gt;react-split&lt;/li&gt;
&lt;li&gt;sublime-command-palette&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;打包/工具

&lt;ul&gt;
&lt;li&gt;parceljs&lt;/li&gt;
&lt;li&gt;electron-builder&lt;/li&gt;
&lt;li&gt;bootcdn&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设计与素材

&lt;ul&gt;
&lt;li&gt;sketch&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tweaknow.com/appicongenerator.php&#34;&gt;Free AppIcon Generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Inconsolata 字体&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://benschwarz.github.io/gallery-css/&#34; title=&#34;pure css gallery&#34;&gt;Gallary CSS&lt;/a&gt; 纯 CSS 实现的焦点图，用于宣传页展示&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;七-结语总结&#34;&gt;七、结语总结&lt;/h2&gt;

&lt;p&gt;实事上我自己的开发这个应用的时候并没有严格按照这篇文章的顺序执行，而是想到一些实现一些，可能一个功能实现了后来觉得不好又干掉了，是不断的取舍、提炼的结果。&lt;/p&gt;

&lt;p&gt;开发中我也不断的问自己这个功能是否有必要，如果可有可无那是不是可以去掉，这样才能使得用户更加关注于代码本身。&lt;/p&gt;

&lt;p&gt;整个开发过程中自己实现的功能模块并不多，只有控制台、命令行窗口是自己实现的，其它的功能基本上都是靠社区现有的工具库来完成的，从这一点来说前端技术的生态还是挺好的。这使得当我从整体上构思一个产品时我不必在意那些细节，虽然过程中还是能感觉到前端工具/库的割裂感，但是整体而言还是向好的，毕竟工具对于开发者只是一种选择的。&lt;/p&gt;

&lt;p&gt;八、引用&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/keelii/code-sketch&#34; title=&#34;code-sketch-source&#34;&gt;https://github.com/keelii/code-sketch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tweaknow.com/appicongenerator.php&#34;&gt;http://www.tweaknow.com/appicongenerator.php&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://benschwarz.github.io/gallery-css/&#34;&gt;http://benschwarz.github.io/gallery-css/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://addyosmani.com/blog/react-window/&#34;&gt;https://addyosmani.com/blog/react-window/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/keelii/reactpatterns.cn&#34;&gt;https://github.com/keelii/reactpatterns.cn&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>开源一个自己写的代码画板</title>
      <link>https://keelii.com/2019/03/06/open-source-code-sketch/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:24 +0000</pubDate>
      
      <guid>https://keelii.com/2019/03/06/open-source-code-sketch/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://code-sketch.com/&#34;&gt;Code sketch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/keelii/code-sketch&#34;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/keelii/code-sketch/releases/download/v0.0.2/Code.Sketch-0.0.2.dmg&#34;&gt;下载 macOS 应用(.dmg)&lt;/a&gt;，基于 electron，不喜欢的也可以使用 &lt;a href=&#34;https://web.code-sketch.com/&#34;&gt;Web 版&lt;/a&gt; 但非全功能支持版&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码画板-code-sketch&#34;&gt;代码画板 Code Sketch&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;最初写代码的地方&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;功能&#34;&gt;功能&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;内置 Sass/Babel 支持&lt;/li&gt;
&lt;li&gt;HTML/CSS emmet 插件支持&lt;/li&gt;
&lt;li&gt;方便的导入三方库 (&lt;a href=&#34;https://www.bootcdn.cn/&#34;&gt;bootcdn&lt;/a&gt; API 支持).&lt;/li&gt;
&lt;li&gt;深色主题支持&lt;/li&gt;
&lt;li&gt;可以打印任意数据格式的控制台&lt;/li&gt;
&lt;li&gt;同时支持 &lt;a href=&#34;http://code-sketch.com&#34;&gt;macOS App&lt;/a&gt; 与 &lt;a href=&#34;http://web.code-sketch.com&#34;&gt;Web 端应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;快捷键&#34;&gt;快捷键&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;切换展示顶部页签: &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;代码字体大小: &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;+/-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;保存刷新: &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;导出到单个 HTML 文件: &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;shift&lt;/code&gt;+&lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;导入文件（仅支持展出文件）: &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;命令提示容器: &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;截图&#34;&gt;截图&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;浅色主题&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://code-sketch.com/image/code-sketch-light-theme.png&#34; alt=&#34;code-sketch-light&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;深色主题&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://code-sketch.com/image/code-sketch-dark-theme.png&#34; alt=&#34;code-sketch-dark&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;错误日志&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://code-sketch.com/image/code-sketch-error-log.png&#34; alt=&#34;log&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;控制台日志&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://code-sketch.com/image/code-sketch-console-log.png&#34; alt=&#34;error&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;开发&#34;&gt;开发&lt;/h3&gt;

&lt;p&gt;yarn or npm&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yarn install
yarn start
yarn dev
# build release for mac
yarn release
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;支持&#34;&gt;支持&lt;/h3&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>理解比平等更重要</title>
      <link>https://keelii.com/2019/01/06/empathy-is-better-than-equality/</link>
      <pubDate>Sun, 06 Jan 2019 19:29:27 +0000</pubDate>
      
      <guid>https://keelii.com/2019/01/06/empathy-is-better-than-equality/</guid>
      <description>&lt;p&gt;很早以前就想聊聊这个话题，但是一直没机会。昨天看完电影《无名之辈》后让我心里突然有了一点感想。这便记录下来&lt;/p&gt;

&lt;p&gt;这部片子的剧情围绕着几小人物之间展开。一心想做协警的保安、一辈子想出人头地的劫匪、一个遭遇了车祸身体瘫痪的女孩、一心只想赚钱娶媳妇过日子普通男人…&lt;/p&gt;

&lt;p&gt;这些角色在我们现实生活中实在是太普通了，而且都处在社会底层。每个人对背负着生活压力，每人个都过着悬崖勒马日子。为了生存和仅有的那点「并不远大的」理想坚持前行&lt;/p&gt;

&lt;p&gt;中间那段胡广生痛骂电视台恶搞他们抢劫的桥段，让我感触很深。电视上那些转微博、发视频娱乐的网友不就是我们自己么，我们经常在网站上看到一些匪夷所思的新闻：一个没有智商的劫匪，拿上一杆枪，跑到手机店里面去抢手机。抢完了才发现是手机模型。这个事情在普通人看来真的是荒诞极了，简直是搞笑，大家都来消费这种新闻。却没有人真的去思考劫匪为什么会做这么愚蠢的事情&lt;/p&gt;

&lt;p&gt;谁知道这个愚蠢的劫匪是一个没见过大世面的农村小伙，不识字，也没什么文化；一心想进城干大事，胸中充满了对生活的渴望。可是谁又知道他进城后遭受了些什么、被多少人排斥、鄙视。现实中处处碰壁，梦想被别人看的一文不值。这种落差感长久积存在心里，有一天终于爆发了，他开始报复社会，打架、抢劫&lt;/p&gt;

&lt;p&gt;胡广生在电视上看见网友的恶搞时情绪完全崩溃，他撕心裂肺的哭着骂到：「老子要是犯法、你抓老子啊，关老子，你枪毙老子，老子认帐啊，为啥要恶搞老子、侮辱老子」&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;他是多么强大，强大到不怕犯法被枪毙；他又多么可怜，可怜没人尊重他，没人理解他&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;我们总是在网络上看到很多人在讲平等。各种阶层，各种角色&lt;/p&gt;

&lt;p&gt;员工与老板的平等、父母和子女的平等、老师与学生的平等、女人和男人的平等、穷人与富人的平等。归结起来只有一种：&lt;strong&gt;强势者和弱势者的平等&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但是实际上强势者强的本质是与生俱来的：老板有权利的优势、父母/老师有地位的优势、男人有生理的优势、富人有家族的优势&lt;/p&gt;

&lt;p&gt;在这些角色之间要求平等是一件很「无理」的事情。举个简单的例子，人都是动物，都有动物的本性，一个高个子的人站在矮个子的人旁边，根本不用讲话，高个子的人会有一种原始的身体上的气势压迫感，矮个子的人会有原始的一种害怕与自我防卫的反应。当然人类是高级动物，人类可以通过语言、眼神的沟通来降低这种差异感。但是本质上讲这两种人的「不平等」是改变不了的，尤其是高个子的人，即使你有很好的修养、很高的受教育程度，这种与生俱来的东西也是没办法完全抹去的。事实上这两个人是没法平等的，你总不能要求别人和你长得一样高吧&lt;/p&gt;

&lt;p&gt;为什么现在很多人要求所谓平等。是因为「平等」这个词可以「量化」。你有的东西我也必须有，你能做的事情我也可以做。这种感觉就像是我们开发了一个复杂的系统，我们需要有一个能实时检测到异常的监控系统，因为监控系统可以量化一个系统的好坏，可以给出一个简单的评价标准。但是监控并不能解决系统本身的好坏问题。与其花费大量精力在监控上面，不如多花时间来了解系统的核心逻辑，各个个部件之间的关系。这样的话即使系统出了问题也是在可预测范围内，监控也只是锦上添花的一个部件&lt;/p&gt;

&lt;p&gt;回到主题上，那么为什么理解或者说*同理心*更重要呢。&lt;/p&gt;

&lt;p&gt;这要从人的情感说起，其实人类是一种非常奇怪的生物，个体之间的差异让你很难理解对方的一些情绪变化。很多人都觉得很了解自己（我也是），实际上并不是的。我就有个非常困扰自己的问题，每当我唱歌非常投入的时候，唱到那么两句伤感的歌词时七窍都会有反应，我自己有的时候也在想，实际上我唱的歌词可能和我境遇半毛钱关系都没有，怎么会有这种反应呢。后来慢慢的我就理解了，因为人和人是不一样的，我们彼此有不同的年龄、性别、生活经历，同时在情感方面人又非常的奇怪，可能有的人会因为一句诗词而哭泣，可能有人会因为一段音乐而哭泣，有的人会因为一张泛黄的照片而哭泣，不同的人有不同的感受周围世界的能力，你通过视觉，别人通过听觉嗅觉。同时这些东西被记忆在大脑内的时候是立体的，全方位的。可能就是某个动作触发到了深藏在大脑中的一幅画面，瞬间你就会想起当时的天气，人物、气氛等，然后立马产生了真情的流露。从这一点来看人的大脑比起计算机简直高得不知道到哪里去了&lt;/p&gt;

&lt;p&gt;以前我老看见电视上很多追星族，在演唱会上痛哭流涕，激动不已。我就很难理解，怎么会有这种人呢，真的是歌手唱的好听吗？可是一首歌又能有多好听呢。然后上大学时听了很多的摇滚乐，当时的状态就是：*我觉得年轻时不喜欢摇滚乐是有病吧*。到现在为止我也没去听过场摇滚演唱会，但是我可以想像到如果我去了，绝对也是和大部分人一样的那种摇头晃脑，疯狂呐喊，兴奋不已的状态。&lt;/p&gt;

&lt;p&gt;所以说，看到一些匪夷所思的事情的时候不要急于去评价，或者下结论。试着去理解一下对方的境遇，万一自已经说错话了那也不要紧，承认自己的错误其实并没有那么困难，可能在你看来很简单的一句话就会让对方感受到整个世界的温柔&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/15866/25/4364/88758/5c31d782Ed9a2fc0a/4efb1466c3229758.jpg&#34; alt=&#34;empathy&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图：&lt;a href=&#34;https://www.pexels.com/photo/photography-of-body-of-water-and-mountains-1544880/&#34;&gt;https://www.pexels.com/photo/photography-of-body-of-water-and-mountains-1544880/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>名不正则言不顺，是这样的吗？</title>
      <link>https://keelii.com/2019/01/01/political-correctness-then-freedom-of-speech/</link>
      <pubDate>Tue, 01 Jan 2019 19:29:27 +0000</pubDate>
      
      <guid>https://keelii.com/2019/01/01/political-correctness-then-freedom-of-speech/</guid>
      <description>&lt;p&gt;名正言顺这个成语大家都知道，尤其在一些政治典故中经常被提及。今天就来聊聊这个话题&lt;/p&gt;

&lt;p&gt;名正言顺的梗概出自于《论语·子路》中孔子和子路的一段对话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;子路曰：“卫君待子而为政，子将奚先？”&lt;/p&gt;

&lt;p&gt;子曰：“必也正名乎！”&lt;/p&gt;

&lt;p&gt;子路曰：“有是哉，子之迂也！奚其正？”&lt;/p&gt;

&lt;p&gt;子曰：“野哉由也！君子于其所不知，盖阙如也。&lt;strong&gt;名不正，则言不顺；言不顺，则事不成；事不成，则礼乐不兴；礼乐不兴，则刑罚不中；刑罚不中，则民无所措手足&lt;/strong&gt;。故君子名之必可言也，言之必可行也。君子于其言，无所苟而已矣。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大概意思是说：&lt;/p&gt;

&lt;p&gt;子路问孔子：“如果让你去卫国执政，你首先会做什么？”&lt;/p&gt;

&lt;p&gt;孔子说：“一定要先找对名份！”&lt;/p&gt;

&lt;p&gt;子路说：“是这样的吗？，你也太迂腐了吧，名份有什么用？”&lt;/p&gt;

&lt;p&gt;孔子说：“你太粗野了！君子对于不懂的事情，一般都采取保留意见。名分不正当，说话就不合理；说话不合理，事情就办不成。事情办不成，法律就不能深入人心；法律不能深入人心，刑罚就不会公正；刑罚不公正，老百姓就会手足无措…”&lt;/p&gt;

&lt;p&gt;正名的「名」就是名份的「名」。是古代官场政治制度下的一种阶级角色感，也是儒家思想核心部分 &lt;strong&gt;礼&lt;/strong&gt; 的角色感。如：君臣、父子、兄弟，各个角色应该做什么事情才是正确的，被提倡的&lt;/p&gt;

&lt;p&gt;比如说《八佾》中开篇第一段：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;孔子谓季氏：“八佾舞于庭，是可忍也，孰不可忍也？”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;意思是说这个季氏用天子的舞蹈阵容在自己家里开 Party。「佾yì」就是舞蹈队伍中的列，天子八列、诸侯六列、大夫四列、士二列，每佾八人。孔子要从政得先正名，正名就要先把礼放在第一位，没有礼的话就会成为君不君、臣不臣、父不父、子不子的状态，这种「八佾舞于庭」的行为在孔子看来就是大逆不道，绝不能忍的事情&lt;/p&gt;

&lt;p&gt;再如：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;定公问：“君使臣，臣事君，如之何？”孔子对曰：“君使臣以礼，臣事君以忠。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;意思是 定公问孔子：“上级怎样对待下级？下级怎样对待上级？”孔子答：“上级尊重下级，下级忠于上级。”&lt;/p&gt;

&lt;p&gt;其实古文是非常精炼的，有的句子我们根本不需要全部搞懂是什么意思，只看几个字眼儿就明白了，比如上面的：君 &lt;strong&gt;使&lt;/strong&gt; shǐ 臣，臣 &lt;strong&gt;事&lt;/strong&gt; shì 君。*使* 就是驱使、使唤；*事* 就是为人做事、服侍的意思。我觉得这句话问之前就有了定位，根本不需要再回答&lt;/p&gt;

&lt;p&gt;封建社会，人们对于名份的认同感处处可见。春秋时期的尊王攘夷，三国时期曹操奉天子以令不臣，刘备打江山也要号称汉景帝阁下玄孙，这些都是政治场上的所谓的正名&lt;/p&gt;

&lt;p&gt;当这种思想蔓延到整个现代社会甚至是家庭里面的时候就更值得思考了&lt;/p&gt;

&lt;p&gt;儒家思想中关于礼的部分我更倾向于认同它的角色感，这一点是古今通用的。现实生活中我们经常会有一种感觉：同样是一句话从某些人口中说出来就很合情合理，从另外一些人口中说出来则让人很难理解甚至气愤。就是因为中国人讲话是非常讲究角色和场合的&lt;/p&gt;

&lt;p&gt;比如说：我（男的）看见一对男女聊天儿，谈到关于生活、工作的话题时，如果这个女的说：男人的一生很不容易，因为他们的一生都注定了要竞争，为钱、为权为了家人过得更好，他们们身上背负着很重的担子。&lt;/p&gt;

&lt;p&gt;当我做为一个男的听到这段话的时候会觉得这话说的很好听，让人很舒服，同时也非常佩服女的身上的那种同理心。但如果这段话是从这个男的口中说出来的我只会觉得这男的矫情娘娘腔，甚至我会找很多理由来推翻他的观点&lt;/p&gt;

&lt;p&gt;在男权社会下女人本来就是弱视的，社会能给予她们的不论是精神上的还是物质上的回报都没有男性多，相反男性天生就获得了更多的优待和资源，所以男性理应肩负更多的责任。事实上女性的一生更不容易，大部分的女性的一生会受到社会舆论家庭伦理方面的影响，以至于她们很少有自己的事业，健立家庭以后通常还有更多身体和精神上的付出，这使得她们几乎没机会做自己想做的事情&lt;/p&gt;

&lt;p&gt;所以说这个角色非常重要，但问题是当你定义了自己是什么样的角色时，再去看问题，其实本来就是不客观的。最终可能会形成一种非黑即白的观点偏见&lt;/p&gt;

&lt;p&gt;当我们今天再去回顾名正言顺的典故时，会发现即就是当下社会，大家还是有很多古时候遗留下来的碎片化的认识，这种认识会让人只相信权威的或者大众的观点，这种所谓名份上正确的角色传达出来的观点&lt;/p&gt;

&lt;p&gt;社会上的名流、功成名就的人说出来的话就是可信的，匹夫布衣甚至都没有说话的权利。所以说名正言顺真的就是正确的吗？难道只有先正其名然后才能有话语权？就算是个小人物，他也有自己的人生境遇，也有喜怒哀乐。只要人家说话有理有据，那就理当受到尊重&lt;/p&gt;

&lt;p&gt;名正言顺事实上讲的是一种政治上的正确，在国外也有很多这方面的讨论，比如说：Code of conduct，它就给出了一系列的准则，诸如人与人之间基本尊重、宗教、人种、道义方面的一些准则。这些准则在大多数人眼里是正确的，但是应不应该强加到其它不认同这个准则的人身上呢，或者说人们可不可以对里面的一些准则进行反驳&lt;/p&gt;

&lt;p&gt;《鸦片战争》大家都知道，船坚炮利的英帝国都打到天津港口了，道光皇帝还是那种处理边疆叛乱，攘除蛮夷的态度，整个大众的的意识形态还停留在天下都是天子的，天朝之外全是名份不正确的蛮族夷地，皇帝发诏告还是「奉天承运皇帝诏曰」的口气。真正枪炮打到脸上的时候才意识到疼&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ProseMirror 编辑器指南中文翻译版</title>
      <link>https://keelii.com/2018/12/09/prosemirror-guide-cn/</link>
      <pubDate>Sun, 09 Dec 2018 17:59:45 +0800</pubDate>
      
      <guid>https://keelii.com/2018/12/09/prosemirror-guide-cn/</guid>
      <description>

&lt;p&gt;这个指南介绍了很多编辑器的设计理念，以及他们之间的关系。想完整的了解整个系统，建议按顺序阅读，或者至少阅读视图组件部分&lt;/p&gt;

&lt;h2 id=&#34;简介-introduction&#34;&gt;简介 Introduction&lt;/h2&gt;

&lt;p&gt;ProseMirror 提供了一组工具和设计概念用来构建富文本编辑器，UI 的使用源于 WYSIWYG 的一些灵感，ProseMirror 试着屏蔽一些排版中的痛点&lt;/p&gt;

&lt;p&gt;ProseMirror 的主要原则是：*你的代码对于 &lt;strong&gt;文档&lt;/strong&gt; 及其事件变更有完整的控制权*。这个 &lt;strong&gt;文档&lt;/strong&gt; 并不是原生的 HTML 文档，而是一个自定义的数据结构，这个数据结构包含了通过你明确允许应该被包含的元素，它们的关系也由你指定。所有的更新都会在一个你可以查看并做出响应的地方进行&lt;/p&gt;

&lt;p&gt;核心的代码库并不是一个容易拿来就用的组合 — 我们会优先考虑 &lt;strong&gt;模块化&lt;/strong&gt; 和 &lt;strong&gt;可自定义&lt;/strong&gt; 化胜过简单化，希望将来有用户会基于 ProseMirror 分发一个拿来就用的版本。因此，ProseMirror 更像是乐高积木而不是火柴盒拼成的玩具车&lt;/p&gt;

&lt;p&gt;总共有四个核心模块，任何编辑行为都需要用到它们，还有很多核心团队维护的扩展模块，类似于三方模块 — 它们提供有用的功能，但是你可以删除或者替换成其它实现了相同功能的模块&lt;/p&gt;

&lt;p&gt;核心模块分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;prosemirror-model&lt;/code&gt; 定义了编辑器的文档模型，数据结构用来描述编辑器的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prosemirror-state&lt;/code&gt; 提供了整个编辑器状态的数据结构，包括选区和维护状态变化的事务系统&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prosemirror-view&lt;/code&gt; 实现一个用户界面组件，用来在浏览器中把编辑器的状态展示成可编辑元素，并且与其进行交互&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prosemirror-transform&lt;/code&gt; 包含了一种可以记录/重放文档修改历史的功能组件，这是 &lt;code&gt;state&lt;/code&gt; 模块中事务的基础，而且这还使得编辑器的恢复历史和协作编辑功能成为可能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，还有一些诸如 基础的编辑命令、快捷键绑定、恢复历史、输入宏、协作编辑，简单的文档骨架 的模块。&lt;a href=&#34;https://github.com/prosemirror/&#34; title=&#34;Prosemirror org&#34;&gt;Github prosemirror 组织&lt;/a&gt; 代码库中还有更多&lt;/p&gt;

&lt;p&gt;事实上 ProseMirror 并没有分发一个独立的浏览器可以加载的脚本，这表示你可能需要一些模块 bunder 来配合使用它。模块 Bunder 就是一个工具，用来自动化查找你的脚本依赖，然后合并到一个单独文件中，使你能很容易的在 web 面页中使用。你可以阅读更多关于 bundling 的东西，比如：&lt;a href=&#34;https://medium.freecodecamp.org/javascript-modules-part-2-module-bundling-5020383cf306&#34; title=&#34;JavaScript Modules Part 2: Module Bundling&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;我的第一个编辑器-my-first-editor&#34;&gt;我的第一个编辑器 My first editor&lt;/h3&gt;

&lt;p&gt;就像拼乐高积木一样，下面的代码可以创建一个最小化的编辑器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;
import {EditorState} from &amp;quot;prosemirror-state&amp;quot;
import {EditorView} from &amp;quot;prosemirror-view&amp;quot;

let state = EditorState.create({schema})
let view = new EditorView(document.body, {state})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ProseMirror 需要你为文档指定一个自己觉得合适的骨架（schema），所以上面的代码第一件事情就是引入一个基础骨架模块&lt;/p&gt;

&lt;p&gt;接着这个骨架被用来创建一个状态，它将按骨架的定义生成一个空的文档，光标会在文档最开始的地方。最后创建了一个与状态关联的视图，并且插入到 &lt;code&gt;document.body&lt;/code&gt;。这将会把状态的文档渲染成一个可编辑的 DOM 节点，并且一旦用户输入内容就会生成一个状态事务（transactions）&lt;/p&gt;

&lt;p&gt;现在这个编辑器还没什么用处。比如说当你按下回车键时没有任何反应，因为核心库并不关心回车键应该用来做什么。我们马上就会谈到这一点&lt;/p&gt;

&lt;h3 id=&#34;事务-transactions&#34;&gt;事务 Transactions&lt;/h3&gt;

&lt;p&gt;当用户输入或者与视图交互时，将会生成「状态事务」。这意味着它不仅仅是只修改文档并以这种方式隐式更新其状态。相反，每次更改都会触发一个事务的创建，该事务描述对状态所做的更改，而且它可以被应用于创建一个新状态，随后用这个新状态来更新视图&lt;/p&gt;

&lt;p&gt;这些过程都会默认地在后台处理，但是你可以写一个插件来挂载进去，或者通过配置视图的参数。例如，下面的代码添加了一个 &lt;code&gt;dispatchTransaction&lt;/code&gt; 属性（props），每当创建一个事务时都会调用它&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// (省略了导入代码库)

let state = EditorState.create({schema})
let view = new EditorView(document.body, {
  state,
  dispatchTransaction(transaction) {
    console.log(&amp;quot;Document size went from&amp;quot;, transaction.before.content.size,
                &amp;quot;to&amp;quot;, transaction.doc.content.size)
    let newState = view.state.apply(transaction)
    view.updateState(newState)
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次状态变化都会经过 &lt;code&gt;updateState&lt;/code&gt;，而且每个普通的编辑更新都将通过调度一个事务来触发&lt;/p&gt;

&lt;h3 id=&#34;插件-plugins&#34;&gt;插件 Plugins&lt;/h3&gt;

&lt;p&gt;插件用于以各种方式扩展编辑器和编辑器状态的状态，有的会非常简单，比如 快捷键 插件 — 为键盘输入绑定具体动作；有的会比较复杂，比如 编辑历史 插件 — 通过观察事务并逆序存储来实现撤销历史记录，以防用户想要撤消它们&lt;/p&gt;

&lt;p&gt;让我们为编辑器添加这两个插件来获取撤消（undo）/重做（redo）的功能：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// (Omitted repeated imports)
import {undo, redo, history} from &amp;quot;prosemirror-history&amp;quot;
import {keymap} from &amp;quot;prosemirror-keymap&amp;quot;

let state = EditorState.create({
  schema,
  plugins: [
    history(),
    keymap({&amp;quot;Mod-z&amp;quot;: undo, &amp;quot;Mod-y&amp;quot;: redo})
  ]
})
let view = new EditorView(document.body, {state})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当创建一个状态的时候插件就会被注册（因为插件需要访问状态事务），当这个开启了编辑历史状态的视图被创建时，你将可以通过按 &lt;code&gt;Ctrl-Z&lt;/code&gt; 或者 &lt;code&gt;Cmd-Z&lt;/code&gt; 来撤消最近的一次变更&lt;/p&gt;

&lt;h3 id=&#34;命令-commands&#34;&gt;命令 Commands&lt;/h3&gt;

&lt;p&gt;上面示例代码中的 &lt;code&gt;undo&lt;/code&gt; 和 &lt;code&gt;redo&lt;/code&gt; 变量值是绑定到指定键位的一种叫做 *命令* 的特殊值。大多数编辑动作都是作为可绑定到键的命令编写的，它可以用来挂载到菜单栏，或者直接暴露给用户&lt;/p&gt;

&lt;p&gt;&lt;code&gt;prosemirror-commands&lt;/code&gt; 包提供了许多基本的编辑命令，其中一些是你可以需要用到的基本的快捷键，比如 回车，删除编辑器中指定的内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// (Omitted repeated imports)
import {baseKeymap} from &amp;quot;prosemirror-commands&amp;quot;

let state = EditorState.create({
  schema,
  plugins: [
    history(),
    keymap({&amp;quot;Mod-z&amp;quot;: undo, &amp;quot;Mod-y&amp;quot;: redo}),
    keymap(baseKeymap)
  ]
})
let view = new EditorView(document.body, {state})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，你已经有了一个算得上可以使用的编辑器了&lt;/p&gt;

&lt;p&gt;添加菜单，额外的为特定骨架指定的快捷键绑定 等功能，可以通过查看 &lt;a href=&#34;https://github.com/prosemirror/prosemirror-example-setup&#34; title=&#34;prosemirror-example-setup&#34;&gt;prosemirror-example-setup&lt;/a&gt; 包了解更多。这个模块提供给你一组插件用来创建一个基础的编辑器，但是就像它的名字一样，只是个例子，并不是生产环境级别的代码库。真正的开发中，你可能会需要替换成自定义的代码来精确实现你想要的功能&lt;/p&gt;

&lt;h3 id=&#34;内容-content&#34;&gt;内容 Content&lt;/h3&gt;

&lt;p&gt;一个状态的文档被挂在它的 &lt;code&gt;doc&lt;/code&gt; 属性上。这是一个只读的数据结构，用各种级别的节点来表示文档，就像是浏览器的 DOM。一个简单的文档可能会由一个包含了两个「段落」节点，每个「段落」节点又包含一个「文本」节点的「文档」节点构成&lt;/p&gt;

&lt;p&gt;当初始化一个状态时，你可以给它一个初始文档。这种情况下，&lt;code&gt;schema&lt;/code&gt; 就变成非必传项了，因为 &lt;code&gt;schame&lt;/code&gt; 可以从文档中获取&lt;/p&gt;

&lt;p&gt;下面我们通过传入一个 DOM 元素 （ID 为 content）做为 DOM parser 的参数初始化一个状态，它将利用 &lt;code&gt;schema&lt;/code&gt; 中的信息来解析出对应的节点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {DOMParser} from &amp;quot;prosemirror-model&amp;quot;
import {EditorState} from &amp;quot;prosemirror-state&amp;quot;
import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;

let content = document.getElementById(&amp;quot;content&amp;quot;)
let state = EditorState.create({
  doc: DOMParser.fromSchema(schema).parse(content)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文档-documents&#34;&gt;文档 Documents&lt;/h3&gt;

&lt;p&gt;ProseMirror 定义了他自己的一种用来表示文档内容的数据结构。由于文档是构建所有编辑器的核心元素，了解它们的工作原理会对我们很有帮助&lt;/p&gt;

&lt;h3 id=&#34;结构-structure&#34;&gt;结构 Structure&lt;/h3&gt;

&lt;p&gt;一个 ProseMirror 文档就是一个节点，它包含一个片段，其中可以有一个或者多个子节点&lt;/p&gt;

&lt;p&gt;这个和浏览器 DOM 非常相似，浏览器 DOM 是一个递归的树型结构。但是 ProseMirror 的不同点在于它存储内联元素的方式&lt;/p&gt;

&lt;p&gt;在 HTML 中，一个段落的标记表示为一个树，就像这个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;This is &amp;lt;strong&amp;gt;strong text with &amp;lt;em&amp;gt;emphasis&amp;lt;/em&amp;gt;&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/14129/3/786/35284/5c0cc441E403d82b0/ef0b3f850962b393.png&#34; alt=&#34;prosemirror-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而在 ProseMirror 中，内联内容被建模为 &lt;strong&gt;扁平&lt;/strong&gt; 的序列，标记作为元数据附加到节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/15813/40/792/39752/5c0cc4e0Ee27f5876/150f7e117aa64233.png&#34; alt=&#34;prosemirror-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这更符合我们思考和使用此类文本的方式，这允许我们使用字符来表示位置而不是树的路径，这使得一些操作如分割、更改内容样式变得比维护树简单&lt;/p&gt;

&lt;p&gt;这也意味着每个文档都只有一种合法的表现层。具有相同标记集的相邻文本节点总是组合在一起，并且不允许有空文本节点，标记出现的顺序由骨架指定&lt;/p&gt;

&lt;p&gt;所以说一个 ProseMirror 文档就是一颗块级节点树，其中大多数叶子节点都是文本块，块级节点可以包含这些文本块儿。你也可以有一些空的叶子节点，比如水平分隔线或者视频元素&lt;/p&gt;

&lt;p&gt;节点对象有很多属性，它们代表所处文档中的角色：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isBlock&lt;/code&gt; 和 isInline 告诉你给定的节点是一个块级节点还是内联节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inlineContent&lt;/code&gt; 表示一个节点希望它的内容是是内联元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isTextblock&lt;/code&gt; 表示一个块级节点包含内联内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isLeaf&lt;/code&gt; 告诉你节点不允许有任何内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;典型的「段落」节点是一个文本节点，而「引用块」可能是一个包含其它块级元素的元素。文本、硬换行（&lt;br&gt;）以及内联图片都是内联叶子节点，水平分隔线节点则是一种块级叶子节点&lt;/p&gt;

&lt;p&gt;骨架允许你更准确地指定什么东西应该出现在什么位置，例如。即使一个节点允许块级内容，这并不表示他会允许所有的节点做为它的内容&lt;/p&gt;

&lt;h3 id=&#34;标识与存储-identity-and-persistence&#34;&gt;标识与存储 Identity and persistence&lt;/h3&gt;

&lt;p&gt;另外一个 DOM 树和 ProseMirror 文档不同的地方是，对象表示节点的行为。在 DOM 中，节点是具有标识的可变的对象，这表示一个节点只能出现在一个父节点中，当节点更新的时候对象也会被修改&lt;/p&gt;

&lt;p&gt;另外一方面，在 ProseMirror 中，节点仅仅是一些 *值*，和你想表示数字 3 一样，3 可以同时出现在很多数据结构中，它自己所处的部分与父元素没有连系，如果你给它加 1，你会得到一个新值 4，并且不用改变和原来 3 相关的任何东西&lt;/p&gt;

&lt;p&gt;所以它是 ProseMirror 文档的一部分，它们不会更改，但是可以用作计算修改后的文档的起始值。它们也不知道自己处在什么数据结构当中，但可以是多个结构的一部分，甚至多次出现在一个结构中。它们是值，不是状态化的对象&lt;/p&gt;

&lt;p&gt;这表示每当你更新文档，你将会获得一个新的文档值。文档值将共享所有子节点，并且不会修改原来的文档值，这使得它创建起来相对廉价&lt;/p&gt;

&lt;p&gt;这有很多优点。它可以使两次更新之间的过程无效（严格控制更新的内容和过程），因为具有新文档的新状态可以瞬间转换。它还使得文档以某种数学方式推理变得更容易，相反的如果你的值不断的在后台发生变化这将会很难做到。这也使得协作编辑成为可能，并允许 ProseMirror 通过将最后一个绘制到屏幕的文档与当前文档进行比较来运行非常高效的 DOM 更新算法&lt;/p&gt;

&lt;p&gt;由于此类节点使用了常规的 JavaScript 对象来表示，如果并且明确地冻结（&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&#34; title=&#34;freeze&#34;&gt;freezing&lt;/a&gt;）其属性可能会影响到性能，实际上属性是 *可以* 改变的，但是并不建议你这么做，这将会导致程序中断，因为它们几乎总是在多个数据结构之间共享。所以要小心！请注意，这也适用于作为节点对象一部分的数组和普通对象，例如用于存储节点属性的对象或片段中子节点的数组（译注：意思是你最好不要更改类似的内部对象，给对象添加或者删除属性）&lt;/p&gt;

&lt;h3 id=&#34;数据结构-data-structures&#34;&gt;数据结构 Data structures&lt;/h3&gt;

&lt;p&gt;一个文档的对象看起来像这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/9284/27/8310/83213/5c0cc4f2E3dca8ae6/dcc5b46f77995593.png&#34; alt=&#34;prosemirror-3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每个节点都是一个 Node 类的实例。都有一个 type 做为标签，通过 type 可以知道节点的名字，节点的属性字段也是有效的等等。节点的类型（和标识类型）每骨架会创建一次，他们知道自己属于骨架的哪个部分&lt;/p&gt;

&lt;p&gt;节点的内容存储在 Fragment 的一个实例中，它掌握着节点序列。即使节点没有或者不允许有内容，这个字段也会有值（共享的空 fragment）&lt;/p&gt;

&lt;p&gt;一些节点类型允许添加属性，它些值被存储到每个节点上。比如，图片节点一般会使用属性来存储 alt 文本和图片的 URL&lt;/p&gt;

&lt;p&gt;此外，内联节点包含一组活动标记 — 例如强调（emphasis）或链接（link）— 活动标记就是一组 Mark 实例&lt;/p&gt;

&lt;p&gt;整个文档就是一个节点。文档内容表现为一个顶级节点的子节点。通常，它将包含一系列块节点，其中一些块节点可能是包含内联内容的文本块。但顶级节点本身也可以是文本块，这样的话文档就只包含内联内容&lt;/p&gt;

&lt;p&gt;什么样的节点可以被允许，是由文档的骨架决定的。用代码的方式创建节点（而不是直接用基础骨架库），你必须通过骨架来实现，比如使用 &lt;code&gt;node&lt;/code&gt; 和 &lt;code&gt;text&lt;/code&gt; 方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;

// 如果需要的话可以把 null 参数替换成你想给节点添加的属性
let doc = schema.node(&amp;quot;doc&amp;quot;, null, [
  schema.node(&amp;quot;paragraph&amp;quot;, null, [schema.text(&amp;quot;One.&amp;quot;)]),
  schema.node(&amp;quot;horizontal_rule&amp;quot;),
  schema.node(&amp;quot;paragraph&amp;quot;, null, [schema.text(&amp;quot;Two!&amp;quot;)])
])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;索引-indexing&#34;&gt;索引 Indexing&lt;/h3&gt;

&lt;p&gt;ProseMirror 节点支持两种索引 — 它们可以看做是树，使用单个节点的偏移量，或者它们可以被视为一个扁平的标识（tokens）序列&lt;/p&gt;

&lt;p&gt;&lt;em&gt;第一种&lt;/em&gt; 允许你执行类似于对 DOM 与单个节点进行操作的交互，使用 &lt;code&gt;child&lt;/code&gt; 方法和 &lt;code&gt;childCount&lt;/code&gt; 直接访问子节点，编写扫描文档的递归函数（如果你只想查看所有节点，请使用 &lt;code&gt;descendants&lt;/code&gt; 或 &lt;code&gt;nodesBetween&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;&lt;em&gt;第二种&lt;/em&gt; 当访问一个文档中指定的位置时更好用。它允许把文档任意位置表示为一个整数 — 即标记序列中的索引。这些标识并不做为对象在内存中 — 它们仅仅是用来计数的惯例 — 但是文档的树形状以及每个节点都知道它的大小，这使得按位置访问变的廉价（译注：类似于用下标访问扁平数组，而不是递归遍历嵌套结构的树）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在第一个内容之前，文档的开头是位置 0&lt;/li&gt;
&lt;li&gt;进入或离开不是叶子节点的节点（即支持内容）计为一个&lt;strong&gt;标识索引位&lt;/strong&gt;。因此，如果文档以段落开头，则该段落的开头计为位置 1&lt;/li&gt;
&lt;li&gt;文本节点中的每个字符都算作一个标识索引位。因此，如果文档开头的段落包含单词「hi」，则位置 2 位于「h」之后，位置 3 位于「i」之后，位置 4 位于整个段落之后&lt;/li&gt;
&lt;li&gt;不允许有内容（例如图像）的叶子节点也算作 &lt;strong&gt;单个&lt;/strong&gt; 标识索引位&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，如果你有一个文档，当表示为 HTML 时，将如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;One&amp;lt;/p&amp;gt;
&amp;lt;blockquote&amp;gt;&amp;lt;p&amp;gt;Two&amp;lt;img src=&amp;quot;...&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标识序列以及位置下标，将会是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0   1 2 3 4    5
 &amp;lt;p&amp;gt; O n e &amp;lt;/p&amp;gt;

5            6   7 8 9 10    11   12            13
 &amp;lt;blockquote&amp;gt; &amp;lt;p&amp;gt; T w o &amp;lt;img&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个节点都有一个 &lt;code&gt;nodeSize&lt;/code&gt; 属性，可以为告诉你整个节点的大小，你可以访问 &lt;code&gt;.content.size&lt;/code&gt; 来获取节点 *内容* 的大小。注意，对于外部文档节点，打开和关闭标记不被视为文档的一部分（因为你无法将光标放在文档外面），因此文档的大小为 &lt;code&gt;doc.content.size&lt;/code&gt;，而不是 &lt;code&gt;doc.nodeSize&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;手动解释这样的位置会涉及相当多的计数操作。你可以调用 &lt;code&gt;Node.resolve&lt;/code&gt; 来获取关于节点位置的更具有描述性的数据结构。这个数据结构将告诉你该位置的父节点是什么，它与父节点的偏移量是什么，父节点的祖先是什么，以及其他一些东西&lt;/p&gt;

&lt;p&gt;注意区分子索引（每个 childCount），文档范围的位置和 &lt;code&gt;node-local&lt;/code&gt; 偏移（有时在递归函数中用于表示当前正在处理的节点中的位置）&lt;/p&gt;

&lt;h3 id=&#34;切片-slices&#34;&gt;切片 Slices&lt;/h3&gt;

&lt;p&gt;为了处理一些诸如复制/粘贴和拖拽之类的操作，通过切片与文档进行通信是非常必要的，比如，两个位置之间的内容。这样的切片不同于整个节点或者片段，一些节点可能位于切片开始或者结束（译注：切片的开始位置可能在某个节点的中间）&lt;/p&gt;

&lt;p&gt;例如，从一个段落的中间选择到下一个段落的中间，你所选择的切片中会有两个段落，那么切片的开始位置在第一个段落打开的地方，结束位置就在第二个段落打开的地方。然而如果你 node-select 一个段落，你就选择了一整个有关闭的节点。可能的情况是，如果将此类开放节点中的内容视为节点的完整内容，则会违反骨架约束（标签可能没关闭），因为某些所需节点落在切片之外&lt;/p&gt;

&lt;p&gt;Slice 数据结构用于表示这样的切片。它存储一个 fragment 以及两侧的 节点打开深度（open depth）。你可以在节点上使用切片方法从文档外剪切切片&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/*
0   1 2 3   4
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
4   5 6 7   8 
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
*/
// doc holds two paragraphs, containing text &amp;quot;a&amp;quot; and &amp;quot;b&amp;quot;
let slice1 = doc.slice(0, 3) // The first paragraph
/*
0|   1 2 3   |4
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
*/
console.log(slice1.openStart, slice1.openEnd) // → 0 0
let slice2 = doc.slice(1, 5) // From start of first paragraph
                             // to end of second
/*
0  1| 2 3   4
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
4    5|6 7   8 
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
*/
console.log(slice2.openStart, slice2.openEnd) // → 1 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;更改-changing&#34;&gt;更改 Changing&lt;/h3&gt;

&lt;p&gt;由于节点和片段是持久存储的，因此 &lt;strong&gt;永远&lt;/strong&gt; 不要修改它们。如果你有文档（或节点或片段）的句柄，那这个句柄引用的对象将保持不变（译注：这意味着并不能通过拿到的引用直接修改节点，因为这个节点的引用是不可变的值，当你想改变的时候节点可能已经成为历史）&lt;/p&gt;

&lt;p&gt;大多数情况下，你将使用转换（transformations）来更新文档，而不必直接接触节点。这些也会留下更改记录，当文档是编辑器状态的一部分时，这是必要的&lt;/p&gt;

&lt;p&gt;如果你确实想要「手动」派发更新的文档，那么 &lt;code&gt;Node&lt;/code&gt; 和 &lt;code&gt;Fragment&lt;/code&gt; 类型上有一些辅助方法可用。要创建整个文档的更新版本，通常需要使用&lt;code&gt;Node.replace&lt;/code&gt;，它用一个新的内容切片替换文档的给定范围。要少量地更新节点，可以使用 copy 方法，该方法使用新内容创建类似的节点。Fragments 还有各种更新方法，例如 &lt;code&gt;replaceChild&lt;/code&gt; 或 &lt;code&gt;append&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;骨架-schemas&#34;&gt;骨架 Schemas&lt;/h2&gt;

&lt;p&gt;每个 ProseMirror 文档都有一个与之关联的骨架，骨架描述了文档中可能出现的节点类型以及它们嵌套的方式。例如，它可能会指定顶级节点可以包含一个或多个块，并且段落节点可以包含任意数量的内联节点，内联节点可以使用任何标记&lt;/p&gt;

&lt;p&gt;有一个包含基础骨架的包，但 ProseMirror 的优点在于它允许你定义自己的骨架&lt;/p&gt;

&lt;h3 id=&#34;节点类型-node-types&#34;&gt;节点类型 Node Types&lt;/h3&gt;

&lt;p&gt;文档中的每个节点都有一个类型，表示其语义和属性，正如其在编辑器中呈现的方式&lt;/p&gt;

&lt;p&gt;定义骨架时，可以枚举其中可能出现的节点类型，并使用 &lt;code&gt;spec&lt;/code&gt; 对象描述：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const trivialSchema = new Schema({
  nodes: {
    doc: {content: &amp;quot;paragraph+&amp;quot;},
    paragraph: {content: &amp;quot;text*&amp;quot;},
    text: {inline: true},
    /* ... and so on */
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码定义了一个骨架，其中文档可能包含一个或多个段落，每个段落可以包含任意数量的文本&lt;/p&gt;

&lt;p&gt;每个骨架必须至少定义顶级节点类型（默认为名称「doc」，但你可以设置），以及文本内容的（text）类型&lt;/p&gt;

&lt;p&gt;注意内联的节点必须使用 inline 属性声明（但对于文本类型，根据定义是内联的，可以省略它）&lt;/p&gt;

&lt;h3 id=&#34;内容表达式-content-expressions&#34;&gt;内容表达式 Content Expressions&lt;/h3&gt;

&lt;p&gt;上面示例模式中的内容字段（paragraph+, text*）中的字符串称为内容表达式。它们控制子节点的哪些序列对此节点类型有效&lt;/p&gt;

&lt;p&gt;例如 &lt;code&gt;paragraph&lt;/code&gt; 表示「一个段落」, &lt;code&gt;paragraph+&lt;/code&gt; 表示「一个或者多个段落」。相似地，&lt;code&gt;paragraph*&lt;/code&gt; 表示「零个或者更多个段落」, &lt;code&gt;caption?&lt;/code&gt; 表示「零个或者一个说明文字」。你可以使用类正则的范围区间，比如 &lt;code&gt;{2}&lt;/code&gt; 表示精确的两次，&lt;code&gt;{1, 5}&lt;/code&gt; 表示 1~5 次，&lt;code&gt;{2,}&lt;/code&gt; 表示 2~更多多次&lt;/p&gt;

&lt;p&gt;可以组合这些表达式来创建序列，比如 &lt;code&gt;heading paragraph+&lt;/code&gt; 表示「首先是标题，然后是一个或多个段落」。你也可以使用管道运算符 &lt;code&gt;|&lt;/code&gt; 表示两个表达式之间的选择，如 &lt;code&gt;(paragraph|blockquote)+&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;某些元素类型组将在你的模式中出现多种类型 — 例如，你可能有一个「块」节点的概念，它可能出现在顶层但也嵌套在块引用内。你可以通过为节点规范提供 group 属性来创建节点组，然后在表达式中按名称引用该组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const groupSchema = new Schema({
  nodes: {
    doc: {content: &amp;quot;block+&amp;quot;},
    paragraph: {group: &amp;quot;block&amp;quot;, content: &amp;quot;text*&amp;quot;},
    blockquote: {group: &amp;quot;block&amp;quot;, content: &amp;quot;block+&amp;quot;},
    text: {}
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 &lt;code&gt;block+&lt;/code&gt; 相当于 &lt;code&gt;(paragraph | blockquote)+&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;建议在具有块内容的节点中始终需要至少一个子节点（例如上面示例中的 &lt;code&gt;doc&lt;/code&gt; 和 &lt;code&gt;blockquote&lt;/code&gt;），因为当节点为空时，浏览器将完全折叠节点，不方便编辑&lt;/p&gt;

&lt;p&gt;节点在 or-表达式中的显示顺序非常重要。为非可选节点创建默认实例时，例如，为了确保在替换步骤后文档仍符合模式，将使用表达式中的第一个类型。如果这是一个组，则使用组中的第一个类型（由组成员在节点映射中显示的顺序确定）。如果我在示例骨架中切换 &lt;code&gt;paragraph&lt;/code&gt; 和 &lt;code&gt;blockquote&lt;/code&gt; 的位置，编辑器尝试创建一个块节点时，你会得到堆栈溢出 - 它会创建一个 &lt;code&gt;blockquote&lt;/code&gt; 节点，其内容至少需要一个块，因此它会尝试创建另一个 &lt;code&gt;blockquote&lt;/code&gt; 作为内容， 等等&lt;/p&gt;

&lt;p&gt;库中的节点操作函数并非每个都会检查它是否正在处理有效的内容 - 高层次的概念，例如 转换（transforms）会，但原始节点创建方法通常不会，而是负责为其调用者提供合理的输入。完全可以使用例如 NodeType.create 来创建具有无效内容的节点。对于在切片边缘 &lt;code&gt;打开&lt;/code&gt; 的节点，这甚至是合理的事情。有一个单独的 createChecked 方法，以及一个事后 check 方法，可用于断言给定节点的内容是有效的。&lt;/p&gt;

&lt;h3 id=&#34;标记-marks&#34;&gt;标记 Marks&lt;/h3&gt;

&lt;p&gt;标记用于向内联内容添加额外样式或其他信息。骨架必须声明允许的所有标记类型。&lt;strong&gt;标记类型&lt;/strong&gt; 是与 &lt;strong&gt;节点类型&lt;/strong&gt; 非常相似的对象，用于标记标记对象并提供其他信息&lt;/p&gt;

&lt;p&gt;默认情况下，具有内联内容的节点允许将骨架中定义的所有标记应用于其子项。你可以使用节点规范上的 marks 属性对其进行配置&lt;/p&gt;

&lt;p&gt;这有一个简单的骨架，支持段落中文本的 strong 和 emphasis 标记，但不支持标题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const markSchema = new Schema({
  nodes: {
    doc: {content: &amp;quot;block+&amp;quot;},
    paragraph: {group: &amp;quot;block&amp;quot;, content: &amp;quot;text*&amp;quot;, marks: &amp;quot;_&amp;quot;},
    heading: {group: &amp;quot;block&amp;quot;, content: &amp;quot;text*&amp;quot;, marks: &amp;quot;&amp;quot;},
    text: {inline: true}
  },
  marks: {
    strong: {},
    em: {}
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标记集被解释为以空格分隔的标记名称或标记组字符串 — &lt;code&gt;_&lt;/code&gt; 充当通配符，空字符串对应于空集&lt;/p&gt;

&lt;h3 id=&#34;属性-attributes&#34;&gt;属性 Attributes&lt;/h3&gt;

&lt;p&gt;文档骨架还定义了每个节点或标记具有的属性。如果你的节点类型需要存储额外的信息，例如标题节点的级别，那就最好使用属性&lt;/p&gt;

&lt;p&gt;属性集可以认为就是普通对象，具有预定义（每个节点或标记）属性集，包含任何 JSON 可序列化值。要指定它允许的属性，请使用节点中的可选 attrs 字段或标记规范&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;heading: {
  content: &amp;quot;text*&amp;quot;,
  attrs: {level: {default: 1}}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的骨架中，标题节点的每个实例都将具有 level 属性。如果不指定，则默认为 1&lt;/p&gt;

&lt;p&gt;如果不指定属性默认值，在尝试创建此类节点又不传属性时将引发错误。在满足模式约束条件下进行转换或调用 createAndFill 时，也无法使用库生成此类节点并填充&lt;/p&gt;

&lt;h3 id=&#34;序列化与解析-serialization-and-parsing&#34;&gt;序列化与解析 Serialization and Parsing&lt;/h3&gt;

&lt;p&gt;为了能够在浏览器中编辑它们，必须能够在浏览器 DOM 中表示文档节点。最简单的方法是使用 node spec 中的 &lt;code&gt;toDOM&lt;/code&gt; 字段包含有关骨架中每个节点的 DOM 表示的信息&lt;/p&gt;

&lt;p&gt;该字段应包含一个函数，当以节点作为参数调用时，该函数返回该节点的DOM 结构的描述。这可以是直接 DOM 节点或描述它的数组，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const schema = new Schema({
  nodes: {
    doc: {content: &amp;quot;paragraph+&amp;quot;},
    paragraph: {
      content: &amp;quot;text*&amp;quot;,
      toDOM(node) { return [&amp;quot;p&amp;quot;, 0] }
    },
    text: {}
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表达式 &lt;code&gt;[“p”, 0]&lt;/code&gt; 声明了一个段落会被渲染成 HTML &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 标签。零是一个「孔」用来表示内容被渲染的地方，你还可以在标记名称后面包含具有 HTML 属性的对象，例如：&lt;code&gt;[&amp;quot;div&amp;quot;, {class: &amp;quot;c&amp;quot;}, 0]&lt;/code&gt;。叶节点在其 DOM 表示中不需要「洞」，因为它们没有内容&lt;/p&gt;

&lt;p&gt;Mark specs 允许类似于 toDOM 方法，但它们需要渲染成直接包装内容的单个标记，因此内容始终直接在返回的节点中，并且不需要指定「孔」&lt;/p&gt;

&lt;p&gt;你可能经常需要从 DOM 数据中 *解析* 文档，例如，当用户将某些内容粘贴或拖动到编辑器中时。模型（Model） 模块具有相应的功能，建议你使用 &lt;code&gt;parseDOM&lt;/code&gt; 属性直接在骨架中包含解析信息&lt;/p&gt;

&lt;p&gt;这可以列出一个解析规则数组，它描述映射到给定节点或标记的 DOM 结构。例如，基础骨架具有以下表示 emphasis 标记：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;parseDOM: [
  {tag: &amp;quot;em&amp;quot;},                 // Match &amp;lt;em&amp;gt; nodes
  {tag: &amp;quot;i&amp;quot;},                  // and &amp;lt;i&amp;gt; nodes
  {style: &amp;quot;font-style=italic&amp;quot;} // and inline &#39;font-style: italic&#39;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析规则中标记的值可以是 CSS 选择器，因此你也可以使用 &lt;code&gt;div.myclass&lt;/code&gt; 之类的操作。同样，style 属性匹配内联 CSS 样式&lt;/p&gt;

&lt;p&gt;当骨架包含 parseDOM 注解时，你可以使用 DOMParser.fromSchema 为其创建DOMParser 对象。这是由编辑器完成的，用于创建默认剪贴板解析器，但你也可以覆写它&lt;/p&gt;

&lt;p&gt;文档还带有内置的 JSON 序列化格式。你可以在文档上调用 toJSON 以获取可以安全地传递给 JSON.stringify 的对象，并且骨架对象具有将此表示形式解析回文档的 nodeFromJSON 方法&lt;/p&gt;

&lt;h3 id=&#34;扩展一个骨架-extending-a-schema&#34;&gt;扩展一个骨架 Extending a schema&lt;/h3&gt;

&lt;p&gt;传递给 Schema 构造函数的 nodes 和 marks 选项采用了 OrderedMap 对象以及纯 JavaScript 对象。骨架的 spec.nodes 和 spec.marks 属性始终是一组 OrderedMap，可以用作其它骨架的基础&lt;/p&gt;

&lt;p&gt;此类映射支持许多方法以方便地创建更新版本。例如，你可以调用 &lt;code&gt;schema.markSpec.remove(“blockquote”)&lt;/code&gt; 来派生一组没有 blockquote 节点的节点，然后可以将其作为新骨架的节点字段传入&lt;/p&gt;

&lt;p&gt;schema-list 模块导出一个便捷方法，将这些模块导出的节点添加到节点集中&lt;/p&gt;

&lt;h2 id=&#34;文档转换-document-transformations&#34;&gt;文档转换 Document transformations&lt;/h2&gt;

&lt;p&gt;转换是 ProseMirror 工作方式的核心。它们构成了事务的基础，转换使得历史追踪和协作编辑成为可能&lt;/p&gt;

&lt;h3 id=&#34;为什么-why&#34;&gt;为什么 Why?&lt;/h3&gt;

&lt;p&gt;为什么我们不能直接改变文档？或者至少创建一个新版本的文档，然后将其放入编辑器中？&lt;/p&gt;

&lt;p&gt;有几个原因。一个是代码清晰度。不可变数据结构确实使得代码更简单。但是，转换系统的主要工作是留下更新的痕迹，以值的形式表示旧版本的文档到新版本所采取的各个步骤&lt;/p&gt;

&lt;p&gt;撤消历史记录可以保存这些步骤并反转应用它们以便及时返回（ProseMirror 实现选择性撤消，这比仅回滚到先前状态更复杂）&lt;/p&gt;

&lt;p&gt;协作编辑系统将这些步骤发送给其他编辑器，并在必要时重新排序，以便每个人最终都使用相同的文档&lt;/p&gt;

&lt;p&gt;更一般地说，编辑器插件能够检查每个更改并对其进行响应是非常有用的，为了保持其自身状态与编辑器的其余状态保持一致&lt;/p&gt;

&lt;h3 id=&#34;步骤-steps&#34;&gt;步骤 Steps&lt;/h3&gt;

&lt;p&gt;对文档的更新会分解为步骤（step）来描述一次更新。通常不需要你直接使用这些，但了解它们的工作方式很有用&lt;/p&gt;

&lt;p&gt;例如使用 &lt;code&gt;ReplaceStep&lt;/code&gt; 来替换一份文档，或者使用 &lt;code&gt;AddMarkStep&lt;/code&gt; 来给指定的范围（Range）添加标记&lt;/p&gt;

&lt;p&gt;可以将步骤应用于文档来成新文档&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(myDoc.toString()) // → p(&amp;quot;hello&amp;quot;)
// A step that deletes the content between positions 3 and 5
let step = new ReplaceStep(3, 5, Slice.empty)
let result = step.apply(myDoc)
console.log(result.doc.toString()) // → p(&amp;quot;heo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用一个步骤是一件相对奇怪的过程 — 它没有做任何巧妙的事情，比如插入节点以保留骨架的约束，或者转换切片以使其适应约束。这意味着应用步骤可能会失败，例如，如果你尝试仅删除节点的打开标记，这会使标记失衡，这对你来说是毫无意义的。这就是为什么 apply 返回一个 result 对象的原因，result 对象包含一个新文档或者一个错误消息&lt;/p&gt;

&lt;p&gt;你通常会使用工具函数来生成步骤，这样就不必担心细节&lt;/p&gt;

&lt;h3 id=&#34;转换-transforms&#34;&gt;转换 Transforms&lt;/h3&gt;

&lt;p&gt;一个编辑动作可以产生一个或多个步骤（step）。处理一系列步骤最方便的方法是创建一个 &lt;code&gt;Transform&lt;/code&gt; 对象（或者，如果你正在使用整个编辑器状态，则可以使用 &lt;code&gt;Transaction&lt;/code&gt;，它是 &lt;code&gt;Transform&lt;/code&gt; 的子类）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let tr = new Transform(myDoc)
tr.delete(5, 7) // Delete between position 5 and 7
tr.split(5)     // Split the parent node at position 5
console.log(tr.doc.toString()) // The modified document
console.log(tr.steps.length)   // → 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大多数转换方法都返回转换本身，方便链式调用 &lt;code&gt;tr.delete(5,7).split(5)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;会有很多关于转换的方法可以使用，删除、替换、添加、删除标记，以及维护树型结构的方法如 分割、合并、包裹等&lt;/p&gt;

&lt;h3 id=&#34;映射-mapping&#34;&gt;映射 Mapping&lt;/h3&gt;

&lt;p&gt;当你对文档进行更改时，指向该文档的指针可能会变成无效或并不是你想要的样子了。例如，如果插入一个字符，那么该字符后面的所有位置都会指向一个旧位置之前的标记。同样，如果删除文档中的所有内容，则指向该内容的所有位置现在都会失效&lt;/p&gt;

&lt;p&gt;我们经常需要保留文档更改的位置，例如选区边界。为了解决这个问题，步骤可以为你提供一个字典映射，可以在应用该步骤之前和之后进行转换并且应用应该步骤&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let step = new ReplaceStep(4, 6, Slice.empty) // Delete 4-5
let map = step.getMap()
console.log(map.map(8)) // → 6
console.log(map.map(2)) // → 2 (nothing changes before the change)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转换对象会自动对其中的步骤（step）累加一系列的字典，使用一种叫做 &lt;strong&gt;映射&lt;/strong&gt; 的抽象，它收集了一系列的步骤字典来帮助你一次性映射它们&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let tr = new Transaction(myDoc)
tr.split(10)    // split a node, +2 tokens at 10
tr.delete(2, 5) // -3 tokens at 2
console.log(tr.mapping.map(15)) // → 14
console.log(tr.mapping.map(6))  // → 3
console.log(tr.mapping.map(10)) // → 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在某些情况下，并不是完全清楚应该将给定位置映射到什么位置。考虑上面示例的最后一行代码。位置 10 恰好指向我们分割节点的地方，插入两个标识。它应该被映射到插入内容后面还是前面？例子中明显是映射到插入内容后面&lt;/p&gt;

&lt;p&gt;但是有时候你需要一些其它的行为，这是为什么 map 方法有第二个参数 &lt;code&gt;bias&lt;/code&gt; 的原因，你可以设置成 -1 当内容被插入到前面时保持你的位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(tr.mapping.map(10, -1)) // → 7
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;rebasing&#34;&gt;Rebasing&lt;/h3&gt;

&lt;p&gt;当使用步骤和位置映射时，比如实现一个变更追踪的功能，或者给协作编辑符加一些功能，你可能就会遇到使用 rebase 步骤的场景&lt;/p&gt;

&lt;p&gt;…（本小节译者并没有完全理解，暂不翻译，有兴趣可以参考&lt;a href=&#34;http://prosemirror.net/docs/guide/#transform.rebasing&#34; title=&#34;prosemirror - transform.rebasing&#34;&gt;原文&lt;/a&gt;）&lt;/p&gt;

&lt;h2 id=&#34;编辑器状态-the-editor-state&#34;&gt;编辑器状态 The editor state&lt;/h2&gt;

&lt;p&gt;编辑的状态由什么构成？当然，你有自己的文档。还有当前的选区。例如当你需要禁用或启用一个标记但还没在该标记上输入内容时，需要有一种方法来存储当前标记集已更改的情况&lt;/p&gt;

&lt;p&gt;一个 ProseMirror 的状态由三个主要的组件构成：&lt;code&gt;doc&lt;/code&gt;, &lt;code&gt;selection&lt;/code&gt; 和 &lt;code&gt;storedMarks&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;
import {EditorState} from &amp;quot;prosemirror-state&amp;quot;

let state = EditorState.create({schema})
console.log(state.doc.toString()) // An empty paragraph
console.log(state.selection.from) // 1, the start of the paragraph
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是插件可能也有存储状态的需求 — 例如，撤消历史记录必须保留其变更记录。这就是为什么所有激活的插件也被存放在状态中的原因，并且这些插件可以用于存储自身状态的槽（slots）&lt;/p&gt;

&lt;h3 id=&#34;选区-selection&#34;&gt;选区 Selection&lt;/h3&gt;

&lt;p&gt;ProseMirror 支持几种选区类型（并允许三方代码定义新的选区类型）。选区就是 &lt;code&gt;Selection&lt;/code&gt; 类的一个实例。就像文档和其它状态相关的值一样，它们是不可变的 — 想改变选区，就得创建一个新的选区对象让新的状态关联它&lt;/p&gt;

&lt;p&gt;选区至少包含一个开始（&lt;code&gt;.from&lt;/code&gt;）和一个结束（&lt;code&gt;.to&lt;/code&gt;）做为当前文档的位置指针。许多选区还区分选区的 &lt;code&gt;anchor&lt;/code&gt;（不可移动的）和 &lt;code&gt;head&lt;/code&gt;（可移动的），因此这两个属性在每个选区对象上都存在&lt;/p&gt;

&lt;p&gt;最常见的选区类型是文本选区（text selection），它用于常规的光标（当 &lt;code&gt;anchor&lt;/code&gt; 和 &lt;code&gt;head&lt;/code&gt; 一样时）或者选择的文本。文本选区两端必须是内联位置，比如 指向内联内容的节点&lt;/p&gt;

&lt;p&gt;核心库同样也支持节点选区（node selections），当一个文档节点被选择，你就能得到它，比如，当你按下 ctrl 或者 cmd 键的同时再用鼠标点击一个节点。这样就会产生一个节点开始到结束的选区&lt;/p&gt;

&lt;h3 id=&#34;事务-transactions-1&#34;&gt;事务 Transactions&lt;/h3&gt;

&lt;p&gt;在正常的编辑过程中，新状态将从它们之前的状态派生而来。但是某些情况例外，例如 你想要创建一个全新的状态来初化化一个新文档&lt;/p&gt;

&lt;p&gt;通过将一个事务应用于现有状态，来生成新状然后进行状态更新。从概念上讲，它们只发生一次：给定旧状态和事务，为状态中的每个组件计算一个新值，并将它们放在一个新的状态值中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let tr = state.tr
console.log(tr.doc.content.size) // 25
tr.insertText(&amp;quot;hello&amp;quot;) // Replaces selection with &#39;hello&#39;
let newState = state.apply(tr)
console.log(tr.doc.content.size) // 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Transaction&lt;/code&gt; 是 &lt;code&gt;Transform&lt;/code&gt; 的子类，它继承了构建一个文档的方法，即 应用步骤到初始文档中。另外一点，事务会追踪选区和其它状态相关的组件，它提供了一些和选区相关的便捷方法，例如 &lt;code&gt;replaceSelection&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建事务的最简单方法是使用编辑器状态对象上的 &lt;code&gt;tr getter&lt;/code&gt;。这将基于当前状态创建一个空事务，然后你可以向其添加步骤和其他更新&lt;/p&gt;

&lt;p&gt;默认情况下，旧选区通过每个步骤映射以生成新选区，但可以使用 &lt;code&gt;setSelection&lt;/code&gt; 显式设置新选区&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let tr = state.tr
console.log(tr.selection.from) // → 10
tr.delete(6, 8)
console.log(tr.selection.from) // → 8 (moved back)
tr.setSelection(TextSelection.create(tr.doc, 3))
console.log(tr.selection.from) // → 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样地，在文档或选区更改后会自动清除激活的标记集，并可使用 &lt;code&gt;setStoredMarks&lt;/code&gt; 或 &lt;code&gt;ensureMarks&lt;/code&gt; 方法设置&lt;/p&gt;

&lt;p&gt;最后，&lt;code&gt;scrollIntoView&lt;/code&gt; 方法可用于确保在下次绘制状态时，选区内容将滚动到视图中。大多情况下都需要执行此操作&lt;/p&gt;

&lt;p&gt;与 &lt;code&gt;Transform&lt;/code&gt; 方法一样，许多 &lt;code&gt;Transaction&lt;/code&gt; 方法都会返回事务本身，以方便链式调用&lt;/p&gt;

&lt;h3 id=&#34;插件-plugins-1&#34;&gt;插件 Plugins&lt;/h3&gt;

&lt;p&gt;当创建一个新状态时，你可以指定一个插件数组挂载到上面。这些插件将被应用在这个新状态以及它的派生状态上，这会影响到事务的应用以及基于这个状态的编辑器行为&lt;/p&gt;

&lt;p&gt;插件是 &lt;code&gt;Plugin&lt;/code&gt; 类的实例，可以用来实现很多功能，最简单的一个例子就是给编辑器视图添加一些属性，例如 处理某些事件。复杂一点的就如添加一个新的状态到编辑器并基于事务更新它&lt;/p&gt;

&lt;p&gt;创建一个插件，你可以传入一个对象来指定它的行为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let myPlugin = new Plugin({
  props: {
    handleKeyDown(view, event) {
      console.log(&amp;quot;A key was pressed!&amp;quot;)
      return false // We did not handle this
    }
  }
})

let state = EditorState.create({schema, plugins: [myPlugin]})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个插件需要他自己的状态槽时，可以定义一个 &lt;code&gt;state&lt;/code&gt; 属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let transactionCounter = new Plugin({
  state: {
    init() { return 0 },
    apply(tr, value) { return value + 1 }
  }
})

function getTransactionCount(state) {
  return transactionCounter.getState(state)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例中的插件定义了一个非常简单的状态，它只计算已经应用于某个状态的事务数。辅助函数使用插件的 &lt;code&gt;getState&lt;/code&gt; 方法，该方法可用于从编辑器的状态对象中（插件作用域外）获取插件状态&lt;/p&gt;

&lt;p&gt;因为编辑器状态是持久化（不可变）的对象，并且插件状态是该对象的一部分，所以插件状态值必须是不可变的。即需要更改，他们的 &lt;code&gt;apply&lt;/code&gt; 方法必须返回一个新值，而不是更改旧值，并且其他代码是不可以更改它们的&lt;/p&gt;

&lt;p&gt;可对于插件而言向事务添加一些额外信息是非常有用的。例如，撤销历史记录在执行实际撤消时会标记生成的事务，以便在插件可以识别到，而不仅仅是生成一个新事务，将它们添加到撤消堆栈，我们需要单独处理它，从撤消（undo）堆栈中删除顶部项，然后同时将此事务添加到重做（redo）堆栈&lt;/p&gt;

&lt;p&gt;为此，事务允许附加元数据（metadata）。我们可以更新我们的事务计数器插件，过滤那些被标记过的事务，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let transactionCounter = new Plugin({
  state: {
    init() { return 0 },
    apply(tr, value) {
      if (tr.getMeta(transactionCounter)) return value
      else return value + 1
    }
  }
})

function markAsUncounted(tr) {
  tr.setMeta(transactionCounter, true)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;metadata 的属性键可以是字符串，但是要避免命名冲突，建议使用插件对象。有一些属性名库中已经定义过了，比如：&lt;code&gt;addToHistory&lt;/code&gt; 可以设置成 &lt;code&gt;false&lt;/code&gt; 表示事务不可以被撤消，当处理一个粘贴动作时，编辑器将在事务上设置 &lt;code&gt;paste&lt;/code&gt; 属性为 &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;视图组件-the-view-component&#34;&gt;视图组件 The view component&lt;/h2&gt;

&lt;p&gt;ProseMirror 编辑器视图是一个 UI 组件，它向用户显示编辑器状态，并允许它们进&lt;/p&gt;

&lt;p&gt;核心视图组件使用的 &lt;em&gt;编辑操作&lt;/em&gt; 的定义相当狭义 — 它用来直接处理与编辑器界面的交互，比如 输入、点击、复制、粘贴、拖拽，除此之外就没了。这表示核心视图组件并不支持一些高级一点的功能，像 菜单、快捷键绑定 等。想实现这类功能必须使用插件&lt;/p&gt;

&lt;h3 id=&#34;可编辑的-dom-editable-dom&#34;&gt;可编辑的 DOM Editable DOM&lt;/h3&gt;

&lt;p&gt;浏览器允许我们指定 DOM 的某些部分是可编辑的，这具有允许我们可以在上面聚焦或者创建选区，并且可以输入内容。视图创建其文档的 DOM 展示（默认情况下使用模式的 &lt;code&gt;toDOM&lt;/code&gt; 方法），并使其可编辑。当聚焦到可编辑的元素时，ProseMirror 确保 DOM 选区对应于编辑器状态中的选区&lt;/p&gt;

&lt;p&gt;它还会注册很多我DOM在事件处理程序，并将事件转换为适当的事务。例如，粘贴时，粘贴的内容将被解析为 ProseMirror 文档切片，然后插入到文档中&lt;/p&gt;

&lt;p&gt;很多事件也会按原生方式触发，然后才会由 ProseMirror 的数据模型重新解释。浏览器很擅长处理光标和选区等问题（当需要两向操作时则变得困难无比），所以大多数与光标相关的键和鼠标操作都由浏览器处理，之后 ProseMirror 会检查当前 DOM 选区对应着什么样的文本选区类型。如果该选区与当前选区不同，则通过调度一次事务来更新选区&lt;/p&gt;

&lt;p&gt;甚至像输入这种动作通常都留给浏览器处理，因为干扰它往往会破坏诸如 拼写检查，某些手机上单词自动首字母大写，以及其它一些设配原生的功能。当浏览器更新 DOM 时，编辑器会注意到，并重新解析文档的更改的部分，并将差异转换为一次事务&lt;/p&gt;

&lt;h3 id=&#34;数据流-data-flow&#34;&gt;数据流 Data flow&lt;/h3&gt;

&lt;p&gt;编辑器视图展示给定的编辑器状态，当发生某些事件时，它会创建一个事务并广播它。然后，这个事务通常用于创建新状态，该状态调用它的 &lt;code&gt;updateState&lt;/code&gt; 方法将状态返回给视图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/28003/16/976/56676/5c0e39efEba5293ce/3ad15f7825aa70c8.png&#34; alt=&#34;prosemirror-4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样就创建了一个简单的循环数据流，在 JavaScript 的世界，通常会立即处理事件处理器（可以理解成命令式的触发事件后直接操作 DOM），后者往往会创建更复杂的数据流网络（数据流可能是双向的，不容易理解与维护）&lt;/p&gt;

&lt;p&gt;由于事务是通过 &lt;code&gt;dispatchTransaction&lt;/code&gt; 属性来调度的，所以拦载事务是可以的做到的，为了将这个循环数据流连接到一个更大的周期 — 如果你的整个应用程序使用这样的数据流模型，就像类似 Redux 的体系结构一样，你可以使 ProseMirror 的事务与主动作调度（main action-dispatching）周期集成起来，将 ProseMirror 的状态保留在你应用程序的 &lt;code&gt;store&lt;/code&gt; 中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// The app&#39;s state
let appState = {
  editor: EditorState.create({schema}),
  score: 0
}

let view = new EditorView(document.body, {
  state: appState.editor,
  dispatchTransaction(transaction) {
    update({type: &amp;quot;EDITOR_TRANSACTION&amp;quot;, transaction})
  }
})

// A crude app state update function, which takes an update object,
// updates the `appState`, and then refreshes the UI.
function update(event) {
  if (event.type == &amp;quot;EDITOR_TRANSACTION&amp;quot;)
    appState.editor = appState.editor.apply(event.transaction)
  else if (event.type == &amp;quot;SCORE_POINT&amp;quot;)
    appState.score++
  draw()
}

// An even cruder drawing function
function draw() {
  document.querySelector(&amp;quot;#score&amp;quot;).textContent = appState.score
  view.updateState(appState.editor)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;高效更新-efficient-updating&#34;&gt;高效更新 Efficient updating&lt;/h3&gt;

&lt;p&gt;一种简单的实现 &lt;code&gt;updateState&lt;/code&gt; 的方法是在每次调用文档时重绘文档。但对于大型文档而言，这会变得很慢&lt;/p&gt;

&lt;p&gt;由于在更新期间，视图可以访问到旧文档和新文档，可以用它们来做对比，单独保留没发生变化的节点对应的 DOM 部分。 ProseMirror 就是这么做的，这将使得常规的更新动作只需要做很少的工作&lt;/p&gt;

&lt;p&gt;在某些情况下，例如 通过浏览器的编辑操作添加到 DOM 的更新文本。确保DOM 和状态一致，根本不需要任何 DOM 更改（当以一个事务被取消，修改时，视图将撤消 DOM 更改以确保 DOM 和状态保持同步）&lt;/p&gt;

&lt;p&gt;类似地，DOM 选区仅在实际与状态中的选区不同步时才会更新，这是为了避免破坏浏览器在选区中的各种「隐藏 hidden」状态（例如，当你使用向下或向上箭头空过短行时，你的水平位置会回到你进入下一条长行的位置）&lt;/p&gt;

&lt;h3 id=&#34;属性-props&#34;&gt;属性 Props&lt;/h3&gt;

&lt;p&gt;大体上讲 Props 很有用，这是从 React 学过来的。属性就像是 UI 组件中的参数。理想情况下，组件的属性完全定义其行为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let view = new EditorView({
  state: myState,
  editable() { return false }, // Enables read-only behavior
  handleDoubleClick() { console.log(&amp;quot;Double click!&amp;quot;) }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，当前的状态就是一个属性。即使一段代码控制了组件并更新某属性，它也不是真正意义上的状态，因为组件 &lt;strong&gt;自己&lt;/strong&gt; 并没有改变它们，&lt;code&gt;updateState&lt;/code&gt; 方法也只是更新状态中某个属性的一种简写&lt;/p&gt;

&lt;p&gt;插件可以声明除了 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;dispatchTransaction&lt;/code&gt; 以外的任意属性，它们可以直接传给视图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function maxSizePlugin(max) {
  return new Plugin({
    props: {
      editable(state) { return state.doc.content.size &amp;lt; max }
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个给定的属性被多次声明时，它的处理方式取决于属性类型。直接传入的的属性优先，然后每个插件按顺序执行。对于一些属性而言，比如 &lt;code&gt;domParser&lt;/code&gt;，只会使用第一次声明的值。如果是事件处理函数，可以返回一个布尔值来告诉底层事件系统是否要执行自己的逻辑（比如 事件处理函数反回 false，这表示底层事件上绑定的相同事件处理函数将不会被处理），有的属性，像 attributes 则会做合并然后使用&lt;/p&gt;

&lt;h3 id=&#34;装饰器-decorations&#34;&gt;装饰器 Decorations&lt;/h3&gt;

&lt;p&gt;装饰使你可以控制视图绘制文档的方式。它们是通过从 装饰器 属性返回值创建的，有三种类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点装饰器&lt;/strong&gt; Node decorations - 将样式或其他 DOM 属性添加到单个节点的 DOM 展示中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;挂件装饰器&lt;/strong&gt; Widget decorations - 在指定位置插入一个 DOM 节点，该节点不是实际文档的一部分&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内联装饰器&lt;/strong&gt; Inline decorations - 添加样式或属性，就像节点装饰器一样，但是会添加到给定范围内的所有内联节点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了能够有效地绘制和比较装饰器，它们需要作为装饰数组提供（这是一种模仿实际文档的树形数据结构）。你可以使用静态 &lt;code&gt;create&lt;/code&gt; 方法创建，提供文档和装饰对象数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let purplePlugin = new Plugin({
  props: {
    decorations(state) {
      return DecorationSet.create(state.doc, [
        Decoration.inline(0, state.doc.content.size, {style: &amp;quot;color: purple&amp;quot;})
      ])
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你有很多装饰器，那么每次重新绘制时都要重新创建这些装置成本会很高。这种情况下，维护装饰器的推荐方法是将数组放在插件的状态中，通过更改将其映射到之前的状态，并且只在需要时进行更改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let specklePlugin = new Plugin({
  state: {
    init(_, {doc}) {
      let speckles = []
      for (let pos = 1; pos &amp;lt; doc.content.size; pos += 4)
        speckles.push(Decoration.inline(pos - 1, pos, {style: &amp;quot;background: yellow&amp;quot;}))
      return DecorationSet.create(doc, speckles)
    },
    apply(tr, set) { return set.map(tr.mapping, tr.doc) }
  },
  props: {
    decorations(state) { return specklePlugin.getState(state) }
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的插件将其状态初始化为装饰器数组，该装饰器数组将会执行每 4 个位置添加黄色背景。这个例子可能并不是非常有用，但有点类似于突出显示搜索匹配或注释区域的场景&lt;/p&gt;

&lt;p&gt;当事务应用于状态时，插件状态的 apply 方法将装饰器数组向前映射，使装饰器保持原位并「适应」新文档形状。通过利用装饰器数组的树形结构使得映射方法（典型的局部变化）变得高效 - 树形结构中只有变化的部分才会被处理或者重建&lt;/p&gt;

&lt;p&gt;在插件的实际使用过程中，apply 方法也可以根据你基于新事件添加或删除装饰的位置而定，或者是通过检测事务中的更新，或基于特定的附加到事务的插件元数据&lt;/p&gt;

&lt;p&gt;最后，装饰属性只是返回插件状态，这就导致装饰器会展示在视图中&lt;/p&gt;

&lt;h3 id=&#34;节点视图-node-views&#34;&gt;节点视图 Node views&lt;/h3&gt;

&lt;p&gt;还有一种方法可以影响编辑器视图绘制文档的方式。节点视图可以为文档中的各个节点定义一种微型的 UI 组件。它们允许你展示 DOM，定义更新方式，并编写自定义代码以及响应事件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let view = new EditorView({
  state,
  nodeViews: {
    image(node) { return new ImageView(node) }
  }
})

class ImageView {
  constructor(node) {
    // The editor will use this as the node&#39;s DOM representation
    this.dom = document.createElement(&amp;quot;img&amp;quot;)
    this.dom.src = node.attrs.src
    this.dom.addEventListener(&amp;quot;click&amp;quot;, e =&amp;gt; {
      console.log(&amp;quot;You clicked me!&amp;quot;)
      e.preventDefault()
    })
  }

  stopEvent() { return true }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的示例为图片节点定义了视图对象，为图像创建了自定义的 DOM 节点，添加了事件处理程序，并使用 stopEvent 方法声明 ProseMirror 应忽略来自该DOM 节点的事件&lt;/p&gt;

&lt;p&gt;通常你可能会有与节点交互以影响文档中的实际节点的需求。但是要创建更改节点的事务，首先需要知道该节点的位置。为此，节点视图将传递一个 getter 函数，该函数可用于查询文档中当前节点的位置。让我们修改示例，实现单击节点查询你输入图像的 alt 文本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let view = new EditorView({
  state,
  nodeViews: {
    image(node, view, getPos) { return new ImageView(node, view, getPos) }
  }
})

class ImageView {
  constructor(node, view, getPos) {
    this.dom = document.createElement(&amp;quot;img&amp;quot;)
    this.dom.src = node.attrs.src
    this.dom.alt = node.attrs.alt
    this.dom.addEventListener(&amp;quot;click&amp;quot;, e =&amp;gt; {
      e.preventDefault()
      let alt = prompt(&amp;quot;New alt text:&amp;quot;, &amp;quot;&amp;quot;)
      if (alt) view.dispatch(view.state.tr.setNodeMarkup(getPos(), null, {
        src: node.attrs.src,
        alt
      }))
    })
  }

  stopEvent() { return true }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;setNodeMarkup&lt;/code&gt; 是一个方法，可用于更改给定位置的节点的类型或属性集。在示例中，我们使用 getPos 查找图像的当前位置，并使用新的 alt 文本为其提供新的属性对象&lt;/p&gt;

&lt;p&gt;节点更新后，默认行为是保持节点外部 DOM 结构不变，并将其子项与新的子元素集进行比较，根据需要更新或替换它们。节点视图可以使用自定义行为覆盖它，这允许我们执行类似于根据内容更改段落类（css class）属性的操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let view = new EditorView({
  state,
  nodeViews: {
    paragraph(node) { return new ParagraphView(node) }
  }
})

class ParagraphView {
  constructor(node) {
    this.dom = this.contentDOM = document.createElement(&amp;quot;p&amp;quot;)
    if (node.content.size == 0) this.dom.classList.add(&amp;quot;empty&amp;quot;)
  }

  update(node) {
    if (node.type.name != &amp;quot;paragraph&amp;quot;) return false
    if (node.content.size &amp;gt; 0) this.dom.classList.remove(&amp;quot;empty&amp;quot;)
    else this.dom.classList.add(&amp;quot;empty&amp;quot;)
    return true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图片标签不会有子内容，所以在我们之前的例子里，我们并不需要关心它是如何渲染的，但是段落有子内容。Node view 支持两种处理内容的方式：要么你让 ProseMirror 库来管理它，要么完全由你自己来管理。如果你提供一个 &lt;code&gt;contentDOM&lt;/code&gt; 属性，ProseMirror 将把节点渲染到这里并处理内容更新。如果你不提供这个属性，内容对于编辑器将变成一个黑盒，内容如何展示如何交互都将取决于你&lt;/p&gt;

&lt;p&gt;在这种情况下，我们希望段落内容的行为类似于常规可编辑文本，因此contentDOM 属性被定义为与 dom 属性相同，因为内容需要直接渲染到外部节点中&lt;/p&gt;

&lt;p&gt;魔术发生在 &lt;code&gt;update&lt;/code&gt; 方法中。首先，该方法负责决定是否可以更新节点视图以显示新节点。此新节点可能是编辑器更新算法尝试绘制的任何内容，因此你必须验证此节点有对应的节点视图来处理它&lt;/p&gt;

&lt;p&gt;示例中的 &lt;code&gt;update&lt;/code&gt; 方法首先检查新节点是否为段落，如果不是，就退出。然后它确保 &lt;code&gt;empty&lt;/code&gt; 类存在或不存在，具体取决于新节点的内容，返回true，则表示更新成功（此时节点的内容将被更新）&lt;/p&gt;

&lt;h2 id=&#34;命令-commands-1&#34;&gt;命令 Commands&lt;/h2&gt;

&lt;p&gt;在 ProseMirror 的术语中，命令是实现编辑操作的功能，用户可以通过按某些组合键或与菜单交互来执行命令&lt;/p&gt;

&lt;p&gt;出于实际原因考虑，命令的接口稍微有点复杂。一个接收 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;dispatch&lt;/code&gt; 参数的函数，该函数返回一个布尔值。下面是一个非常简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false
  dispatch(state.tr.deleteSelection())
  return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个命令非正常执行时应该返回 false，表示什么都不会发生。相反如果返正常执行，则应该调度一个事务并且返回 true。确实是这样的，当一个命令被绑定到一个健位并执行时，keymap 插件中对应于这个健位的事件将会被阻止&lt;/p&gt;

&lt;p&gt;为了能够查询一个命令对于一个状态下是否具有&lt;strong&gt;可执行性&lt;/strong&gt;（可执行但又不通过执行来验证），&lt;code&gt;dispatch&lt;/code&gt; 参数是可选的 — 当命令被调用并且没传入 dispatch 参数时，如果命令具有可执行性，那就应该什么也不做并返回 true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false
  if (dispatch) dispatch(state.tr.deleteSelection())
  return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了能够知道一个选区否可以被删除，你可以调用 &lt;code&gt;deleteSelection(view.state, null)&lt;/code&gt;，然而如果你想真正执行这个命令就应该这样调 &lt;code&gt;deleteSelection(view.state, view.dispatch)&lt;/code&gt;。菜单栏就是用这个来决定菜单按钮的可用性的&lt;/p&gt;

&lt;p&gt;这种行式下，命令并不需要访问实际的编辑器视图 — 大多数命令都不需要，这样的话命令就可以在设置中应用和测试而不必关心视图是否可用。但是有的命令则偏偏需要与 DOM 交互 — 可能需要查询指定的位置是否在文本块儿后面，或者打开一个相对于视图定位的对话框。为了解决这种需求，命令还提供了第三个（整个编辑器视图）参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function blinkView(_state, dispatch, view) {
  if (dispatch) {
    view.dom.style.background = &amp;quot;yellow&amp;quot;
    setTimeout(() =&amp;gt; view.dom.style.background = &amp;quot;&amp;quot;, 1000)
  }
  return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子可能并不是合适，因为命令并没有调度一次事务 — 调用他们可能会产生副作用，所以 *通常* 需要调度一次事务，但是也可能不需要，比如弹出一个层（因为这个层不在编辑器视图里面，并不属于编辑器的状态，所以调度事务就显得多余了）&lt;/p&gt;

&lt;p&gt;prosemirror-commands 模块提供了很多编辑器命令，从简单如 &lt;code&gt;deleteSelection&lt;/code&gt; 命令到复杂如 &lt;code&gt;joinBackward&lt;/code&gt; 命令，后者实现了块级节点的拼合，当你在文本块开始的地方触发 backspace 键的时候就会发生。它也会附加一些基本的快捷键绑定&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chainCommands&lt;/code&gt; 函数可以合并一系列的命令并执行直到某个命令返回 true&lt;/p&gt;

&lt;p&gt;举个例子，基础的快捷键绑定模块中，backspace 会被绑定到一个&lt;code&gt;命令链&lt;/code&gt;上：1. &lt;code&gt;deleteSelection&lt;/code&gt; 当选区不为空时删除选区；2. joinBackward 当光标在文本块开始的地方时；3. selectNodeBackward 选择选区前的节点，以防骨架中不允许有常规的拼合操作。当这些都不适用时，允许浏览器运行自己的 backspace 行为，这对于清除文本块内容是合理的&lt;/p&gt;

&lt;p&gt;命令模块还导出许多命令构造器，例如 &lt;code&gt;toggleMark&lt;/code&gt;，它采用标记类型和可选的一组属性，并返回一个命令函数，用于切换当前选区上的标记&lt;/p&gt;

&lt;p&gt;其他一些模块也会导出命令函数 — 例如，从 history 模块中 &lt;code&gt;undo&lt;/code&gt; 和 &lt;code&gt;redo&lt;/code&gt;。要自定义编辑器，或允许用户与自定义文档节点进行交互，你可能还需要编写自定义命令&lt;/p&gt;

&lt;h2 id=&#34;协作编辑-collaborative-editing&#34;&gt;协作编辑 Collaborative editing&lt;/h2&gt;

&lt;p&gt;实时协作编辑允许多人同时编辑同一文档。它们所做的更改会立即应用到本地文档，然后发送给对等（pears）方，这些对等方会自动合并这些更改（无需手动解决冲突），以便编辑动作可以不间断地进行，文档也会不断地被合并&lt;/p&gt;

&lt;p&gt;这一节将介绍如何给 ProseMirror 嫁接上协作编辑的功能&lt;/p&gt;

&lt;h3 id=&#34;算法-algorithm&#34;&gt;算法 Algorithm&lt;/h3&gt;

&lt;p&gt;ProseMirror 的协作编辑使用了一种中央集权式的系统，它会决定哪个变更会被应用。如果两个编辑器同时发生变更，他们两都将带着自己的变更进入系统，系统会接受其中之一，并且广播到其它编辑器中，另外一方的变更将不会被应用，当这个编辑器接收到新的变更时，它将被基于其它编辑器之上执行本地变更的 rebase 操作，然后再次提交更新&lt;/p&gt;

&lt;h3 id=&#34;权鉴-the-authority&#34;&gt;权鉴 The Authority&lt;/h3&gt;

&lt;p&gt;集权式的系统的角色其实是相对简单的，它只须做到以下几点…&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;跟踪当前文档的版本&lt;/li&gt;
&lt;li&gt;接受编辑器的变更，当变更被应用时，添加到变更列表中&lt;/li&gt;
&lt;li&gt;当给定一个版本时，提供一种编辑器接受变更的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;让我们实现一个简单的集权式的系统，它在与编辑器相同的 JavaScript 环境中运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Authority {
  constructor(doc) {
    this.doc = doc
    this.steps = []
    this.stepClientIDs = []
    this.onNewSteps = []
  }

  receiveSteps(version, steps, clientID) {
    if (version != this.steps.length) return

    // Apply and accumulate new steps
    steps.forEach(step =&amp;gt; {
      this.doc = step.apply(this.doc).doc
      this.steps.push(step)
      this.stepClientIDs.push(clientID)
    })
    // Signal listeners
    this.onNewSteps.forEach(function(f) { f() })
  }

  stepsSince(version) {
    return {
      steps: this.steps.slice(version),
      clientIDs: this.stepClientIDs.slice(version)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当编辑器试着提交他们的变更到系统时，可以调用 &lt;code&gt;receiveSteps&lt;/code&gt; 方法，传递他们接收到的最新版本号，同时携带着新的变更及他们自己的 client ID（用来识别变更来自哪里）&lt;/p&gt;

&lt;p&gt;当这步骤被接收，客户端就会知道被接收了。因为系统会通知他们新的可用步骤，然后发送给他们自己的步骤。真正的实现中，做为优化项，你也可以调用 &lt;code&gt;receiveSteps&lt;/code&gt; 返回一个状态码，然后立即确认发送的步骤，但是这里用到的东西必须要在不可靠的网络环境下保证同步&lt;/p&gt;

&lt;p&gt;这种权限的实现保持了一系列不断增长的步骤，其长度表示当前版本&lt;/p&gt;

&lt;h3 id=&#34;协作模块-the-collab-module&#34;&gt;协作模块 The &lt;code&gt;collab&lt;/code&gt; Module&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;collab&lt;/code&gt; 模块导出一个 &lt;code&gt;collab&lt;/code&gt; 函数，该函数返回一个插件，负责跟踪本地变更，接收远程变更，并对于何时必须将某些内容发送到中央机构做出指示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {EditorState} from &amp;quot;prosemirror-state&amp;quot;
import {EditorView} from &amp;quot;prosemirror-view&amp;quot;
import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;
import collab from &amp;quot;prosemirror-collab&amp;quot;

function collabEditor(authority, place) {
  let view = new EditorView(place, {
    state: EditorState.create({schema, plugins: [collab.collab()]}),
    dispatchTransaction(transaction) {
      let newState = view.state.apply(transaction)
      view.updateState(newState)
      let sendable = collab.sendableSteps(newState)
      if (sendable)
        authority.receiveSteps(sendable.version, sendable.steps,
                               sendable.clientID)
    }
  })

  authority.onNewSteps.push(function() {
    let newData = authority.stepsSince(collab.getVersion(view.state))
    view.dispatch(
      collab.receiveTransaction(view.state, newData.steps, newData.clientIDs))
  })

  return view
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;collabEditor&lt;/code&gt; 函数创建一个加载了&lt;code&gt;collab&lt;/code&gt; 插件的编辑器视图。每当状态更新时，它都会检查是否有任何内容要发送给系统。如果有，就发送&lt;/p&gt;

&lt;p&gt;它还注册了一个当新的步骤可用时系统应该调用的函数，并创建一个事务来更新我们的本地编辑器反映这些步骤的状态&lt;/p&gt;

&lt;p&gt;当一组步骤被系统拒绝时，它们将一直保持未确认状态，这个时间段应该会比较短，持续到我们从系统收到新的步骤之后。接着，因为 &lt;code&gt;onNewSteps&lt;/code&gt; 回调调用 &lt;code&gt;dispatch&lt;/code&gt;，&lt;code&gt;dispatch&lt;/code&gt; 再调用我们的 &lt;code&gt;dispatchTransaction&lt;/code&gt; 函数，代码才会将尝试再次提交其更改&lt;/p&gt;

&lt;p&gt;这基本上就是的所有协作模块的功能了。当然，对于异步数据通道（例如上面的演示代码中的长轮询或 Web套接字），你需要更复杂的通信和同步代码，而且你也可能需要集权系统在某些情况下开始抛出步骤，而不至于内存被消耗完。但是这个小例子大概也描述清楚了实现过程&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>