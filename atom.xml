<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>臨池不輟</title>
    <link>https://keelii.com/</link>
    <description>Recent content on 臨池不輟</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 10 May 2020 18:33:57 +0800</lastBuildDate>
    
        <atom:link href="https://keelii.com/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>前端开发的瓶颈与未来之路</title>
      <link>https://keelii.com/2020/05/10/frontend-dev-bottleneck-and-future/</link>
      <pubDate>Sun, 10 May 2020 18:33:57 +0800</pubDate>
      
      <guid>https://keelii.com/2020/05/10/frontend-dev-bottleneck-and-future/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;前端开发的瓶颈到底在哪里，前端技术是否已经走到一个十字路口，全栈化的系统架构是否能改变目前的窘境？本文将根据我自己的开发经历谈谈当下前端开发中遇到的一些问题和想法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;引子&#34;&gt;引子&lt;/h2&gt;

&lt;p&gt;近两年我一直在思考的一个问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果前端不用考虑性能问题、不用考虑终端兼容性、不用考虑历史遗留问题，甚至不用考虑具体技术实现&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果我们假设自己有丰富的技术储备，同时不用考虑上面的问题，那么前端究竟 &lt;strong&gt;能&lt;/strong&gt; 做出什么样有价值的东西？&lt;/p&gt;

&lt;p&gt;我们把时间拉到 5 年前&amp;hellip;&lt;/p&gt;

&lt;p&gt;如果你「那时」还是前端开发的话。上面的问题肯定是你不得不面临的典型问题。甚至是当时前端开发的意义所在。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你会为了精确还原设计稿熬夜加班，从而练就一双像素眼；&lt;/li&gt;
&lt;li&gt;你会为了解决几个字节的性能问题研究优化方案，以至看懂了每一个 HTTP 请求头；&lt;/li&gt;
&lt;li&gt;你也会因为某些技术问题和同事理论，最终到达到产品谈笑风声的境界；&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是随着时间的推移，前端技术的更新迭代，以及互联网的发展。你会发现这些曾经的问题似乎已经不再是问题，或者说在能预见的未来 &lt;em&gt;可能&lt;/em&gt; 不再是问题。&lt;/p&gt;

&lt;p&gt;页面加载性能可能不再是问题，技术上有了 HTTP2，基建上有了 5G，硬盘也越来越快。&lt;/p&gt;

&lt;p&gt;兼容性问题慢慢淡出大家的视角，Chrome 一家独大，微软也不得不向它靠拢。&lt;/p&gt;

&lt;p&gt;很多前端开发已经具备了后端（或者说多端）的技术能力，技术储备也可能不是问题，当然前提是你能招到人。&lt;/p&gt;

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;到底什么是前端开发，前端与后端的界限在哪里？我在三年前对它的定义是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;前端为 界面、交互展示负责；
后端为 数据、业务逻辑负责;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不过现在看来似乎已经过时了，我越来越觉得不应该有这样一个清晰的界限把前后端分割开来，尤其是技术层面（除了职能层面的界限有利于协作以外）。这就好比说：如果你不能打破规则，那就必将被规则束缚。&lt;/p&gt;

&lt;p&gt;我一直认为程序员应该对新的技术、工具、理念有比平常人更快的适应能力。举个简单的例子，我以前写代码通常使用 tab 缩进，后来大家都建议使用空格，刚开始尝试换成空格肯定是拒绝的，因为让人改变习惯是一件很难的事情。但是当你真正为了改变做出实践的时候，往往就会发现一条新大路。同样还有加不加分号的问题。&lt;/p&gt;

&lt;p&gt;现在回过头来再看，前端在整个系统层面担任的角色至少应该是整个视图 View 层面的。视图层面的技术更接近软件系统的上层，更感性。感性的东西就是说一个颜色，我觉得好看，他觉得不好看，完全属于个人情感诉求。所以前端更注重与 UI、交互 以及整个产品层面需要解决的问题。优秀的前端必然要具备敏锐的产品洞察能力。&lt;/p&gt;

&lt;p&gt;当然这还只是前端最基础的职责所在。同时前端做为最接近产品的技术角色，技术才是前端真正的硬实力。&lt;/p&gt;

&lt;p&gt;大约在去年一年的时间，我的岗位从前端转向了后端 Java 程序员的角色。虽然只做了一年的 Java 程序员，但是对我自身的技术提升而言是最多的一年。大家可能普遍的认为后端转前端比较容易，前端转后端会有门槛，实际上根据我自己的体验来讲并非如此。&lt;/p&gt;

&lt;p&gt;Java 这门语言是商业化、成熟度特别高的语言。无论是语言本身，还是周边框架、工具都有一套非常成熟且层次分明的系统化抽象。如果你有两、三年的编程经验，突然让你上转写 Java 是非常容易的一件事情，尤其是写 Java web。Spring 框架已经为程序员屏蔽了很多复杂问题，而且已经事实上成为了各大互联网公司的主流框架选型。&lt;/p&gt;

&lt;p&gt;我特意按我自己的学习线路绘制了一张 Java 版的程序员学习线路，仅供参考：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vip1.loli.net/2020/05/10/wpNtkiOI231evPV.png&#34; alt=&#34;Java arch.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以清楚的看出来 Java 构建的整个体系最大的特点：它是渐进式的，一步一步地给开发者建立正向的引导。&lt;/p&gt;

&lt;p&gt;当我处在在&lt;strong&gt;应用层&lt;/strong&gt;阶段的时候，我需要关心的只是一些概念，方法，具备基础了以后就可以借助 Spring 框架入门，入门后就可以研究源码，你会发现 Spring 的本质核心类 DispatchServlet，从此 Servlet 就出现在了你的视野。我以前上学时理解不了 java 中 Servlet 的概念，后来参加了工作又学些了 Python，再次看到 Java 中的 Servlet 的时候瞬间就明白了它就是 Python 中的 uwsgi，就是一种接口，将编程语言和服务器网关链接起来的一种规范。&lt;/p&gt;

&lt;p&gt;然后你就可以顺利进入下一环节，服务器/通信。这里你会发现整个网络编程的核心 Socket，同样以前上学的时候没理解 Socket 的概念，继续学习后你就会明白 Socket 其实就是操作系统提供给编程语言的一种能力，有了它就可以建立服务器与客户端之间的通信。在这一环节中你会学习到网络层 TCP/IP 协议，明白了 TCP/UDP 的区别，&lt;code&gt;while (true) { socket.listen() }&lt;/code&gt; 建立 Socket 监听会有性能问题，此时你便进入下一个抽象层次，操作系统和计算机原理。&lt;/p&gt;

&lt;p&gt;为了解决「while true」监听连接的性能问题，你会去学习多线程技术，了解并发的概念。你可能总会听到别人讨论并发和并行的区别。继续学习后，慢慢的你就会明白：并发多用来解决网络IO（硬盘）的效率问题，而并行则是为了更好的利用多/核处理器（CPU）的问题。这时你会发现这个阶段涉及到了很多的计算机硬件知识。内存分配、CPU计算、IO 复用等等。&lt;/p&gt;

&lt;p&gt;像 Spring 这种框架才能真正意义上被称做 &lt;strong&gt;框架&lt;/strong&gt;，因为它不仅仅解决了软件开发的问题，更重要的是 AOP/IoC 这类概念可以完全改变编程的一些理念。使用 Spring 开发 web 应用，联合 Java 构建出来的生态，整个开发流程就像呼吸一样自然。&lt;/p&gt;

&lt;p&gt;Java 构建出来的软件开发体系就像是把程序员放进了一个一个的层次分明的小柜子里面，进去了以后你根本不需要关注外界是怎么样的，做好自己那部分工作就可以了。如果你对外界有兴趣可以一点点的按图索骥跳出你原来的小柜子。即保证精力专注的同时又建立起一套有秩序的提升曲线。这一点是别的语言体系没有的。&lt;/p&gt;

&lt;p&gt;实际上我在转 Java 之前对 Java 有着不小的误解，甚至转 Java 本身也不是我自己的想法。但当你真正转型成 Java 程序员后。看懂了数以百万行记的代码仓库、维护过每秒好几十万的 QPS 项目、见识过百行的 SQL 的时候，你才会对 Java 和软件开发产生一种敬畏之心，才会对技术才有了更深层次的理解。&lt;/p&gt;

&lt;p&gt;这时候再回过头来看前端，看 JavaScript，才会发现它们之间的区别与特点。很多之前争论的东西也就有了结论。&lt;/p&gt;

&lt;h2 id=&#34;瓶颈&#34;&gt;瓶颈&lt;/h2&gt;

&lt;p&gt;我相信从事前端工作稍微长一点（5年以上）的人近两年都会有一种感觉：前端似乎没什么东西可以玩出花样了。这是因为很多东西都已经成为了前端事实上的主流，以前前端没有的基建慢慢的被完善。语言、框架、可视化、跨端、游戏、工具/自动化/工程化 这些领域都在发展。&lt;/p&gt;

&lt;p&gt;语言方面 TypeScript 必然是主流，无论你愿意与否，你都将不得不使用它来写前端。框架方面 React 已经是事实上的主流了，没必要再做选择题。打包工具 Webpack 也是一家独大，虽然被很多人诟病，但是社区生态起来了，想改变就很难。跨端应用 Electron 也不用想了，VSCode 能做好你做不好那就不是选型的问题了。2D 游戏/绘图方面 PixiJS 6 已经在设计中了，3D 我个人认为就先别玩了。&lt;/p&gt;

&lt;p&gt;这些看似成熟的体系实际上还是有很多可以挖掘的东西。如果你不深入研究，或许会认为过两年这些技术就稳定了前端就可以做到大一统的状态。这个想法可能就过于天真了，我举例解释下它们各自的瓶颈：&lt;/p&gt;

&lt;h3 id=&#34;前-客户端框架的瓶颈&#34;&gt;前/客户端框架的瓶颈&lt;/h3&gt;

&lt;p&gt;React（并不特指 React）虽然现在看起来是主流，但是它本身有很多问题是没解决的，甚至可以说是无解的。React 的本质只是一个 UI Library，并不是框架 Framework。框架要解决的问题是系统层面的不是某个抽象层面的。用 React 写过几个项目以后你就会认识到用 React 去写大型项目是非常麻烦的事情，React 本身并不解决 SPA 应用中数据流的问题，甚至没解决状态管理的问题（或者说状态管理本来就是个伪命题？）。一个很简单的父子组件之间状态共享的问题一直没有成熟的解决方案，hooks 这种方案更像是拆了东墙补西墙。&lt;/p&gt;

&lt;p&gt;而且现在 React 社区弥漫着一种崇尚函数式编程的邪气，hooks 更像是一块遮羞布。多数人用 hooks 的原因仅仅是不想使用 Class，因为 Class 很臃肿，function 更简单。当然这个逻辑是没问题的。函数确实简单，但是如果你把一个函数里面写上几百行的代码，各种 hooks 用到飞起的时候，你才会回过头来反思如何组织代码。如果 Class 能以一种更好/更易于理解的方式去抽象那为什么不用呢？&lt;/p&gt;

&lt;h3 id=&#34;后-服务端框架的瓶颈&#34;&gt;后/服务端框架的瓶颈&lt;/h3&gt;

&lt;p&gt;前端框架如此，基于 Node.JS 的后端框架也好不到哪儿去，难道你真的想用 Express/Koa.js 去写大型的后端应用？这种量级的框架连 web 开发最简单的三层模型（ 模型、视图、控制器）支持都不完整。当然你可能会说小型框架本来就只关注某一方面嘛，视图和模型层的东西可以用其它三方库解决。是的，确实可以这样，不过你不觉得 Node.JS 的第三方库有点太多了吗。正如 NestJS 在文档中提到的一个问题一样「很多 JavaScript 类库都没有高效地解决一个问题 &lt;strong&gt;架构&lt;/strong&gt;。」React/Vue/Express/Koa 这些都是相对独立的点，没有一个东西能把他们连接起来形成一个面，形成一种框架级别的体系。这就是架构的问题。&lt;/p&gt;

&lt;p&gt;这里多说一点，结合上面 Java 构建出来的生态，对比 Node.JS 的话。我借用自己打过的比喻：如果你低头看到的是 Node.JS，那么你抬头未必能看见 Java。假如你从事前端开发 2，3 年遇到瓶颈，想转学  Node.JS，你会学习 Exporess/Koa 这类框架，但是很快你就会发现一个严重的问题：没办法深入下去了。因为当你用 Express 写完一个页面后就面临着各种技术上的盲点，会让你无所适从。&lt;/p&gt;

&lt;p&gt;我也尝试绘制一张我对 JavaScript/Node.JS 或者说大前端体系理解的一张图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vip1.loli.net/2020/05/10/6DBWfH7tybxdP1Q.png&#34; alt=&#34;node-arch.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;JavaScript 体系看似前后端通吃，客户端、 服务端甚至桌面端皆有。但是最大的问题在于：没有一个东西能给他们建立起关系并发展成为一种体系。&lt;/p&gt;

&lt;p&gt;插播一条娱乐看点，前两天写 Ruby on rails 框架的作者 DHH 发推并配图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vip1.loli.net/2020/05/10/bKAeufqpHXNRmoG.png&#34; alt=&#34;dhh.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;大意如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;现在的年轻人在 web 开发的时候是这样的嘛？底层逻辑、纯手写连接池 + 纯手工 SQL、配置文件都放在了一起。天哪！（截图中使用的式TJ大神写的 Express 框架）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后 TJ 大神也回复了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vip1.loli.net/2020/05/10/vCJ4zSNBVDmLEHo.png&#34; alt=&#34;tj.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;大意如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;只有菜鸟玩家才能写出干净、简洁、高性能（黑 Ruby 性能）、见名知意的 SQL，而不是去写一个有15层的抽象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;两者的推特对话挺有意思，大家娱乐一下。&lt;/p&gt;

&lt;h3 id=&#34;typescript-语言的瓶颈&#34;&gt;TypeScript 语言的瓶颈&lt;/h3&gt;

&lt;p&gt;TypeScript 也主流，但是持续关注 TS 到现在，我发现 TS 也遇到了瓶颈，这个瓶颈不仅来自于 TS 的设计目标与理念，更多的还是社区及 TC39。TS 的设计初衷是 JavaScript 的超集，由于本身要编译成 JS，这一点本质上限制了 TypeScript 的方向，设计者对于添加一个新特性会非常谨慎，一者怕与 TC39 ES proposal 冲突，二者要考编译到不同版本 JavaScript 的兼容性问题。以至于现在 TS 新的语言特性只会跟进 TC 39 发布的最新 ES proposal。但是我个人对于 TC 39 的效率及未来持怀疑态度，decorator 的提案一直还处于 Stage 2 的阶段，像这种其它语言都成为标配好几年的事情，现在 JavaScript 社区还在草案（stage-2）阶段。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;普及下 ECMA 的标准的流程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;stage-1：前期设想&lt;/li&gt;
&lt;li&gt;stage-2：正式提案（装饰器所在的阶段）&lt;/li&gt;
&lt;li&gt;stage-3：实现候选&lt;/li&gt;
&lt;li&gt;Stage-4：完成测试&lt;/li&gt;
&lt;li&gt;各个浏览器 JS 引擎实现；TypeScript 实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://vip1.loli.net/2020/05/10/zuS1fYsNeyUKtxI.png&#34; alt=&#34;stage2-decorator.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在这个问题上我认为其实也很好解决，开个脑洞：如果微软想借助编程语言一统浏览器和客户端是没有什么不可能的。并入 TC39 组织，开发真正属于 TypeScript 的原生引擎，奉天子以令不臣的方式也未尝不可。&lt;/p&gt;

&lt;p&gt;近几年 Microsoft 对于开源的投入是肉眼可见的，微软要发力我相信很多东西都会有翻天覆地的变化。&lt;/p&gt;

&lt;h3 id=&#34;打包工具的瓶颈&#34;&gt;打包工具的瓶颈&lt;/h3&gt;

&lt;p&gt;Webpack/Babel 就更不用说了，主流中的主流。但是也是问题最严重的一个。Webpack/Babel 的流行恰恰从反面证明了前端的基础设施有多么的烂。现在国外网友老天天叫喊着 Webpack/Babel is eval 也是挺值得深思的。我们引入了一个新工具来解决问题，却又在不经意之间产生了新问题。&lt;/p&gt;

&lt;p&gt;前端构建工具问题的本质还是在于 Node.JS 的包管理工具的设计。这一点在 Node.JS 的作者 Ryan Dahl 关于 Deno 演讲《10 Things I Regret About Node.js》中也有过「官方」的承认。我相信任何一个实现过构建工具的人都被 Node gyp 打败过。node-sass, fsevent 的痛不必细说。更不用说万年被黑的 node_modules 了，你根本不知道一个简单的 npm install 命令会导致安装成千上万个 npm 包被安装到你的机器上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vip1.loli.net/2020/05/10/4FWgDfbqiOLh5Iu.png&#34; alt=&#34;ry-node-regret.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然每种编程语言对应的包管理工具都要解决依赖问题，而且这是一个普遍的问题，脚本/解释型编程语言尤为突出，Python/Ruby/PHP 都有这些类似的问题。或许 Go/Rust 这种把源代码编译打包成单个可执行文件的方式才是好的解决方式。&lt;/p&gt;

&lt;h2 id=&#34;未来&#34;&gt;未来&lt;/h2&gt;

&lt;p&gt;从前人们总是抱怨 JavaScript 这门语言，黑它、讽刺它。但是我看到的是它在一点点变好。不仅是语言层面逐步完善，工具链生态日趋成熟，使用它的也人越来越多。大家对它的关注程度也在提高，整个 JavaScript 开发者的水平也在向更高更强的方向发展。生存环境只会淘汰那些老旧不再进化的事物，能适应变化的才会永存。&lt;/p&gt;

&lt;p&gt;JavaScript 这门语言有两个其它 &lt;strong&gt;任何&lt;/strong&gt; 编程语言都不具备的优点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;几乎 &lt;strong&gt;无所不在&lt;/strong&gt; 且不用安装，有浏览器就有 JavaScript。脚本语言意味着它能被嵌入到任何宿主环境中去：Nginx、Native应用、硬件编程、物连网、嵌入式 都有它的身影&lt;/li&gt;
&lt;li&gt;这门语言对于技术的更新迭代有着强大的 &lt;strong&gt;适应能力&lt;/strong&gt;。JavaScript 本身的更新迭代速度导致它进化速度很多，语言上的新特性会很快被运用到生产环境。相比 Python 而言，这简直是做梦，Python 2 到 3 的转换没人能看到真正的时间表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当下的前端开发状况不由得让我我想起苏东坡《晁错论》中的一段话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;天下之患，最不可为者，名为治平无事，而其实有不测之忧&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最大的问题在于，有些事物，从表面上看着平淡无奇，但实际上底层暗流涌动，似乎每一时刻都有着巨变的可能性。这也是前端开发最有趣也最有潜力的地方。&lt;/p&gt;

&lt;p&gt;作为一名新时代的前端开发者，就是要在这看似风平浪静的表面之下，找到一些真正的突破点，兴许只是一个简单的想法，顺应时势然后造就出不斐的成就也说不定呢。&lt;/p&gt;

&lt;p&gt;无论是前端还是后端、国内还是国外，技术才是真正的核心竞争力，只有技术革新才能提高生产力，而对于我们程序员来讲，编程则是唯一能提升硬实力的方法。只要你心中充满了热情，坚持下去总会走出一条自己的路子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分享一段小经历&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我在 2018 年有幸参加了 TypeScirpt 的推广大会，TypeScript 的作者 Anders Hejlsberg 亲自主讲。一位将近 60 岁的程序员在讲台上滔滔不绝的讲技术方案，TS 的设计理念。你真的很难想像这样一位处于「知天命」阶段的老头子（实际上很年轻）讲的东西。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vip1.loli.net/2020/05/10/lz6uP1RijHBqotd.jpg&#34; alt=&#34;typescript-2015.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;QA 环节有个年轻小伙问到 Anders「在中国做程序员很累、很难应该怎么坚持下去（类似这样的描述，细节记不清楚了）」的问题。&lt;/p&gt;

&lt;p&gt;Anders 几乎毫不犹豫的说出了「Passion」这个单词。我瞬间就被打动了。因为在此之前我对于「激情」这个词的认识还停留在成功人士的演讲说辞层面，当 Anders 亲口说出 Passion 一词的时候，让人感觉真的是一字千金。&lt;/p&gt;

&lt;p&gt;直到现在 Anders 还做为 TypeScript 的核心贡献者为它提交代码，到处奔走为 TypeScript 宣传。&lt;/p&gt;

&lt;p&gt;我们再回到前端，那么未来的前端到底会发展成什么样？长期而言充满了未知数，谁也没法预测，但是短期来讲我比较关注几个东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ESBuild&lt;/strong&gt; ：一个极快的 JavaScript bundler。这个工具可以说是真正的「Game changer」。同样是一个打包任务，它快到让你没反应过来就完成任务了。ESBuild 使用 Go 语言编写，实现了整套 &lt;strong&gt;并行的&lt;/strong&gt; ES 解析器、代码生成器，作者是 Figma 的 CTO（是的国外的 CTO 是要写代码的）。最近更新很频繁，Vue 新的构建工具也会基于它来做 TS 部分的打包功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deno&lt;/strong&gt; ：一个安全的 JavaScript &amp;amp; TypeScript 运行时。Deno 的方向充满了可能性，未来 deno 不仅仅可以做 JS 后端，还能和 Rust 打通，给JS注入一些原生 native 的能力，然后 Webasmbly, webGL 之类的技术都变成了可能，1.0 正式版发布日期也快到了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Figma&lt;/strong&gt;：一个在线版的 Sketch，虽然功能还没有 Sketch 强大，但是已经有了设计界面的基本能力。关键还在于它的整个实现都是基于 web 技术，底层 C++ 实现图形的渲染、绘制，前端通过 Webasmbly 与浏览器 Canvas 交互，做到了让用户在浏览器端体验到了 Native 软件能力。像 AutoLayout 这种功能在用户体验上就是颠覆式的，使用的时候它很自然，没有什么存在感。但是用了就回不去了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你仔细研究一番，上面的这些新鲜东西，都是起源于前端，但又不把视野局限在前端。或许这就是前端未来的发展方向吧。&lt;/p&gt;

&lt;p&gt;这几项技术我们会在后期的更新中会有专门的干货文章，敬请期待~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java 并发与多线程教程</title>
      <link>https://keelii.com/2019/11/24/java-concurrency-and-multithreading-tutorial/</link>
      <pubDate>Sun, 24 Nov 2019 19:10:24 +0000</pubDate>
      
      <guid>https://keelii.com/2019/11/24/java-concurrency-and-multithreading-tutorial/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;注：此文翻译自 &lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/index.html&#34;&gt;Java Concurrency and Multithreading Tutorial&lt;/a&gt;，本文只是首篇翻译&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Java 中的*并发*是一个术语，涉及 Java 平台中的多线程、并发、并行等概念。包括 Java 并发工具，问题和解决方案。这个教程涵盖了多线程的核心概念、并发组成结构、并发的问题、成本与收益以及与 Java 多线程相关的问题。&lt;/p&gt;

&lt;h2 id=&#34;什么是多线程&#34;&gt;什么是多线程？&lt;/h2&gt;

&lt;p&gt;多线程的意思是在同一个应用中有多个*执行线程*。线程就好比是你应用中的一个独立的 CPU。因此多线程的应用就好比一个拥有多个 CPU 的应用程序，这些 CPU 可以在同一时间执行不同的代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/25/pCfkMihbEd6zFla.png&#34; alt=&#34;introduction-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;尽管一个线程并不等同于一个 CPU，但是通常一个 CPU 将会共享执行时间给多个线程，CPU 会在不同的线程之间来回切换，每个线程上执行一点。当然让应用中的线程执行在不同的 CPU 上也是可以的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/25/zJOFEXSY2GTux7H.png&#34; alt=&#34;introduction-2&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;为什么要使用多线程&#34;&gt;为什么要使用多线程&lt;/h2&gt;

&lt;p&gt;大家需使用多线程的原因有很多，最重要的有以下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更好的利用单个 CPU&lt;/li&gt;
&lt;li&gt;更好的利用多个（核）CPU&lt;/li&gt;
&lt;li&gt;更好的用户响应体验&lt;/li&gt;
&lt;li&gt;更好的用户公允体验&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的章节中我将一一解释这几个原因的细节。&lt;/p&gt;

&lt;h3 id=&#34;更好的利用单个-cpu&#34;&gt;更好的利用单个 CPU&lt;/h3&gt;

&lt;p&gt;最常见的原因之一是能够更好地利用计算机中的资源，比如说，一个线程正在等待一个网络请求响应的同时，另一个线程可以利用 CPU 做别的事情。另外，如果计算机有多个 CPU 或者 CPU 有多个执行内核，那么多线程同样可以帮你更好的利用这些 CPU 内核。&lt;/p&gt;

&lt;h3 id=&#34;更好的利用多个-核-cpu&#34;&gt;更好的利用多个（核）CPU&lt;/h3&gt;

&lt;p&gt;如果计算机有多个 CPU 或者 CPU 有多个执行内核，那么你需要在应用中使用多线程来更好的利用到所有的 CPU 和多核 CPU。单个线程最多只能利用一个 CPU，就像我上面提到的，有时甚至不能完全地利用好一个 CPU。&lt;/p&gt;

&lt;h3 id=&#34;更好的用户响应体验&#34;&gt;更好的用户响应体验&lt;/h3&gt;

&lt;p&gt;另外一个使用多线程的原因是提供良好的用户体验。比如说，当你点击了一个 GUI 界面上的按钮，这个动作会触发一个网络请求，接着哪个线程来处理这个请求就非常关键了。如果你同时又使用这个处理请求的线程来更新 GUI 界面，然后当 GUI 线程等待请求响应时用户就会体验到 GUI *挂起*的状态。作为替代方案，这个处理请求的线程可以单独创建成后台线程，这样的话 GUI 线程就可以用来同时响应其它请求。&lt;/p&gt;

&lt;h3 id=&#34;更好的用户公允体验&#34;&gt;更好的用户公允体验&lt;/h3&gt;

&lt;p&gt;第四个原因是在用户之间更公平的共享资源，想象一个例子，服务器接收客户端的请求，但是只有一个线程来处理这些请求。如果有一个客户端发送了一个请求并且处理了很久，然后其它客户端请求不得不等待那个请求结束。让每个请求都有一个属于自己的处理线程去执行，这样的话就不会有任何一个任务可以完全地霸占 CPU。&lt;/p&gt;

&lt;h2 id=&#34;多线程与多任务&#34;&gt;多线程与多任务&lt;/h2&gt;

&lt;p&gt;以前的计算机只有一个 CPU，并且在同一时间只能执行一个程序。许多的小型计算机并没有强大到能在同一时间执行多个程序，也没有尝试过这么设计。坦白地说，许多主机系统可以在同一时间执行多任务这比个人电脑已经提前好多年了。&lt;/p&gt;

&lt;h3 id=&#34;多任务处理&#34;&gt;多任务处理&lt;/h3&gt;

&lt;p&gt;后来多任务出现了，这意味着计算机可以同时执行多个程序（或者说任务、进程），这才真正意义上叫做同时执行。CPU 在多个程序之间被共享。操作系统在运行的程序中来回切换，每次执行一小会儿。&lt;/p&gt;

&lt;p&gt;随着多任务处理给软件开发人员带来了新的挑战，程序不再假设 CPU 一直可用，其它如内存这样的计算机资源也一样。好的程序员会在不使用资源的时候释放它们，这样别的程序才可以使用到这些资源。&lt;/p&gt;

&lt;h3 id=&#34;多线程处理&#34;&gt;多线程处理&lt;/h3&gt;

&lt;p&gt;后来又出现了多线程。这意味着在程序内部你可以有多个执行线程。执行线程可以想象成 CPU 执行程序。当你有多个线程执行同一个程序时，就好比多个 CPU 在同一个程序中执行。&lt;/p&gt;

&lt;h2 id=&#34;多线程并非易事&#34;&gt;多线程并非易事&lt;/h2&gt;

&lt;p&gt;对于某些程序而言，多线程是一个非常好的提升性能的办法。然而多线程的使用相对于多任务来说具有更高的挑战。多个线程在同一个程序中执行，因此可以同时读取和写入相同的内存。这可能会导致一些单线程应用中不存在的问题。这些问题在单 CPU 的机器上可能不会被发现，因为&lt;strong&gt;两个线程永远不可能真正地同时执行&lt;/strong&gt;。尽管如此，现代计算机可以拥有多核CPU，或者多个 CPU。这意味着不同的线程可以在不同核心的 CPU 上被同时执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/25/mOCWPpeyrZNEfTX.png&#34; alt=&#34;java-concurrency-tutorial-introduction-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果没有合适的预防措施，这些问题就很可能会出现。程序行为甚至不能被预测。结果可能频繁地改变。因此对于程序员来说做好预防措施就变得非常重要—意味着需要去学习线程是如何访问到共享资源（内存、文件、数据库）的，这也是一个本教程要讲到的主题。&lt;/p&gt;

&lt;h2 id=&#34;java-中的多线程与并发&#34;&gt;Java 中的多线程与并发&lt;/h2&gt;

&lt;p&gt;Java 是首个把多线程处理特性提供给开发者的编程语言之一。Java 在最开始的时候就提供了多线程处理的能力。因此 Java 程序员经常面临上面我们提到的问题。这也是我写这篇文章的初衷，做为我自己的学习记录的同时也希望其它 Java 程序员能从中受益。&lt;/p&gt;

&lt;p&gt;本教程将主要关注 Java 中的多线程处理。但是有的多线程问题与分布式系统中多任务处理面临的问题很相似。所以教程中也会出现多任务与分布式系统的相关引用，因此教程使用「并发」而不是「多线程」这个关键字。&lt;/p&gt;

&lt;h2 id=&#34;并发模型&#34;&gt;并发模型&lt;/h2&gt;

&lt;p&gt;第一种*并发模型*假定多个线程在同一个程序中执行并可以同享对象。这种并发模型被称做「共享状态的并发模型」，有很多并发语言的组件构成都支持这种并发模型。&lt;/p&gt;

&lt;p&gt;然而，自从第一本 Java 并发书被写出以来并发构架设计已经发生了很多变化，甚至是从 Java 5并发工具包发布以来，并发构架设计也经历了很多的变化。&lt;/p&gt;

&lt;p&gt;共享状态的并发模型会引发很多难以解决的并发问题，因此，另外一种被叫做「无共享/状态分离」的并发模型流行了起来。在状态分离的并发模型中线程之间不共享任何对象或数据。这样就可以避免很多在共享并发模型中的并发访问类题。&lt;/p&gt;

&lt;p&gt;最新的如 Netty, Vert.x 和 Play,Akka, Qbit 等异步「状态分离」平台套件慢慢崭露头角。新的非阻塞并发算法也已经发布，新的非阻塞工具像 LMax Disrupter 也被加进了套件中。Java 7 中的 Fork 和 Join 框架也引入了新的函数式编程并行特性。&lt;/p&gt;

&lt;p&gt;随着技术的不断发展，也是时候更新下这篇教程了。因此这篇教程再一次进入了&lt;strong&gt;重写&lt;/strong&gt;状态。新的教程会在合适的时间发布。&lt;/p&gt;

&lt;h2 id=&#34;java-并发学习指引&#34;&gt;Java 并发学习指引&lt;/h2&gt;

&lt;p&gt;如果你对 Java 并发还不是很了解，我建议你按下面的学习计划。你可以在左侧的菜单中找到所有主题的链接。&lt;/p&gt;

&lt;p&gt;通用的并发与多线程理论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/benefits.html&#34;&gt;多线程的好处&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/costs.html&#34;&gt;多线程的代价&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/concurrency-models.html&#34;&gt;多线程模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/same-threading.html&#34;&gt;Same-threading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html&#34;&gt;并发与并行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java 并发基础：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/creating-and-starting-threads.html&#34;&gt;Creating and Starting Java Threads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html&#34;&gt;Race Conditions and Critical Sections&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/thread-safety.html&#34;&gt;Thread Safety and Shared Resources&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/thread-safety-and-immutability.html&#34;&gt;Thread Safety and Immutability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/java-memory-model.html&#34;&gt;Java Memory Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/synchronized.html&#34;&gt;Java Synchronized Blocks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/volatile.html&#34;&gt;Java Volatile Keyword&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/threadlocal.html&#34;&gt;Java ThreadLocal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/thread-signaling.html&#34;&gt;Java Thread Signaling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java 并发中的经典问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/deadlock.html&#34;&gt;Deadlock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/deadlock-prevention.html&#34;&gt;Deadlock Prevention&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html&#34;&gt;Starvation and Fairness&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/nested-monitor-lockout.html&#34;&gt;Nested Monitor Lockout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/slipped-conditions.html&#34;&gt;Slipped Conditions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java 中用来解决上面问题并发体系：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/locks.html&#34;&gt;Locks in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/read-write-locks.html&#34;&gt;Read / Write Locks in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/reentrance-lockout.html&#34;&gt;Reentrance Lockout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/semaphores.html&#34;&gt;Semaphores&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/blocking-queues.html&#34;&gt;Blocking Queues&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/thread-pools.html&#34;&gt;Thread Pools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html&#34;&gt;Compare and Swap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多主题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/anatomy-of-a-synchronizer.html&#34;&gt;Anatomy of a Synchronizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html&#34;&gt;Non-blocking Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/amdahls-law.html&#34;&gt;Amdahl&amp;rsquo;s Law&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/references.html&#34;&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>漫谈哲学与编程</title>
      <link>https://keelii.com/2019/08/25/philosophy-and-programming/</link>
      <pubDate>Sun, 25 Aug 2019 18:33:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/08/25/philosophy-and-programming/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://i.v2ex.co/nfs1f0Yn.jpeg&#34; alt=&#34;philosophy and programming&#34; /&gt;&lt;/p&gt;

&lt;p&gt;谈到哲学，多数人都会直觉性的认为它是很高深的一门学问。实际上大多数情况并非如此，哲学研究的往往是非常简单的一些命题，而这些命题在常人看来可能并没有现实意义。&lt;/p&gt;

&lt;p&gt;比如说：到底是先有鸡还是先有蛋的问题；比如说：一个号称只给不能给自己理发的人理发的理发师到底能不能给自己理发的问题。当然本文的目的并不在于讨论这两个问题，我们来聊聊几个稍微简单一些的概念：&lt;/p&gt;

&lt;h3 id=&#34;哲学中的理性与感性&#34;&gt;哲学中的理性与感性&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;理性是超越的，本质在于追求无限&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;超越&lt;/strong&gt;的意思是说理性本身不依赖任何现实或者经验社会中的任何对象，&lt;strong&gt;无限&lt;/strong&gt;实际上就是说理性本身需要达到的某种理想状态。&lt;/p&gt;

&lt;p&gt;比方说：「&lt;strong&gt;100%的金」&lt;/strong&gt; 就是一种无限状态。我们不使用任何经验就可以判断出 100% 的金是必然有的，概念上没人能否定这一点。&lt;/p&gt;

&lt;p&gt;但是运用在经验社会中的知识来判断，这个命题就是不正确的，或者说不具有*普遍*的正确性。因为我们知道无论人类的技术如何高超也无法制造出来 100% 的金。即使到 99.99% 逻辑上也没到达 100%。&lt;/p&gt;

&lt;p&gt;这个时候人们对于类似的事情就会产生了不同的反应。有的人会因为理想状态达不到而&lt;strong&gt;反向&lt;/strong&gt;地认为原来的命题是错误的；有的人内心则有一种说不清道不明的东西指引着他，不会因为到达不到无限状态而肯定整个命题。&lt;/p&gt;

&lt;p&gt;这个问题也一直困扰了我很久，因为在现实生活中在你看来很多明显正确的事情忽出现了一个反例，结果就会有一堆人来告诉你你错了。&lt;/p&gt;

&lt;p&gt;德国哲学家康德在《&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BA%AF%E7%B2%B9%E7%90%86%E6%80%A7%E6%89%B9%E5%88%A4&#34;&gt;纯粹理性批判&lt;/a&gt;》这本书中给出了一种解释：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;理性的调节性是引导经验去追求无限，追求绝对，但是永远也达不到。达不到也有作用 — 它使得经验科学不断的前进，并且有了明确的目的和方向…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;类似的哲学观点好就好在一但明白了其中的本质和它阐述的真理以后，它就可以在某种层次上解释经验世界的各种现象。这或许就是大家说的哲学是任何其它学科的奠基，是第一学科的原因。&lt;/p&gt;

&lt;p&gt;对应的在编程领域也有一些无限的概念，对于多数前端工程师来讲「实现一个无限级的下拉菜单」似乎也在表达着一种无限状态。当然用户在使用的时候根本不可能用到无限级的菜单，无限级的菜单在交互方面也也是极其反人类的，一步可以做到的事情没人愿意多增加一步。但是为什么程序员们热衷于实现这种类似的无限状态。实际上这就是理性的力量，总有一种说不清楚的力量在引导着你，你也没法解释。&lt;/p&gt;

&lt;p&gt;理解了这一点你就会有一个很简单的评判程序好坏的论点，即：程序或者代码是否表现了某种&lt;strong&gt;无限&lt;/strong&gt;状态？如果你的程序函数里面只是几个简单的 if else，那你有没有考虑过如果当输入不断的增加或者变化时，原来的代码是否还可以正常返回。或者说在不考虑硬件等客观条件的前提下，你的程序是否存在极限状态。&lt;/p&gt;

&lt;p&gt;我们经常在知乎或者其它论坛上争论一些问题，本质上讲大家都没有区分清楚自己对于一个论点的&lt;strong&gt;逻辑认知&lt;/strong&gt;和&lt;strong&gt;情感认知&lt;/strong&gt;。太多人喜欢用自己的感情认知去否定逻辑事实，以至于争来争去谁也没能说服谁，试图用唯心观点去解释唯物的现象或者相反，这是极其不正确的。&lt;/p&gt;

&lt;p&gt;一个典型的问题是我不久之前在知乎上回答的一个问题：&lt;a href=&#34;https://www.zhihu.com/question/309891718&#34;&gt;谁能大致说下vue和react的最大区别之处&lt;/a&gt;？我的回答简单总结就两句话：Vue 有一种设计层面追求的简洁感性之美，React 则是一种数学层面的逻辑一致之美。本质上讲没有什么好坏之分。但是诸如些类的一些前端框架问题正在变成一种帮派化的「站队」风气。&lt;/p&gt;

&lt;h3 id=&#34;编程中的低阶-low-level-与高阶-hight-level&#34;&gt;编程中的低阶（low-level）与高阶（hight-level）&lt;/h3&gt;

&lt;p&gt;注意这里讲的 low/hight level 并不是计算机术语中特定的某种形式。&lt;/p&gt;

&lt;p&gt;有个笑话是这么讲的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个程序员去相亲，程序员自己介绍说「我是做嵌入式C语言底层开发的」，妹子反问「那啥时候做到高层开发呢」？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;程序员们内心都有一个做底层开发的梦，因为这才是一个真正的程序员的追求与理想。&lt;/p&gt;

&lt;p&gt;但是现实往往相反，大多数程序员每天都在写业务代码（重复的 CRUD）。所以很多程序员得出来一个结论就是：越底层的东西越重要，越高层的东西越肤浅。通常这也会行成一条鄙视链，他们会不由自主地忽略高层的东西。&lt;/p&gt;

&lt;p&gt;注意这里有两个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;业务代码有没有价值？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然有了，业务部分的代码是系统的最终结果。从结果导向上讲底层代码如何优雅、实现如何科学我们根本不关心，我们更关心整个系统层面的稳定与健壮。这是一种领导的高层次视角。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;底层的东西就一定重要？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;并不一定，这里说的不一定不是要完全否定底层的重要性。恰恰相反，软件领域一些特别优秀或者说伟大的软件底层并不是那么的如人意。比方说微软开发的 VSCode 代码编辑器。要是从底层去讨论它的构架合理性那确实挺像一个笑话的。因为本质上讲 VSCode 基于 electron，它把编辑器放在了一个 webview 中去运行，但是 webview 是用来浏览网页的，而且 electron 居然把 NodeJS 运行时也整合进去，以至于最小的一个应用解压完也有上百兆。&lt;/p&gt;

&lt;p&gt;这感觉就像是上学的时候你很期待一个数学教授教你数学课，但是实际上你的数学课却是一个体育老师带的，这不是可不可以的问题对吧。&lt;/p&gt;

&lt;p&gt;然而 VSCode 这样做的结果是：它还真的成功了，而且编辑器的性能比很多原生软件做的都要好，以至于周围所有人都在使用它，VSCode 在 Github 上名列前茅，也改变了很多程序员对于微软的刻板印象。&lt;/p&gt;

&lt;p&gt;如果我们再回过头从哲学的角度去思考这个问题，实际上计算机中的&lt;strong&gt;底层&lt;/strong&gt;与&lt;strong&gt;高层&lt;/strong&gt;正好对应着哲学中的&lt;strong&gt;理性&lt;/strong&gt;与&lt;strong&gt;感性&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;底层更注重逻辑严谨，因为这是构建高层建筑的基础，它面向的是理论&lt;/li&gt;
&lt;li&gt;高层更注重表现形式，因为高层的部分呈现出来的是一个完整的系统，它面向的对象是人。是人，那需求就是多样化的，因为人的想法总是特别的感性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理性的认知是有对错可以批判的，但是感性的直观是没有对错的，因为即使是同一种声音、颜色对不同人观感都是不一样的。&lt;/p&gt;

&lt;p&gt;比如说你在火车上看书，对面的人说话声音太大吵到了你。你说：你们说话小声点可以吗？对方会说：车上这么多人说话为啥就我们吵到你了？你说：因为就你们声音最大。对方说：我咋没觉得？&lt;/p&gt;

&lt;h3 id=&#34;现实中的主观与客观&#34;&gt;现实中的主观与客观&lt;/h3&gt;

&lt;p&gt;现实生活中我们经常会遇到一些对于论点的评价：主观还是客观。但是很多人没搞清楚这两个词的关系。多数人都觉得客观的观点就是好的，主观的就是臆断的。&lt;/p&gt;

&lt;p&gt;主观和客观的关系就像是主人与客人的关系一样，有的人会认为应该主随客便，有的人则认为应该是客随主便。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果一个人表达的观点全是主观的，那我们会认为这些观点是不可以讨论与评判的，不经过讨论批判的观点是站不住脚的。&lt;/li&gt;
&lt;li&gt;如果一个人表达的观点全是客观的，那似乎也不对，因为这些观点全是别人的，你可能忽略了自己的意识，最终只能游走在别人的规则中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任何语言中都有那么一些词语是成对儿出现的，像因果、主客、高低，这些词在被造出来的时候就是成对出现的，缺一不可。没有前者，后者将不会单独存在。它们之间没有绝对性的对于错。如果有，那对方就没有了存在的意义，反过来自己也将不存在。&lt;/p&gt;

&lt;p&gt;当有人抛出一个观点的时候我的经验是一定要听清楚对方说的是「我觉得」还是「我认为」。「我觉得」那必然就是人家的主观感受，这种观点我们就没必要讨论了。你应该回复：「嗯，没错，确实是这样的。」。如果对方说「我认为」那你要是有不同的观点就完全可以和他讨论，因为说「我认为」的观点必然是有一些客观事实做为依据的，有事实有逻辑，那就可以有对错。&lt;/p&gt;

&lt;h3 id=&#34;结语&#34;&gt;结语&lt;/h3&gt;

&lt;p&gt;哲学中的知识并不能完全解释现实中的事物，因为哲学研究的终点是一些没有结论的东西：上帝、自由、灵魂不朽。这些东西并非常人能理解的，但是人们对于无限真理的追求驱使着大家去研究它，很多人会觉得既然研究不出来结果那是不是就没意义了，当然不是。事实恰恰相反，如果我们把所有的事物本质都研究清楚了，那我们的存在也将失去意义。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>法布里斯·贝拉 — 一个真正的程序员</title>
      <link>https://keelii.com/2019/07/13/a-real-programmer-fabrice-bellard/</link>
      <pubDate>Sat, 13 Jul 2019 18:33:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/13/a-real-programmer-fabrice-bellard/</guid>
      <description>&lt;p&gt;&lt;strong&gt;法布里斯·贝拉&lt;/strong&gt;是一位法国著名的计算机程序员，在7月9日前我对他几乎一无所知。也就在这一天他发布了 &lt;a href=&#34;https://bellard.org/quickjs/&#34;&gt;QuickJS&lt;/a&gt; 引擎的首个公开发行版。这个名字才进入了很多和我一样无知的前端工程师的世界里。&lt;/p&gt;

&lt;p&gt;官网中是这么介绍 QuickJS 的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;QuickJS 是一个精巧可嵌入的 JavaScript 引擎。它支持 &lt;a href=&#34;https://tc39.es/ecma262/&#34;&gt;ES2019&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:JavaScript&#34;&gt;&lt;a href=&#34;#fn:JavaScript&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 中的很多特性 — 模块、异步生成器和代理。可选支持数学扩展 — 大整型，大浮点型数和操作符重载。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;主要的功能特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;轻量级很方便嵌入：源代码也只有几个 C 文件，没有外部依赖，一个简单的 hello world 程序会被编译成190Kb 的 x86 代码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;超快的解释器及启动时间：在一个普通的桌面 PC 上跑 ECMAScript 测试套件中的 56000 个用例只需要 100 秒&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;几乎完成的 ES2019 新特性支持，模块、异常生成器和完整的 Annex B&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Hypothetical-Ref&#34;&gt;&lt;a href=&#34;#fn:Hypothetical-Ref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 支持&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以将 JavaScript 源代码编译成无任何外部依赖的可执行程序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;垃圾回收使用引用计数机制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数学扩展支持：大整型，大浮点型数、操作符重载、大整型模式、数学模式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 JavaScript 实现的具有色彩支持的命令行解释器&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内置的微型标准库（C语言包装而成）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript 引擎在这之前只有主流的 Google V8，忽然出现这么一个项目，还是非常令人震惊的，尤其是它上面的这些特性，某种程度上让前端看到了新希望。&lt;/p&gt;

&lt;p&gt;QuickJS 发布后不久后，便在 Hack news、Twitter 上引发了大量的讨论，我也不由得起了八卦之心。下面引用一些网友的讨论：&lt;/p&gt;

&lt;p&gt;HN 上有网友回复到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is there anything that Fabrice can&amp;rsquo;t do? I mean, FFMpeg is almost a PhD thesis in and of itself, and he still manages to find time to make TinyC, QEMU, and now this. To say I&amp;rsquo;m jealous of his skills would be an understatement.&lt;/p&gt;

&lt;p&gt;还有什么事情是&lt;strong&gt;法布里斯&lt;/strong&gt;不能做的吗？我的意思是，FFMpeg 几乎是一个 PhD 论文级别的项目，但是他仍然有时间写 TinyC、QEMU 现在又是 QuickJS。我对他的佩服之情已经远超「嫉妒」之心。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;后面的网友也是八卦之心作祟：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I have two question in my mind. 我有两个问题&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Are there anyone on HN knows him in real life? HN 上有了解法布里斯在现实生活中的样子吗？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Does anyone have other people in their mind who is in the same league as this man? — 大家心目中与法布里斯类似的人有哪些？&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;++第一个问题++：根据几个（有机会见到过本人）网友的描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I know Fabrice a little. He&amp;rsquo;s definitely real, smart and humble. — 我知道一点关于&lt;strong&gt;法布里斯&lt;/strong&gt;。他是肯定是一个实际存在的、聪明且谦逊人。&lt;/p&gt;

&lt;p&gt;He is definitely very humble and a very good listener. — 他绝对是一个非常谦逊、内敛人，是一个非常好的倾听者。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;++第二个问题++：简单来说就是有没有和法布里斯一样利害的程序员，网友纷纷回复了自己眼中最利害的程序员名字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dan Bernstein&lt;/strong&gt; — 德裔美国数学家，密码学家和程序员。埃因霍温理工大学数学与计算机科学系的个人教授。发明了chacha20算法（几乎所有的现在加密算法都在使用它）。1995年，伯恩斯坦将&lt;strong&gt;伯恩斯坦诉合众国案&lt;/strong&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:-&#34;&gt;&lt;a href=&#34;#fn:-&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;件提起诉讼。该案的裁决宣称软件是第一修正案下的受保护言论。此前加密算法是高度机密的，受到国家/政府管制的，而伯恩斯坦自己认为写的 Snuffle 加密算法及相关的源代码是某种意义上的言论自由，因此与美国政府打官司最后还赢了，在那之后发表自由/开源软件才被视为一种言论自由。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Richard Stallman&lt;/strong&gt; — 理查德·马修·斯托曼，美国程序员，自由软件活动家。&lt;a href=&#34;https://zh.wikipedia.org/wiki/GCC&#34; title=&#34;GCC&#34;&gt;GCC&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/GNU%E4%BE%A6%E9%94%99%E5%99%A8&#34; title=&#34;GNU调试器&#34;&gt;GDB&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/Emacs&#34; title=&#34;Emacs&#34;&gt;GNU Emacs&lt;/a&gt; 都是他的作品&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linus Torvalds&lt;/strong&gt; — 芬兰程序员，Linux内核的最早作者，是当今世界最著名的计算机程序员、黑客之一。他的作品 Linux、Git 或许是开源软件领域最成功的两个项目。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;John Carmack&lt;/strong&gt; — 约翰·卡马克，美国的电玩游戏程序员、id Software 的创始人之一。卡马克创造的游戏引擎被用来制作其他的第一人称射击游戏，比如《半条命》和《荣誉勋章》&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rob Pike and Ken Thompson&lt;/strong&gt; — 肯·汤普逊，他创造了Go 语言、&lt;a href=&#34;https://zh.wikipedia.org/wiki/B%E8%AF%AD%E8%A8%80&#34; title=&#34;B语言&#34;&gt;B语言&lt;/a&gt;（&lt;a href=&#34;https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80&#34; title=&#34;C语言&#34;&gt;C语言&lt;/a&gt;的前身）。与&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87&#34; title=&#34;丹尼斯·里奇&#34;&gt;丹尼斯·里奇&lt;/a&gt;同为1983年&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96&#34; title=&#34;图灵奖&#34;&gt;图灵奖&lt;/a&gt;得主。&lt;/p&gt;

&lt;p&gt;后面还有有提到前端比较熟悉的 TJ 大神等。&lt;/p&gt;

&lt;p&gt;法布里斯与其它程序员不同的是他似乎很少有网络社交，平常人想与他沟通只能用 email，他没有任何社交账号。如果提到 Linus，你脑海里面一定会出现那些他说过的名言：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Talk is cheap. Show me the code, I am linus i&amp;rsquo;m your god.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linus 的利害之处在于他说他是你的上帝，一般人连否定这句话的资格都没有。从前我也一直很崇拜 Linus，因为它比较高调，语出惊人又无法否定。法布里斯则不一样，相比而言更低调，更有传统程序员的特点。但是朴实的外表怎么能遮住人家的才华呢。&lt;/p&gt;

&lt;p&gt;法布里斯的每个作品都是那么惊艳：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开源软件 FFmpeg，几乎被现在所有主流的媒体播放器使用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;发明了贝拉公式—最快圆周率算法，这个计算 N 位 PI 的公式比传统的 BBQ 算法要快 47%&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在PC上用软件实现 4G LTE 基站&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 JavaScript 写了一个 PC 虚拟机 &lt;a href=&#34;https://zh.wikipedia.org/wiki/Jslinux&#34; title=&#34;Jslinux&#34;&gt;Jslinux&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;QuickJS 问世后，JavaScript 之父 Brendan Eich 也坐不住了，称赞法布里斯是&lt;strong&gt;超级黑客&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/13/5d297b8fad00320486.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;实际上我觉得不应该给这些利害的程序员以程序员的「分类」，因为写代码/编程对于他们来说只是一种手段或者方法，最重要的是他们创造出来的东西会让世界上所有的人受益。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:JavaScript&#34;&gt;JavaScript 语言最新的标准规范 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:JavaScript&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Hypothetical-Ref&#34;&gt;Hypothetical Reference Decoder  &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Hypothetical-Ref&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:-&#34;&gt;伯恩斯坦诉合众国案 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:-&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>我想要 AOP — 使用 AOP 分离关注点</title>
      <link>https://keelii.com/2019/07/06/i-want-my-aop-cn/</link>
      <pubDate>Sat, 06 Jul 2019 18:33:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/06/i-want-my-aop-cn/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&#34;https://www.javaworld.com/article/2073918/i-want-my-aop---part-1.html&#34;&gt;I want my AOP&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;关注点&lt;/strong&gt;表示人们的一种特殊的意愿、理念或是某个感兴趣的领域。从技术角度来讲：软件系统包括若干&lt;strong&gt;核心的&lt;/strong&gt;、&lt;strong&gt;系统级别的&lt;/strong&gt;关注点。比方说：信用卡处理系统的&lt;strong&gt;核心&lt;/strong&gt;关注点是处理交易，同时系统级别的关注点或许应该是处理日志、事务、一致性、授权、安全、性能等。许多这种关注点被叫做&lt;strong&gt;横切关注点&lt;/strong&gt; — 往往会影响许多模块的实现。&lt;/p&gt;

&lt;p&gt;使用目前的编程方法，跨越多个模块横切关注点会导致系统更难设计、理解、实现和迭代。&lt;/p&gt;

&lt;p&gt;阅读完全的「我想要 AOP」系列文章：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第一部分&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二部分&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第三部分&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;面向切面的编程相比之前的方法更简单的分享了关注点，从而提供横切关注点的模块化。&lt;/p&gt;

&lt;p&gt;在本系列文章中，第一篇涉及 AOP 的概念，我首先解释了在一般复杂的软件系统中由横切关注点引起的问题。然后，我引入了 AOP 核心概念，并展示了 AOP 是如何通过横切关注点解决问题的。&lt;/p&gt;

&lt;p&gt;这个系列的第二篇文章将介绍 AspectJ，Xerox PARC 基于 Java 实现的 AOP 框架。最后一篇文章将以几个示例的方式向你展示 AOP 的概念，并基于建立更易懂、易实现、易迭代的软件系统。&lt;/p&gt;

&lt;h2 id=&#34;软件编程方法的演进&#34;&gt;软件编程方法的演进&lt;/h2&gt;

&lt;p&gt;早些年的计算机科学领域，开发者直接使用机器码进行编程。不幸的是，程序员花了更多时间去考虑特定机器的指令集而不是手头的问题。慢慢地，我们迁移到高级编程语言，高级编程语言允许对底层机器码进行一些抽象。然后结构化的语言出现了；我们现在可以根据任务的执行过程来分解我们的问题。然而，随着复杂度的增长，我们需要更好的技术。面向对象的编程让我们可以把系统看成一系列的合作对象。类可以让我们隐藏接口背后的实现细节。多态提供了通用行的为和接口，并允许更特殊的组件更改指定定行为，而无需接触基本概念的实现。&lt;/p&gt;

&lt;p&gt;编程方法和语言定义了我们与机器交流的方式。每一种新方法都提供某种分解问题的方式：机器码、独立于机器的代码、过程、类等等。每种方法都在建立某种&lt;strong&gt;系统需求&lt;/strong&gt;与&lt;strong&gt;程序结构&lt;/strong&gt;之间的对应关系。这些编程方法的演进让我们可以创建越来越复杂的系统。反过来复杂的系统使得我们又必须使用更先进的技术去解决这些复杂度。&lt;/p&gt;

&lt;p&gt;目前来讲，放多新的软件项目开发都使用面向对象的编程模式。的确，面向对象的编程模式能模拟常见行为方面表现出了强大的能力。然而，我们很快将会看见，或许你已经有所体验了，面向对象的编程模式没能充分地解决许多跨区的行为的问题 — 那种通常不相关的模块。相比而言，面向切面的编程方法填补了这个空白。AOP 很可能代表了编程方法演进的下一个重要方向。&lt;/p&gt;

&lt;h2 id=&#34;将系统看做一系列的关注点&#34;&gt;将系统看做一系列的关注点&lt;/h2&gt;

&lt;p&gt;我们可以将复杂系统看做是多个关注点的联合实现。典型的系统可能包含多种关注点，包括业务逻辑、性能、数据持久化 、日志，以及调试、授权、安全、线程安全 、错误检查等等。而且你还会遇到开发流程中的关注点，比如说：可理解、可维护，可追溯、更易迭代。图1描绘出了一个系统中不同模块关注点的实现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/05/5d1f0bb5278bd31387.gif&#34; alt=&#34;&#34; /&gt;图1&lt;/p&gt;

&lt;p&gt;图2展示了一系列的需求（一个光束）通过关注点识别器（棱镜）分离各种关注点成为独立模块。这个过程就对应着我们开发过程的关注点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/05/5d1f0d071673b46919.gif&#34; alt=&#34;&#34; /&gt;图2&lt;/p&gt;

&lt;h2 id=&#34;在系统中进行横切&#34;&gt;在系统中进行横切&lt;/h2&gt;

&lt;p&gt;开发者建立一个系统并且负责实现多个需求。我们可以把这些需求大体上从&lt;strong&gt;核心模块&lt;/strong&gt;级别需求与&lt;strong&gt;系统级别&lt;/strong&gt;需求两个维度进行分类。许多系统级别的需求相互之间（或与模块级别的需求）是正交的（相互依赖）。系统级别的需求倾向于横切许多核心模块，比如，一个个典型的企业应用包含的横切关注点有：身份验证，日志记录，资源池，管理，性能和存储管理。每个都被横切成多个子系统。比如，存储管理会影响每个业务对象。&lt;/p&gt;

&lt;p&gt;让我们举个简单的例子，比如有一个单例实现封装了一些业务逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SomeBusinessClass extends OtherBusinessClass {
    // 核心数据成员
    // 其它数据成员：比如日志，数据一致性标识
    // 重写基类中的方法
    public void performSomeOperation(OperationInformation info) {
        // 保证授权正常
        // 保证条件正常满足
        // 锁定对象保证数据一致性
        // 线程进入threads access it
        // 保证缓存正常
        // 打印操作启动日志
        // ==== 进行具体的操作 ====
        // 打印操作完成日志
        // 解锁对象
    }
    // 与上面类似的其它操作
    public void save(PersitanceStorage ps) {
    }
    public void load(PersitanceStorage ps) {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中我们必须考虑至少三个问题，首先，&lt;strong&gt;其它数据成员&lt;/strong&gt;不属于这个类所关心的内容。其次，performSomeOperation 的实现似乎比核心操作执行了更多的逻辑；它处理了日志、授权、线程安全以及其它&lt;strong&gt;外部&lt;/strong&gt;关注点。重要的是，似乎这些许多外围关注点其它类也会用到。最后，save() 和 load() 方法操作存储层，这两个方法放在这个类中比较合适还是放在其它类中比较合适，这个问题并不是很清楚。&lt;/p&gt;

&lt;h2 id=&#34;横切关注的问题&#34;&gt;横切关注的问题&lt;/h2&gt;

&lt;p&gt;虽然会跨模块横切关注点，但是现在的技术实现倾向于使用一维的方式实现，把问题聚焦在需求与实现的单一维度。这个单一维度的实现将变成&lt;strong&gt;核心模块&lt;/strong&gt;级别的实现。其余的需求围绕着这个主导维度被分类。换句话说，需求空间是多维的，然而实现空间是单维的。这种不匹配会导致需求与实现之间的映射难以做到。&lt;/p&gt;

&lt;h3 id=&#34;症状&#34;&gt;症状&lt;/h3&gt;

&lt;p&gt;使用目前的方法实现横切关注点会出现一些问题/症状，大体上分两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码纠缠&lt;/strong&gt;：系统中的模块可能会同时地与多个需求交互。比如，开发者经常同时考虑业务逻辑、性能、同步、日志和安全等问题。大量的并行需求导致需要许多关注点的实现同时存在，最终导致代码纠缠。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码分散&lt;/strong&gt;：由于横切关注点，按定义，很多模块都需要分离，甚至是相关的实现都需要分离。比如，一个使用数据库的系统，性能问题可能会影响所有访问数据库的模块&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;暗示&#34;&gt;暗示&lt;/h3&gt;

&lt;p&gt;代码纠缠与代码分散对软件设计和开发有以下影响：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不可追溯&lt;/strong&gt;：同时分离多个关注点会&lt;strong&gt;掩盖&lt;/strong&gt;关注点与实现之间的对应关系，导致关系不清楚&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;低效的&lt;/strong&gt;：同时实现多个关注点会打乱开发者的注意力，将注意力分散到外围问题上，这将导致低效&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码复用性低&lt;/strong&gt;：由于模块实现了多个需求，其它系统将无法很容易地复用这个模块，进一步导致低效&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码质量低&lt;/strong&gt;：代码纠缠会产生一些不易查觉的问题。此外，一次关注太多问题，某些关注点可能没有被真正关注到&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;难于迭代&lt;/strong&gt;：有限的视界和受限的资源通常会产生仅解决当前关注点的设计。解决未来问题通常需要重新实现。由于这个实现并不是模块化的，这表示触摸许多模块。为了实现新需求需要修改每个子系统可能会引起不一致的问题。它还需要大量的测试工作来保证实现做出的变更没有引入新问题。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;目前的解决方式&#34;&gt;目前的解决方式&lt;/h3&gt;

&lt;p&gt;由于大多数系统都可以横切关注点，因此出现模块化实现的一些技术就不足为奇了。这些技术包括混入（mix-in）类，设计模式和领域特定的解决方案。&lt;/p&gt;

&lt;p&gt;使用混入类可以让你延迟分离关注点到最终的实现。主类包含混入类实例，并允许系统的其他部分设置该实例。例如，上面的信用卡处理例子，将一个实现了业务逻辑的类组合成混入类，系统的其它模块可以通过配置来获取适合自身的日志器。例如，日志器可以设置成使用文件系统或者消息中间件。发送日志的被延后了，但是各个消息发送点（调用的地方）还是需要加入相关的代码。&lt;/p&gt;

&lt;p&gt;基于行为的设计模式，比如说访问者、模板方法，可以让你延迟实现。但是就像混入类一样，控制操作—调用访问逻辑或者模板方法—仍然在主类中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;领域特定&lt;/strong&gt;的解决方案，比如说框架和应用服务，让开发者可以用模块化的方式实现横切关注点。比如 EJB 架构，在安全、管理、性能和持久容器管理方面实现横切关注点。Bean 的开发者专注于业务逻辑，部署工程师专注于部署相关问题，比如 bean-data 与数据库的对应关系。对于 Bean 开发者来讲其余需要关注的就只有存储的问题了。在这个例子中你可以使用基于 XML 的映射描述符来实现横切关注点。&lt;/p&gt;

&lt;p&gt;领域特定的解决方案提供了一种特殊的办法来解决指定的问题。它的缺点是，开发者必须为它学习新的技术。然后由于这些解决方案都是领域特定的，它并不能直接有效地横切关注点。&lt;/p&gt;

&lt;h2 id=&#34;构架设计的窘境&#34;&gt;构架设计的窘境&lt;/h2&gt;

&lt;p&gt;好的系统架构会考眼前与未来的一些需求，从而避免打补丁式的实现。但是这有一个问题，预测未来是一件非常困难的事情。如果你没有搞清楚未来的需求，那就需要改变、或者将系统的很多地方重新实现。另外一方面，将精力聚焦在低可能性的一些需求会导致过度的设计、混乱和臃肿的系统。因此系统构架的一个困境是：应该设计到什么程度？我应该保守式的设计还是盈余式的设计。&lt;/p&gt;

&lt;p&gt;比方说，构架中是否应该追念一个初始化时并不需要的日志系统？如果是，日志打点的地方应该在哪里，什么样的信息应该被记录？这个是一个类似的出现在优化相关需求过程中的困境—我们很少提前知道瓶颈，常归的做法是构建一个系统，对其进行分析，并通过优化进行改进以提高性能。这种方法会潜在引导我们根据分析结果去修改系统很多部分。过不了多久，一个新的瓶颈又会出现，而这个瓶颈很可能就是上一步的改进引起的。设计可复用库架构的任务会变得非常困难，因为找到库的所有的使用场景并非易事。&lt;/p&gt;

&lt;p&gt;总之，架构师很少知道系统所有可能需要解决的问题。即使提前了解了需求，一个实现的具体细节可能并没有被考虑到。因此，架构师面临着究竟应该保守设计还是盈余设计的困境。&lt;/p&gt;

&lt;h2 id=&#34;aop-的基本概念&#34;&gt;AOP 的基本概念&lt;/h2&gt;

&lt;p&gt;到这里我们主要讨论了模块化的横切关注点会有很大益处。研究人员已经研究了在「关注点分离」这一更为泛化的主题下完成该任务的各种方法。 AOP 就是这样的一种方法。AOP 力争将关注点彻底分离，以克服上述问题。&lt;/p&gt;

&lt;p&gt;AOP 的核心在于，以松散耦合的方式让你实现一个独立的关注点，然后结合这些实现成为一个最终的系统。确实，AOP 使用松散耦合、模块化的&lt;strong&gt;分离关注点&lt;/strong&gt;的方式来创建系统。相反，OOP，则使用松散耦合、模块化的实现&lt;strong&gt;共同关注点&lt;/strong&gt;方式来创建系统。AOP 中模块化的单位叫做*横切面*（aspect），好比 OOP 中共同的关注点是*类*（class）。&lt;/p&gt;

&lt;p&gt;AOP涉及三个不同的开发步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;切面分解&lt;/strong&gt;：将需求分解并识别出横切关注点与共同关注点。你可以将系统级别的关注点与模块级别关注点分离。比如说，上面提到的信用卡模块，你需要识别三种关注点：信用卡核心流程，日志和授权。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;关注点实现&lt;/strong&gt;：分离的实现各个关注点。像上面的例子一样，你可以单独实现核心流程、日志和授权三个单元。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;切面重组&lt;/strong&gt;：在这个步骤中，切面集成器通过创建模块化单元来指定重组规则 — 切面。重组过程（也称为&lt;strong&gt;编织&lt;/strong&gt;或集成）使用此信息来组合成最终系统。比如上面的信用卡例子，你得使用一种 AOP 实现的*语言*具体/规范化操作中哪一步需要打日志。还得指定每个操作在被前都需要清除授权。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/06/5d207ff77b21c16740.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;AOP 实现横切关注点的方法与 OOP 不一样。对于 AOP 来讲，每个关注点的实现并不会意识到其它关注点下在横切它。比如上面的信用卡例子，信用止处理模块并不知道其它的关注点是日志、授权操作。这对于 OOP 来讲意味着很大的范式转换。&lt;/p&gt;

&lt;p&gt;注意：一个 AOP 的实现可以采用其它编程方法作为它的基本方法。因此可以保证基础系统非常完善。比如说，一个 AOP 的实现可以选择 OOP 做为基础系统，这样就可以获得 OOP 共同关注点的优势。每个独立的关注点可以采用 OOP 技术识别关注点。这类似于过程式的语言可以做为许多 OOP 语言的基础语言。&lt;/p&gt;

&lt;h2 id=&#34;编织的例子&#34;&gt;编织的例子&lt;/h2&gt;

&lt;p&gt;编织器是一个将独立的关注点纺织起来的过程。换句话说，编织器根据提供给它的某些标准将不同的执行逻辑片段编织起来。&lt;/p&gt;

&lt;p&gt;为了能够演示编织过程，让我们回到之前的信用卡处理系统的例子。为了看起来更简单，我们只考虑两个操作：信用卡和借记卡。并且已经有一个合适的日志器了。&lt;/p&gt;

&lt;p&gt;考虑下面的信用卡处理模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CreditCardProcessor {
    public void debit(CreditCard card, Currency amount) 
       throws InvalidCardException, NotEnoughAmountException,
              CardExpiredException {
        // Debiting logic
    }
    
    public void credit(CreditCard card, Currency amount) 
        throws InvalidCardException {
        // Crediting logic
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样还有一个日志接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Logger {
    public void log(String message);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们想要的组合需要以下编织规则，这些规则以自然语言表示（稍后将提供这些编织规则的编程语言版本）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打印每个公共操作的开始&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打印每个公共操作完成&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打印每个公共操作的异常&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;编织器随后将使用这些规则，并关注每个实现以产生等价于以下代码的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CreditCardProcessorWithLogging {
    Logger _logger;
    public void debit(CreditCard card, Money amount) 
        throws InvalidCardException, NotEnoughAmountException,
               CardExpiredException {
        _logger.log(&amp;quot;Starting CreditCardProcessor.credit(CreditCard,
Money) &amp;quot;
                    + &amp;quot;Card: &amp;quot; + card + &amp;quot; Amount: &amp;quot; + amount);
        // Debiting logic
        _logger.log(&amp;quot;Completing CreditCardProcessor.credit(CreditCard,
Money) &amp;quot;
                    + &amp;quot;Card: &amp;quot; + card + &amp;quot; Amount: &amp;quot; + amount);
    }
    
    public void credit(CreditCard card, Money amount) 
        throws InvalidCardException {
        System.out.println(&amp;quot;Debiting&amp;quot;);
        _logger.log(&amp;quot;Starting CreditCardProcessor.debit(CreditCard,
Money) &amp;quot;
                    + &amp;quot;Card: &amp;quot; + card + &amp;quot; Amount: &amp;quot; + amount);
        // Crediting logic
        _logger.log(&amp;quot;Completing CreditCardProcessor.credit(CreditCard,
Money) &amp;quot;
                    + &amp;quot;Card: &amp;quot; + card + &amp;quot; Amount: &amp;quot; + amount);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;分解-aop-语言&#34;&gt;分解 AOP 语言&lt;/h2&gt;

&lt;p&gt;就像其它编程语言方法的实现，AOP 实现包括两个部分：一种语言规范和一种实现。语言规范描述语言的构成与语法。实现则根据语言规范去论证代码的正确性，然后转换成机器码然后执行。在这小节中，我将解释 AOP 语言的不同组成部分。&lt;/p&gt;

&lt;h4 id=&#34;aop-语言的规范&#34;&gt;AOP 语言的规范&lt;/h4&gt;

&lt;p&gt;在一个高层次上，AOP 语言有两种组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;关注点的实现&lt;/strong&gt;：创建一个独立的需求与代码之间的对应关系，这样编译器才能翻译成可执行代码。由于关注点的实现需要通过具体的过程，你可以使用传统的语言，比如 C，C++ 或者 Java&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;编织规则的规范&lt;/strong&gt;：如何将独立的关注点实现结合成最终的系统。为了达到这个目标，实现需要使用或者创建一种语言来具体说明结合的规则。具体化编织规则的语言可以是实现语言的一种扩展，或者其它完全不同的东西。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;aop-语言的实现&#34;&gt;AOP 语言的实现&lt;/h4&gt;

&lt;p&gt;AOP 语言编译器有以下两个逻辑步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;结合独立的关注点&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;转换最终结果成可执行代码&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;AOP 语言实现编织器的方法有很多，包括源码到源码的翻译。你可以预处理独立切面的源码，然后将它加工成编织过的源码。然后 AOP 编译器将这些源码转交给基本语言编译器用来生成最终可执行代码，最后让 Java 编译器把代码编译成子节码。同样的，编织过程可以是子节码级别的；毕竟，子节码也是一种源代码。引外底层系统—VM虚拟机，是可以感知到切面的。使用这种基于 Java 的 AOP 实现，比如，VM虚拟机将首先加载编织规则，然后将这些规则应用到随后加载的类中。换句话说，它表现得像是 JIT 化的切面编织。&lt;/p&gt;

&lt;h2 id=&#34;aop-的益处&#34;&gt;AOP 的益处&lt;/h2&gt;

&lt;p&gt;AOP 有助于克服由代码纠缠和代码分散引起的上述问题。以下是 AOP 提供的其他优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;模块化地横切关注点&lt;/strong&gt;：AOP 使得每个独立的关注点有最小化的耦合，最终产出模块化的实现。这样的一种实现会产生很少的重复代码。由于每个关注点的实现是分离的，也将减少无用代码，更重要的模块化的实现让最终系统更易于理解与维护。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;更便于系统迭代&lt;/strong&gt;：由于切面模块对于横切关注点是无感知的，添加新功能、新切面将变得简单。而且当你在系统中添加新模块时，现有的切面将横切它们，这有助于你构建一系列连贯的迭代演进。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;延迟设计目标的绑定&lt;/strong&gt;：回顾下架构师的困境，有了 AOP，架构师对于将来的需求就可以推迟做出设计上的决定，因为他可以用分离的切面来实现。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;更高的代码复用性&lt;/strong&gt;：由于 AOP 分离的实现每个切面，每个独立模块之间的耦合更加的松散。比如说，你可以使用不同的日志器来记录你模块与数据库的操作。通常来讲，松散耦合的实现是代码高复用性的关键点。 AOP 的实现比 OOP 的实现更加松散耦合。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;aspectj-一种-java-的-aop-实现&#34;&gt;AspectJ：一种 Java 的 AOP 实现&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第十篇：拦截器）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-10/</link>
      <pubDate>Wed, 03 Jul 2019 18:40:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-10/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/05/5d1edebfa26f771380.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;拦截器&lt;/strong&gt;（Interceptors）是一个使用 @Injectable() 装饰的类，它必须实现 NestInterceptor 接口。&lt;/p&gt;

&lt;p&gt;拦截器有一系列的功能，这些功能的设计灵感都来自于面向切面的编程（AOP）技术。这使得下面这些功能成为可能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在函数执行前/后绑定&lt;strong&gt;额外的逻辑&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;转换&lt;/strong&gt;一个函数的返回值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;转换&lt;/strong&gt;函数抛出的异常&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;基础函数的行为&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据特定的条件&lt;strong&gt;完全的重写&lt;/strong&gt;一个函数（比如：缓存）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;基础&#34;&gt;基础&lt;/h2&gt;

&lt;p&gt;每个拦截器都要实现 intercept() 方法，此方法有两个参数。第一个是 ExecutionContext 实例（这和守卫中的对象一样）。ExecutionContext 继承自 ArgumentsHost。上一节中我们见过，它是一个包装了传递向原始处理器而且根据应用的不同包含不同的参数数组的类&lt;/p&gt;

&lt;h2 id=&#34;执行上下文&#34;&gt;执行上下文&lt;/h2&gt;

&lt;p&gt;ExecutionContext 通过继承 ArgumentsHost，提供了更多的执行过种中的更多细节，它看起来长这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export interface ExecutionContext extends ArgumentsHost {
  getClass&amp;lt;T = any&amp;gt;(): Type&amp;lt;T&amp;gt;;
  getHandler(): Function;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getHandler() 方法返回一个将会被调用的路由处理器的引用。getClass() 方法返回控制器类的类型。例如，如果当前进行着一个 POST 请求，假定它会由 CatsController 的 create() 方法处理，那么 getHandler() 方法将返回 create() 方法的引用，而 getClass() 则会返回 CatsController 的类型（非实例）&lt;/p&gt;

&lt;h2 id=&#34;调用处理器&#34;&gt;调用处理器&lt;/h2&gt;

&lt;p&gt;第二个参数是一个 CallHandler。CallHandler 接口实现了 handle() 方法，这个方法就是你可以在你拦截器的某个地方调用的路由处理器。如果你的 intercept() 方法中没调用 handle() 方法，那么路由处理器将不会被执行。&lt;/p&gt;

&lt;p&gt;不像守卫与过滤器，拦截器对于一次请求响应有完全的&lt;strong&gt;控制权与责任&lt;/strong&gt;。这样的方式意味着 intercept() 方法可以高效地包装请求/响应流。因此，你可以在最终的路由处理器执行前/后实现自己的逻辑。显然，你已经可以通过在 intercept() 方法中的 handle() 调用之前写自己的代码，但是后续的逻辑应该如何处理？因为 handle() 方法返回的是一个 Observable，我们可以使用 RxJS 做到修改后来的响应。使用 AOP 技术，路由处理器的调用被称做一个 &lt;strong&gt;切点&lt;/strong&gt;（Pointcut），这表示一个我们的自定义的逻辑插入的地方。&lt;/p&gt;

&lt;p&gt;假如有一个 &lt;code&gt;POST /cats&lt;/code&gt; 的请求，这个请求将被 CatsController 中的 create() 方法处理。如果一个没调用 handle() 方法的拦截器在某处被调用，create() 方法将不会被执行。一但 handle() 方法被调用（它的 Observable 已返回），create() 处理器将被触发。一但响应流通过 Observable 接收到，附加的操作可以在注上被执行，最后的结果将返回给调用方。&lt;/p&gt;

&lt;h2 id=&#34;切面拦截&#34;&gt;切面拦截&lt;/h2&gt;

&lt;p&gt;我们将要研究的第一个例子就是用户登录的交互。下面展示了一个简单的日志拦截器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&amp;lt;any&amp;gt; {
    console.log(&#39;Before...&#39;);

    const now = Date.now();
    return next
      .handle()
      .pipe(
        tap(() =&amp;gt; console.log(`After... ${Date.now() - now}ms`)),
      );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 handle() 方法返回了一个 RxJS 的 Observable 对象，对于修改流我们将有更多的选择。上面的示例中我们使用了 tap() 操作符。它在 Observable 流的正常或异常终止时调用我们的匿名日志记录函数，但不会干扰到响应周期。&lt;/p&gt;

&lt;h2 id=&#34;绑定拦截器&#34;&gt;绑定拦截器&lt;/h2&gt;

&lt;p&gt;我们可以使用 @UseInterceptors() 装饰器来绑定一个拦截器，和管道、守卫一样，它即可以是控制器作用域的，也可以是方法作用域的，或者是全局的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@UseInterceptors(LoggingInterceptor)
export class CatsController {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的实现，在请求进入 CatsController 后，你将看到下面的日志输出。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Before...
After... 1ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;响应映射&#34;&gt;响应映射&lt;/h2&gt;

&lt;p&gt;我们已经知道了 handle() 方法返回一个 Observable。流包含路由处理器返回的值，因此，我们可以很容易的使用 RxJS 的 map() 操作符改变它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：响应映射功能并不适用于库级别的响应策略（不可以使用 @Res 装饰器）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;让我们新建一个 TransformInterceptor，它可以修改每个响应。它将使用 map() 操作符来给响应对象符加 data 属性，并且将这个新的响应返回给客户端。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;
import { map } from &#39;rxjs/operators&#39;;

export interface Response&amp;lt;T&amp;gt; {
  data: T;
}

@Injectable()
export class TransformInterceptor&amp;lt;T&amp;gt; implements NestInterceptor&amp;lt;T, Response&amp;lt;T&amp;gt;&amp;gt; {
  intercept(context: ExecutionContext, next: CallHandler): Observable&amp;lt;Response&amp;lt;T&amp;gt;&amp;gt; {
    return next.handle().pipe(map(data =&amp;gt; ({ data })));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当有请求进入时，响应看起来将会是下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;data&amp;quot;: []
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拦截器对于创建整个应用层面的可复用方案有非常大的意义。比如说，我们需要将所有响应中出现的 null 值改成空字符串 &amp;ldquo;&amp;ldquo;。我们可以使用拦截器功能仅用下面一行代码就可以实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;
import { map } from &#39;rxjs/operators&#39;;

@Injectable()
export class ExcludeNullInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&amp;lt;any&amp;gt; {
    return next
      .handle()
      .pipe(map(value =&amp;gt; value === null ? &#39;&#39; : value ));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;异常映射&#34;&gt;异常映射&lt;/h2&gt;

&lt;p&gt;另外一个有趣的用例是使用 RxJS 的 catchError() 操作符来重写异常捕获：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  BadGatewayException,
  CallHandler,
} from &#39;@nestjs/common&#39;;
import { Observable, throwError } from &#39;rxjs&#39;;
import { catchError } from &#39;rxjs/operators&#39;;

@Injectable()
export class ErrorsInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&amp;lt;any&amp;gt; {
    return next
      .handle()
      .pipe(
        catchError(err =&amp;gt; throwError(new BadGatewayException())),
      );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;流重写&#34;&gt;流重写&lt;/h2&gt;

&lt;p&gt;有一些情况下我们希望完全阻止处理器的调用并返回一个不同的值。比如缓存的实现。让我们来试试使用缓存拦截器来实现它。当然真正的缓存实现还包含 TTL，缓存验证，缓存大小等问题，我们这个例子只是一个简单的示意。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from &#39;@nestjs/common&#39;;
import { Observable, of } from &#39;rxjs&#39;;

@Injectable()
export class CacheInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&amp;lt;any&amp;gt; {
    const isCached = true;
    if (isCached) {
      return of([]);
    }
    return next.handle();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中我们硬编码了 isCached 变量，以及返回的缓存数据 []。关键点在于我们返回了一个新的流，使用了 RxJS 的 of() 操作符。因此路由处理器永远不会被调用。为了实现一个更完整的解决方案，你可以通过使用 Reflector 创建一个自定义的装饰器来实现缓存功能。&lt;/p&gt;

&lt;h2 id=&#34;更多的操作符&#34;&gt;更多的操作符&lt;/h2&gt;

&lt;p&gt;RxJS 的操作符有很多种能力，我们可以考虑下面这种用例。你需要处理路由请求的超时问题。当你的响应很久都没正常返回时，你会想把它关闭并返回一个错误的响应。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;
import { timeout } from &#39;rxjs/operators&#39;;

@Injectable()
export class TimeoutInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&amp;lt;any&amp;gt; {
    return next.handle().pipe(timeout(5000))
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5 秒后，请求处理将会被取消。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第九篇：守卫）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-9/</link>
      <pubDate>Wed, 03 Jul 2019 18:39:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-9/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;守卫&lt;/strong&gt;（Guards）是一个使用 @Injectable() 装饰的类，它必须实现 CanActivate 接口。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/05/5d1ec2a0e2ae056395.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;守卫&lt;/strong&gt;只有&lt;strong&gt;一个&lt;/strong&gt;职责，就是决定请求是否需要被控制器处理。一般用在权限、角色的场景中。&lt;/p&gt;

&lt;p&gt;守卫和中间件的区别在于：中间件很简单，next 方法调用后中间的任务就完成了。但是守卫需要关心上下游，它需要鉴别请求与控制器之间的关系。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;守卫会在中间件逻辑之==后==、拦截器/管道之==前==执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;授权守卫&#34;&gt;授权守卫&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, CanActivate, ExecutionContext } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise&amp;lt;boolean&amp;gt; | Observable&amp;lt;boolean&amp;gt; {
    const request = context.switchToHttp().getRequest();
    return validateRequest(request);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;canActivate 返回 true，控制器正常执行，false 请求会被 deny&lt;/p&gt;

&lt;h2 id=&#34;执行上下文&#34;&gt;执行上下文&lt;/h2&gt;

&lt;p&gt;ExecutionContext 不但继承了 ArgumentsHost，还有两个额外方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export interface ExecutionContext extends ArgumentsHost {
  getClass&amp;lt;T = any&amp;gt;(): Type&amp;lt;T&amp;gt;;
  getHandler(): Function;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getHandler() 方法会返回一个将被调用的方法处理器，getClass() 返回处理器对应的控制器类。&lt;/p&gt;

&lt;h2 id=&#34;基于角色的认证&#34;&gt;基于角色的认证&lt;/h2&gt;

&lt;p&gt;我们来实现一个小型的基于角色的认证系统。&lt;/p&gt;

&lt;p&gt;创建一个守卫，先让它返回 true，后面再改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, CanActivate, ExecutionContext } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;

@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise&amp;lt;boolean&amp;gt; | Observable&amp;lt;boolean&amp;gt; {
    return true;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;绑定守卫&#34;&gt;绑定守卫&lt;/h2&gt;

&lt;p&gt;就像过滤器一样，守卫可以是控制器作用域的，也可以是方法作用域或者全局作用域。我们使用 @UseGuards 来引用一个控制器作用域的守卫。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Controller(&#39;cats&#39;)
@UseGuards(RolesGuard)
export class CatsController {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想引用到全局作用域可以调用 useGlobalGuards 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const app = await NestFactory.create(ApplicationModule);
app.useGlobalGuards(new RolesGuard());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们在根模块外层引用了全局守卫，这时守卫无法注入依赖。所以我们还需要在要模块上引入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Module } from &#39;@nestjs/common&#39;;
import { APP_GUARD } from &#39;@nestjs/core&#39;;

@Module({
  providers: [
    {
      provide: APP_GUARD,
      useClass: RolesGuard,
    },
  ],
})
export class ApplicationModule {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;反射&#34;&gt;反射&lt;/h2&gt;

&lt;p&gt;虽然现在已经有了守卫，但是它还没有执行上下文。CatsController 应该有一些需要访问到的权限类型。比如：管理员（admin）角色可以访问、其它角色不可以。&lt;/p&gt;

&lt;p&gt;这时我们需要对控制器（或方法）添加一些&lt;strong&gt;元数据&lt;/strong&gt;，用来标记这个控制器的权限类型。在 Nest 中我们通常使用 @SetMetadata() 装饰器来完成这个工作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@SetMetadata(&#39;roles&#39;, [&#39;admin&#39;])
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码表示给 create 方法设置角色的元数据，用来标识 create 方法只能是 roles 关联的一些角色（admin…）才能访问到的。&lt;/p&gt;

&lt;p&gt;如果你觉得 SetMetadata 这个装饰器看着不是那么见名知意，也可以实现一个自定义的装饰器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { SetMetadata } from &#39;@nestjs/common&#39;;

export const Roles = (...roles: string[]) =&amp;gt; SetMetadata(&#39;roles&#39;, roles);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以用更简洁的方式来声明角色权限关系了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@Roles(&#39;admin&#39;)
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;联合在一起使用&#34;&gt;联合在一起使用&lt;/h2&gt;

&lt;p&gt;我们将使用反射机制来获取控制器上的元数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, CanActivate, ExecutionContext } from &#39;@nestjs/common&#39;;
import { Observable } from &#39;rxjs&#39;;
import { Reflector } from &#39;@nestjs/core&#39;;

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private readonly reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const roles = this.reflector.get&amp;lt;string[]&amp;gt;(&#39;roles&#39;, context.getHandler());
    if (!roles) {
      return true;
    }
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const hasRole = () =&amp;gt; user.roles.some((role) =&amp;gt; roles.includes(role));
    return user &amp;amp;&amp;amp; user.roles &amp;amp;&amp;amp; hasRole();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 canActivate 方法返回 false 时，Nest 将会抛出一个 ForbiddenException 异常。你也可以手动抛出别的异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;throw new UnauthorizedException();
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第八篇：管道）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-8/</link>
      <pubDate>Wed, 03 Jul 2019 18:38:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-8/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/04/5d1dc90b3606425009.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;管道&lt;/strong&gt;（Pipes）是一个用 @Injectable() 装饰过的类，它必须实现 PipeTransform 接口。&lt;/p&gt;

&lt;p&gt;从官方的示意图中我们可以看出来管道 pipe 和过滤器 filter 之间的关系：管道偏向于服务端控制器逻辑，过滤器则更适合用客户端逻辑。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;过滤器在客户端发送请求&lt;strong&gt;==后==&lt;/strong&gt;处理，管道则在控制器接收请求&lt;strong&gt;==前==&lt;/strong&gt;处理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;管道通常有两种作用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;转换/变形&lt;/strong&gt;：转换输入数据为目标格式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;验证&lt;/strong&gt;：对输入数据时行验证，如果合法让数据通过管道，否则抛出异常。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;管道会处理控制器路由的参数，Nest 会在方法调用前插入管道，管道接收发往该方法的参数，此时就会触发上面两种情况。然后路由处理器会接收转换过的参数数据并处理后续逻辑。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;++小提示++：管道会在异常范围内执行，这表示异常处理层可以处理管道异常。如果管道发生了异常，控制器的执行将会&lt;strong&gt;停止&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;内置管道&#34;&gt;内置管道&lt;/h2&gt;

&lt;p&gt;Nest 内置了两种管道：&lt;code&gt;ValidationPipe&lt;/code&gt; 和 &lt;code&gt;ParseIntPipe&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { PipeTransform, Injectable, ArgumentMetadata } from &#39;@nestjs/common&#39;;

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里可能不太好理解，因为我们前面已经在控制器参数上使用了 @body 装饰器，并且使用 TypeScript 的类型声明它为 CreateCatDto，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是 TypeScript 类型是静态的、编译时类型，当编译成 JavaScript 后在运行时并没有任何类型校验。这时我们就需要自己去验证，或者借助第三方工具、库来验证。&lt;/p&gt;

&lt;p&gt;Nest 官方文档在这一节中使用了 &lt;a href=&#34;https://www.npmjs.com/package/@hapi/joi&#34;&gt;joi&lt;/a&gt; 这个验证库。这个验证库的使用需要传入一个 schema，实际上对应着我们的在 Nest 中写的 dto 类型，所以我们只需要给 joi 传入一个 CreateCatDto 类的实例即可。&lt;/p&gt;

&lt;p&gt;首页在 ValidationPipe 管道中添加 joi 的验证功能。验证通过就返回，不通过直接抛出异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Injectable()
export class JoiValidationPipe implements PipeTransform {
  constructor(private readonly schema: Object) {}

  transform(value: any, metadata: ArgumentMetadata) {
    const { error } = Joi.validate(value, this.schema);
    if (error) {
      throw new BadRequestException(JSON.stringify(error.details));
    }
    return value;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;绑定管道&#34;&gt;绑定管道&lt;/h2&gt;

&lt;p&gt;管道有了，我们还需要在控制器方法上绑定它。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@UsePipes(new JoiValidationPipe(createCatSchema))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 @UsePipes 修饰器即可，传入管道的实例，并构造 schema。此时我们的应用就可以在运行时通过 schema 去校验参数对象的开头了。createCatSchema 的写法可以参考&lt;a href=&#34;https://github.com/hapijs/joi/blob/v15.1.0/API.md&#34;&gt;相关文档&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const createCatSchema = {
  name: Joi.string().required(),
  age: Joi.number().required(),
  breed: Joi.string().required(),
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如上面的 schema，如果客户端发送的 POST 请求中如果缺少任意参数 Nest 都会捕获到这个异常并返回信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;statusCode&amp;quot;: 400,
    &amp;quot;error&amp;quot;: &amp;quot;Bad Request&amp;quot;,
    &amp;quot;message&amp;quot;: &amp;quot;[{\&amp;quot;message\&amp;quot;:\&amp;quot;\\\&amp;quot;name\\\&amp;quot; is required\&amp;quot;,\&amp;quot;path\&amp;quot;:[\&amp;quot;name\&amp;quot;],\&amp;quot;type\&amp;quot;:\&amp;quot;any.required\&amp;quot;,\&amp;quot;context\&amp;quot;:{\&amp;quot;key\&amp;quot;:\&amp;quot;name\&amp;quot;,\&amp;quot;label\&amp;quot;:\&amp;quot;name\&amp;quot;}}]&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 message 就是我们在管道中传到异常类 BadRequestException 中的参数。&lt;/p&gt;

&lt;h2 id=&#34;类验证器&#34;&gt;类验证器&lt;/h2&gt;

&lt;p&gt;当然上面这种方法看起来没那么优雅，因为毕竟 CreateCatDto 和 createCatSchema 太重复了。Nest 还支持类型验证器，虽然也需要借助于三方库，但是看起来会优雅很多。&lt;/p&gt;

&lt;p&gt;首先，要使用类验证器，你需要先安装 &lt;a href=&#34;https://github.com/pleerock/class-validator&#34;&gt;class-validator&lt;/a&gt; 库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm i --save class-validator class-transformer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;class-validator 可以让你使用给类变量加装饰器的写法给类添加额外的验证功能。这样以来我们就可以直接在原始的 CreateCatDto 类上添加验证装饰器了，这样看起来就整洁多了，而且还没有重复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { IsString, IsInt } from &#39;class-validator&#39;;

export class CreateCatDto {
  @IsString()
  readonly name: string;

  @IsInt()
  readonly age: number;

  @IsString()
  readonly breed: string;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过管道验证器中的代码也需要适配一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { validate } from &#39;class-validator&#39;;
import { plainToClass } from &#39;class-transformer&#39;;

@Injectable()
export class ValidationPipe implements PipeTransform&amp;lt;any&amp;gt; {
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return value;
    }
    const object = plainToClass(metatype, value);
    const errors = await validate(object);
    if (errors.length &amp;gt; 0) {
      throw new BadRequestException(&#39;Validation failed&#39;);
    }
    return value;
  }

  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object];
    return !types.includes(metatype);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这次的 transform 是 async 异步的，因为内部需要用到异步验证方法。Nest 是支持你这么做的，因为管道可以是异步的。&lt;/p&gt;

&lt;p&gt;然后我们可以插入这个管道，位置可以是方法级别的，也可以是参数级别的。&lt;/p&gt;

&lt;p&gt;++参数作用域++&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
async create(
  @Body(new ValidationPipe()) createCatDto: CreateCatDto,
) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;++方法作用域++&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@UsePipes(new ValidationPipe())
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;管道修饰器入参可以是类而不必是管道实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@UsePipes(ValidationPipe)
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样以来将实例化过程留给框架去做并肝启用依赖注入。&lt;/p&gt;

&lt;p&gt;由于 ValidationPipe 被尽可能的泛化，所以它可以直接使用在全局作用域上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async function bootstrap() {
  const app = await NestFactory.create(ApplicationModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3000);
}
bootstrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;转换用例&#34;&gt;转换用例&lt;/h2&gt;

&lt;p&gt;我们还可以用管道来进行数据转换，比如说上面的例子中 age 虽然声明的是 int 类型，但是我们知道 HTTP 请求传递的都是纯字符流，所以通常我们还要把期望传进行类型转换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from &#39;@nestjs/common&#39;;

@Injectable()
export class ParseIntPipe implements PipeTransform&amp;lt;string, number&amp;gt; {
  transform(value: string, metadata: ArgumentMetadata): number {
    const val = parseInt(value, 10);
    if (isNaN(val)) {
      throw new BadRequestException(&#39;Validation failed&#39;);
    }
    return val;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个管道的功能就是强制转换成 Int 类型，如果转换不成功就抛出异常。我们可以针对性的对传入控制器的&lt;strong&gt;某个&lt;/strong&gt;参数插入这个管道：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get(&#39;:id&#39;)
async findOne(@Param(&#39;id&#39;, new ParseIntPipe()) id) {
  return await this.catsService.findOne(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;内置的验证管道&#34;&gt;内置的验证管道&lt;/h2&gt;

&lt;p&gt;比较贴心的是 Nest 已经内置了如上面的例子类似的一些通用验证器，你可以以参数的方式去实例化 ValidationPipe。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@UsePipes(new ValidationPipe({ transform: true }))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ValidationPipe 接收一个 ValidationPipeOptions 类型的参数，并且这个参数继承自 ValidatorOptions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export interface ValidationPipeOptions extends ValidatorOptions {
  transform?: boolean;
  disableErrorMessages?: boolean;
  exceptionFactory?: (errors: ValidationError[]) =&amp;gt; any;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ValidatorOptions 又继承了如下所有 class-validator 的参数：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Option&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;skipMissingProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If set to true, validator will skip validation of all properties that are missing in the validating object.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;whitelist&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If set to true, validator will strip validated (returned) object of any properties that do not use any validation decorators.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;forbidNonWhitelisted&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If set to true, instead of stripping non-whitelisted properties validator will throw an exception.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;forbidUnknownValues&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If set to true, attempts to validate unknown objects fail immediately.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disableErrorMessages&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If set to true, validation errors will not be returned to the client.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;exceptionFactory&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Takes an array of the validation errors and returns an exception object to be thrown.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;groups&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;string[]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Groups to be used during validation of the object.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dismissDefaultMessages&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If set to true, the validation will not use default messages. Error message always will be &lt;code&gt;undefined&lt;/code&gt; if its not explicitly set.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;validationError.target&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Indicates if target should be exposed in &lt;code&gt;ValidationError&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;validationError.value&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Indicates if validated value should be exposed in &lt;code&gt;ValidationError&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第七篇：异常过滤器）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-7/</link>
      <pubDate>Wed, 03 Jul 2019 18:37:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-7/</guid>
      <description>

&lt;p&gt;Nest 框架内部实现了一个异常处理层，专门用来负责应用程序中&lt;strong&gt;未处理&lt;/strong&gt;的异常。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/02/5d1b66de9370734231.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;默认情况未处理的异常会被全局过滤异常器 HttpException 或者它的子类处理。如果一个未识别的异常（非 HttpException 或未继承自 HttpException）被抛出，下面的信息将被返回给客户端：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;statusCode&amp;quot;: 500,
  &amp;quot;message&amp;quot;: &amp;quot;Internal server error&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基础异常&#34;&gt;基础异常&lt;/h2&gt;

&lt;p&gt;我们可以从控制器的方法中手动抛出一个异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get()
async findAll() {
  throw new HttpException(&#39;Forbidden&#39;, HttpStatus.FORBIDDEN);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端将收到如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;statusCode&amp;quot;: 403,
  &amp;quot;message&amp;quot;: &amp;quot;Forbidden&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然你也可以自定义返回状态值和错误信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get()
async findAll() {
  throw new HttpException({
    status: HttpStatus.FORBIDDEN,
    error: &#39;This is a custom message&#39;,
  }, 403);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;异常的级别&#34;&gt;异常的级别&lt;/h2&gt;

&lt;p&gt;比较好的做法是实现你自己想要的异常类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export class ForbiddenException extends HttpException {
  constructor() {
    super(&#39;Forbidden&#39;, HttpStatus.FORBIDDEN);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后你就可以手动在需要的地方抛出它。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get()
async findAll() {
  throw new ForbiddenException();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;http-异常&#34;&gt;HTTP 异常&lt;/h2&gt;

&lt;p&gt;Nest 内置了以下集成自 HttpException 的异常类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;BadRequestException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UnauthorizedException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NotFoundException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ForbiddenException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NotAcceptableException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;RequestTimeoutException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ConflictException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GoneException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PayloadTooLargeException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UnsupportedMediaTypeException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UnprocessableEntityException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;InternalServerErrorException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NotImplementedException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;BadGatewayException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ServiceUnavailableException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GatewayTimeoutException&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;异常过滤器&#34;&gt;异常过滤器&lt;/h2&gt;

&lt;p&gt;如果你想给异常返回值加一些动态的参数，可以使用异常过滤器来实现。例如下面的异常过滤器将会给 HttpException 添加额外的时间缀和路径参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from &#39;@nestjs/common&#39;;
import { Request, Response } from &#39;express&#39;;

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse&amp;lt;Response&amp;gt;();
    const request = ctx.getRequest&amp;lt;Request&amp;gt;();
    const status = exception.getStatus();

    response
      .status(status)
      .json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：所有的异常过滤器都必须实现泛型接口 ExceptionFilter&lt;T&gt;。就是说你必须要提供一个 catch(exception: T, host: ArgumentsHost) 方法&lt;/p&gt;

&lt;h2 id=&#34;参数宿主&#34;&gt;参数宿主&lt;/h2&gt;

&lt;p&gt;上面代码中的 host 参数是一个类型为 ArgumentsHost 的原生请求处理器包装对象。根据应用程序的不同它具有不同的接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export interface ArgumentsHost {
  getArgs&amp;lt;T extends Array&amp;lt;any&amp;gt; = any[]&amp;gt;(): T;
  getArgByIndex&amp;lt;T = any&amp;gt;(index: number): T;
  switchToRpc(): RpcArgumentsHost;
  switchToHttp(): HttpArgumentsHost;
  switchToWs(): WsArgumentsHost;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;绑定过滤器&#34;&gt;绑定过滤器&lt;/h2&gt;

&lt;p&gt;可以使用 @UseFilters 装饰器让一个控制器方法具有过滤器处理逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@UseFilters(HttpExceptionFilter)
async create(@Body() createCatDto: CreateCatDto) {
  throw new ForbiddenException();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然过滤器可以被使用在不同的作用域上：&lt;strong&gt;方法作用域、控制器作用域、全局作用域&lt;/strong&gt;。比如应用一个控制器作用域的过滤器，可以这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@UseFilters(new HttpExceptionFilter())
export class CatsController {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全局过滤器可以通过如下代码实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async function bootstrap() {
  const app = await NestFactory.create(ApplicationModule);
  app.useGlobalFilters(new HttpExceptionFilter());
  await app.listen(3000);
}
bootstrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过这样注册的全局过滤器无法进入依赖注入，因为它在模块作用域之外。为了解决这个问题，你可以在根模块上面注册一个全局作用域的过滤器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Module } from &#39;@nestjs/common&#39;;
import { APP_FILTER } from &#39;@nestjs/core&#39;;

@Module({
  providers: [
    {
      provide: APP_FILTER,
      useClass: HttpExceptionFilter,
    },
  ],
})
export class ApplicationModule {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;捕获所有异常&#34;&gt;捕获所有异常&lt;/h2&gt;

&lt;p&gt;@Catch() 装饰器不传入参数就默认捕获所有的异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus } from &#39;@nestjs/common&#39;;

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    const status = exception instanceof HttpException
      ? exception.getStatus()
      : HttpStatus.INTERNAL_SERVER_ERROR;

    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;

&lt;p&gt;通常你可能并不需要自己实现完全定制化的异常过滤器，可以继承自 BaseExceptionFilter 即可复用内置的过滤器逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Catch, ArgumentsHost } from &#39;@nestjs/common&#39;;
import { BaseExceptionFilter } from &#39;@nestjs/core&#39;;

@Catch()
export class AllExceptionsFilter extends BaseExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    super.catch(exception, host);
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第六篇：中间件）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-6/</link>
      <pubDate>Wed, 03 Jul 2019 18:36:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-6/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;中间件&lt;/strong&gt;就是一个函数，在路由处理器之前调用。这就表示中间件函数可以访问到请求和响应对象以及应用的请求响应周期中的 next() 中间间函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/01/5d19e2f1938ef39341.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nest 中间件实际上和 Express 的中间件是一样的，Express 文档中对中间件的描述如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;中间件函数主要做以下的事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行任意的代码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对请求/响应做操作&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;终结请求-响应周期&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用下一个栈中的中间件函数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果当前的中间间函数没有终结请求响应周期，那么它必须调用 next() 方法将控制权传递给下一个中间件函数。否则请求将被挂起&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nest 允许你使用函数或者类来实现自己的中间件。如果用类实现，则需要使用 &lt;code&gt;@Injectable()&lt;/code&gt; 装饰，并且实现 &lt;code&gt;NestMiddleware&lt;/code&gt; 接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable, NestMiddleware } from &#39;@nestjs/common&#39;;
import { Request, Response } from &#39;express&#39;;

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: Function) {
    console.log(&#39;Request...&#39;);
    next();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;依赖注入&#34;&gt;依赖注入&lt;/h2&gt;

&lt;p&gt;中间件也是支持依赖注入的，就像其它支持方式一样，你可以使用构造函数注入依赖。&lt;/p&gt;

&lt;h2 id=&#34;应用中间件&#34;&gt;应用中间件&lt;/h2&gt;

&lt;p&gt;@Module() 装饰器中并不能指定中间件参数，我们可以在模块类的构 configure() 方法中应用中间件，下面的代码会应用一个 ApplicationModule级别的日志中间件 LoggerMiddleware&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Module({
  imports: [CatsModule],
})
export class ApplicationModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes(&#39;cats&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码 forRoutes 方法表示只将中间件应用在 cats 路由上，还可以是指定的 HTTP 方法，甚至是路由通配符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.forRoutes({ path: &#39;cats&#39;, method: RequestMethod.GET });
.forRoutes({ path: &#39;ab*cd&#39;, method: RequestMethod.ALL });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你也可以指定不包括某些路由规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;consumer
  .apply(LoggerMiddleware)
  .exclude(
    { path: &#39;cats&#39;, method: RequestMethod.GET },
    { path: &#39;cats&#39;, method: RequestMethod.POST }
  )
  .forRoutes(CatsController);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过请注意 exclude 方法不能运用在函数式的中间件上，而且这里指定的 path 也不支持通配符，这只是个快捷方法，如果你真的需要某种路由级别的控制，那完全可以把逻辑写在一个单独的中间件中。&lt;/p&gt;

&lt;h2 id=&#34;函数式的中间件&#34;&gt;函数式的中间件&lt;/h2&gt;

&lt;p&gt;函数式的中间件可以用一个简单无依赖函数来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export function logger(req, res, next) {
  console.log(`Request...`);
  next();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;多个中间件&#34;&gt;多个中间件&lt;/h2&gt;

&lt;p&gt;apply 方法传入多个中间件参数即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;consumer.apply(cors(), helmet(), logger)
.forRoutes(CatsController);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;全局中间件&#34;&gt;全局中间件&lt;/h2&gt;

&lt;p&gt;在实现了 INestApplication 接口的实例上调用 use() 方法即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const app = await NestFactory.create(ApplicationModule);
app.use(logger);
await app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>