<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Something</title>
    <link>https://keelii.com/</link>
    <description>Recent content on Something</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 03 Sep 2018 19:10:27 +0000</lastBuildDate>
    
        <atom:link href="https://keelii.com/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>HTTPie 官方文档中文翻译版</title>
      <link>https://keelii.com/2018/09/03/HTTPie/</link>
      <pubDate>Mon, 03 Sep 2018 19:10:27 +0000</pubDate>
      
      <guid>https://keelii.com/2018/09/03/HTTPie/</guid>
      <description>

&lt;p&gt;HTTPie 是一个命令行 HTTP 客户端。目标是让 CLI 与 Web services 的交互尽可能的更友好。它提供了一个简单的 &lt;code&gt;http&lt;/code&gt; 命令，可以让我们用简单自然的表述发送任意 HTTP 请求，并且可以输出带代码高亮的结果。HTTPie 可以使用在测试、调试以及通用的与 HTTP 交互场景&lt;/p&gt;

&lt;h2 id=&#34;主要功能特性&#34;&gt;主要功能特性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;自然而且简单的命令语句&lt;/li&gt;
&lt;li&gt;格式化且高亮显示输出内容&lt;/li&gt;
&lt;li&gt;内置 JSON 支持&lt;/li&gt;
&lt;li&gt;表单和文件上传&lt;/li&gt;
&lt;li&gt;支持 HTTPS, 代理和授权验证&lt;/li&gt;
&lt;li&gt;支持多样化的请求数据格式&lt;/li&gt;
&lt;li&gt;自定义 headers 头&lt;/li&gt;
&lt;li&gt;持久 sessions 存储&lt;/li&gt;
&lt;li&gt;类似 &lt;code&gt;wget&lt;/code&gt; 的下载模式&lt;/li&gt;
&lt;li&gt;兼容 Python 2.6, 2.7 以及 3.x&lt;/li&gt;
&lt;li&gt;支持 Linux, macOS 和 Windows 操作系统&lt;/li&gt;
&lt;li&gt;插件支持&lt;/li&gt;
&lt;li&gt;详细的文档说明&lt;/li&gt;
&lt;li&gt;完善的测试用例覆盖&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;h3 id=&#34;macos&#34;&gt;macOS&lt;/h3&gt;

&lt;p&gt;在 macOS 系统中推荐使用 &lt;a href=&#34;brew.sh&#34;&gt;Homebrew&lt;/a&gt; 来安装:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install httpie
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然 MacPorts 也是可以的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;port install httpie
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;linux&#34;&gt;Linux&lt;/h3&gt;

&lt;p&gt;大多数的 Linux 构建版都提供了包管理组件，可以使用他们来安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 基于 Debian Linux 的构建版，比如 Ubuntu
apt-get install httpie

# 基于 RPM Linux 的构建版
yum install httpie

# Arch Linux 系统
pacman -S httpie
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;windows-及其它&#34;&gt;Windows 及其它&lt;/h3&gt;

&lt;p&gt;使用 &lt;a href=&#34;https://pip.pypa.io/en/latest/installing/&#34;&gt;pip&lt;/a&gt; 是一种通用的（可以使用在 Windows, MacOS, Linux &amp;hellip;）并且提供最新版本安装包的安装方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 确保使用了最新版本的 pip 和 setuptools:
pip install --upgrade pip setuptools

pip install --upgrade httpie
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;开发版&#34;&gt;开发版&lt;/h3&gt;

&lt;p&gt;最新的开发版本可以直接通过 github 安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Homebrew
brew install httpie --HEAD

# pip
pip install --upgrade https://github.com/jkbrzt/httpie/archive/master.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;python-版本&#34;&gt;Python 版本&lt;/h3&gt;

&lt;p&gt;虽然兼容 Python 2.6, 2.7 版本的，但是如果可以的话还是建议使用最新版的 Python 3.x 来安装 HTTPie。这将保证一些比较新的功能（比如：&lt;a href=&#34;#服务器名称指示-sni-server-name-indication&#34;&gt;SNI&lt;/a&gt; ）可以开箱即用。Python 3 在 Homebrew 0.9.4 版本以上已经成为了默认的 Python 版本。可以使用 &lt;code&gt;http --debug&lt;/code&gt; 来查看 HTTPie 使用的 python 版本&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;最简单的使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http httpie.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用语法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http [flags] [METHOD] URL [ITEM [ITEM]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用 &lt;code&gt;http --help&lt;/code&gt; 来查看更多使用方法：&lt;/p&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;p&gt;自定义 HTTP 方法，HTTP 头和 JSON 数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http PUT example.org X-API-Token:123 name=John
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表单提交：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -f POST example.org hello=World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用一个输出参数 &lt;code&gt;-v&lt;/code&gt; 来查看请求信息（默认不显示请求信息）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -v example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;a href=&#34;http://developer.github.com/v3/issues/comments/#create-a-comment&#34;&gt;Github API&lt;/a&gt; 向 issue 发送一条评论（需要授权验证参数）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -a USERNAME POST https://api.github.com/repos/jkbrzt/httpie/issues/83/comments body=&#39;HTTPie is awesome! :heart:&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过命令行的输入重定向上传文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http example.org &amp;lt; file.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;wget&lt;/code&gt; 风格下载文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --download example.org/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用命令会话对同一 host 进行请求之间的持久通信：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --session=logged-in -a username:password httpbin.org/get API-Key:123
http --session=logged-in httpbin.org/headers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义请求 host 头：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http localhost:8000 Host:example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;http-方法&#34;&gt;HTTP 方法&lt;/h2&gt;

&lt;p&gt;HTTP 方法的名称在 URL 参数之前：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http DELETE example.org/todos/7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这看起来就像是原生的 HTTP 请求发送的文本一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;DELETE /todos/7 HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;请求-url&#34;&gt;请求 URL&lt;/h2&gt;

&lt;p&gt;HTTPie 唯一必传的一个参数是请求 URL，默认的方案不出意料的是
&lt;code&gt;http://&lt;/code&gt;，可以在请求的时候缺省 - &lt;code&gt;http example.org&lt;/code&gt; 是没问题的&lt;/p&gt;

&lt;h3 id=&#34;querystring-参数&#34;&gt;Querystring 参数&lt;/h3&gt;

&lt;p&gt;如果需要在命令行手动构建 URLs，你可能会觉得使用 &lt;code&gt;param==value&lt;/code&gt; 添加参数的方式是比较方便的，这样你就不需要担心命令行中转义链接字符串 &lt;code&gt;&amp;amp;&lt;/code&gt; 的问题，当然参数中的特殊字符也将被自动转义（除非已经转义过）。用下面的命令搜索 &lt;code&gt;HTTPie logo&lt;/code&gt; 可以在 google 图片上结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http www.google.com search==&#39;HTTPie logo&#39; tbm==isch

GET /?search=HTTPie+logo&amp;amp;tbm=isch HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;localhost-的-url-缩写&#34;&gt;localhost 的 URL 缩写&lt;/h3&gt;

&lt;p&gt;另外，类似 &lt;code&gt;curl&lt;/code&gt; 的 localhost 缩写也是支持的。这表示你可以使用 &lt;code&gt;:3000&lt;/code&gt; 来代替
&lt;code&gt;http://localhost:3000&lt;/code&gt;, 如果不传入端口号，&lt;code&gt;80&lt;/code&gt; 将会默认被使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http :/foo

GET /foo HTTP/1.1
Host: localhost
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http :3000/bar

GET /bar HTTP/1.1
Host: localhost:3000
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http :

GET / HTTP/1.1
Host: localhost
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自定义默认的方案&#34;&gt;自定义默认的方案&lt;/h3&gt;

&lt;p&gt;你可以使用 &lt;code&gt;--default-scheme &amp;lt;URL_SCHEME&amp;gt;&lt;/code&gt; 参数来指定非 HTTP 的其它协义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;alias https=&#39;http --default-scheme=https&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;请求项&#34;&gt;请求项&lt;/h2&gt;

&lt;p&gt;不同的请求项类型提供一种便捷的方法来指定 HTTP 头、简单的 JSON
、表单数据、文件、URL 参数&lt;/p&gt;

&lt;p&gt;URL 参数后面紧随的是 &lt;code&gt;键/值&lt;/code&gt; 对参数都会被拼装成请求发送。不同类型的 &lt;code&gt;键/值&lt;/code&gt;
对分割符号分别是：&lt;code&gt;:&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;:=&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;=@&lt;/code&gt;, &lt;code&gt;:=@&lt;/code&gt;。用 &lt;code&gt;@&lt;/code&gt;
分割的参数表示文件路径&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;项类型(item type)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述(Description)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;HTTP 头参数&lt;br/&gt; &lt;code&gt;Name:Value&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;任意的 HTTP 头，比如：&lt;code&gt;X-API-Token:123&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;URL 参数&lt;br/&gt; &lt;code&gt;name==value&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;通过分割符 &lt;code&gt;==&lt;/code&gt; 表示一个查询字符串的 &lt;code&gt;键/值&lt;/code&gt; 对&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;数据域&lt;br/&gt; &lt;code&gt;field=value&lt;/code&gt;,&lt;br/&gt; &lt;code&gt;field=@file.txt&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;请求一个默认会被序列化成 JSON 的数据域，或者表单类型 form-encoded&lt;code&gt;(--form, -f)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;纯 JSON 域&lt;br/&gt; &lt;code&gt;field:=json&lt;/code&gt;,&lt;br/&gt; &lt;code&gt;field:=@file.json&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当需要指定一个或者多数域参数类型 &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; .. 时非常有用， 比如：meals:=&amp;rsquo;[&amp;ldquo;ham&amp;rdquo;,&amp;ldquo;spam&amp;rdquo;]&amp;rsquo; or pies:=&lt;a href=&#34;注意引号&#34;&gt;1,2,3&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;Form 表单文件域&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;仅当传入参数 &lt;code&gt;--form, -f&lt;/code&gt; 时有效，比如 &lt;code&gt;screenshot@~/Pictures/img.png&lt;/code&gt; 文件内容将会被序列化成 &lt;code&gt;multipart/form-data&lt;/code&gt; 发送&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;数据域不是唯一的指定请求数据的方式，&lt;a href=&#34;#重定向输入&#34;&gt;重定向输入&lt;/a&gt;也可以&lt;/p&gt;

&lt;h3 id=&#34;字符转义规则&#34;&gt;字符转义规则&lt;/h3&gt;

&lt;p&gt;可以使用 &lt;code&gt;\&lt;/code&gt; 来转义不应该被用于分割符的情况。比如 &lt;code&gt;foo\==bar&lt;/code&gt;
会被转义成一个数据键值对（foo= 和 bar）而不是 URL 参数&lt;/p&gt;

&lt;p&gt;通常情况需要使用引号包围值，比如 &lt;code&gt;foo=&#39;bar baz&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果有一个域的名字或者 header 以减号开头，你需要把这些参数放在一个特殊符号 &lt;code&gt;--&lt;/code&gt; &lt;strong&gt;后面&lt;/strong&gt;
，这样做是为了和 &lt;code&gt;--arguments&lt;/code&gt; 区分开&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http httpbin.org/post  --  -name-starting-with-dash=foo -Unusual-Header:bar

POST /post HTTP/1.1
-Unusual-Header: bar
Content-Type: application/json

{
    &amp;quot;-name-starting-with-dash&amp;quot;: &amp;quot;value&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;json&#34;&gt;JSON&lt;/h2&gt;

&lt;p&gt;JSON 是现代 web services 通用规范，HTTPie 也默认遵循了它的 &lt;strong&gt;不严格的数据类型&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http PUT example.org name=John email=john@example.org

PUT / HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Content-Type: application/json
Host: example.org

{
    &amp;quot;name&amp;quot;: &amp;quot;John&amp;quot;,
    &amp;quot;email&amp;quot;: &amp;quot;john@example.org&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;默认行为&#34;&gt;默认行为&lt;/h3&gt;

&lt;p&gt;如果你的命令包含了一些请求项数据，它们将默认被序列化成 JSON 对象。HTTPie
会默认自动添加下面两个 header 头，当然这两个头也可以重新传入&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;Content-Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;code&gt;application/json&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;Accept&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;application/json, */*&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;明确的-json&#34;&gt;明确的 JSON&lt;/h3&gt;

&lt;p&gt;你可以使用命令行参数 &lt;code&gt;--json, -j&lt;/code&gt; 明确地设置 &lt;code&gt;Accept&lt;/code&gt; 为 &lt;code&gt;application/json&lt;/code&gt;
而无需在意发送的数据是什么（这是个快捷方式，也可以使用普通的 header 注解：&lt;code&gt;http
url Accept:&#39;application/json, */*&#39;&lt;/code&gt;），另外，HTTPie 会试着检测 JSON 响应，即使
&lt;code&gt;Content-Type&lt;/code&gt; 是不正常的 &lt;code&gt;text/plain&lt;/code&gt; 或者未知类型&lt;/p&gt;

&lt;h3 id=&#34;非字符串的-json-域&#34;&gt;非字符串的 JSON 域&lt;/h3&gt;

&lt;p&gt;非字符串类型的 JSON 域使用 &lt;code&gt;:=&lt;/code&gt; 分割，这可以允许你嵌入原生纯 JSON
到结果对象，文本和原生的纯 JSNO 文件也可以使用 &lt;code&gt;=@&lt;/code&gt; 和 &lt;code&gt;:=G&lt;/code&gt; 嵌入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http PUT api.example.com/person/1 \
    name=John \
    age:=29 married:=false hobbies:=&#39;[&amp;quot;http&amp;quot;, &amp;quot;pies&amp;quot;]&#39; \  # Raw JSON
    description=@about-john.txt \   # Embed text file
    bookmarks:=@bookmarks.json      # Embed JSON file

PUT /person/1 HTTP/1.1
Accept: application/json, */*
Content-Type: application/json
Host: api.example.com

{
    &amp;quot;age&amp;quot;: 29,
    &amp;quot;hobbies&amp;quot;: [
        &amp;quot;http&amp;quot;,
        &amp;quot;pies&amp;quot;
    ],
    &amp;quot;description&amp;quot;: &amp;quot;John is a nice guy who likes pies.&amp;quot;,
    &amp;quot;married&amp;quot;: false,
    &amp;quot;name&amp;quot;: &amp;quot;John&amp;quot;,
    &amp;quot;bookmarks&amp;quot;: {
        &amp;quot;HTTPie&amp;quot;: &amp;quot;http://httpie.org&amp;quot;,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过请注意，当发送复杂数据的时候，这个例子使用的语法会显得很笨重。在这种情况下 &lt;a href=&#34;#重定向输入&#34;&gt;重定向输入&lt;/a&gt; 将会更合适：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http POST api.example.com/person/1 &amp;lt; person.json
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;表单&#34;&gt;表单&lt;/h2&gt;

&lt;p&gt;提交表单和发送 JSON 请求很相似，通常情况下唯一的不同是添加额外的 &lt;code&gt;--form, -f&lt;/code&gt;
参数，这将确保数据域和 &lt;code&gt;Content-Type&lt;/code&gt; 被设置成 &lt;code&gt;application/x-www-form-urlencoded; charset=utf-8&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;普通的表单&#34;&gt;普通的表单&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --form POST api.example.org/person/1 name=&#39;John Smith&#39;

POST /person/1 HTTP/1.1
Content-Type: application/x-www-form-urlencoded; charset=utf-8

name=John+Smith
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文件上传表单&#34;&gt;文件上传表单&lt;/h3&gt;

&lt;p&gt;如果有一个文件域，序列化方式和 content type 会是 &lt;code&gt;multipart/form-data&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -f POST example.com/jobs name=&#39;John Smith&#39; cv@~/Documents/cv.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的请求和下面的 HTML 表单发送请求是一样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form enctype=&amp;quot;multipart/form-data&amp;quot; method=&amp;quot;post&amp;quot; action=&amp;quot;http://example.com/jobs&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot; /&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;cv&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 &lt;code&gt;@&lt;/code&gt; 用来模拟文件上传域，而 &lt;code&gt;=@&lt;/code&gt;
是把文件内容以文本的方式嵌入到数据域的值里面&lt;/p&gt;

&lt;h2 id=&#34;http-头&#34;&gt;HTTP 头&lt;/h2&gt;

&lt;p&gt;可以使用 &lt;code&gt;Header:Value&lt;/code&gt; 注解的形式来添加自定义头信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http example.org  User-Agent:Bacon/1.0  &#39;Cookie:valued-visitor=yes;foo=bar&#39;  \
    X-Foo:Bar  Referer:http://httpie.org/

GET / HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Cookie: valued-visitor=yes;foo=bar
Host: example.org
Referer: http://httpie.org/
User-Agent: Bacon/1.0
X-Foo: Bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;默认的请求头&#34;&gt;默认的请求头&lt;/h3&gt;

&lt;p&gt;有几个默认的请求头是 HTTPie 设置的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;GET / HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
User-Agent: HTTPie/&amp;lt;version&amp;gt;
Host: &amp;lt;taken-from-URL&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;空头和重新设置默认头&#34;&gt;空头和重新设置默认头&lt;/h3&gt;

&lt;p&gt;可以使用 &lt;code&gt;Header:&lt;/code&gt; 来取消上面的几个默认头信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http httpbin.org/headers Accept: User-Agent:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求中的 &lt;code&gt;Accept&lt;/code&gt; 和 &lt;code&gt;User-Agent&lt;/code&gt; 头都会被移除&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;Header;&lt;/code&gt; 表示添加一个为空的头信息，注意须使用引号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -v httpbin.org/headers &#39;Host;&#39;

GET /headers HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host:
User-Agent: HTTPie/0.9.9
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;授权验证&#34;&gt;授权验证&lt;/h2&gt;

&lt;p&gt;目前支持的验证方案有基础和摘要两种（查看更多 &lt;a href=&#34;#授权插件&#34;&gt;授权插件&lt;/a&gt;），有两种标识来控制验证：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--auth, -a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把 &lt;code&gt;用户名:密码&lt;/code&gt; 做为键值对参数传入，如果只指定用户名可以使用 &lt;code&gt;-a 用户名&lt;/code&gt;，密码在接下来的提示符中输入，空密码使用 &lt;code&gt;username:&lt;/code&gt;，&lt;code&gt;username:password@hostname&lt;/code&gt; 格式的 URL 语法也是支持的，证书通过 &lt;code&gt;-a&lt;/code&gt; 参数传入且具有更高的优先级&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--auth-type, -A&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定指定身份验证机制。&lt;code&gt;basic&lt;/code&gt;(默认) 和 &lt;code&gt;digest&lt;/code&gt; 两种&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;basic-授权&#34;&gt;Basic 授权&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -a username:password example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;digest-授权&#34;&gt;Digest 授权&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -A digest -a username:password example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;密码提示&#34;&gt;密码提示&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -a username example.org&amp;lt;Paste&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;netrc&#34;&gt;.netrc&lt;/h3&gt;

&lt;p&gt;从你的 &lt;code&gt;~/.netrc&lt;/code&gt; 文件授权也可以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat ~/.netrc
machine httpbin.org
login httpie
password test

http httpbin.org/basic-auth/httpie/test
HTTP/1.1 200 OK
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;授权插件&#34;&gt;授权插件&lt;/h3&gt;

&lt;p&gt;授权机制可以使用安装插件的方式来实现，可以在 Python Package 上面找到更多相关插件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pd/httpie-api-auth&#34;&gt;httpie-api-auth&lt;/a&gt;: ApiAuth&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/httpie/httpie-aws-auth&#34;&gt;httpie-aws-auth&lt;/a&gt;: AWS / Amazon S3&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/akamai-open/httpie-edgegrid&#34;&gt;httpie-edgegrid&lt;/a&gt;: EdgeGrid&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/guardian/httpie-hmac-auth&#34;&gt;httpie-hmac-auth&lt;/a&gt;: HMAC&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/teracyhq/httpie-jwt-auth&#34;&gt;httpie-jwt-auth&lt;/a&gt;: JWTAuth (JSON Web Tokens)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ndzou/httpie-negotiate&#34;&gt;httpie-negotiate&lt;/a&gt;: SPNEGO (GSS Negotiate)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/httpie/httpie-ntlm&#34;&gt;httpie-ntlm&lt;/a&gt;: NTLM (NT LAN Manager)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/httpie/httpie-oauth&#34;&gt;httpie-oauth&lt;/a&gt;: OAuth&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mozilla-services/requests-hawk&#34;&gt;requests-hawk&lt;/a&gt;: Hawk&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;http-重定向&#34;&gt;HTTP 重定向&lt;/h2&gt;

&lt;p&gt;HTTP 重定向默认不会自动跳转，请求发出后命令行只会显示 &lt;strong&gt;第一次&lt;/strong&gt; 收到的响应&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http httpbin.org/redirect/3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;按-header-头中的-location-字段值跳转&#34;&gt;按 header 头中的 location 字段值跳转&lt;/h3&gt;

&lt;p&gt;指定 &lt;code&gt;--follow, -F&lt;/code&gt; 参数让 HTTPie 自动跟随 &lt;code&gt;30x&lt;/code&gt; 响应头中的 &lt;code&gt;location&lt;/code&gt;
字段值进行跳转，并且显示最终的响应内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --follow httpbin.org/redirect/3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;显示中间的跳转响应&#34;&gt;显示中间的跳转响应&lt;/h3&gt;

&lt;p&gt;如果你也想看到更多的跳转信息，可以指定 &lt;code&gt;--all&lt;/code&gt; 参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --follow --all httpbin.org/redirect/3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;限制重定向最大次数&#34;&gt;限制重定向最大次数&lt;/h3&gt;

&lt;p&gt;改变默认最大 &lt;code&gt;30&lt;/code&gt; 次重定向值可以使用 &lt;code&gt;--max-redirects=&amp;lt;limit&amp;gt;&lt;/code&gt; 参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --follow --all --max-redirects=5 httpbin.org/redirect/3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代理&#34;&gt;代理&lt;/h2&gt;

&lt;p&gt;你可以通过添加参数 &lt;code&gt;--proxy&lt;/code&gt; 来指定各自协义（为了防止跨协义的重定向，协义被包含在了参数值中）的代理服务器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --proxy=http:http://10.10.1.10:3128 --proxy=https:https://10.10.1.10:1080 example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加 basic 授权&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --proxy=http:http://user:pass@10.10.1.10:3128 example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;环境变量&#34;&gt;环境变量&lt;/h3&gt;

&lt;p&gt;也可以通过设置 &lt;code&gt;HTTP_PROXY&lt;/code&gt; 和 &lt;code&gt;HTTPS_PROXY&lt;/code&gt; 环境变量来配置代理，底层的 request
库也将使用这些代理配置，如果你想指定某些 host 不使用代理，可以通过添加 &lt;code&gt;NO_PROXY&lt;/code&gt; 参数来实现&lt;/p&gt;

&lt;p&gt;在你的 &lt;code&gt;~/.bash_profile&lt;/code&gt; 文件中（zsh 则在 &lt;code&gt;~/.zshrc&lt;/code&gt; 中）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export HTTP_PROXY=http://10.10.1.10:3128
export HTTPS_PROXY=https://10.10.1.10:1080
export NO_PROXY=localhost,example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;socks&#34;&gt;Socks&lt;/h3&gt;

&lt;p&gt;要启用 socks 代理支持请使用 pip 安装 &lt;code&gt;requests[socks]&lt;/code&gt; 库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install -U requests[socks]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法与其它类型的代理相同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --proxy=http:socks5://user:pass@host:port --proxy=https:socks5://user:pass@host:port example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;https&#34;&gt;HTTPS&lt;/h2&gt;

&lt;h3 id=&#34;服务器-ssl-证书验证&#34;&gt;服务器 SSL 证书验证&lt;/h3&gt;

&lt;p&gt;使用参数 &lt;code&gt;--verify=no&lt;/code&gt; 可以跳过主机 SSL 验证（默认：&lt;code&gt;yes&lt;/code&gt;）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --verify=no https://example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自定义-ca-包&#34;&gt;自定义 CA 包&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;--verify=&amp;lt;CA_BUNDLE_PATH&amp;gt;&lt;/code&gt; 指定 CA 认证包路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --cert=client.pem https://example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;客户端-ssl-证书&#34;&gt;客户端 SSL 证书&lt;/h3&gt;

&lt;p&gt;使用客户端 SSL 证书进行 SSL 通信，可以用 &lt;code&gt;--cert&lt;/code&gt; 参数指定证书文件路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --cert=client.pem https://example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果证书中不包含私钥，可以通过 &lt;code&gt;--cert-key&lt;/code&gt; 参数指定密钥文件路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --cert=client.crt --cert-key=client.key https://example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ssl-版本&#34;&gt;SSL 版本&lt;/h3&gt;

&lt;p&gt;参数 &lt;code&gt;--ssl=&amp;lt;PROTOCOL&amp;gt;&lt;/code&gt; 用来指定你想使用的 SSL 协义版本，默认是 &lt;code&gt;SSL
v2.3&lt;/code&gt;。这将会协商服务端和你安装的 OpenSSL 支持的最高 SSL
协议版本。可用的版本有： &lt;code&gt;ssl2.3&lt;/code&gt;, &lt;code&gt;ssl3&lt;/code&gt;, &lt;code&gt;tls1&lt;/code&gt;, &lt;code&gt;tls1.1&lt;/code&gt;, &lt;code&gt;tls1.2&lt;/code&gt;
（实际上可用的协义可能有很多种，这由你安装的 OpenSSL 决定）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 指定容易受到攻击的 SSL v3 协义与老服务器进行通信
http --ssl=ssl3 https://vulnerable.example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;服务器名称指示-sni-server-name-indication&#34;&gt;服务器名称指示 SNI(Server Name Indication)&lt;/h3&gt;

&lt;p&gt;如果你的 HTTPie 版本（可以使用 &lt;code&gt;http --debug&lt;/code&gt; 查看版本）小于 2.7.9，又需要使用
SNI 与服务器会话。那么你需要安装额外的依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install --upgrade requests[security]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面的命令测试 SNI 支持&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http https://sni.velox.ch
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;输出参数&#34;&gt;输出参数&lt;/h2&gt;

&lt;p&gt;HTTPie 默认只输出最终响应信息并且打印（header,
body同样），你可以通过下面一些参数控制打印内容：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;命令行参数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&amp;ndash;headers, -h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;仅打印响应头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&amp;ndash;body, -b&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;仅打印响应体&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&amp;ndash;verbose, -v&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印所有的 HTTP 请求来回内容，这将默认开启 &lt;code&gt;--all&lt;/code&gt; 参数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;使用 &lt;code&gt;--verbose&lt;/code&gt; 参数来调试请求或生成文档时是非常有用的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --verbose PUT httpbin.org/put hello=world
PUT /put HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Content-Type: application/json
Host: httpbin.org
User-Agent: HTTPie/0.2.7dev

{
    &amp;quot;hello&amp;quot;: &amp;quot;world&amp;quot;
}


HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 477
Content-Type: application/json
Date: Sun, 05 Aug 2012 00:25:23 GMT
Server: gunicorn/0.13.4

{
    […]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;哪部分的-http-请求内容应该打印出来&#34;&gt;哪部分的 HTTP 请求内容应该打印出来&lt;/h3&gt;

&lt;p&gt;所有的 HTTP 输出选项都属于更强大的 &lt;code&gt;--print, -p&lt;/code&gt; 参数的快捷方式。&lt;code&gt;--print, -p&lt;/code&gt;
 接受一个字符串，字符串的每个字母都表示下面的 HTTP 某一部分&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;字符&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;代表&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;H&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;请求头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;请求体&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;h&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;响应头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;响应体&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;打印请求头和响应头：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --print=Hh PUT httpbin.org/put hello=world
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查看中间的请求-响应&#34;&gt;查看中间的请求/响应&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;--all&lt;/code&gt; 参数可以查看 HTTP 通信中的所有信息，中间的 HTTP
通信包括跟随重定向（使用参数&lt;code&gt;--follow&lt;/code&gt;）和使用 HTTP
摘要授权时第一次未授权的请求（使用参数 &lt;code&gt;--auth=diggest&lt;/code&gt;）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 包括最终响应之前的所有响应信息
http --all --follow httpbin.org/redirect/3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中间请求/响应默认会使用 &lt;code&gt;--print, -p&lt;/code&gt; 参数指定的值格式化，可以使用 &lt;code&gt;--history-print, -P&lt;/code&gt; 指定，
参数和 &lt;code&gt;--print, -p&lt;/code&gt; 是一样的。但是这只实用于 &lt;strong&gt;中间请求&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 中间请求/响应信息使用 H 格式化，最终请求/响应信息使用 Hh 格式化:
http -A digest -a foo:bar --all -p Hh -P H httpbin.org/digest-auth/auth/foo/bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;条件化的-body-内容下载&#34;&gt;条件化的 body 内容下载&lt;/h3&gt;

&lt;p&gt;做为一个优化项，响应体在仅作为输出一部分时才会被下载，这和 &lt;code&gt;HEAD&lt;/code&gt;
类型的请求类似（除了 HEAD 可以使用在任何 HTTP 请求中）&lt;/p&gt;

&lt;p&gt;比如有一个 API 更新后会返回整个资源，但是你只对更新后响应头中的状态码感兴趣：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --headers PATCH example.org/Really-Huge-Resource name=&#39;New Name&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们在上面设置了只打印头信息，当响应头接收完成的时候服务器连接就会被关闭，
带宽和时间不会浪费在下载响应体，你可以不必在意。响应头总是会被下载的无论它是不是输出部分&lt;/p&gt;

&lt;h2 id=&#34;重定向输入&#34;&gt;重定向输入&lt;/h2&gt;

&lt;p&gt;直接从 &lt;code&gt;stdin&lt;/code&gt; （标准输入）管道传入请求数据是大部分人认为比较好的方法。
这些数据被缓冲而且不需要更多的操作就可以做为请求体被使用，使用管道有下面几个好用的方法：&lt;/p&gt;

&lt;p&gt;从一个文件重新定向&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http PUT example.com/person/1 X-API-Token:123 &amp;lt; person.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者从其它程序的输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep &#39;401 Unauthorized&#39; /var/log/httpd/error_log | http POST example.org/intruders
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然也可以使用 &lt;code&gt;echo&lt;/code&gt; 命令来传简单数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#39;{&amp;quot;name&amp;quot;: &amp;quot;John&amp;quot;}&#39; | http PATCH example.com/person/1 X-API-Token:123
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;甚至可以使用 web services&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http GET https://api.github.com/repos/jkbrzt/httpie | http POST httpbin.org/post
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用 &lt;code&gt;cat&lt;/code&gt; 命令来输入多行文本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat | http POST example.com
&amp;lt;paste&amp;gt;
^D
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat | http POST example.com/todos Content-Type:text/plain
- buy milk
- call parents
^D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 macOS 中可以使用 &lt;code&gt;pbpaste&lt;/code&gt; 命令把剪贴板中的内容做为数据发送&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pbpaste | http PUT example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;stdin&lt;/code&gt; 传递数据的方式 &lt;strong&gt;不能&lt;/strong&gt; 和指定数据域的方式混合使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#39;data&#39; | http POST example.org more=data   # 不可以
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;从一个文件中取请求数据&#34;&gt;从一个文件中取请求数据&lt;/h3&gt;

&lt;p&gt;指定文件路径（&lt;code&gt;@/path/to/file&lt;/code&gt;）方式可以替代上面使用 &lt;code&gt;stdin&lt;/code&gt; 的方式&lt;/p&gt;

&lt;p&gt;这个方法有个优点，&lt;code&gt;Content-Type&lt;/code&gt;
可以根据提供的文件扩展名自动设置成对应的。比如下面的请求会被设置头 &lt;code&gt;Content-Type: application/xml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http PUT httpbin.org/put @/data/file.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;命令行输出&#34;&gt;命令行输出&lt;/h2&gt;

&lt;p&gt;HTTPie 默认会做一些事情，目的是为了让命令行输出内容有更高的可读性&lt;/p&gt;

&lt;h3 id=&#34;颜色和格式化&#34;&gt;颜色和格式化&lt;/h3&gt;

&lt;p&gt;语法高亮会应用在 HTTP 请求的 headers 和 body 里面。如果你不喜欢默认的配色方案，可以使用
&lt;code&gt;--style&lt;/code&gt; 参数自定义（使用&lt;code&gt;http --help&lt;/code&gt;命令查看更多选项）&lt;/p&gt;

&lt;p&gt;还有下面几个格式化规则会被使用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP 头会按名称排序&lt;/li&gt;
&lt;li&gt;JSON 数据会有缩进，并且按 key 名排序，unicode 序列会被转换成实际字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这些参数可以用在处理输出结果中：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;命令行参数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&amp;ndash;pretty=all&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;应用颜色和格式化，默认&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&amp;ndash;pretty=colors&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;仅应用颜色&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&amp;ndash;pretty=format&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;仅应用格式化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&amp;ndash;pretty=none&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不使用颜色和格式化，重定向时默认使用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;二进制数据&#34;&gt;二进制数据&lt;/h3&gt;

&lt;p&gt;二进制数据在命令行中会被禁止，这会使处理响应返回的二进制数据变得更安全，重定向时也禁止二进制数据，但是会被装饰输出。一旦当我们知道响应体是二进制数据时，连接会关闭&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http example.org/Movie.mov
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你几乎可以立即看见下面的提示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;HTTP/1.1 200 OK
Accept-Ranges: bytes
Content-Encoding: gzip
Content-Type: video/quicktime
Transfer-Encoding: chunked

+-----------------------------------------+
| NOTE: binary data not shown in terminal |
+-----------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重定向输出&#34;&gt;重定向输出&lt;/h2&gt;

&lt;p&gt;与命令行输出相比，重定向输出使用了不同的默认值，不同之处在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;格式化和种颜色默认不会使用（除非&lt;code&gt;--pretty&lt;/code&gt;被指定）&lt;/li&gt;
&lt;li&gt;只输出响应体（除非指定了输出参数）&lt;/li&gt;
&lt;li&gt;二进制结果不会被禁止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原因是为了把 HTTPie 的结果直接 piping
到其它程序，并且使下载文件不需要额外的参数标识。多数情况下输出重定向时只有响应体有意义&lt;/p&gt;

&lt;p&gt;下载一个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http example.org/Movie.mov &amp;gt; Movie.mov
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载 Octocat 图片，使用 ImageMagick 修改大小，上传到其它地方：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http octodex.github.com/images/original.jpg | convert - -resize 25% -  | http example.org/Octocats
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;强制使用格式化与颜色，在 &lt;code&gt;less&lt;/code&gt; 的分页中显示请求和响应&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --pretty=all --verbose example.org | less -R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-R&lt;/code&gt; 标识告诉 &lt;code&gt;less&lt;/code&gt; 命令解析 HTTPie 输出中的颜色序列&lt;/p&gt;

&lt;p&gt;你可以使用下面的 bash 函数代码建立一个调用 HTTPie
分页格式化且高亮输出的快捷方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;function httpless {
    # `httpless example.org&#39;
    http --pretty=all --print=hb &amp;quot;$@&amp;quot; | less -R;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;下载模式&#34;&gt;下载模式&lt;/h2&gt;

&lt;p&gt;HTTPie 具有下载模式，这和 &lt;code&gt;wget&lt;/code&gt; 命令类似&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;--download, -d&lt;/code&gt; 标识启用，响应头会打印到命令行，下载响应体的进度条也会显示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --download https://github.com/jkbrzt/httpie/archive/master.tar.gz
HTTP/1.1 200 OK
Content-Disposition: attachment; filename=httpie-master.tar.gz
Content-Length: 257336
Content-Type: application/x-gzip

Downloading 251.30 kB to &amp;quot;httpie-master.tar.gz&amp;quot;
Done. 251.30 kB in 2.73862s (91.76 kB/s)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;下载文件的文件名&#34;&gt;下载文件的文件名&lt;/h3&gt;

&lt;p&gt;如果没有指定参数 &lt;code&gt;--output, -o&lt;/code&gt;，文件名将由 &lt;code&gt;Content-Disposition&lt;/code&gt; 决定，或者通过
URL 及其 &lt;code&gt;Content-Type&lt;/code&gt;，如果名字已占用，HTTPie 会添加唯一后缀&lt;/p&gt;

&lt;h3 id=&#34;下载的同时-piping&#34;&gt;下载的同时 piping&lt;/h3&gt;

&lt;p&gt;即使响应头和进度状态显示在命令行中，你仍然可以将响应重定向到其它的程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -d https://github.com/jkbrzt/httpie/archive/master.tar.gz |  tar zxf -
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;恢复下载&#34;&gt;恢复下载&lt;/h3&gt;

&lt;p&gt;如果指定 &lt;code&gt;--output, -o&lt;/code&gt;，你可以 &lt;code&gt;--continue, -c&lt;/code&gt;
恢复部分下载。不过仅当服务器支持 &lt;code&gt;Range&lt;/code&gt; 请求而且响应返回 &lt;code&gt;206 Partial Content&lt;/code&gt;
才可以，如果服务器不支持这个功能，那就只会下载整个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -dco file.zip example.org/file
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;其它注意事项&#34;&gt;其它注意事项&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--download&lt;/code&gt; 仅更改响应正文的处理方式&lt;/li&gt;
&lt;li&gt;仍然可以使用自定义 header 头、使用 session 会话，&lt;code&gt;--verbose, -v&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--download&lt;/code&gt; 意味着启用 &lt;code&gt;--follow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果文件没有被完全下载完，HTTPie 将会返回错误状态码 &lt;code&gt;1&lt;/code&gt; 并退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt; 不能和 &lt;code&gt;--download&lt;/code&gt; 一起使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;流式响应&#34;&gt;流式响应&lt;/h2&gt;

&lt;p&gt;响应体会被以块的形式下载和打印，这使程序在不使用大量内存情况下进行流式传输和下载，然而如果使用颜色和格式化参数，&lt;strong&gt;整个&lt;/strong&gt; 响应体会被缓冲，然后立即处理&lt;/p&gt;

&lt;h3 id=&#34;禁用缓冲&#34;&gt;禁用缓冲&lt;/h3&gt;

&lt;p&gt;可以使用 &lt;code&gt;--stream, -S&lt;/code&gt; 进行下面的操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;输出内容以更小的块更新，不需要任何缓冲，这使得 HTTPie 表现的像 &lt;code&gt;tail -f&lt;/code&gt; 命令一样&lt;/li&gt;
&lt;li&gt;即使输出被美化，流也会启用：它将应用于响应的每一行并立即更新。这样就可以为持续时间长的请求提供一个漂亮的输出，例如一个 Twitter 的流 API&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;修饰过的流响应&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --stream -f -a YOUR-TWITTER-NAME https://stream.twitter.com/1/statuses/filter.json track=&#39;Justin Bieber&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像 &lt;code&gt;tail -f&lt;/code&gt; 一样小块的流输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --stream -f -a YOUR-TWITTER-NAME https://stream.twitter.com/1/statuses/filter.json track=Apple \
| while read tweet; do echo &amp;quot;$tweet&amp;quot; | http POST example.org/tweets ; done
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;会话&#34;&gt;会话&lt;/h2&gt;

&lt;p&gt;默认情况下，同一个 host 每个 HTTPie 发出的请求完全独立&lt;/p&gt;

&lt;p&gt;然而，HTTPie 支持使用 &lt;code&gt;--session=SESSION_NAME_OR_PATH&lt;/code&gt;
参数进行持久会话。在同一个 host 的会话中，自定义 header(除了以&lt;code&gt;Content-&lt;/code&gt; 和 &lt;code&gt;If-&lt;/code&gt; 开头)、authorization、cookies(手动指定或者服务器发送) 会持续保存&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 创建一个新会话
http --session=/tmp/session.json example.org API-Token:123

# 复制用已存在的会话 API-Token 会自动设置
http --session=/tmp/session.json example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的会话数据都会被存储成纯文本，这表示会话文件可以使用编辑器手动添加或者修改——其实就是 JSON 数据&lt;/p&gt;

&lt;h3 id=&#34;具名会话&#34;&gt;具名会话&lt;/h3&gt;

&lt;p&gt;每个 host 都可以建一个或者多个会话，比如：下面的命令将为 host 是 &lt;code&gt;example.org&lt;/code&gt; 的请求建一个名为 &lt;code&gt;name1&lt;/code&gt; 的会话：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --session=user1 -a user1:password example.org X-Foo:Bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从现在起，你就通过名字来选择会话，当你选择使用一个会话时，之前用过的授权、HTTP
头都会被自动添加：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --session=user1 example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建或者重用不同的会话，只需要指定不同的名字即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --session=user2 -a user2:password example.org X-Bar:Foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具名会话将被以 JSON 的数据格式存储在 &lt;code&gt;~/.httpie/sessions/&amp;lt;host&amp;gt;/&amp;lt;name&amp;gt;.json&lt;/code&gt;
下面（windows下则是 &lt;code&gt;%APPDATA%\httpie\sessions\&amp;lt;host&amp;gt;\&amp;lt;name&amp;gt;.json&lt;/code&gt;）&lt;/p&gt;

&lt;h3 id=&#34;匿名会话&#34;&gt;匿名会话&lt;/h3&gt;

&lt;p&gt;不同与具名会话，你也可以直接使用一个文件路径来指定会话文件的存储地址，这也可以在不同的 host 间复用会话：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http --session=/tmp/session.json example.org
http --session=/tmp/session.json admin.example.org
http --session=~/.httpie/sessions/another.example.org/test.json example.org
http --session-read-only=/tmp/session.json example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;只读会话&#34;&gt;只读会话&lt;/h3&gt;

&lt;p&gt;如果复用一个会话又不想更新会话信息，可以通过指定 &lt;code&gt;--session-read-only=SESSION_NAME_OR_PATH&lt;/code&gt; 来实现&lt;/p&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;p&gt;HTTPie 使用了一个简单的 JSON 配置文件&lt;/p&gt;

&lt;h3 id=&#34;配置文件路径&#34;&gt;配置文件路径&lt;/h3&gt;

&lt;p&gt;默认的配置文件路径在 &lt;code&gt;~/.httpie/config.json&lt;/code&gt; （window 在 &lt;code&gt;%APPDATA%\httpie\config.json&lt;/code&gt;），配置文件的路径也可以通过修改环境变量 &lt;code&gt;HTTPIE_CONFIG_DIR&lt;/code&gt; 来更改，可以使用 &lt;code&gt;http --debug&lt;/code&gt; 命令查看当前配置文件路径&lt;/p&gt;

&lt;h3 id=&#34;可配置的参数&#34;&gt;可配置的参数&lt;/h3&gt;

&lt;p&gt;JSON 配置文件包含以下的键：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;default_options&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参数默认值数组（默认为空），数组里面的参数会被应用于每次 HTTPie 的调用&lt;/p&gt;

&lt;p&gt;比如说，你可以使用这个选项改变默认的样式和输出参数：&lt;code&gt;&amp;quot;default_options&amp;quot;: [&amp;quot;--style=fruity&amp;quot;, &amp;quot;--body&amp;quot;]&lt;/code&gt; ，另外一个常用的默认参数是 &lt;code&gt;&amp;quot;--session=default&amp;quot;&lt;/code&gt;，这会让 HTTPie 总是使用会话（名称为default）。也可以使用 &lt;code&gt;--form&lt;/code&gt; 改变默认 &lt;strong&gt;不严格的&lt;/strong&gt; JSON 类型为 form 类型&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__meta__&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;HTTPie 自动存储了一些它自己的元数据，不要动它&lt;/p&gt;

&lt;h3 id=&#34;取消之前指定的参数&#34;&gt;取消之前指定的参数&lt;/h3&gt;

&lt;p&gt;配置文件中的参数和其它任何指定参数的方法，都可以使用 &lt;code&gt;--no-OPTION&lt;/code&gt;
参数来取消，比如：&lt;code&gt;--no-style&lt;/code&gt; 或者 &lt;code&gt;--no-session&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;脚本&#34;&gt;脚本&lt;/h2&gt;

&lt;p&gt;当你在 shell 脚本中使用 HTTPie 的时候，&lt;code&gt;--check-status&lt;/code&gt;
标识会比较好用。这个标识将告知 HTTPie 如果响应状态码是 &lt;code&gt;3xx&lt;/code&gt;, &lt;code&gt;4xx&lt;/code&gt;, &lt;code&gt;5xx&lt;/code&gt;
时程序将退出并显示对应的错误码 &lt;code&gt;3&lt;/code&gt;（除非 &lt;code&gt;--follow&lt;/code&gt; 参数被指定）, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

if http --check-status --ignore-stdin --timeout=2.5 HEAD example.org/health &amp;amp;&amp;gt; /dev/null; then
    echo &#39;OK!&#39;
else
    case $? in
        2) echo &#39;Request timed out!&#39; ;;
        3) echo &#39;Unexpected HTTP 3xx Redirection!&#39; ;;
        4) echo &#39;HTTP 4xx Client Error!&#39; ;;
        5) echo &#39;HTTP 5xx Server Error!&#39; ;;
        6) echo &#39;Exceeded --max-redirects=&amp;lt;n&amp;gt; redirects!&#39; ;;
        *) echo &#39;Other Error!&#39; ;;
    esac
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;最佳实践&#34;&gt;最佳实践&lt;/h2&gt;

&lt;p&gt;在非交互式调用的情况下通常不希望使用 &lt;code&gt;stdin&lt;/code&gt; 的默认行为，可以使用 &lt;code&gt;--ignore-stdin&lt;/code&gt; 参数来禁止它&lt;/p&gt;

&lt;p&gt;如果没有这个选项，HTTPie 可能会挂起，这是一个常见的问题。发生的场景可能是——例如从定时任务中调用HTTPie时，&lt;code&gt;stdin&lt;/code&gt; 未连接到终端。因此，重定向输入的规则适用，即 HTTPie 开始读取它，希望请求体将被传递。由于没有数据也没有 EOF，它会被卡住。因此，除非你将一些数据传递给 HTTPie，否则应在脚本中使用此标志&lt;/p&gt;

&lt;p&gt;当然使用 &lt;code&gt;--timeout&lt;/code&gt; 参数手动设置（默认 30 秒）延迟时间是个比较好的做法&lt;/p&gt;

&lt;h2 id=&#34;元信息&#34;&gt;元信息&lt;/h2&gt;

&lt;h3 id=&#34;接口设计&#34;&gt;接口设计&lt;/h3&gt;

&lt;p&gt;命令行参数的设计与通过网络发送 HTTP 请求的过程密切相关。这使得 HTTPie
的命令更容易记忆和阅读。有时你甚至可以把原生的 HTTP
请求串连到一行就很自然的形成了 HTTPie 的命令行参数。例如 对比下面这个原生 HTTP
请求：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;POST /collection HTTP/1.1
X-API-Key: 123
User-Agent: Bacon/1.0
Content-Type: application/x-www-form-urlencoded

name=value&amp;amp;name2=value2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和使用 HTTPie 命令发送同样的参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;http -f POST example.org/collection \
  X-API-Key:123 \
  User-Agent:Bacon/1.0 \
  name=value \
  name2=value2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意他们两者的顺序和参数都非常相似，并且只有一小部分命令用于控制 HTTPie（&lt;code&gt;-f&lt;/code&gt; 表示让 HTTPie 发送一个 from 请求），并且不直接对应于请求的任何部分&lt;/p&gt;

&lt;p&gt;两种模式：&lt;code&gt;--pretty=all&lt;/code&gt;（命令行中默认）、&lt;code&gt;--pretty=none&lt;/code&gt;（重定向输出时默认），对交互式使用和脚本调用都比较友好，HTTPie 在这过程中作为通用的 HTTP 客户端&lt;/p&gt;

&lt;p&gt;由于 HTTPie 还在频繁的开发中，现有的一些命令行参数在最终版 &lt;code&gt;1.0&lt;/code&gt;
发布之前可能会有一些微小的调整。这些调整都会在&lt;a href=&#34;#变更日志&#34;&gt;变更日志&lt;/a&gt; 里面记录&lt;/p&gt;

&lt;h3 id=&#34;用户支持&#34;&gt;用户支持&lt;/h3&gt;

&lt;p&gt;你可以通过下面的一些途径找到帮助支持&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jkbr/httpie/issues&#34;&gt;GitHub issues&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitter.im/jkbrzt/httpie&#34;&gt;Our Gitter chat room&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/&#34;&gt;StackOverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Twitter &lt;a href=&#34;https://twitter.com/clihttp&#34;&gt;@clihttp&lt;/a&gt;，也可以直接 &lt;a href=&#34;https://twitter.com/jkbrzt&#34;&gt;@jkbrzt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;相关项目&#34;&gt;相关项目&lt;/h3&gt;

&lt;h4 id=&#34;依赖&#34;&gt;依赖&lt;/h4&gt;

&lt;p&gt;HTTPie 底层使用了两个特别棒的库：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://python-requests.org/&#34;&gt;Requests&lt;/a&gt; — Python HTTP 库
&lt;a href=&#34;http://pygments.org/&#34;&gt;Pygments&lt;/a&gt; — Python 代码高亮&lt;/p&gt;

&lt;h4 id=&#34;httpie-的朋友&#34;&gt;HTTPie 的朋友&lt;/h4&gt;

&lt;p&gt;HTTPie 可以和下面两个好友愉快地玩耍：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://stedolan.github.io/jq/&#34;&gt;jq&lt;/a&gt;
&lt;a href=&#34;https://github.com/eliangcs/http-prompt&#34;&gt;http-prompt&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;贡献&#34;&gt;贡献&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jakubroztocil/httpie/blob/master/CONTRIBUTING.rst&#34;&gt;CONTRIBUTING.rst&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;变更日志&#34;&gt;变更日志&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jkbrzt/httpie/blob/master/CHANGELOG.rst&#34;&gt;CHANGELOG&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;插图&#34;&gt;插图&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/claudiatd/httpie-artwork&#34;&gt;claudiatd/httpie-artwork&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;许可证&#34;&gt;许可证&lt;/h3&gt;

&lt;p&gt;BSD-3-Clause: &lt;a href=&#34;https://github.com/jkbrzt/httpie/blob/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;作者&#34;&gt;作者&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://roztocil.co/&#34;&gt;Jakub Roztocil&lt;/a&gt; (&lt;a href=&#34;https://twitter.com/jkbrzt&#34;&gt;@jkbrzt&lt;/a&gt;)
创造了 HTTPie，还有一些 &lt;a href=&#34;https://github.com/jkbrzt/httpie/contributors&#34;&gt;优秀的人&lt;/a&gt; 也贡献力量&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VIM 代码片段插件 ultisnips 使用教程</title>
      <link>https://keelii.com/2018/08/26/vim-plugin-ultisnips-advanced-tips/</link>
      <pubDate>Sun, 26 Aug 2018 17:59:45 +0800</pubDate>
      
      <guid>https://keelii.com/2018/08/26/vim-plugin-ultisnips-advanced-tips/</guid>
      <description>

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/SirVer/ultisnips&#34;&gt;Ultisnips&lt;/a&gt; 插件安装分两部分，一个是 ultisnips 插件本身，另外一个是代码片段仓库。一般来说把默认的代码片段仓库下载下来按需修改后上传到自己的 github 即可。如果你和我一样也使用 vim-plug 来管理插件的话，添加下面的代码到你的 vimrc 中保存刷新即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Plug &#39;SirVer/ultisnips&#39;
# 你自己的代码仓库 git 地址
Plug &#39;keelii/vim-snippets&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的示例中所有的代码片段都存放在插件安装目录下面的 &lt;code&gt;vim-snippets/UltiSnips&lt;/code&gt; 中，文件命名格式为 &lt;code&gt;ft&lt;/code&gt;.snippets, &lt;code&gt;ft&lt;/code&gt; 就是 vim 中的 &lt;code&gt;filetype&lt;/code&gt;，其中有个 &lt;code&gt;all.snippets&lt;/code&gt; 是唯一一个所有文件都适用的代码片段&lt;/p&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;p&gt;快捷键设置，我一般使用 tab 来触发代码片段补全，&lt;strong&gt;且不使用 YCM&lt;/strong&gt; （官方文档表示使用YCM的话就不能使用tab补全）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;let g:UltiSnipsExpandTrigger=&amp;quot;&amp;lt;tab&amp;gt;&amp;quot;
&amp;quot; 使用 tab 切换下一个触发点，shit+tab 上一个触发点
let g:UltiSnipsJumpForwardTrigger=&amp;quot;&amp;lt;tab&amp;gt;&amp;quot;
let g:UltiSnipsJumpBackwardTrigger=&amp;quot;&amp;lt;S-tab&amp;gt;&amp;quot;
&amp;quot; 使用 UltiSnipsEdit 命令时垂直分割屏幕
let g:UltiSnipsEditSplit=&amp;quot;vertical&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;依赖&#34;&gt;依赖&lt;/h2&gt;

&lt;p&gt;ultisnips 插件需要你的 vim 支持 python，可以在 vim 命令模式下使用下面的检测你的 vim 版本是否支持 python&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 1 表示支持
:echo has(&amp;quot;python&amp;quot;)
:echo has(&amp;quot;python3&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;定义一个代码片段&#34;&gt;定义一个代码片段&lt;/h2&gt;

&lt;h3 id=&#34;定义格式&#34;&gt;定义格式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;snippet 触发字符 [&amp;quot;代码片段说明&amp;quot; [参数]]
代码片段内容
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;最小化的一个代码片段&#34;&gt;最小化的一个代码片段&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;snippet if &amp;quot;if (condition) { ... }&amp;quot;
if (${1:true}) {
    $0
}
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时当你在 vim 中输入 if 敲 tab 就会展开一条 if 语句，第一个触发点是 if 条件表达式，最后一个是 if 语句体&lt;/p&gt;

&lt;p&gt;&lt;code&gt;${1:true}&lt;/code&gt; 表示这是第一个触发点，占位符为 &lt;code&gt;true&lt;/code&gt;，如果占位符没有默认值可直接使用 &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;可视选择区的内容为占位符&#34;&gt;可视选择区的内容为占位符&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;snippet if &amp;quot;if (...)&amp;quot;
if (${1:true}) {
    ${VISUAL}
}
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;${VISUAL}&lt;/code&gt; 表示在 vim 中使用可视模式下选择的文本，这个在重构代码的时候&lt;strong&gt;非常有用&lt;/strong&gt;（后面会有高级用法），上个图感受一下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t25252/299/1019207883/36468/bca93de/5b84a8a9N8dd5a8c5.gif&#34; alt=&#34;if-with-visual-mode&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;代码片段的参数&#34;&gt;代码片段的参数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 表示触发字符应该在一行的开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; 表示触发字符可以在单词内（连续展示会使用这个选项）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; 表示触发字符的前后必须是一个字母分界点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 表示触发字符可以是一个正则表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; 表示展开的代码片段中如果有制表符，原样输出，即使你的 vimrc 里面设置了 expandtab&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; 表示删除代码片段右边的所有空白字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e&lt;/code&gt; 表示自定义上下文&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 表示自动触发，不需要按 tab，类似于 VIM 中的 abbr&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内容解释器&#34;&gt;内容解释器&lt;/h2&gt;

&lt;p&gt;Ultisnips 定义的代码片段中支持三种不同的语言注入：shell, vimscript, python，在代码片段中用反引号表示&lt;/p&gt;

&lt;h2 id=&#34;shell-代码&#34;&gt;shell 代码&lt;/h2&gt;

&lt;p&gt;就是在你的命令行 shell 能执行的代码片段，比如输出当前时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜ date
2018年 8月27日 星期一 18时19分38秒 CST
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码片段中用反引号「`」引用即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;snippet today
Today is the `date`.
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入 today 按 tab 展开后（格式和上面shell中的不一样，估计是因为 vim 语言设置的问题）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Today is the Mon Aug 27 18:24:51 CST 2018.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;vimscript-代码&#34;&gt;vimscript 代码&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;indent&lt;/code&gt; 来输出当前缩进值，使用前缀 &lt;code&gt;!v&lt;/code&gt; 表示是 vimscript&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;snippet indent
Indent is: `!v indent(&amp;quot;.&amp;quot;)`.
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;//img12.360buyimg.com/devfe/jfs/t23467/4/2565317844/22166/a39566b/5b84a97fNa6174311.gif&#34; alt=&#34;vimscript-indent-size&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;python-代码&#34;&gt;python 代码&lt;/h3&gt;

&lt;p&gt;在代码片段中解释执行 python 代码是 ultisnips 最强大的功能，以前缀 &lt;code&gt;!p&lt;/code&gt; 开始。系统会向 python 中注入一些变量，可以使用 python 代码直接对其进行操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fn&lt;/code&gt; - 表示当前文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt; -  当前文件名的路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; - 占位符的字典，可以使用 &lt;code&gt;t[1], t[2], t.v&lt;/code&gt; 来取占位符内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snip&lt;/code&gt; - &lt;a href=&#34;https://github.com/SirVer/ultisnips/blob/6fdc3647f72e0a1f321ea6bd092ecd01f7c187ba/pythonx/UltiSnips/text_objects/_python_code.py#L56&#34;&gt;UltiSnips.TextObjects.SnippetUtil&lt;/a&gt; 对象的一个实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;match&lt;/code&gt; - 正则代码片段时返回的匹配元素（非常强大）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中最常用的 &lt;code&gt;snip&lt;/code&gt; 对象提供了下面一些变量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;snip.rv&lt;/code&gt; 表示 return value，python 代码执行后处理过的字符串赋给 rv 即可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snip.fn&lt;/code&gt; 表示当前文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snip.ft&lt;/code&gt; 表示当前文件类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snip.v&lt;/code&gt; 表示 VISUAL 模式变量，其中 &lt;code&gt;snip.v.mode&lt;/code&gt; 表示模式类型，&lt;code&gt;snip.v.text&lt;/code&gt; 表示 VISUAL 模式中选择的字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t27739/311/103185395/173892/d6a786e3/5b84af90Nfa6cd193.gif&#34; alt=&#34;python-snippet-var&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;占位符选择&#34;&gt;占位符选择&lt;/h2&gt;

&lt;p&gt;UltiSnips 支持使用快捷键切换占位符，我使用 &lt;code&gt;&amp;lt;tab&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;shift-tab&amp;gt;&lt;/code&gt; 来切换 &lt;code&gt;下一个&lt;/code&gt; 和 &lt;code&gt;上一个&lt;/code&gt; 占位符，占位符切换的作用域为当前代码片段内部（即使占位符已被修改过），当光标移动出去以后就不起作用了&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img12.360buyimg.com/devfe/jfs/t24559/158/2571218888/171431/2459a91d/5b84bf9aN96a7ee7e.gif&#34; alt=&#34;mul-placeholder-editing&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;自定义上下文&#34;&gt;自定义上下文&lt;/h2&gt;

&lt;p&gt;自定义上下文可以通过正则匹配来决定代码片断是否可用，比如判断在指定的 if 语句里面才起作用的代码片断，定义格式如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;snippet 触发字符 &amp;ldquo;描述&amp;rdquo; &amp;ldquo;表达式&amp;rdquo; 参数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比如我们定义一个 &lt;strong&gt;只有&lt;/strong&gt; 在上一行以 &lt;code&gt;if (DEVELOPMENT) {&lt;/code&gt; 开头才可以展开的代码片段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;snippet dbg &amp;quot;if (DEVELOPMENT) dbg&amp;quot; &amp;quot;re.match(&#39;^if \(DEVELOPMENT\) \{&#39;, snip.buffer[snip.line-1])&amp;quot; be
debugger;
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常见用法&#34;&gt;常见用法&lt;/h2&gt;

&lt;h3 id=&#34;行内连续展开&#34;&gt;行内连续展开&lt;/h3&gt;

&lt;p&gt;这个常见于需要连续展开代码片段的情况，比如，有两个片段，一个打印变量，一个处理 JSON 序列化。这时需要使用参数选项 &lt;code&gt;i&lt;/code&gt;n-word&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t25579/50/1036526670/419976/53521e3b/5b84c7d2Nd6a0cb5e.gif&#34; alt=&#34;continue-expand-snippets&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用正则代码片段&#34;&gt;使用正则代码片段&lt;/h3&gt;

&lt;p&gt;通常写代码的时候需要使用 log, print 等来打印上下文中的变量。使用普通片段按 cl 展示 console.log() 然后把变量字符复制进括号，这样操作会比较复杂。使用正则来动态匹配前面的字符可以很好的解决这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;# 展开 console.log
snippet &amp;quot;([^\s]\w+)\.log&amp;quot; &amp;quot;console.log(postfix)&amp;quot; r
console.log(`!p snip.rv = match.group(1)`)$0
endsnippet
# 当前行转换成大写
snippet &amp;quot;([^\s].*)\.upper&amp;quot; &amp;quot;Uppercase(postfix)&amp;quot; r
`!p snip.rv = match.group(1).upper()`$0
endsnippet
# 上一个单词转换成小写
snippet &amp;quot;([^\s]\w+)\.lower&amp;quot; &amp;quot;Lowercase(postfix)&amp;quot; r
`!p snip.rv = match.group(1).lower()`$0
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动图演示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t25492/223/971280921/61984/701b0ab1/5b84cc6aN6fe8ea04.gif&#34; alt=&#34;expand-regexp-snippets&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：正则代码片段只适用于单行文本处理，如果是多行转换还是得用到下面的 python + VISUAL 代码片段来处理&lt;/p&gt;

&lt;h3 id=&#34;使用-python-解释器-visual-模式实现代码注释功能&#34;&gt;使用 python 解释器 + VISUAL 模式实现代码注释功能&lt;/h3&gt;

&lt;p&gt;通常我们需要使用一大堆插件来实现各种代码的注释功能。不过 Ultisnips 提供了 VISUAL 模式可以提取 vim 可视模式中选择的内容到代码片段里面，于是我们就可以结合起来制作一个&lt;strong&gt;具有注释功能的代码片段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流程大概是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;进入 vim 可视模式，选择要注释的内容&lt;/li&gt;
&lt;li&gt;按 tab，清除选择内容&lt;/li&gt;
&lt;li&gt;输入代码片段触发字符，按 tab 完成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于实现的 python 代码相对复杂一些，主要分成两个方法。单行注释和多行注释，注意 Ultisnips 中可以直接写 python 但是大段的方法建议放在插件目录下面的 pythonx 目录下面，使用的时候在对应的代码片段中的全局 python 代码 &lt;code&gt;global !p&lt;/code&gt; 引入即可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单行注释&lt;/strong&gt;(pythonx/javascript_snippets.py)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def comment(snip, START=&amp;quot;&amp;quot;, END=&amp;quot;&amp;quot;):
    lines = snip.v.text.split(&#39;\n&#39;)[:-1]
    first_line = lines[0]
    spaces = &#39;&#39;
    initial_indent = snip._initial_indent

    # Get the first non-empty line
    for idx, l in enumerate(lines):
        if l.strip() != &#39;&#39;:
            first_line = lines[idx]
            sp = re.findall(r&#39;^\s+&#39;, first_line)
            if len(sp):
                spaces = sp[0]
            break            

    # Uncomment
    if first_line.strip().startswith(START):
        result = [line.replace(START, &amp;quot;&amp;quot;, 1).replace(END, &amp;quot;&amp;quot;, 1) if line.strip() else line for line in lines]
    else:
        result = [f&#39;{spaces}{START}{line[len(spaces):]}{END}&#39; if line.strip() else line for line in lines ]

    # Remove initial indent
    if result[0] and initial_indent:
        result[0] = result[0].replace(initial_indent, &#39;&#39;, 1)

    if result:
        return &#39;\n&#39;.join(result)
    else:
        return &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;多行注释：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def comment_inline(snip, START=&amp;quot;/* &amp;quot;, END=&amp;quot; */&amp;quot;):
    text = snip.v.text
    lines = text.split(&#39;\n&#39;)[:-1]
    first_line = lines[0]
    initial_indent = snip._initial_indent
    spaces = &#39;&#39;

    # Get the first non-empty line
    for idx, l in enumerate(lines):
        if l.strip() != &#39;&#39;:
            first_line = lines[idx]
            sp = re.findall(r&#39;^\s+&#39;, first_line)
            if len(sp):
                spaces = sp[0]
            break            

    if text.strip().startswith(START):
        result = text.replace(START, &#39;&#39;, 1).replace(END, &#39;&#39;, 1)
    else:
        result = text.replace(spaces, spaces + START, 1).rstrip(&#39;\n&#39;) + END + &#39;\n&#39;

    if initial_indent:
        result = result.replace(initial_indent, &#39;&#39;, 1)

    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;代码片段定义：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;global !p
from javascript_snippets import (
	comment, comment_inline
)
endglobal

# ...

snippet c &amp;quot;Toggle comment every single line&amp;quot;
`!p
snip.rv = comment(snip, START=&#39;// &#39;, END=&#39;&#39;)
`$0
endsnippet

snippet ci &amp;quot;Toggle comment inline.&amp;quot;
`!p
snip.rv = comment_inline(snip, START=&amp;quot;/* &amp;quot;, END=&amp;quot; */&amp;quot;)
`$0
endsnippet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动图演示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t24175/330/2554434390/319822/5d8cf724/5b850d67N4c475946.gif&#34; alt=&#34;python-snippets-to-comment&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不同的语言可以在对应的片段文件中定义并传入注释符号参数即可，有了这个功能就可以愉快的删除其它的 vim 注释插件了 😀&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fuzzy finder(fzf&#43;vim) 使用全指南</title>
      <link>https://keelii.com/2018/08/12/fuzzy-finder-full-guide/</link>
      <pubDate>Sun, 12 Aug 2018 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2018/08/12/fuzzy-finder-full-guide/</guid>
      <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;Fuzzy finder&lt;/a&gt; 是一款使用 GO 语言编写的交互式的 Unix 命令行工具。可以用来查找任何 &lt;strong&gt;列表&lt;/strong&gt; 内容，文件、Git 分支、进程等。所有的命令行工具可以生成列表输出的都可以再通过管道 pipe 到 fzf 上进行搜索和查找&lt;/p&gt;

&lt;h2 id=&#34;优点&#34;&gt;优点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GO 语言编写，编译完生成可执行文件没有任何依赖&lt;/li&gt;
&lt;li&gt;搜索/查找速度飞快&lt;/li&gt;
&lt;li&gt;功能全面/可视化界面体验很棒&lt;/li&gt;
&lt;li&gt;周边插件丰富 (vim, tmux, fuzzy auto-completion)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;以 macOS 为例子，直接使用 homebrew 安装即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install fzf
# 如果要使用内置的快捷键绑定和命令行自动完成功能的话可以按需安装
$(brew --prefix)/opt/fzf/install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;命令行下执行 &lt;code&gt;fzf&lt;/code&gt; 即可展示当前目录下所有文件列表，可以用键盘上下键或者鼠标点出来选择
&lt;a href=&#34;https://img10.360buyimg.com/devfe/jfs/t26002/277/432949068/59208/9725245b/5b6fc71fN03036763.png&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t26002/277/432949068/59208/9725245b/5b6fc71fN03036763.png&#34; alt=&#34;fzf-normal&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;或许你会觉得这个查找提示看起来挺漂亮的，但是并没有什么卵用，因为查找出来就没有然后了。其实这也是 Fuzzy finder 最核心的地方，他只是一个通用的下拉查找功能，自己本身并不关心你用它来做什么，通常我们需要组合使用才会有很好的效果&lt;/p&gt;

&lt;h3 id=&#34;用-vim-打开文件&#34;&gt;用 vim 打开文件&lt;/h3&gt;

&lt;p&gt;比如我们用 vim 组合 fzf 来查找并打开目录下的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim $(fzf)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t25372/5/461999989/83158/3ce44a5/5b6fc7f2Nd6432499.gif&#34; alt=&#34;fzf-vim&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;切换当前工作目录&#34;&gt;切换当前工作目录&lt;/h3&gt;

&lt;p&gt;再比如进入到某个文件夹下面，使用 fzf 的过滤选择真是太方便了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd $(find * -type d | fzf)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是个组合 (cd+find+fzf) 命令，完成切换到任意子目录的功能。可以看出来当 fzf 和其它命令组合使用时就能使得一些操作更方便：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用 find 命令找出所有的子目录&lt;/li&gt;
&lt;li&gt;把子目录列表 pipe 到 fzf 上进行选择&lt;/li&gt;
&lt;li&gt;再把结果以子命令的形式传给 cd&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t23848/96/1951894215/50884/20a513d7/5b6fcabbNb77c46d5.gif&#34; alt=&#34;fzf-find-cd&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;切换-git-分支&#34;&gt;切换 git 分支&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout $(git branch -r | fzf)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t23242/262/2000817850/127859/c0955478/5b6fce70N3c3573ae.gif&#34; alt=&#34;fzf-git-branch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不过这样组合使用命令的实在太长了，如果你不使用自动补全的话巧起来很累的。建议把常用的 alias 放在 .zshrc 中管理嘛&lt;/p&gt;

&lt;h3 id=&#34;shell-命令行补全&#34;&gt;shell 命令行补全&lt;/h3&gt;

&lt;p&gt;fzf 默认使用 &lt;code&gt;**&lt;/code&gt; 来补全 shell 命令，比起默认的 tab 补全，fzf 补全不知道高到哪里去了。cd, vim, kill, ssh, export&amp;hellip; 统统都能补全，好用哭了 🤣&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t24820/280/435378103/490486/3777afba/5b6fedc6N59529380.gif&#34; alt=&#34;fzf-completion&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;p&gt;fzf 提供了两个 &lt;em&gt;环境变量&lt;/em&gt; 配置参数，来分别设置默认的调用命令和 fzf 默认配置参数&lt;/p&gt;

&lt;h3 id=&#34;核心命令-fzf-default-command&#34;&gt;核心命令 FZF_DEFAULT_COMMAND&lt;/h3&gt;

&lt;p&gt;对于使用 fzf 来查找文件的情况，fzf 其实底层是调用的 Unix 系统 &lt;code&gt;find&lt;/code&gt; 命令，如果你觉得 find 不好用也可以使用其它查找文件的命令行工具「我使用 &lt;a href=&#34;https://github.com/sharkdp/fd&#34;&gt;fd&lt;/a&gt;」。注意：对原始命令添加一些参数应该在这个环境变量里面添加&lt;/p&gt;

&lt;p&gt;比如说我们一般都会查找文件 &lt;code&gt;-type f&lt;/code&gt;，通常会忽略一些文件夹/目录 &lt;code&gt;--exclude=...&lt;/code&gt;，下面是我的变量值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export FZF_DEFAULT_COMMAND=&amp;quot;fd --exclude={.git,.idea,.vscode,.sass-cache,node_modules,build} --type f&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;界面展示-fzf-default-opts&#34;&gt;界面展示 FZF_DEFAULT_OPTS&lt;/h3&gt;

&lt;p&gt;界面展示这些参数在 &lt;code&gt;fzf --help&lt;/code&gt; 中都有，按需配置即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export FZF_DEFAULT_OPTS=&amp;quot;--height 40% --layout=reverse --preview &#39;(highlight -O ansi {} || cat {}) 2&amp;gt; /dev/null | head -500&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;界面配置参数加上后就漂亮多了
&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t24178/228/1983729650/93496/412c5c52/5b6fd697N0d686b66.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t24178/228/1983729650/93496/412c5c52/5b6fd697N0d686b66.png&#34; alt=&#34;fzf-with-preview&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--preview&lt;/code&gt; 表示在右侧显示文件的预览界面，语法高亮的设置使用了 &lt;a href=&#34;http://www.andre-simon.de/doku/highlight/en/highlight.php&#34;&gt;highlight&lt;/a&gt; 如果 highlight 失败则使用最常见的 &lt;code&gt;cat&lt;/code&gt; 命令来查看文件内容&lt;/p&gt;

&lt;p&gt;highlight 安装可能会有个小插曲。highlight 需要手动编译安装，默认安装目录在 &lt;code&gt;/usr/bin&lt;/code&gt;, &lt;code&gt;/usr/share&lt;/code&gt; 下面。然而在 macOS 中由于 &lt;abbr title=&#34;System Integrity Protection&#34;&gt;SIP&lt;/abbr&gt; 保护，用户安装的程序不能在这几个目录下面「即使有 sudo 权限也不行」。我们可以手动更改下 highlight 源代码中 makefile 中的参数即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;# PREFIX = /usr
PREFIX = /usr/local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将 &lt;code&gt;PREFIX = /usr&lt;/code&gt; 改成 &lt;code&gt;PREFIX = /usr/local&lt;/code&gt;，然后 &lt;code&gt;make&lt;/code&gt;，&lt;code&gt;sudo make install&lt;/code&gt; 就可以了&lt;/p&gt;

&lt;h3 id=&#34;触发命令行补全-fzf-completion-trigger&#34;&gt;触发命令行补全 FZF_COMPLETION_TRIGGER&lt;/h3&gt;

&lt;p&gt;默认是 &lt;code&gt;**&lt;/code&gt;，一般不用修改&lt;/p&gt;

&lt;h2 id=&#34;vim-fzf-插件&#34;&gt;VIM fzf 插件&lt;/h2&gt;

&lt;p&gt;如果你使用 vim，那么官方提供的插件会让你的 vim 使用更加流畅&lt;/p&gt;

&lt;h3 id=&#34;安装插件&#34;&gt;安装插件&lt;/h3&gt;

&lt;p&gt;如果你本地安装过 fzf 命令行工具了，只需要在 .vimrc 里面添加下面两个插件配置即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Plug &#39;/usr/local/opt/fzf&#39;
Plug &#39;junegunn/fzf.vim&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：使用了 &lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;vim-plug&lt;/a&gt; 插件管理&lt;/p&gt;

&lt;p&gt;插件主要对 fzf 集成绑定了一些和 vim 相关的功能，比如：查找当前 Buffer、Tag、Marks。甚至切换 window 更换 vim 主题配色等&lt;/p&gt;

&lt;p&gt;命令模式下敲 &lt;code&gt;Files&lt;/code&gt; 即可选择当前目录下所有文件，&lt;code&gt;Buffers&lt;/code&gt; 可以过滤当前所有 vim buffer 内容&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t25240/349/434572567/558564/433c151a/5b6fdfadNfd6ea407.gif&#34; alt=&#34;fzf-vim-plugin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再配置几个常用快捷键就可以直接取代 CtrlP 插件了 🤔&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ctrl + p 查看文件列表&lt;/li&gt;
&lt;li&gt;Ctrl + e 查看当前 Buffer，两次 Ctrl + e 快速切换上次打开的 Buffer&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;nmap &amp;lt;C-p&amp;gt; :Files&amp;lt;CR&amp;gt;
nmap &amp;lt;C-e&amp;gt; :Buffers&amp;lt;CR&amp;gt;
let g:fzf_action = { &#39;ctrl-e&#39;: &#39;edit&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;当然 fzf 还可以在很多其它场景下用来。如果你想使用可视化的列表选择而不是咣咣敲命令，那就自己搭配一些组合来使用吧&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jQuery ajax 方法 data 参数默认 encode 失败的 bug</title>
      <link>https://keelii.com/2018/05/25/jquery-ajax-data-param-auto-encode-bug/</link>
      <pubDate>Fri, 25 May 2018 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2018/05/25/jquery-ajax-data-param-auto-encode-bug/</guid>
      <description>&lt;p&gt;使用 jQuery ajax 方法调用异步接口时 data 参数默认会被添加转码 &lt;code&gt;encodeURIComponent&lt;/code&gt;，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$.ajax({
    url: &#39;http://your.domain.com/action&#39;,
    dataType: &#39;jsonp&#39;,
    data: {
        spaces: &#39;a b&#39;,
        other: &#39;&amp;amp;&#39;
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码会向 &lt;code&gt;http://your.domain.com/action?spaces=a+b&amp;amp;other=%26&lt;/code&gt; 发送 get 请求，奇怪的是参数中的 &lt;code&gt;&amp;amp;&lt;/code&gt; 被正确转码成 &lt;code&gt;%26&lt;/code&gt;，但是  被转成了 &lt;code&gt;+&lt;/code&gt; 而不是 &lt;code&gt;%20&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;看看正确的转码结果长啥样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;encodeURIComponent(&#39;&amp;amp;&#39;) // =&amp;gt; &amp;quot;%26&amp;quot;
encodeURIComponent(&#39; &#39;) // =&amp;gt; &amp;quot;%20&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然 data 参数里面的 key,value 都要被 encodeURIComponent，那么出现这种情况只能去查 jQuery 源代码了。jQuery 会调用 $.param 方法来编码 data 参数，大概在 &lt;strong&gt;jQuery-1.7.2&lt;/strong&gt; 的 &lt;em&gt;(7736)&lt;/em&gt; 行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;param: function( a, traditional ) {
    // ...
    } else {
        // If traditional, encode the &amp;quot;old&amp;quot; way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for ( var prefix in a ) {
            buildParams( prefix, a[ prefix ], traditional, add );
        }
    }

    // Return the resulting serialization
    return s.join( &amp;quot;&amp;amp;&amp;quot; ).replace( r20, &amp;quot;+&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;param 方法内部会再调用 &lt;code&gt;buildParams&lt;/code&gt; 来把 data 对象键值对添加编码，一切都很正常&lt;/p&gt;

&lt;p&gt;然饿最后一行 &lt;code&gt;replace( r20, &amp;quot;+&amp;quot; )&lt;/code&gt; 是什么鬼！&lt;code&gt;r20&lt;/code&gt; 变量是内部的一个空白转义符的正则 &lt;code&gt;/%20/g&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这就有点意思了，为啥把正确的空格编码再转回 &lt;code&gt;+&lt;/code&gt; 呢？&lt;/p&gt;

&lt;p&gt;外事不决问 Google，搜索 &lt;code&gt;why jquery ajax convert %20 to +&lt;/code&gt; 结果发现有一条 jQuery 官方的 github issue: &lt;a href=&#34;https://github.com/jquery/jquery/issues/2658&#34;&gt;Only change %20 to + for application/x-www-form-urlencoded&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t20344/242/259059096/183424/9e8e0f30/5b078bbdN06c75a01.png&#34; alt=&#34;google-why-jquery-convert-space-to-plus&#34; /&gt;&lt;/p&gt;

&lt;p&gt;根据 issue 的描述大意是说 &lt;code&gt;convert %20 to +&lt;/code&gt; 这个逻辑只应该在 POST 请求的时候做转换，而不是所有请求。我们的示例中的 jsonp 刚好是 get 请求&lt;/p&gt;

&lt;p&gt;继续往下看找到了一个 &lt;a href=&#34;https://github.com/dmethvin/jquery/commit/60453ce299a0c84550e70010ceea12d538226bf5&#34;&gt;commit(60453ce)&lt;/a&gt; 修复了这个问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img14.360buyimg.com/devfe/jfs/t20692/166/263146843/79735/7f45adb2/5b078b49N8f97629d.png&#34; alt=&#34;jquery-param-encode-bug&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意一点，我们并不能简单的在 data 对象传入的时候手动添加 &lt;code&gt;encodeURIComponent&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$.ajax({
    url: &#39;http://your.domain.com/action&#39;,
    dataType: &#39;jsonp&#39;,
    data: {
        // 错误的做法
        spaces: encodeURIComponent(&#39;a b&#39;),
        other: &#39;&amp;amp;&#39;
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 spaces 参数有别的应该被正常编码的字符串，这样会导致正常的被编码的字符被 &lt;strong&gt;两次&lt;/strong&gt; encodeURIComponent。所以要正确解决这个问题需要修改 jQuery 源代码，这个可以参考上面的那个 fix commit&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>又双叒叕写了一个 host 管理插件</title>
      <link>https://keelii.com/2017/11/07/yet-another-host-manager-plugin/</link>
      <pubDate>Tue, 07 Nov 2017 12:51:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/11/07/yet-another-host-manager-plugin/</guid>
      <description>

&lt;p&gt;切 host 对于平常开发来说再正常不过了，可是「切 host 难」的问题一直没解决，因为手动修改 host 文件会有很多（系统dns、浏览器）缓存问题。经常听到xx说「我这是好的呀，你 host 有问题吧&amp;hellip;」&lt;/p&gt;

&lt;p&gt;在 windows 下我一直使用 fiddler 来切换 host，很多人可能不知道这个功能。他的实现本质就是实用代理映射来实现 host 切换。这样的欢最大的优点就是 &lt;strong&gt;无延迟，秒切 host&lt;/strong&gt; 这个体验就非常赞，而且是系统级别的，也就是说别的浏览器里面也适用（前提是浏览器代理设置为系统）&lt;/p&gt;

&lt;p&gt;然后由于最近切换到 mac 开发环境，发现 mac 下面的解决方案都不是很完美，或者说不适合我的要求。无外乎以下几种：&lt;/p&gt;

&lt;h2 id=&#34;物理修改-host-文件&#34;&gt;物理修改 host 文件&lt;/h2&gt;

&lt;p&gt;像 iHosts, Switchhosts 这类，但据我所知这种方法都有延迟&lt;/p&gt;

&lt;h2 id=&#34;抓包工具代理切-host&#34;&gt;抓包工具代理切 host&lt;/h2&gt;

&lt;p&gt;比如 mac 下的 Wireshark、Charles，这些工具据说很强大，可是我自己用不惯，而且我是需求也很小，杀鸡焉用牛刀。fiddler for mac 虽然也能跑起来，但是体验太差了，界面卡的要死&lt;/p&gt;

&lt;h2 id=&#34;浏览器插件代理切-host&#34;&gt;浏览器插件代理切 host&lt;/h2&gt;

&lt;p&gt;像 Chrome 下的 Chrome-host-switch、 Switch host plus 等，试用了下效果很理想。美中不足的是体验不好，只有标签没有分组，把标签当分组切的人很蛋疼&lt;/p&gt;

&lt;p&gt;简单看了下 switch host plus 的实现方式，再加上自己之前也写过 chrome 插件就决定自己造个轮子。Chrome 插件基于html、css、javascript 自然很适合前端来做&lt;/p&gt;

&lt;p&gt;由于最近在看 react 相关的东西，刚好拿来练练手。技术选型基本上都是现成的框架拿来用就行了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;react &amp;amp; redux 构建整体应用&lt;/li&gt;
&lt;li&gt;bulma.css 简洁小巧的 CSS 框架&lt;/li&gt;
&lt;li&gt;localStorage 数据直接写本地存储&lt;/li&gt;
&lt;li&gt;create react app 构建打包应用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;应用截图&#34;&gt;应用截图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t11611/80/1444685331/28555/590b5dfa/5a013f0aN19565830.png&#34; alt=&#34;ahm-640x440&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t11845/332/1453803626/635686/c8e4f98/5a013fe8N41db44e3.png&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t11845/332/1453803626/635686/c8e4f98/5a013fe8N41db44e3.png&#34; alt=&#34;ahm-1280x800&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;功能&#34;&gt;功能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;秒切 host 无延迟 😎&lt;/li&gt;
&lt;li&gt;基于 chrome 代理 ❤️&lt;/li&gt;
&lt;li&gt;兼容 socket 代理 🤔&lt;/li&gt;
&lt;li&gt;简洁好用，无多余功能 👏&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/awesome-host-manager/pikaoeecieigblebdddckmlegonlogha?hl=zh-CN&#34;&gt;Chrome 应用商店&lt;/a&gt;（建议）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/keelii/awesome-host-manager/master/awesome-host-manager.crx&#34;&gt;下载 .crx 文件&lt;/a&gt; chrome 中打开 chrome://extensions/ 将.crx 文件托进安装即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;h4 id=&#34;host-proxy&#34;&gt;Host proxy&lt;/h4&gt;

&lt;p&gt;和 host 文件规则一致&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;192.168.100.1 your.domain.com your-anther.domain.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;socket-proxy&#34;&gt;Socket proxy&lt;/h4&gt;

&lt;p&gt;新建分组加入以下规则（按自己实际情况修改）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOCKS5 127.0.0.1:1080
SOCKS 127.0.0.1:1080
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;源代码&#34;&gt;源代码&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/keelii/awesome-host-manager&#34;&gt;Github&lt;/a&gt;(MIT)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解决 seajs parseDependencies 方法引起的依赖解析错误问题</title>
      <link>https://keelii.com/2017/11/03/fix-seajs-parse-dep-bug/</link>
      <pubDate>Fri, 03 Nov 2017 15:51:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/11/03/fix-seajs-parse-dep-bug/</guid>
      <description>&lt;p&gt;使用 seajs 的过程中偶尔会发现 require 进来的模块甚至都没有加载。查看源代码之后发现 seajs 是通过正则表达式匹配出了模块 factory 中的 require 路径&lt;/p&gt;

&lt;p&gt;正常情况下，下面这个模块里面 require 的外部模块会解析出依赖 &lt;code&gt;GLOBAL_ROOT/base/cookie&lt;/code&gt; 和 &lt;code&gt;GLOBAL_ROOT/base/utils&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;define(&#39;moduleName&#39;, function() {
    var a = require(&#39;GLOBAL_ROOT/base/cookie&#39;)
    var b = require(&#39;GLOBAL_ROOT/base/utils&#39;)
    // 正常情况 a 应该是个对象，
    console.log(a)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果 cookie 模块加载失败，a 就会返回 null 这时候再调 a 上面的方法就会报错。当 seajs 内部解析依赖时发生了错误时就会出现这种情况，由于我们使用的是比较老的 seajs 版本（2.2.0），去查看源代码发现 parseDependencies 方法使用了一个正则表达式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var REQUIRE_RE = /&amp;quot;(?:\\&amp;quot;|[^&amp;quot;])*&amp;quot;|&#39;(?:\\&#39;|[^&#39;])*&#39;|\/\*[\S\s]*?\*\/|\/(?:\\\/|[^\/\r\n])+\/(?=[^\/])|\/\/.*|\.\s*require|(?:^|[^$])\brequire\s*\(\s*([&amp;quot;&#39;])(.+?)\1\s*\)/g
var SLASH_RE = /\\\\/g

function parseDependencies(code) {
  var ret = []

  code.replace(SLASH_RE, &amp;quot;&amp;quot;)
      .replace(REQUIRE_RE, function(m, m1, m2) {
        if (m2) {
          ret.push(m2)
        }
      })

  return ret
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在控制台里面跑一下看看结果，上面的模块解析正确：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t11401/113/1005903134/64122/b08677b9/59fc23d6N998f2848.png&#34; alt=&#34;seajs-works-well&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是我自己的场景并没有这么简单，我贴上自己的代码时就异常了，由于源码比较多我就放到 jsbin 上了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jsbin.com/bowazakosu/edit?html,js,console,output&#34;&gt;压缩成一行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jsbin.com/likonikoye/edit?html,js,console,output&#34;&gt;格式化压缩代码后&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有意思的地方就在于 压缩成一行 的代码中是异常的，但是当我把代码格式化后就正常了？！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;seajs 3.x 版本以后 &lt;a href=&#34;https://github.com/seajs/seajs/blob/3.0.0/src/util-deps.js&#34;&gt;util-deps.js&lt;/a&gt; 引入了一个依赖解析器方法，直接用这个替代原来的即可。至于为什么那个正则对于压缩后的代码没起作用我暂还没详细研究，不过感觉像获取模块依赖关系这种静态分析任务还是用解析器靠谱点，正则有太多的不确定性，虽然它能节省很多代码&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>macOS Sierra 开发环境配置指南</title>
      <link>https://keelii.com/2017/10/07/macos-development-setup-guide/</link>
      <pubDate>Sat, 07 Oct 2017 17:19:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/10/07/macos-development-setup-guide/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文来自于我自己配置两台 macOS 开发环境的过程，主要记录一些常用的配置技巧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;系统设置&#34;&gt;系统设置&lt;/h2&gt;

&lt;h3 id=&#34;更改计算机名称&#34;&gt;更改计算机名称&lt;/h3&gt;

&lt;p&gt;macOS 默认的计算机名称「xx的xx」，我一般会把这个名字改成英文，在命令行中看起来会漂亮一点。修改 &lt;code&gt;系统设置-共享-电脑名称&lt;/code&gt; 即可&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t9919/194/838196844/87087/80259170/59d8e3f4N4277172a.png&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t9919/194/838196844/87087/80259170/59d8e3f4N4277172a.png&#34; alt=&#34;computer-name&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;触控板&#34;&gt;触控板&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;设置轻点触控板为鼠标点击&lt;/li&gt;
&lt;li&gt;设置三指拖动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t10129/124/847447368/253995/96574062/59d8e534Nc3e40d9f.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t10129/124/847447368/253995/96574062/59d8e534Nc3e40d9f.png&#34; alt=&#34;tap-click&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://img10.360buyimg.com/devfe/jfs/t10396/219/830021333/98488/bcc6e984/59d8e43cN04d84771.png&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t10396/219/830021333/98488/bcc6e984/59d8e43cN04d84771.png&#34; alt=&#34;drag-drop&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;finder&#34;&gt;Finder&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;开启新 Fidder 窗口时打开 &lt;code&gt;桌面&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行搜索时 &lt;code&gt;搜索当前文件夹&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;显示所有文件扩展名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t9571/278/833569016/71935/221e5956/59d8e45dN67661921.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t9571/278/833569016/71935/221e5956/59d8e45dN67661921.png&#34; alt=&#34;finder&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;其它&#34;&gt;其它&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;系统偏好设置-键盘-输入法-自动切换到文稿输入法&lt;/code&gt; 应用切换的时候会保持原来的输入法不变&lt;/li&gt;
&lt;li&gt;&lt;code&gt;桌面空白处右键-排序方式-贴紧网格&lt;/code&gt; 右键整理图标的时候就会按网格排列&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;开发环境设置&#34;&gt;开发环境设置&lt;/h2&gt;

&lt;h3 id=&#34;安装-command-line-tools&#34;&gt;安装 Command line tools&lt;/h3&gt;

&lt;p&gt;方便后续编译安装其它应用&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t9601/44/840280004/58067/a2e0aa5e/59d8e496N2cdf9cca.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t9601/44/840280004/58067/a2e0aa5e/59d8e496N2cdf9cca.png&#34; alt=&#34;xcode-select&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;xcode-select --install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-brew&#34;&gt;安装 brew&lt;/h3&gt;

&lt;p&gt;一般命令行的工具，或者开发环境包都用 &lt;a href=&#34;https://brew.sh/&#34;&gt;brew&lt;/a&gt; 来安装。GUI 的应用直接去网站下载安装包即可，App Store 我一般用来购买安装一些收费软件&lt;/p&gt;

&lt;p&gt;打开命令行执行下面的命令来安装 brew&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面的命令替换 brew 源为&lt;a href=&#34;https://lug.ustc.edu.cn/wiki/mirrors/help/brew.git&#34;&gt;中科大镜像&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 替换brew.git:
cd &amp;quot;$(brew --repo)&amp;quot;
git remote set-url origin https://mirrors.ustc.edu.cn/brew.git

# 替换homebrew-core.git:
cd &amp;quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;quot;
git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 brew 安装下载源码包有时是用 curl 的，所以可以配置下 curl 来走 &lt;em&gt;番习习墙&lt;/em&gt; 代理，我一般在配置文件中设置 &lt;code&gt;vim ~/.curlrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;socks5 = &amp;quot;127.0.0.1:1080&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-zsh-oh-my-zsh&#34;&gt;安装 Zsh &amp;amp; oh-my-zsh&lt;/h3&gt;

&lt;p&gt;Zsh 是一种 &lt;a href=&#34;https://zh.wikipedia.org/wiki/Unix_shell&#34;&gt;shell&lt;/a&gt;，功能和 bash, csh 一样，用来和操作系统交互&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装 zsh
brew install zsh
# 安装 oh-my-zsh 插件
# 更换默认 shell 为 zsh
chsh -s /bin/zsh
sh -c &amp;quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功的话会有下面的提示&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t10303/164/828630186/232717/e8624f08/59d8e4d7N2c9b44f6.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t10303/164/828630186/232717/e8624f08/59d8e4d7N2c9b44f6.png&#34; alt=&#34;ohmyzsh&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装自动补全提示插件 &lt;a href=&#34;https://github.com/zsh-users/zsh-autosuggestions&#34;&gt;zsh-autosuggestions&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions
source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://img30.360buyimg.com/devfe/jfs/t10564/347/828202786/16788/8bd58613/59d8e50cN2ef8aa62.gif&#34;&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t10564/347/828202786/16788/8bd58613/59d8e50cN2ef8aa62.gif&#34; alt=&#34;zsh-autosuggestions&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装-配置-iterm2&#34;&gt;安装/配置 iTerm2&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.iterm2.com/&#34;&gt;下载&lt;/a&gt; 并安装，打开 Preferences 偏好设置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;General&lt;/code&gt; 关闭 &lt;code&gt;Native full screen windows&lt;/code&gt; 我不使用系统的全屏（因为有过渡动画），是为了使用全局快捷键 &lt;strong&gt;立即&lt;/strong&gt; 调出命令行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Profiles-Window-Transparency&lt;/code&gt; 设置透明度 10%~20% 即可，太高会和桌面背景冲突。如果需要临时禁用透明度可以使用快捷键 &lt;code&gt;⌘+u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Keys-Hotkey&lt;/code&gt; 设置全局显示隐藏快捷键 系统级别的快捷键设置为 &lt;code&gt;⌘+\&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;最佳实践，启动 iTerm2 后按 &lt;code&gt;⌘+enter&lt;/code&gt; 全屏，然后 &lt;code&gt;⌘+\&lt;/code&gt; 隐藏它，这时候就可以做别的事情去了。任何时间想再用 iTerm2 只需要按 &lt;code&gt;⌘+\&lt;/code&gt; 即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;brew-常用工具&#34;&gt;brew 常用工具&lt;/h3&gt;

&lt;p&gt;下面这些都是用 brew 安装的，即 &lt;code&gt;brew install xxx&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;htop&#34;&gt;htop&lt;/h4&gt;

&lt;p&gt;用来查看当前运行的程序，top 命令的升级版&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t10783/119/847515894/438295/9e4709ce/59d8e566N62c288f9.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t10783/119/847515894/438295/9e4709ce/59d8e566N62c288f9.png&#34; alt=&#34;htop&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;tree&#34;&gt;tree&lt;/h4&gt;

&lt;p&gt;显示文件为树形菜单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  keelii.github.io tree . -L 2
.
├── config.toml
├── content
│   ├── about
│   └── archives
├── deploy.sh
├── public
│   ├── 2016
...
│   └── tags
└── themes
    └── octo-enhance

17 directories, 8 files
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;httpie&#34;&gt;httpie&lt;/h4&gt;

&lt;p&gt;使用比 curl 简单多了，而且还有一些代码高亮的效果&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img13.360buyimg.com/devfe/jfs/t9175/233/2384082355/52554/472f733/59d8e58fN956a159a.png&#34;&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t9175/233/2384082355/52554/472f733/59d8e58fN956a159a.png&#34; alt=&#34;httpie&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;vim&#34;&gt;vim&lt;/h4&gt;

&lt;p&gt;安装 vim 添加一些默认的模块和编程语言支持 cscope, lua, python 并且覆盖系统默认的 vim&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install vim --HEAD --with-cscope --with-lua --with-override-system-vim --with-luajit --with-python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 vim-plug&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;autojump&#34;&gt;autojump&lt;/h4&gt;

&lt;p&gt;方便在命令行中快速跳转目录，安装后程序会读取你 cd 过的目录并存起来，方便后面用快捷方式调用，支持模糊匹配。&lt;strong&gt;注意: autojump 只会记录安装后使用 cd 命令进入过的目录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//img10.360buyimg.com/devfe/jfs/t10066/212/961703883/22512/ed0565/59dae741N3fcc655c.gif&#34;&gt;&lt;img src=&#34;//img10.360buyimg.com/devfe/jfs/t10066/212/961703883/22512/ed0565/59dae741N3fcc655c.gif&#34; alt=&#34;autojump&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;yarn&#34;&gt;yarn&lt;/h4&gt;

&lt;p&gt;npm 的替代品，Production Ready。如果系统中安装过 node，就使用 &lt;code&gt;yarn --without-node&lt;/code&gt; 命令只安装 yarn 工具&lt;/p&gt;

&lt;h3 id=&#34;安装-python-pip&#34;&gt;安装 python pip&lt;/h3&gt;

&lt;p&gt;下载 &lt;a href=&#34;https://bootstrap.pypa.io/get-pip.py&#34;&gt;get-pip.py&lt;/a&gt; 在命令行中使用 python 运行这个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo python get-pip.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;更改各种程序语言包源&#34;&gt;更改各种程序语言包源&lt;/h3&gt;

&lt;h4 id=&#34;ruby-gemrc&#34;&gt;ruby - .gemrc&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/
gem sources -l
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat ~/.gemrc
---
:backtrace: false
:bulk_threshold: 1000
:sources:
- https://mirrors.tuna.tsinghua.edu.cn/rubygems/
:update_sources: true
:verbose: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;node-yarnrc-npmrc&#34;&gt;node - .yarnrc/.npmrc&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat ~/.yarnrc
registry &amp;quot;https://registry.npm.taobao.org&amp;quot;
disturl &amp;quot;https://npm.taobao.org/dist&amp;quot;
electron_mirror &amp;quot;http://cdn.npm.taobao.org/dist/electron/&amp;quot;
node_inspector_cdnurl &amp;quot;https://npm.taobao.org/mirrors/node-inspector&amp;quot;
sass_binary_site &amp;quot;http://cdn.npm.taobao.org/dist/node-sass&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dotfiles-配置文件&#34;&gt;dotfiles 配置文件&lt;/h3&gt;

&lt;p&gt;可以参照我的 &lt;a href=&#34;https://github.com/keelii/dotfiles&#34;&gt;dotfiles&lt;/a&gt; 配置文件&lt;/p&gt;

&lt;h3 id=&#34;其它-gui-应用&#34;&gt;其它 GUI 应用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.alfredapp.com/&#34;&gt;Alfred&lt;/a&gt; 程序启动器&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://theunarchiver.com/&#34;&gt;The Unarchiver&lt;/a&gt; ⇒ 解压工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/magnet/id441258766?mt=12&#34;&gt;Magent&lt;/a&gt; ⇒ 排列窗口（付费）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mowglii.com/itsycal/&#34;&gt;Itsycal&lt;/a&gt; ⇒ 简洁版日历&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href=&#34;http://snip.qq.com/&#34;&gt;Snip&lt;/a&gt; ⇒ 屏幕截图&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href=&#34;http://snappy-app.com/&#34;&gt;Snappy&lt;/a&gt; ⇒ 屏幕截图、修改分享&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.snipaste.com/&#34;&gt;Snipaste&lt;/a&gt; ⇒ 更好用的屏幕截图&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pasteapp.me/&#34;&gt;Paste&lt;/a&gt; 剪贴板管理工具（付费）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://typora.io/&#34;&gt;Typora&lt;/a&gt; 正确的使用 markdown 写文档笔记等&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pqrs.org/osx/karabiner/&#34;&gt;Karabiner-Elements&lt;/a&gt; ⇒ 改键器, 改键方案参照&lt;a href=&#34;https://keelii.com/2017/10/03/how-to-map-single-command-key-on-mac/&#34;&gt;上篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://freemacsoft.net/appcleaner/&#34;&gt;AppCleaner 2&lt;/a&gt; ⇒ 卸载应用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cockos.com/licecap/&#34;&gt;licecap for mac&lt;/a&gt; ⇒ 录制 gif 图片&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zipzapmac.com/go2shell&#34;&gt;Go2shell&lt;/a&gt; ⇒ Finder 当前目录打开命令行&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>macOS 单独设置 command(⌘) 键点击功能</title>
      <link>https://keelii.com/2017/10/03/how-to-map-single-command-key-on-mac/</link>
      <pubDate>Tue, 03 Oct 2017 17:10:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/10/03/how-to-map-single-command-key-on-mac/</guid>
      <description>&lt;p&gt;由于最近全面切换工作环境到 Mac 上，快捷键基本上成了适应期的最大问题&lt;/p&gt;

&lt;p&gt;传统意义上像 &lt;code&gt;Ctrl, Alt, Shift, Win, Option, Command&lt;/code&gt; 都属于 &lt;code&gt;修饰键&lt;/code&gt;，只能和其它键配合使用才可以（Ctrl+c,Ctrl+v），单独敲击并没有效果&lt;/p&gt;

&lt;p&gt;但是 Win 键在 Windows 中被赋予了更多的功能，下面这几个系统级别的快捷键用起来是非常方便的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Win + E&lt;/code&gt; ⇒ 打开资源管理器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Win + D&lt;/code&gt; ⇒ 显示桌面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Win + L&lt;/code&gt; ⇒ 锁定计算机&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前使用过 Windows 和 Ubuntu gnome，特别方便的一点就是 super(Win) 键 &lt;strong&gt;不仅&lt;/strong&gt; 可以做为修饰键和其它键组合使用，而且还可以响应 &lt;strong&gt;单独的&lt;/strong&gt; 点击事件，Windows 中点击 Win 键会全局呼出 &lt;em&gt;开始菜单&lt;/em&gt; 方便我们 &lt;em&gt;查找/打开&lt;/em&gt; 应用。这样的话单独点击相当于可以少按一个按键，切找应用什么的非常快&lt;/p&gt;

&lt;p&gt;Mac 中我通常使用 Spotlight 来快速切换程序。用惯了 Mac 的人会觉得 command 键位非常舒服好按（键位原因），这时候我希望尽可能把常用的键组织到 command 上又 &lt;strong&gt;不影响&lt;/strong&gt; 原来的组合键，比如我有下面两个最常使用的快捷键：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘&lt;/code&gt; ⇒ 呼出 Spotlight&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ + Space&lt;/code&gt; ⇒ 切换输入法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而 Mac 系统中并不允许我们这么做 🤔，于是我使用了一个改键器 &lt;a href=&#34;https://pqrs.org/osx/karabiner/&#34;&gt;Karabiner&lt;/a&gt; 😎&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t9160/329/2610957899/117091/8481138f/59d34e67Nb3bd2a2d.png&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t9160/329/2610957899/117091/8481138f/59d34e67Nb3bd2a2d.png&#34; alt=&#34;mac-karabiner&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我的配置方法是使用 &lt;code&gt;Complex Modifications&lt;/code&gt; 因为它允许我把修饰键改成其它按钮功能。在这里我将其改为一个没用的键位（f13 - PrtSc），因为 Spotlight 不接受单独的修饰键，所以只能这样区线救国了&lt;/p&gt;

&lt;p&gt;然后在系统偏好设置 - 键盘 - 快捷键 中将 Spotlight 设置成 F13&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img12.360buyimg.com/devfe/jfs/t9769/96/578527884/124966/ff1a2f04/59d34fbeN5b1e4775.png&#34;&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t9769/96/578527884/124966/ff1a2f04/59d34fbeN5b1e4775.png&#34; alt=&#34;mac-spotlight&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意：默认的 Complex Modifications 里面是空的，需要你手动导入一个叫 &lt;a href=&#34;https://pqrs.org/osx/karabiner/complex_modifications/#modifier_keys&#34;&gt;Tapping modifier-keys produces a f-key.&lt;/a&gt;。然后我们 &lt;code&gt;enable&lt;/code&gt; 这条：&lt;strong&gt;Press left_command alone produces F14&lt;/strong&gt;，噫~我们是要 map 成 F13 这里默认的是 F14，怎么改下呢。改配置文件吧，打开下面这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim ~/.config/karabiner/karabiner.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将里面的 F14 改成 F13 即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;// ...
&amp;quot;complex_modifications&amp;quot;: {
    &amp;quot;parameters&amp;quot;: {
        &amp;quot;basic.to_if_alone_timeout_milliseconds&amp;quot;: 600
    },
    &amp;quot;rules&amp;quot;: [
        {
            &amp;quot;description&amp;quot;: &amp;quot;Press left_command alone produces F14&amp;quot;,
            &amp;quot;manipulators&amp;quot;: [
                {
                    &amp;quot;from&amp;quot;: {
                        &amp;quot;key_code&amp;quot;: &amp;quot;left_command&amp;quot;,
                        &amp;quot;modifiers&amp;quot;: { &amp;quot;optional&amp;quot;: [ &amp;quot;any&amp;quot; ] }
                    },
                    &amp;quot;to&amp;quot;: [ { &amp;quot;key_code&amp;quot;: &amp;quot;left_command&amp;quot; } ],
                    &amp;quot;to_if_alone&amp;quot;: [ { &amp;quot;key_code&amp;quot;: &amp;quot;f14&amp;quot; } ],
                    &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;
                }
            ]
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样基本上的完成我的需求了，打开应用只需要按一次 ⌘ 即可呼出 Spotlight，像打开 Google Chrome 只需要两个键即可 &lt;code&gt;⌘ g&lt;/code&gt;、Webstorm &lt;code&gt;⌘ w&lt;/code&gt;、Firefox &lt;code&gt;⌘ f&lt;/code&gt; &amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;备注：我用的机器是 Mac mini 主机 + filco 87 键盘&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>jQuery data 方法的一个小特技</title>
      <link>https://keelii.com/2017/05/03/a-trick-from-jquery-data-method/</link>
      <pubDate>Wed, 03 May 2017 17:59:45 +0800</pubDate>
      
      <guid>https://keelii.com/2017/05/03/a-trick-from-jquery-data-method/</guid>
      <description>&lt;p&gt;通常我们在用 JavaScript 操作 DOM 元素的时候会往 DOM 上临时添加一些参数，用来记住一些状态，或者从后端取参数值等&lt;/p&gt;

&lt;p&gt;一般通过在 HTML 标签上添加自定义属性来实现，但是这样会不可避免的访问 DOM，性能上并不好。如果你使用 jQuery 的话建议使用 &lt;code&gt;$el.data()&lt;/code&gt; 方法来取元素上 &lt;code&gt;data-*&lt;/code&gt; 的值，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;demo&amp;quot; data-key=&amp;quot;value&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    $(&#39;#demo&#39;).attr(&#39;data-key&#39;)
    $(&#39;#demo&#39;).data(&#39;key&#39;)  // 第一次访问 DOM，以后从缓存取
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个方法的区别在于 attr 每次都会直接访问 DOM 元素，而 data 方法会缓存第一次的查找，后续调用不需要访问 DOM&lt;/p&gt;

&lt;p&gt;很明显建议使用后者，但是在 &lt;strong&gt;低版本的 jQuery&lt;/strong&gt; 中默认会对 data 方法取到的值进行粗暴的强制数据类型转换「parseFloat」。看下面代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;demo0&amp;quot; data-key=&amp;quot;abc&amp;quot;&amp;gt;字符串&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo1&amp;quot; data-key=&amp;quot;123&amp;quot;&amp;gt;数字&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo2&amp;quot; data-key=&amp;quot;123e456&amp;quot;&amp;gt;科学计数法&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo3&amp;quot; data-key=&amp;quot;0000123&amp;quot;&amp;gt;八进制数字&amp;lt;/div&amp;gt;
&amp;lt;script src=&amp;quot;jquery-1.6.4&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    $(&#39;#demo0&#39;).data(&#39;key&#39;)  // &amp;quot;abc&amp;quot;
    $(&#39;#demo1&#39;).data(&#39;key&#39;)  // 123
    $(&#39;#demo2&#39;).data(&#39;key&#39;)  // Infinity
    $(&#39;#demo3&#39;).data(&#39;key&#39;)  // 83
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面两种显然出错了，就是因为 jQuery 对属性值进行了强制 parseFloat 操作。这种转换是方便了使用者，如果是数字的话我们取到这个值进行计算什么的就不用再转数据类型了，但是一不小心就会出 bug&lt;/p&gt;

&lt;p&gt;发现这个 bug 的时候第一感觉是 jQuery 不应该没考虑到这一点呀。后来果断去查了下最新版的 jQuery 源代码，发现已经修复了。核心代码在 &lt;a href=&#34;https://github.com/jquery/jquery/blob/master/src/data.js#L36&#34;&gt;data.js 35 行&lt;/a&gt;，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getData( data ) {
    if ( data === &amp;quot;true&amp;quot; ) {
        return true;
    }

    if ( data === &amp;quot;false&amp;quot; ) {
        return false;
    }

    if ( data === &amp;quot;null&amp;quot; ) {
        return null;
    }

    // Only convert to a number if it doesn&#39;t change the string
    // 重点就在这里 →_→
    if ( data === +data + &amp;quot;&amp;quot; ) {
        return +data;
    }

    if ( rbrace.test( data ) ) {
        return JSON.parse( data );
    }

    return data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getData 方法就返回了节点属性的值，只不过加了一些特殊处理使得我们取到了没有 bug 的值，关键地方就在这里： &lt;code&gt;data === +data + &amp;quot;&amp;quot;&lt;/code&gt; 。这行代码做了些什么神奇的事情&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;将节点的属性值强制转换成数字「+data」后再转成字符串「+ &amp;ldquo;&amp;ldquo;」，如果转换后的值与原来相等就取转换后的值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以简单的这么理解：jQuery 会尝试转换数据类型，如果转换后和转换前的 &lt;strong&gt;长得一样&lt;/strong&gt; 那么 jQuery 就认为它是需要被转换成数字的。这样就可以完美规避上面例子中的两种问题，我们来测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var data = &#39;abc&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值

var data = &#39;123&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // true 转换，使用转换后的数字类型值

var data = &#39;123e456&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值

var data = &#39;0000123&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sublime text 3 配置 ESLint 代码检查</title>
      <link>https://keelii.com/2017/04/29/sublime-text-3-configure-eslint/</link>
      <pubDate>Sat, 29 Apr 2017 17:17:24 +0800</pubDate>
      
      <guid>https://keelii.com/2017/04/29/sublime-text-3-configure-eslint/</guid>
      <description>

&lt;h2 id=&#34;安装环境&#34;&gt;安装环境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Windows 7 SP1 企业版&lt;/li&gt;
&lt;li&gt;Sublime text 3 Build 3162&lt;/li&gt;
&lt;li&gt;Node.js v6.9.5&lt;/li&gt;
&lt;li&gt;Yarn 0.23.2 (可用 npm 代替)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装-eslint&#34;&gt;安装 ESLint&lt;/h2&gt;

&lt;p&gt;到你的项目根目录生成一个 package.json 文件，如果没有使用 &lt;code&gt;yarn init -y&lt;/code&gt; 来自动生成&lt;/p&gt;

&lt;p&gt;ESLint 默认的 parser 是 esprima，如果你需要检查 Babel 转义的 JSX 等文件那可以选择安装 &lt;a href=&#34;https://github.com/babel/babel-eslint&#34;&gt;babel-eslint&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yarn init -y
yarn global add eslint
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 sublime text 3 配置 eslint 来做代码检查&lt;/p&gt;

&lt;h2 id=&#34;安装-sublime-text-3-插件&#34;&gt;安装 Sublime text 3 插件&lt;/h2&gt;

&lt;h3 id=&#34;安装-sublime-linter-和-sublimelinter-contrib-eslint&#34;&gt;安装 Sublime​Linter 和 SublimeLinter-contrib-eslint&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://packagecontrol.io/packages/SublimeLinter&#34;&gt;Sublime​Linter&lt;/a&gt; 是一个代码检查框架插件，功能非常强大，支持各种语言的检查。但是它本身并没有代码检查的功能，需要借助 ESLint 这样的特定语言检查支持。我们只需要使用对应的 &lt;a href=&#34;https://packagecontrol.io/packages/SublimeLinter-contrib-eslint&#34;&gt;Sublime​Linter-contrib-eslint&lt;/a&gt; 插件即可&lt;/p&gt;

&lt;p&gt;在 Sublime text 中 &lt;code&gt;Ctrl + Shift + p &amp;gt; Package Control:Install Package&lt;/code&gt; 里面搜索关键词 &lt;code&gt;linter&lt;/code&gt;，&lt;strong&gt;注意&lt;/strong&gt;别选成了 SummitLinter。然后再搜索 &lt;code&gt;eslint&lt;/code&gt; 找到 SublimeLinter-contrib-eslint 安装（不得不吐槽下 Sublime package 搜索匹配让人无法理解）&lt;/p&gt;

&lt;h2 id=&#34;配置-eslint&#34;&gt;配置 ESLint&lt;/h2&gt;

&lt;p&gt;到项目根目录下面使用 eslint 命令交互式的生成配置文件。这里 ESLint 会让你确认项目的配置项目，包括代码风格、目标文件等。我一般选择 &lt;code&gt;Answer questions about your style&lt;/code&gt;，即通过选择性的回答命令行中的问题让 ESLint 生成适合我项目的配置文件&lt;/p&gt;

&lt;p&gt;生成的配置文件我一般选择 JavaScript 因为这样比较方便写注释。我的配置项大概如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;How would you like to configure ESLint?
Answer questions about your style
Are you using ECMAScript 6 features? No
Where will your code run? Browser
Do you use CommonJS? No
Do you use JSX? No
What style of indentation do you use? Spaces
What quotes do you use for strings? Single
What line endings do you use? Unix
Do you require semicolons? No
What format do you want your config file to be in? JavaScript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的配置文件竟然是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
    &amp;quot;env&amp;quot;: {
        &amp;quot;browser&amp;quot;: true
    },
    &amp;quot;extends&amp;quot;: &amp;quot;eslint:recommended&amp;quot;,
    &amp;quot;rules&amp;quot;: {
        &amp;quot;indent&amp;quot;: [
            &amp;quot;error&amp;quot;,
            4
        ],
        &amp;quot;linebreak-style&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;unix&amp;quot;
        ],
        &amp;quot;quotes&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;single&amp;quot;
        ],
        &amp;quot;semi&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;never&amp;quot;
        ]
    }
}; // Do you require semicolons? No !!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 &lt;code&gt;extends&lt;/code&gt; 设置成 &lt;code&gt;eslint:recommended&lt;/code&gt; 表示在 &lt;a href=&#34;http://eslint.org/docs/rules/&#34;&gt;ESLint 规则页面&lt;/a&gt; 中标记成 「✔」 的项都开启检测&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;打开项目中任意一个 JavaScript 文件，右键 &lt;code&gt;SublimeLint &amp;gt; Lint this view&lt;/code&gt; 来试试检查当前文件，如果有错误，编辑器会展示对应 Gutter 错误行和信息。可以使用 &lt;code&gt;SublimeLint &amp;gt; Show all errors&lt;/code&gt; 来查看所有的错误&lt;/p&gt;

&lt;p&gt;上个图吧&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img11.360buyimg.com/devfe/jfs/t4531/175/3699692200/112024/b747eb91/590466dcN6f0ad2ac.png&#34;&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t4531/175/3699692200/112024/b747eb91/590466dcN6f0ad2ac.png&#34; alt=&#34;sublimetext-eslint&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>