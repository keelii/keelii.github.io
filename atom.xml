<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>臨池不輟</title>
    <link>https://keelii.com/</link>
    <description>Recent content on 臨池不輟</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 06 Mar 2019 19:19:24 +0000</lastBuildDate>
    
        <atom:link href="https://keelii.com/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>开源一个自己写的代码画板</title>
      <link>https://keelii.com/2019/03/06/open-source-code-sketch/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:24 +0000</pubDate>
      
      <guid>https://keelii.com/2019/03/06/open-source-code-sketch/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://code-sketch.com/&#34;&gt;Code sketch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/keelii/code-sketch&#34;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/keelii/code-sketch/releases/download/v0.0.2/Code.Sketch-0.0.2.dmg&#34;&gt;下载 macOS 应用(.dmg)&lt;/a&gt;，基于 electron，不喜欢的也可以使用 &lt;a href=&#34;https://web.code-sketch.com/&#34;&gt;Web 版&lt;/a&gt; 但非全功能支持版&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码画板-code-sketch&#34;&gt;代码画板 Code Sketch&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;最初写代码的地方&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;功能&#34;&gt;功能&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;内置 Sass/Babel 支持&lt;/li&gt;
&lt;li&gt;HTML/CSS emmet 插件支持&lt;/li&gt;
&lt;li&gt;方便的导入三方库 (&lt;a href=&#34;https://www.bootcdn.cn/&#34;&gt;bootcdn&lt;/a&gt; API 支持).&lt;/li&gt;
&lt;li&gt;深色主题支持&lt;/li&gt;
&lt;li&gt;可以打印任意数据格式的控制台&lt;/li&gt;
&lt;li&gt;同时支持 &lt;a href=&#34;http://code-sketch.com&#34;&gt;macOS App&lt;/a&gt; 与 &lt;a href=&#34;http://web.code-sketch.com&#34;&gt;Web 端应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;快捷键&#34;&gt;快捷键&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;切换展示顶部页签: &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;代码字体大小: &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;+/-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;保存刷新: &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;导出到单个 HTML 文件: &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;shift&lt;/code&gt;+&lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;导入文件（仅支持展出文件）: &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;命令提示容器: &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;截图&#34;&gt;截图&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;浅色主题&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://code-sketch.com/image/code-sketch-light-theme.png&#34; alt=&#34;code-sketch-light&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;深色主题&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://code-sketch.com/image/code-sketch-dark-theme.png&#34; alt=&#34;code-sketch-dark&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;错误日志&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://code-sketch.com/image/code-sketch-error-log.png&#34; alt=&#34;log&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;控制台日志&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://code-sketch.com/image/code-sketch-console-log.png&#34; alt=&#34;error&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;开发&#34;&gt;开发&lt;/h3&gt;

&lt;p&gt;yarn or npm&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yarn install
yarn start
yarn dev
# build release for mac
yarn release
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;支持&#34;&gt;支持&lt;/h3&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>理解比平等更重要</title>
      <link>https://keelii.com/2019/01/06/empathy-is-better-than-equality/</link>
      <pubDate>Sun, 06 Jan 2019 19:29:27 +0000</pubDate>
      
      <guid>https://keelii.com/2019/01/06/empathy-is-better-than-equality/</guid>
      <description>&lt;p&gt;很早以前就想聊聊这个话题，但是一直没机会。昨天看完电影《无名之辈》后让我心里突然有了一点感想。这便记录下来&lt;/p&gt;

&lt;p&gt;这部片子的剧情围绕着几小人物之间展开。一心想做协警的保安、一辈子想出人头地的劫匪、一个遭遇了车祸身体瘫痪的女孩、一心只想赚钱娶媳妇过日子普通男人…&lt;/p&gt;

&lt;p&gt;这些角色在我们现实生活中实在是太普通了，而且都处在社会底层。每个人对背负着生活压力，每人个都过着悬崖勒马日子。为了生存和仅有的那点「并不远大的」理想坚持前行&lt;/p&gt;

&lt;p&gt;中间那段胡广生痛骂电视台恶搞他们抢劫的桥段，让我感触很深。电视上那些转微博、发视频娱乐的网友不就是我们自己么，我们经常在网站上看到一些匪夷所思的新闻：一个没有智商的劫匪，拿上一杆枪，跑到手机店里面去抢手机。抢完了才发现是手机模型。这个事情在普通人看来真的是荒诞极了，简直是搞笑，大家都来消费这种新闻。却没有人真的去思考劫匪为什么会做这么愚蠢的事情&lt;/p&gt;

&lt;p&gt;谁知道这个愚蠢的劫匪是一个没见过大世面的农村小伙，不识字，也没什么文化；一心想进城干大事，胸中充满了对生活的渴望。可是谁又知道他进城后遭受了些什么、被多少人排斥、鄙视。现实中处处碰壁，梦想被别人看的一文不值。这种落差感长久积存在心里，有一天终于爆发了，他开始报复社会，打架、抢劫&lt;/p&gt;

&lt;p&gt;胡广生在电视上看见网友的恶搞时情绪完全崩溃，他撕心裂肺的哭着骂到：「老子要是犯法、你抓老子啊，关老子，你枪毙老子，老子认帐啊，为啥要恶搞老子、侮辱老子」&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;他是多么强大，强大到不怕犯法被枪毙；他又多么可怜，可怜没人尊重他，没人理解他&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;我们总是在网络上看到很多人在讲平等。各种阶层，各种角色&lt;/p&gt;

&lt;p&gt;员工与老板的平等、父母和子女的平等、老师与学生的平等、女人和男人的平等、穷人与富人的平等。归结起来只有一种：&lt;strong&gt;强势者和弱势者的平等&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但是实际上强势者强的本质是与生俱来的：老板有权利的优势、父母/老师有地位的优势、男人有生理的优势、富人有家族的优势&lt;/p&gt;

&lt;p&gt;在这些角色之间要求平等是一件很「无理」的事情。举个简单的例子，人都是动物，都有动物的本性，一个高个子的人站在矮个子的人旁边，根本不用讲话，高个子的人会有一种原始的身体上的气势压迫感，矮个子的人会有原始的一种害怕与自我防卫的反应。当然人类是高级动物，人类可以通过语言、眼神的沟通来降低这种差异感。但是本质上讲这两种人的「不平等」是改变不了的，尤其是高个子的人，即使你有很好的修养、很高的受教育程度，这种与生俱来的东西也是没办法完全抹去的。事实上这两个人是没法平等的，你总不能要求别人和你长得一样高吧&lt;/p&gt;

&lt;p&gt;为什么现在很多人要求所谓平等。是因为「平等」这个词可以「量化」。你有的东西我也必须有，你能做的事情我也可以做。这种感觉就像是我们开发了一个复杂的系统，我们需要有一个能实时检测到异常的监控系统，因为监控系统可以量化一个系统的好坏，可以给出一个简单的评价标准。但是监控并不能解决系统本身的好坏问题。与其花费大量精力在监控上面，不如多花时间来了解系统的核心逻辑，各个个部件之间的关系。这样的话即使系统出了问题也是在可预测范围内，监控也只是锦上添花的一个部件&lt;/p&gt;

&lt;p&gt;回到主题上，那么为什么理解或者说*同理心*更重要呢。&lt;/p&gt;

&lt;p&gt;这要从人的情感说起，其实人类是一种非常奇怪的生物，个体之间的差异让你很难理解对方的一些情绪变化。很多人都觉得很了解自己（我也是），实际上并不是的。我就有个非常困扰自己的问题，每当我唱歌非常投入的时候，唱到那么两句伤感的歌词时七窍都会有反应，我自己有的时候也在想，实际上我唱的歌词可能和我境遇半毛钱关系都没有，怎么会有这种反应呢。后来慢慢的我就理解了，因为人和人是不一样的，我们彼此有不同的年龄、性别、生活经历，同时在情感方面人又非常的奇怪，可能有的人会因为一句诗词而哭泣，可能有人会因为一段音乐而哭泣，有的人会因为一张泛黄的照片而哭泣，不同的人有不同的感受周围世界的能力，你通过视觉，别人通过听觉嗅觉。同时这些东西被记忆在大脑内的时候是立体的，全方位的。可能就是某个动作触发到了深藏在大脑中的一幅画面，瞬间你就会想起当时的天气，人物、气氛等，然后立马产生了真情的流露。从这一点来看人的大脑比起计算机简直高得不知道到哪里去了&lt;/p&gt;

&lt;p&gt;以前我老看见电视上很多追星族，在演唱会上痛哭流涕，激动不已。我就很难理解，怎么会有这种人呢，真的是歌手唱的好听吗？可是一首歌又能有多好听呢。然后上大学时听了很多的摇滚乐，当时的状态就是：*我觉得年轻时不喜欢摇滚乐是有病吧*。到现在为止我也没去听过场摇滚演唱会，但是我可以想像到如果我去了，绝对也是和大部分人一样的那种摇头晃脑，疯狂呐喊，兴奋不已的状态。&lt;/p&gt;

&lt;p&gt;所以说，看到一些匪夷所思的事情的时候不要急于去评价，或者下结论。试着去理解一下对方的境遇，万一自已经说错话了那也不要紧，承认自己的错误其实并没有那么困难，可能在你看来很简单的一句话就会让对方感受到整个世界的温柔&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/15866/25/4364/88758/5c31d782Ed9a2fc0a/4efb1466c3229758.jpg&#34; alt=&#34;empathy&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图：&lt;a href=&#34;https://www.pexels.com/photo/photography-of-body-of-water-and-mountains-1544880/&#34;&gt;https://www.pexels.com/photo/photography-of-body-of-water-and-mountains-1544880/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>名不正则言不顺，是这样的吗？</title>
      <link>https://keelii.com/2019/01/01/political-correctness-then-freedom-of-speech/</link>
      <pubDate>Tue, 01 Jan 2019 19:29:27 +0000</pubDate>
      
      <guid>https://keelii.com/2019/01/01/political-correctness-then-freedom-of-speech/</guid>
      <description>&lt;p&gt;名正言顺这个成语大家都知道，尤其在一些政治典故中经常被提及。今天就来聊聊这个话题&lt;/p&gt;

&lt;p&gt;名正言顺的梗概出自于《论语·子路》中孔子和子路的一段对话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;子路曰：“卫君待子而为政，子将奚先？”&lt;/p&gt;

&lt;p&gt;子曰：“必也正名乎！”&lt;/p&gt;

&lt;p&gt;子路曰：“有是哉，子之迂也！奚其正？”&lt;/p&gt;

&lt;p&gt;子曰：“野哉由也！君子于其所不知，盖阙如也。&lt;strong&gt;名不正，则言不顺；言不顺，则事不成；事不成，则礼乐不兴；礼乐不兴，则刑罚不中；刑罚不中，则民无所措手足&lt;/strong&gt;。故君子名之必可言也，言之必可行也。君子于其言，无所苟而已矣。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大概意思是说：&lt;/p&gt;

&lt;p&gt;子路问孔子：“如果让你去卫国执政，你首先会做什么？”&lt;/p&gt;

&lt;p&gt;孔子说：“一定要先找对名份！”&lt;/p&gt;

&lt;p&gt;子路说：“是这样的吗？，你也太迂腐了吧，名份有什么用？”&lt;/p&gt;

&lt;p&gt;孔子说：“你太粗野了！君子对于不懂的事情，一般都采取保留意见。名分不正当，说话就不合理；说话不合理，事情就办不成。事情办不成，法律就不能深入人心；法律不能深入人心，刑罚就不会公正；刑罚不公正，老百姓就会手足无措…”&lt;/p&gt;

&lt;p&gt;正名的「名」就是名份的「名」。是古代官场政治制度下的一种阶级角色感，也是儒家思想核心部分 &lt;strong&gt;礼&lt;/strong&gt; 的角色感。如：君臣、父子、兄弟，各个角色应该做什么事情才是正确的，被提倡的&lt;/p&gt;

&lt;p&gt;比如说《八佾》中开篇第一段：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;孔子谓季氏：“八佾舞于庭，是可忍也，孰不可忍也？”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;意思是说这个季氏用天子的舞蹈阵容在自己家里开 Party。「佾yì」就是舞蹈队伍中的列，天子八列、诸侯六列、大夫四列、士二列，每佾八人。孔子要从政得先正名，正名就要先把礼放在第一位，没有礼的话就会成为君不君、臣不臣、父不父、子不子的状态，这种「八佾舞于庭」的行为在孔子看来就是大逆不道，绝不能忍的事情&lt;/p&gt;

&lt;p&gt;再如：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;定公问：“君使臣，臣事君，如之何？”孔子对曰：“君使臣以礼，臣事君以忠。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;意思是 定公问孔子：“上级怎样对待下级？下级怎样对待上级？”孔子答：“上级尊重下级，下级忠于上级。”&lt;/p&gt;

&lt;p&gt;其实古文是非常精炼的，有的句子我们根本不需要全部搞懂是什么意思，只看几个字眼儿就明白了，比如上面的：君 &lt;strong&gt;使&lt;/strong&gt; shǐ 臣，臣 &lt;strong&gt;事&lt;/strong&gt; shì 君。*使* 就是驱使、使唤；*事* 就是为人做事、服侍的意思。我觉得这句话问之前就有了定位，根本不需要再回答&lt;/p&gt;

&lt;p&gt;封建社会，人们对于名份的认同感处处可见。春秋时期的尊王攘夷，三国时期曹操奉天子以令不臣，刘备打江山也要号称汉景帝阁下玄孙，这些都是政治场上的所谓的正名&lt;/p&gt;

&lt;p&gt;当这种思想蔓延到整个现代社会甚至是家庭里面的时候就更值得思考了&lt;/p&gt;

&lt;p&gt;儒家思想中关于礼的部分我更倾向于认同它的角色感，这一点是古今通用的。现实生活中我们经常会有一种感觉：同样是一句话从某些人口中说出来就很合情合理，从另外一些人口中说出来则让人很难理解甚至气愤。就是因为中国人讲话是非常讲究角色和场合的&lt;/p&gt;

&lt;p&gt;比如说：我（男的）看见一对男女聊天儿，谈到关于生活、工作的话题时，如果这个女的说：男人的一生很不容易，因为他们的一生都注定了要竞争，为钱、为权为了家人过得更好，他们们身上背负着很重的担子。&lt;/p&gt;

&lt;p&gt;当我做为一个男的听到这段话的时候会觉得这话说的很好听，让人很舒服，同时也非常佩服女的身上的那种同理心。但如果这段话是从这个男的口中说出来的我只会觉得这男的矫情娘娘腔，甚至我会找很多理由来推翻他的观点&lt;/p&gt;

&lt;p&gt;在男权社会下女人本来就是弱视的，社会能给予她们的不论是精神上的还是物质上的回报都没有男性多，相反男性天生就获得了更多的优待和资源，所以男性理应肩负更多的责任。事实上女性的一生更不容易，大部分的女性的一生会受到社会舆论家庭伦理方面的影响，以至于她们很少有自己的事业，健立家庭以后通常还有更多身体和精神上的付出，这使得她们几乎没机会做自己想做的事情&lt;/p&gt;

&lt;p&gt;所以说这个角色非常重要，但问题是当你定义了自己是什么样的角色时，再去看问题，其实本来就是不客观的。最终可能会形成一种非黑即白的观点偏见&lt;/p&gt;

&lt;p&gt;当我们今天再去回顾名正言顺的典故时，会发现即就是当下社会，大家还是有很多古时候遗留下来的碎片化的认识，这种认识会让人只相信权威的或者大众的观点，这种所谓名份上正确的角色传达出来的观点&lt;/p&gt;

&lt;p&gt;社会上的名流、功成名就的人说出来的话就是可信的，匹夫布衣甚至都没有说话的权利。所以说名正言顺真的就是正确的吗？难道只有先正其名然后才能有话语权？就算是个小人物，他也有自己的人生境遇，也有喜怒哀乐。只要人家说话有理有据，那就理当受到尊重&lt;/p&gt;

&lt;p&gt;名正言顺事实上讲的是一种政治上的正确，在国外也有很多这方面的讨论，比如说：Code of conduct，它就给出了一系列的准则，诸如人与人之间基本尊重、宗教、人种、道义方面的一些准则。这些准则在大多数人眼里是正确的，但是应不应该强加到其它不认同这个准则的人身上呢，或者说人们可不可以对里面的一些准则进行反驳&lt;/p&gt;

&lt;p&gt;《鸦片战争》大家都知道，船坚炮利的英帝国都打到天津港口了，道光皇帝还是那种处理边疆叛乱，攘除蛮夷的态度，整个大众的的意识形态还停留在天下都是天子的，天朝之外全是名份不正确的蛮族夷地，皇帝发诏告还是「奉天承运皇帝诏曰」的口气。真正枪炮打到脸上的时候才意识到疼&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ProseMirror 编辑器指南中文翻译版</title>
      <link>https://keelii.com/2018/12/09/prosemirror-guide-cn/</link>
      <pubDate>Sun, 09 Dec 2018 17:59:45 +0800</pubDate>
      
      <guid>https://keelii.com/2018/12/09/prosemirror-guide-cn/</guid>
      <description>

&lt;p&gt;这个指南介绍了很多编辑器的设计理念，以及他们之间的关系。想完整的了解整个系统，建议按顺序阅读，或者至少阅读视图组件部分&lt;/p&gt;

&lt;h2 id=&#34;简介-introduction&#34;&gt;简介 Introduction&lt;/h2&gt;

&lt;p&gt;ProseMirror 提供了一组工具和设计概念用来构建富文本编辑器，UI 的使用源于 WYSIWYG 的一些灵感，ProseMirror 试着屏蔽一些排版中的痛点&lt;/p&gt;

&lt;p&gt;ProseMirror 的主要原则是：*你的代码对于&lt;strong&gt;文档&lt;/strong&gt;及其事件变更有完整的控制权*。这个 &lt;strong&gt;文档&lt;/strong&gt; 并不是原生的 HTML 文档，而是一个自定义的数据结构，这个数据结构包含了通过你明确允许应该被包含的元素，它们的关系也由你指定。所有的更新都会在一个你可以查看并做出响应的地方进行&lt;/p&gt;

&lt;p&gt;核心的代码库并不是一个容易拿来就用的组合 — 我们会优先考虑 &lt;strong&gt;模块化&lt;/strong&gt; 和 &lt;strong&gt;可自定义&lt;/strong&gt; 化胜过简单化，希望将来有用户会基于 ProseMirror 分发一个拿来就用的版本。因此，ProseMirror 更像是乐高积木而不是火柴盒拼的成的玩具车&lt;/p&gt;

&lt;p&gt;总共有四个核心模块，任何编辑行为都需要用到它们，还有很多核心团队维护的扩展模块，类似于三方模块 — 它们提供有用的功能，但是你可以删除或者替换成其它实现了相同功能的模块&lt;/p&gt;

&lt;p&gt;核心模块分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;prosemirror-model&lt;/code&gt; 定义了编辑器的文档模型，数据结构用来描述编辑器的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prosemirror-state&lt;/code&gt; 提供了整个编辑器状态的数据结构，包括选区和维护状态变化的事务系统&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prosemirror-view&lt;/code&gt; 实现一个用户界面组件，用来在浏览器中把编辑器的状态展示成可编辑元素，并且与其进行交互&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prosemirror-transform&lt;/code&gt; 包含了一种可以记录/重放文档修改历史的功能组件，这是 &lt;code&gt;state&lt;/code&gt; 模块中事务的基础，而且这还使得编辑器的恢复历史和协作编辑功能成为可能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，还有一些诸如 基础的编辑命令、快捷键绑定、恢复历史、输入宏、协作编辑，简单的文档骨架 的模块。&lt;a href=&#34;https://github.com/prosemirror/&#34; title=&#34;Prosemirror org&#34;&gt;Github prosemirror 组织&lt;/a&gt; 代码库中还有更多&lt;/p&gt;

&lt;p&gt;事实上 ProseMirror 并没有分发一个独立的浏览器可以加载的脚本，这表示你可能需要一些模块 bunder 来配合使用它。模块 Bunder 就是一个工具，用来自动化查找你的脚本依赖，然后合并到一个单独文件中，使你能很容易的在 web 面页中使用。你可以阅读更多关于 bundling 的东西，比如：&lt;a href=&#34;https://medium.freecodecamp.org/javascript-modules-part-2-module-bundling-5020383cf306&#34; title=&#34;JavaScript Modules Part 2: Module Bundling&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;我的第一个编辑器-my-first-editor&#34;&gt;我的第一个编辑器 My first editor&lt;/h3&gt;

&lt;p&gt;就像拼乐高积木一样，下面的代码可以创建一个最小化的编辑器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;
import {EditorState} from &amp;quot;prosemirror-state&amp;quot;
import {EditorView} from &amp;quot;prosemirror-view&amp;quot;

let state = EditorState.create({schema})
let view = new EditorView(document.body, {state})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ProseMirror 需要你为文档指定一个自己觉得合适的骨架（schema），所以上面的代码第一件事情就是引入一个基础骨架模块&lt;/p&gt;

&lt;p&gt;接着这个骨架被用来创建一个状态，它将按骨架的定义生成一个空的文档，光标会在文档最开始的地方。最后创建了一个与状态关联的视图，并且插入到 &lt;code&gt;document.body&lt;/code&gt;。这将会把状态的文档渲染成一个可编辑的 DOM 节点，并且一旦用户输入内容就会生成一个状态事务（transactions）&lt;/p&gt;

&lt;p&gt;现在这个编辑器还没什么用处。比如说当你按下回车键时没有任何反应，因为核心库并不关心回车键应该用来做什么。我们马上就会谈到这一点&lt;/p&gt;

&lt;h3 id=&#34;事务-transactions&#34;&gt;事务 Transactions&lt;/h3&gt;

&lt;p&gt;当用户输入或者与视图交互时，将会生成「状态事务」。这意味着它不仅仅是只修改文档并以这种方式隐式更新其状态。相反，每次更改都会触发一个事务的创建，该事务描述对状态所做的更改，而且它可以被应用于创建一个新状态，随后用这个新状态来更新视图&lt;/p&gt;

&lt;p&gt;这些过程都会默认地在后台处理，但是你可以写一个插件来挂载进去，或者通过配置视图的参数。例如，下面的代码添加了一个 &lt;code&gt;dispatchTransaction&lt;/code&gt; 属性（props），每当创建一个事务时都会调用它&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// (省略了导入代码库)

let state = EditorState.create({schema})
let view = new EditorView(document.body, {
  state,
  dispatchTransaction(transaction) {
    console.log(&amp;quot;Document size went from&amp;quot;, transaction.before.content.size,
                &amp;quot;to&amp;quot;, transaction.doc.content.size)
    let newState = view.state.apply(transaction)
    view.updateState(newState)
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次状态变化都会经过 &lt;code&gt;updateState&lt;/code&gt;，而且每个普通的编辑更新都将通过调度一个事务来触发&lt;/p&gt;

&lt;h3 id=&#34;插件-plugins&#34;&gt;插件 Plugins&lt;/h3&gt;

&lt;p&gt;插件用于以各种方式扩展编辑器和编辑器状态的状态，有的会非常简单，比如 快捷键 插件 — 为键盘输入绑定具体动作；有的会比较复杂，比如 编辑历史 插件 — 通过观察事务并逆序存储来实现撤销历史记录，以防用户想要撤消它们&lt;/p&gt;

&lt;p&gt;让我们为编辑器添加这两个插件来获取撤消（undo）/重做（redo）的功能：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// (Omitted repeated imports)
import {undo, redo, history} from &amp;quot;prosemirror-history&amp;quot;
import {keymap} from &amp;quot;prosemirror-keymap&amp;quot;

let state = EditorState.create({
  schema,
  plugins: [
    history(),
    keymap({&amp;quot;Mod-z&amp;quot;: undo, &amp;quot;Mod-y&amp;quot;: redo})
  ]
})
let view = new EditorView(document.body, {state})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当创建一个状态的时候插件就会被注册（因为插件需要访问状态事务），当这个开启了编辑历史状态的视图被创建时，你将可以通过按 &lt;code&gt;Ctrl-Z&lt;/code&gt; 或者 &lt;code&gt;Cmd-Z&lt;/code&gt; 来撤消最近的一次变更&lt;/p&gt;

&lt;h3 id=&#34;命令-commands&#34;&gt;命令 Commands&lt;/h3&gt;

&lt;p&gt;上面示例代码中的 &lt;code&gt;undo&lt;/code&gt; 和 &lt;code&gt;redo&lt;/code&gt; 变量值是绑定到指定键位的一种叫做 *命令* 的特殊值。大多数编辑动作都是作为可绑定到键的命令编写的，它可以用来挂载到菜单栏，或者直接暴露给用户&lt;/p&gt;

&lt;p&gt;&lt;code&gt;prosemirror-commands&lt;/code&gt; 包提供了许多基本的编辑命令，其中一些是你可以需要用到的基本的快捷键，比如 回车，删除编辑器中指定的内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// (Omitted repeated imports)
import {baseKeymap} from &amp;quot;prosemirror-commands&amp;quot;

let state = EditorState.create({
  schema,
  plugins: [
    history(),
    keymap({&amp;quot;Mod-z&amp;quot;: undo, &amp;quot;Mod-y&amp;quot;: redo}),
    keymap(baseKeymap)
  ]
})
let view = new EditorView(document.body, {state})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，你已经有了一个算得上可以使用的编辑器了&lt;/p&gt;

&lt;p&gt;添加菜单，额外的为特定骨架指定的快捷键绑定 等功能，可以通过查看 &lt;a href=&#34;https://github.com/prosemirror/prosemirror-example-setup&#34; title=&#34;prosemirror-example-setup&#34;&gt;prosemirror-example-setup&lt;/a&gt; 包了解更多。这个模块提供给你一组插件用来创建一个基础的编辑器，但是就像它的名字一样，只是个例子，并不是生产环境级别的代码库。真正的开发中，你可能会需要替换成自定义的代码来精确实现你想要的功能&lt;/p&gt;

&lt;h3 id=&#34;内容-content&#34;&gt;内容 Content&lt;/h3&gt;

&lt;p&gt;一个状态的文档被挂在它的 &lt;code&gt;doc&lt;/code&gt; 属性上。这是一个只读的数据结构，用各种级别的节点来表示文档，就像是浏览器的 DOM。一个简单的文档可能会由一个包含了两个「段落」节点，每个「段落」节点又包含一个「文本」节点的「文档」节点构成&lt;/p&gt;

&lt;p&gt;当初始化一个状态时，你可以给它一个初始文档。这种情况下，&lt;code&gt;schema&lt;/code&gt; 就变成非必传项了，因为 &lt;code&gt;schame&lt;/code&gt; 可以从文档中获取&lt;/p&gt;

&lt;p&gt;下面我们通过传入一个 DOM 元素 （ID 为 content）做为 DOM parser 的参数初始化一个状态，它将利用 &lt;code&gt;schema&lt;/code&gt; 中的信息来解析出对应的节点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {DOMParser} from &amp;quot;prosemirror-model&amp;quot;
import {EditorState} from &amp;quot;prosemirror-state&amp;quot;
import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;

let content = document.getElementById(&amp;quot;content&amp;quot;)
let state = EditorState.create({
  doc: DOMParser.fromSchema(schema).parse(content)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文档-documents&#34;&gt;文档 Documents&lt;/h3&gt;

&lt;p&gt;ProseMirror 定义了他自己的一种用来表示文档内容的数据结构。由于文档是构建所有编辑器的核心元素，了解它们的工作原理会对我们很有帮助&lt;/p&gt;

&lt;h3 id=&#34;结构-structure&#34;&gt;结构 Structure&lt;/h3&gt;

&lt;p&gt;一个 ProseMirror 文档就是一个节点，它包含一个片段，其中可以有一个或者多个子节点&lt;/p&gt;

&lt;p&gt;这个和浏览器 DOM 非常相似，浏览器 DOM 是一个递归的树型结构。但是 ProseMirror 的不同点在于它存储内联元素的方式&lt;/p&gt;

&lt;p&gt;在 HTML 中，一个段落的标记表示为一个树，就像这个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;This is &amp;lt;strong&amp;gt;strong text with &amp;lt;em&amp;gt;emphasis&amp;lt;/em&amp;gt;&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/14129/3/786/35284/5c0cc441E403d82b0/ef0b3f850962b393.png&#34; alt=&#34;prosemirror-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而在 ProseMirror 中，内联内容被建模为 &lt;strong&gt;扁平&lt;/strong&gt; 的序列，标记作为元数据附加到节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/15813/40/792/39752/5c0cc4e0Ee27f5876/150f7e117aa64233.png&#34; alt=&#34;prosemirror-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这更符合我们思考和使用此类文本的方式，这允许我们使用字符来表示位置而不是树的路径，这使得一些操作如分割、更改内容样式变得比维护树简单&lt;/p&gt;

&lt;p&gt;这也意味着每个文档都只有一种合法的表现层。具有相同标记集的相邻文本节点总是组合在一起，并且不允许有空文本节点，标记出现的顺序由骨架指定&lt;/p&gt;

&lt;p&gt;所以说一个 ProseMirror 文档就是一颗块级节点树，其中大多数叶子节点都是文本块，块级节点可以包含这些文本块儿。你也可以有一些空的叶子节点，比如水平分隔线或者视频元素&lt;/p&gt;

&lt;p&gt;节点对象有很多属性，它们代表所处文档中的角色：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isBlock&lt;/code&gt; 和 isInline 告诉你给定的节点是一个块级节点还是内联节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inlineContent&lt;/code&gt; 表示一个节点希望它的内容是是内联元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isTextblock&lt;/code&gt; 表示一个块级节点包含内联内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isLeaf&lt;/code&gt; 告诉你节点不允许有任何内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;典型的「段落」节点是一个文本节点，而「引用块」可能是一个包含其它块级元素的元素。文本、硬换行（&lt;br&gt;）以及内联图片都是内联叶子节点，水平分隔线节点则是一种块级叶子节点&lt;/p&gt;

&lt;p&gt;骨架允许你更准确地指定什么东西应该出现在什么位置，例如。即使一个节点允许块级内容，这并不表示他会允许所有的节点做为它的内容&lt;/p&gt;

&lt;h3 id=&#34;标识与存储-identity-and-persistence&#34;&gt;标识与存储 Identity and persistence&lt;/h3&gt;

&lt;p&gt;另外一个 DOM 树和 ProseMirror 文档不同的地方是，对象表示节点的行为。在 DOM 中，节点是具有标识的可变的对象，这表示一个节点只能出现在一个父节点中，当节点更新的时候对象也会被修改&lt;/p&gt;

&lt;p&gt;另外一方面，在 ProseMirror 中，节点仅仅是一些 *值*，和你想表示数字 3 一样，3 可以同时出现在很多数据结构中，它自己所处的部分与父元素没有连系，如果你给它加 1，你会得到一个新值 4，并且不用改变和原来 3 相关的任何东西&lt;/p&gt;

&lt;p&gt;所以它是 ProseMirror 文档的一部分，它们不会更改，但是可以用作计算修改后的文档的起始值。它们也不知道自己处在什么数据结构当中，但可以是多个结构的一部分，甚至多次出现在一个结构中。它们是值，不是状态化的对象&lt;/p&gt;

&lt;p&gt;这表示每当你更新文档，你将会获得一个新的文档值。文档值将共享所有子节点，并且不会修改原来的文档值，这使得它创建起来相对廉价&lt;/p&gt;

&lt;p&gt;这有很多优点。它可以使两次更新之间的过程无效（严格控制更新的内容和过程），因为具有新文档的新状态可以瞬间转换。它还使得文档以某种数学方式推理变得更容易，相反的如果你的值不断的在后台发生变化这将会很难做到。这也使得协作编辑成为可能，并允许 ProseMirror 通过将最后一个绘制到屏幕的文档与当前文档进行比较来运行非常高效的 DOM 更新算法&lt;/p&gt;

&lt;p&gt;由于此类节点使用了常规的 JavaScript 对象来表示，如果并且明确地冻结（&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&#34; title=&#34;freeze&#34;&gt;freezing&lt;/a&gt;）其属性可能会影响到性能，实际上属性是 *可以* 改变的，但是并不建议你这么做，这将会导致程序中断，因为它们几乎总是在多个数据结构之间共享。所以要小心！请注意，这也适用于作为节点对象一部分的数组和普通对象，例如用于存储节点属性的对象或片段中子节点的数组（译注：意思是你最好不要更改类似的内部对象，给对象添加或者删除属性）&lt;/p&gt;

&lt;h3 id=&#34;数据结构-data-structures&#34;&gt;数据结构 Data structures&lt;/h3&gt;

&lt;p&gt;一个文档的对象看起来像这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/9284/27/8310/83213/5c0cc4f2E3dca8ae6/dcc5b46f77995593.png&#34; alt=&#34;prosemirror-3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每个节点都是一个 Node 类的实例。都有一个 type 做为标签，通过 type 可以知道节点的名字，节点的属性字段也是有效的等等。节点的类型（和标识类型）每骨架会创建一次，他们知道自己属于骨架的哪个部分&lt;/p&gt;

&lt;p&gt;节点的内容存储在 Fragment 的一个实例中，它掌握着节点序列。即使节点没有或者不允许有内容，这个字段也会有值（共享的空 fragment）&lt;/p&gt;

&lt;p&gt;一些节点类型允许添加属性，它些值被存储到每个节点上。比如，图片节点一般会使用属性来存储 alt 文本和图片的 URL&lt;/p&gt;

&lt;p&gt;此外，内联节点包含一组活动标记 — 例如强调（emphasis）或链接（link）— 活动标记就是一组 Mark 实例&lt;/p&gt;

&lt;p&gt;整个文档就是一个节点。文档内容表现为一个顶级节点的子节点。通常，它将包含一系列块节点，其中一些块节点可能是包含内联内容的文本块。但顶级节点本身也可以是文本块，这样的话文档就只包含内联内容&lt;/p&gt;

&lt;p&gt;什么样的节点可以被允许，是由文档的骨架决定的。用代码的方式创建节点（而不是直接用基础骨架库），你必须通过骨架来实现，比如使用 &lt;code&gt;node&lt;/code&gt; 和 &lt;code&gt;text&lt;/code&gt; 方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;

// 如果需要的话可以把 null 参数替换成你想给节点添加的属性
let doc = schema.node(&amp;quot;doc&amp;quot;, null, [
  schema.node(&amp;quot;paragraph&amp;quot;, null, [schema.text(&amp;quot;One.&amp;quot;)]),
  schema.node(&amp;quot;horizontal_rule&amp;quot;),
  schema.node(&amp;quot;paragraph&amp;quot;, null, [schema.text(&amp;quot;Two!&amp;quot;)])
])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;索引-indexing&#34;&gt;索引 Indexing&lt;/h3&gt;

&lt;p&gt;ProseMirror 节点支持两种索引 — 它们可以看做是树，使用单个节点的偏移量，或者它们可以被视为一个扁平的标识（tokens）序列&lt;/p&gt;

&lt;p&gt;&lt;em&gt;第一种&lt;/em&gt; 允许你执行类似于对 DOM 与单个节点进行操作的交互，使用 &lt;code&gt;child&lt;/code&gt; 方法和 &lt;code&gt;childCount&lt;/code&gt; 直接访问子节点，编写扫描文档的递归函数（如果你只想查看所有节点，请使用 &lt;code&gt;descendants&lt;/code&gt; 或 &lt;code&gt;nodesBetween&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;&lt;em&gt;第二种&lt;/em&gt; 当访问一个文档中指定的位置时更好用。它允许把文档任意位置表示为一个整数 — 即标记序列中的索引。这些标识并不做为对象在内存中 — 它们仅仅是用来计数的惯例 — 但是文档的树形状以及每个节点都知道它的大小，这使得按位置访问变的廉价（译注：类似于用下标访问扁平数组，而不是递归遍历嵌套结构的树）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在第一个内容之前，文档的开头是位置 0&lt;/li&gt;
&lt;li&gt;进入或离开不是叶子节点的节点（即支持内容）计为一个&lt;strong&gt;标识索引位&lt;/strong&gt;。因此，如果文档以段落开头，则该段落的开头计为位置 1&lt;/li&gt;
&lt;li&gt;文本节点中的每个字符都算作一个标识索引位。因此，如果文档开头的段落包含单词「hi」，则位置 2 位于「h」之后，位置 3 位于「i」之后，位置 4 位于整个段落之后&lt;/li&gt;
&lt;li&gt;不允许有内容（例如图像）的叶子节点也算作 &lt;strong&gt;单个&lt;/strong&gt; 标识索引位&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，如果你有一个文档，当表示为 HTML 时，将如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;One&amp;lt;/p&amp;gt;
&amp;lt;blockquote&amp;gt;&amp;lt;p&amp;gt;Two&amp;lt;img src=&amp;quot;...&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标识序列以及位置下标，将会是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0   1 2 3 4    5
 &amp;lt;p&amp;gt; O n e &amp;lt;/p&amp;gt;

5            6   7 8 9 10    11   12            13
 &amp;lt;blockquote&amp;gt; &amp;lt;p&amp;gt; T w o &amp;lt;img&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个节点都有一个 &lt;code&gt;nodeSize&lt;/code&gt; 属性，可以为告诉你整个节点的大小，你可以访问 &lt;code&gt;.content.size&lt;/code&gt; 来获取节点 *内容* 的大小。注意，对于外部文档节点，打开和关闭标记不被视为文档的一部分（因为你无法将光标放在文档外面），因此文档的大小为 &lt;code&gt;doc.content.size&lt;/code&gt;，而不是 &lt;code&gt;doc.nodeSize&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;手动解释这样的位置会涉及相当多的计数操作。你可以调用 &lt;code&gt;Node.resolve&lt;/code&gt; 来获取关于节点位置的更具有描述性的数据结构。这个数据结构将告诉你该位置的父节点是什么，它与父节点的偏移量是什么，父节点的祖先是什么，以及其他一些东西&lt;/p&gt;

&lt;p&gt;注意区分子索引（每个 childCount），文档范围的位置和 &lt;code&gt;node-local&lt;/code&gt; 偏移（有时在递归函数中用于表示当前正在处理的节点中的位置）&lt;/p&gt;

&lt;h3 id=&#34;切片-slices&#34;&gt;切片 Slices&lt;/h3&gt;

&lt;p&gt;为了处理一些诸如复制/粘贴和拖拽之类的操作，通过切片与文档进行通信是非常必要的，比如，两个位置之间的内容。这样的切片不同于整个节点或者片段，一些节点可能位于切片开始或者结束（译注：切片的开始位置可能在某个节点的中间）&lt;/p&gt;

&lt;p&gt;例如，从一个段落的中间选择到下一个段落的中间，你所选择的切片中会有两个段落，那么切片的开始位置在第一个段落打开的地方，结束位置就在第二个段落打开的地方。然而如果你 node-select 一个段落，你就选择了一整个有关闭的节点。可能的情况是，如果将此类开放节点中的内容视为节点的完整内容，则会违反骨架约束（标签可能没关闭），因为某些所需节点落在切片之外&lt;/p&gt;

&lt;p&gt;Slice 数据结构用于表示这样的切片。它存储一个 fragment 以及两侧的 节点打开深度（open depth）。你可以在节点上使用切片方法从文档外剪切切片&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/*
0   1 2 3   4
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
4   5 6 7   8 
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
*/
// doc holds two paragraphs, containing text &amp;quot;a&amp;quot; and &amp;quot;b&amp;quot;
let slice1 = doc.slice(0, 3) // The first paragraph
/*
0|   1 2 3   |4
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
*/
console.log(slice1.openStart, slice1.openEnd) // → 0 0
let slice2 = doc.slice(1, 5) // From start of first paragraph
                             // to end of second
/*
0  1| 2 3   4
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
4    5|6 7   8 
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
*/
console.log(slice2.openStart, slice2.openEnd) // → 1 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;更改-changing&#34;&gt;更改 Changing&lt;/h3&gt;

&lt;p&gt;由于节点和片段是持久存储的，因此 &lt;strong&gt;永远&lt;/strong&gt; 不要修改它们。如果你有文档（或节点或片段）的句柄，那这个句柄引用的对象将保持不变（译注：这意味着并不能通过拿到的引用直接修改节点，因为这个节点的引用是不可变的值，当你想改变的时候节点可能已经成为历史）&lt;/p&gt;

&lt;p&gt;大多数情况下，你将使用转换（transformations）来更新文档，而不必直接接触节点。这些也会留下更改记录，当文档是编辑器状态的一部分时，这是必要的&lt;/p&gt;

&lt;p&gt;如果你确实想要「手动」派发更新的文档，那么 &lt;code&gt;Node&lt;/code&gt; 和 &lt;code&gt;Fragment&lt;/code&gt; 类型上有一些辅助方法可用。要创建整个文档的更新版本，通常需要使用&lt;code&gt;Node.replace&lt;/code&gt;，它用一个新的内容切片替换文档的给定范围。要少量地更新节点，可以使用 copy 方法，该方法使用新内容创建类似的节点。Fragments 还有各种更新方法，例如 &lt;code&gt;replaceChild&lt;/code&gt; 或 &lt;code&gt;append&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;骨架-schemas&#34;&gt;骨架 Schemas&lt;/h2&gt;

&lt;p&gt;每个 ProseMirror 文档都有一个与之关联的骨架，骨架描述了文档中可能出现的节点类型以及它们嵌套的方式。例如，它可能会指定顶级节点可以包含一个或多个块，并且段落节点可以包含任意数量的内联节点，内联节点可以使用任何标记&lt;/p&gt;

&lt;p&gt;有一个包含基础骨架的包，但 ProseMirror 的优点在于它允许你定义自己的骨架&lt;/p&gt;

&lt;h3 id=&#34;节点类型-node-types&#34;&gt;节点类型 Node Types&lt;/h3&gt;

&lt;p&gt;文档中的每个节点都有一个类型，表示其语义和属性，正如其在编辑器中呈现的方式&lt;/p&gt;

&lt;p&gt;定义骨架时，可以枚举其中可能出现的节点类型，并使用 &lt;code&gt;spec&lt;/code&gt; 对象描述：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const trivialSchema = new Schema({
  nodes: {
    doc: {content: &amp;quot;paragraph+&amp;quot;},
    paragraph: {content: &amp;quot;text*&amp;quot;},
    text: {inline: true},
    /* ... and so on */
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码定义了一个骨架，其中文档可能包含一个或多个段落，每个段落可以包含任意数量的文本&lt;/p&gt;

&lt;p&gt;每个骨架必须至少定义顶级节点类型（默认为名称「doc」，但你可以设置），以及文本内容的（text）类型&lt;/p&gt;

&lt;p&gt;注意内联的节点必须使用 inline 属性声明（但对于文本类型，根据定义是内联的，可以省略它）&lt;/p&gt;

&lt;h3 id=&#34;内容表达式-content-expressions&#34;&gt;内容表达式 Content Expressions&lt;/h3&gt;

&lt;p&gt;上面示例模式中的内容字段（paragraph+, text*）中的字符串称为内容表达式。它们控制子节点的哪些序列对此节点类型有效&lt;/p&gt;

&lt;p&gt;例如 &lt;code&gt;paragraph&lt;/code&gt; 表示「一个段落」, &lt;code&gt;paragraph+&lt;/code&gt; 表示「一个或者多个段落」。相似地，&lt;code&gt;paragraph*&lt;/code&gt; 表示「零个或者更多个段落」, &lt;code&gt;caption?&lt;/code&gt; 表示「零个或者一个说明文字」。你可以使用类正则的范围区间，比如 &lt;code&gt;{2}&lt;/code&gt; 表示精确的两次，&lt;code&gt;{1, 5}&lt;/code&gt; 表示 1~5 次，&lt;code&gt;{2,}&lt;/code&gt; 表示 2~更多多次&lt;/p&gt;

&lt;p&gt;可以组合这些表达式来创建序列，比如 &lt;code&gt;heading paragraph+&lt;/code&gt; 表示「首先是标题，然后是一个或多个段落」。你也可以使用管道运算符 &lt;code&gt;|&lt;/code&gt; 表示两个表达式之间的选择，如 &lt;code&gt;(paragraph|blockquote)+&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;某些元素类型组将在你的模式中出现多种类型 — 例如，你可能有一个「块」节点的概念，它可能出现在顶层但也嵌套在块引用内。你可以通过为节点规范提供 group 属性来创建节点组，然后在表达式中按名称引用该组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const groupSchema = new Schema({
  nodes: {
    doc: {content: &amp;quot;block+&amp;quot;},
    paragraph: {group: &amp;quot;block&amp;quot;, content: &amp;quot;text*&amp;quot;},
    blockquote: {group: &amp;quot;block&amp;quot;, content: &amp;quot;block+&amp;quot;},
    text: {}
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 &lt;code&gt;block+&lt;/code&gt; 相当于 &lt;code&gt;(paragraph | blockquote)+&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;建议在具有块内容的节点中始终需要至少一个子节点（例如上面示例中的 &lt;code&gt;doc&lt;/code&gt; 和 &lt;code&gt;blockquote&lt;/code&gt;），因为当节点为空时，浏览器将完全折叠节点，不方便编辑&lt;/p&gt;

&lt;p&gt;节点在 or-表达式中的显示顺序非常重要。为非可选节点创建默认实例时，例如，为了确保在替换步骤后文档仍符合模式，将使用表达式中的第一个类型。如果这是一个组，则使用组中的第一个类型（由组成员在节点映射中显示的顺序确定）。如果我在示例骨架中切换 &lt;code&gt;paragraph&lt;/code&gt; 和 &lt;code&gt;blockquote&lt;/code&gt; 的位置，编辑器尝试创建一个块节点时，你会得到堆栈溢出 - 它会创建一个 &lt;code&gt;blockquote&lt;/code&gt; 节点，其内容至少需要一个块，因此它会尝试创建另一个 &lt;code&gt;blockquote&lt;/code&gt; 作为内容， 等等&lt;/p&gt;

&lt;p&gt;库中的节点操作函数并非每个都会检查它是否正在处理有效的内容 - 高层次的概念，例如 转换（transforms）会，但原始节点创建方法通常不会，而是负责为其调用者提供合理的输入。完全可以使用例如 NodeType.create 来创建具有无效内容的节点。对于在切片边缘 &lt;code&gt;打开&lt;/code&gt; 的节点，这甚至是合理的事情。有一个单独的 createChecked 方法，以及一个事后 check 方法，可用于断言给定节点的内容是有效的。&lt;/p&gt;

&lt;h3 id=&#34;标记-marks&#34;&gt;标记 Marks&lt;/h3&gt;

&lt;p&gt;标记用于向内联内容添加额外样式或其他信息。骨架必须声明允许的所有标记类型。&lt;strong&gt;标记类型&lt;/strong&gt; 是与 &lt;strong&gt;节点类型&lt;/strong&gt; 非常相似的对象，用于标记标记对象并提供其他信息&lt;/p&gt;

&lt;p&gt;默认情况下，具有内联内容的节点允许将骨架中定义的所有标记应用于其子项。你可以使用节点规范上的 marks 属性对其进行配置&lt;/p&gt;

&lt;p&gt;这有一个简单的骨架，支持段落中文本的 strong 和 emphasis 标记，但不支持标题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const markSchema = new Schema({
  nodes: {
    doc: {content: &amp;quot;block+&amp;quot;},
    paragraph: {group: &amp;quot;block&amp;quot;, content: &amp;quot;text*&amp;quot;, marks: &amp;quot;_&amp;quot;},
    heading: {group: &amp;quot;block&amp;quot;, content: &amp;quot;text*&amp;quot;, marks: &amp;quot;&amp;quot;},
    text: {inline: true}
  },
  marks: {
    strong: {},
    em: {}
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标记集被解释为以空格分隔的标记名称或标记组字符串 — &lt;code&gt;_&lt;/code&gt; 充当通配符，空字符串对应于空集&lt;/p&gt;

&lt;h3 id=&#34;属性-attributes&#34;&gt;属性 Attributes&lt;/h3&gt;

&lt;p&gt;文档骨架还定义了每个节点或标记具有的属性。如果你的节点类型需要存储额外的信息，例如标题节点的级别，那就最好使用属性&lt;/p&gt;

&lt;p&gt;属性集可以认为就是普通对象，具有预定义（每个节点或标记）属性集，包含任何 JSON 可序列化值。要指定它允许的属性，请使用节点中的可选 attrs 字段或标记规范&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;heading: {
  content: &amp;quot;text*&amp;quot;,
  attrs: {level: {default: 1}}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的骨架中，标题节点的每个实例都将具有 level 属性。如果不指定，则默认为 1&lt;/p&gt;

&lt;p&gt;如果不指定属性默认值，在尝试创建此类节点又不传属性时将引发错误。在满足模式约束条件下进行转换或调用 createAndFill 时，也无法使用库生成此类节点并填充&lt;/p&gt;

&lt;h3 id=&#34;序列化与解析-serialization-and-parsing&#34;&gt;序列化与解析 Serialization and Parsing&lt;/h3&gt;

&lt;p&gt;为了能够在浏览器中编辑它们，必须能够在浏览器 DOM 中表示文档节点。最简单的方法是使用 node spec 中的 &lt;code&gt;toDOM&lt;/code&gt; 字段包含有关骨架中每个节点的 DOM 表示的信息&lt;/p&gt;

&lt;p&gt;该字段应包含一个函数，当以节点作为参数调用时，该函数返回该节点的DOM 结构的描述。这可以是直接 DOM 节点或描述它的数组，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const schema = new Schema({
  nodes: {
    doc: {content: &amp;quot;paragraph+&amp;quot;},
    paragraph: {
      content: &amp;quot;text*&amp;quot;,
      toDOM(node) { return [&amp;quot;p&amp;quot;, 0] }
    },
    text: {}
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表达式 &lt;code&gt;[“p”, 0]&lt;/code&gt; 声明了一个段落会被渲染成 HTML &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 标签。零是一个「孔」用来表示内容被渲染的地方，你还可以在标记名称后面包含具有 HTML 属性的对象，例如：&lt;code&gt;[&amp;quot;div&amp;quot;, {class: &amp;quot;c&amp;quot;}, 0]&lt;/code&gt;。叶节点在其 DOM 表示中不需要「洞」，因为它们没有内容&lt;/p&gt;

&lt;p&gt;Mark specs 允许类似于 toDOM 方法，但它们需要渲染成直接包装内容的单个标记，因此内容始终直接在返回的节点中，并且不需要指定「孔」&lt;/p&gt;

&lt;p&gt;你可能经常需要从 DOM 数据中 *解析* 文档，例如，当用户将某些内容粘贴或拖动到编辑器中时。模型（Model） 模块具有相应的功能，建议你使用 &lt;code&gt;parseDOM&lt;/code&gt; 属性直接在骨架中包含解析信息&lt;/p&gt;

&lt;p&gt;这可以列出一个解析规则数组，它描述映射到给定节点或标记的 DOM 结构。例如，基础骨架具有以下表示 emphasis 标记：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;parseDOM: [
  {tag: &amp;quot;em&amp;quot;},                 // Match &amp;lt;em&amp;gt; nodes
  {tag: &amp;quot;i&amp;quot;},                  // and &amp;lt;i&amp;gt; nodes
  {style: &amp;quot;font-style=italic&amp;quot;} // and inline &#39;font-style: italic&#39;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析规则中标记的值可以是 CSS 选择器，因此你也可以使用 &lt;code&gt;div.myclass&lt;/code&gt; 之类的操作。同样，style 属性匹配内联 CSS 样式&lt;/p&gt;

&lt;p&gt;当骨架包含 parseDOM 注解时，你可以使用 DOMParser.fromSchema 为其创建DOMParser 对象。这是由编辑器完成的，用于创建默认剪贴板解析器，但你也可以覆写它&lt;/p&gt;

&lt;p&gt;文档还带有内置的 JSON 序列化格式。你可以在文档上调用 toJSON 以获取可以安全地传递给 JSON.stringify 的对象，并且骨架对象具有将此表示形式解析回文档的 nodeFromJSON 方法&lt;/p&gt;

&lt;h3 id=&#34;扩展一个骨架-extending-a-schema&#34;&gt;扩展一个骨架 Extending a schema&lt;/h3&gt;

&lt;p&gt;传递给 Schema 构造函数的 nodes 和 marks 选项采用了 OrderedMap 对象以及纯 JavaScript 对象。骨架的 spec.nodes 和 spec.marks 属性始终是一组 OrderedMap，可以用作其它骨架的基础&lt;/p&gt;

&lt;p&gt;此类映射支持许多方法以方便地创建更新版本。例如，你可以调用 &lt;code&gt;schema.markSpec.remove(“blockquote”)&lt;/code&gt; 来派生一组没有 blockquote 节点的节点，然后可以将其作为新骨架的节点字段传入&lt;/p&gt;

&lt;p&gt;schema-list 模块导出一个便捷方法，将这些模块导出的节点添加到节点集中&lt;/p&gt;

&lt;h2 id=&#34;文档转换-document-transformations&#34;&gt;文档转换 Document transformations&lt;/h2&gt;

&lt;p&gt;转换是 ProseMirror 工作方式的核心。它们构成了事务的基础，转换使得历史追踪和协作编辑成为可能&lt;/p&gt;

&lt;h3 id=&#34;为什么-why&#34;&gt;为什么 Why?&lt;/h3&gt;

&lt;p&gt;为什么我们不能直接改变文档？或者至少创建一个新版本的文档，然后将其放入编辑器中？&lt;/p&gt;

&lt;p&gt;有几个原因。一个是代码清晰度。不可变数据结构确实使得代码更简单。但是，转换系统的主要工作是留下更新的痕迹，以值的形式表示旧版本的文档到新版本所采取的各个步骤&lt;/p&gt;

&lt;p&gt;撤消历史记录可以保存这些步骤并反转应用它们以便及时返回（ProseMirror 实现选择性撤消，这比仅回滚到先前状态更复杂）&lt;/p&gt;

&lt;p&gt;协作编辑系统将这些步骤发送给其他编辑器，并在必要时重新排序，以便每个人最终都使用相同的文档&lt;/p&gt;

&lt;p&gt;更一般地说，编辑器插件能够检查每个更改并对其进行响应是非常有用的，为了保持其自身状态与编辑器的其余状态保持一致&lt;/p&gt;

&lt;h3 id=&#34;步骤-steps&#34;&gt;步骤 Steps&lt;/h3&gt;

&lt;p&gt;对文档的更新会分解为步骤（step）来描述一次更新。通常不需要你直接使用这些，但了解它们的工作方式很有用&lt;/p&gt;

&lt;p&gt;例如使用 &lt;code&gt;ReplaceStep&lt;/code&gt; 来替换一份文档，或者使用 &lt;code&gt;AddMarkStep&lt;/code&gt; 来给指定的范围（Range）添加标记&lt;/p&gt;

&lt;p&gt;可以将步骤应用于文档来成新文档&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(myDoc.toString()) // → p(&amp;quot;hello&amp;quot;)
// A step that deletes the content between positions 3 and 5
let step = new ReplaceStep(3, 5, Slice.empty)
let result = step.apply(myDoc)
console.log(result.doc.toString()) // → p(&amp;quot;heo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用一个步骤是一件相对奇怪的过程 — 它没有做任何巧妙的事情，比如插入节点以保留骨架的约束，或者转换切片以使其适应约束。这意味着应用步骤可能会失败，例如，如果你尝试仅删除节点的打开标记，这会使标记失衡，这对你来说是毫无意义的。这就是为什么 apply 返回一个 result 对象的原因，result 对象包含一个新文档或者一个错误消息&lt;/p&gt;

&lt;p&gt;你通常会使用工具函数来生成步骤，这样就不必担心细节&lt;/p&gt;

&lt;h3 id=&#34;转换-transforms&#34;&gt;转换 Transforms&lt;/h3&gt;

&lt;p&gt;一个编辑动作可以产生一个或多个步骤（step）。处理一系列步骤最方便的方法是创建一个 &lt;code&gt;Transform&lt;/code&gt; 对象（或者，如果你正在使用整个编辑器状态，则可以使用 &lt;code&gt;Transaction&lt;/code&gt;，它是 &lt;code&gt;Transform&lt;/code&gt; 的子类）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let tr = new Transform(myDoc)
tr.delete(5, 7) // Delete between position 5 and 7
tr.split(5)     // Split the parent node at position 5
console.log(tr.doc.toString()) // The modified document
console.log(tr.steps.length)   // → 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大多数转换方法都返回转换本身，方便链式调用 &lt;code&gt;tr.delete(5,7).split(5)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;会有很多关于转换的方法可以使用，删除、替换、添加、删除标记，以及维护树型结构的方法如 分割、合并、包裹等&lt;/p&gt;

&lt;h3 id=&#34;映射-mapping&#34;&gt;映射 Mapping&lt;/h3&gt;

&lt;p&gt;当你对文档进行更改时，指向该文档的指针可能会变成无效或并不是你想要的样子了。例如，如果插入一个字符，那么该字符后面的所有位置都会指向一个旧位置之前的标记。同样，如果删除文档中的所有内容，则指向该内容的所有位置现在都会失效&lt;/p&gt;

&lt;p&gt;我们经常需要保留文档更改的位置，例如选区边界。为了解决这个问题，步骤可以为你提供一个字典映射，可以在应用该步骤之前和之后进行转换并且应用应该步骤&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let step = new ReplaceStep(4, 6, Slice.empty) // Delete 4-5
let map = step.getMap()
console.log(map.map(8)) // → 6
console.log(map.map(2)) // → 2 (nothing changes before the change)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转换对象会自动对其中的步骤（step）累加一系列的字典，使用一种叫做 &lt;strong&gt;映射&lt;/strong&gt; 的抽象，它收集了一系列的步骤字典来帮助你一次性映射它们&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let tr = new Transaction(myDoc)
tr.split(10)    // split a node, +2 tokens at 10
tr.delete(2, 5) // -3 tokens at 2
console.log(tr.mapping.map(15)) // → 14
console.log(tr.mapping.map(6))  // → 3
console.log(tr.mapping.map(10)) // → 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在某些情况下，并不是完全清楚应该将给定位置映射到什么位置。考虑上面示例的最后一行代码。位置 10 恰好指向我们分割节点的地方，插入两个标识。它应该被映射到插入内容后面还是前面？例子中明显是映射到插入内容后面&lt;/p&gt;

&lt;p&gt;但是有时候你需要一些其它的行为，这是为什么 map 方法有第二个参数 &lt;code&gt;bias&lt;/code&gt; 的原因，你可以设置成 -1 当内容被插入到前面时保持你的位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(tr.mapping.map(10, -1)) // → 7
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;rebasing&#34;&gt;Rebasing&lt;/h3&gt;

&lt;p&gt;当使用步骤和位置映射时，比如实现一个变更追踪的功能，或者给协作编辑符加一些功能，你可能就会遇到使用 rebase 步骤的场景&lt;/p&gt;

&lt;p&gt;…（本小节译者并没有完全理解，暂不翻译，有兴趣可以参考&lt;a href=&#34;http://prosemirror.net/docs/guide/#transform.rebasing&#34; title=&#34;prosemirror - transform.rebasing&#34;&gt;原文&lt;/a&gt;）&lt;/p&gt;

&lt;h2 id=&#34;编辑器状态-the-editor-state&#34;&gt;编辑器状态 The editor state&lt;/h2&gt;

&lt;p&gt;编辑的状态由什么构成？当然，你有自己的文档。还有当前的选区。例如当你需要禁用或启用一个标记但还没在该标记上输入内容时，需要有一种方法来存储当前标记集已更改的情况&lt;/p&gt;

&lt;p&gt;一个 ProseMirror 的状态由三个主要的组件构成：&lt;code&gt;doc&lt;/code&gt;, &lt;code&gt;selection&lt;/code&gt; 和 &lt;code&gt;storedMarks&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;
import {EditorState} from &amp;quot;prosemirror-state&amp;quot;

let state = EditorState.create({schema})
console.log(state.doc.toString()) // An empty paragraph
console.log(state.selection.from) // 1, the start of the paragraph
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是插件可能也有存储状态的需求 — 例如，撤消历史记录必须保留其变更记录。这就是为什么所有激活的插件也被存放在状态中的原因，并且这些插件可以用于存储自身状态的槽（slots）&lt;/p&gt;

&lt;h3 id=&#34;选区-selection&#34;&gt;选区 Selection&lt;/h3&gt;

&lt;p&gt;ProseMirror 支持几种选区类型（并允许三方代码定义新的选区类型）。选区就是 &lt;code&gt;Selection&lt;/code&gt; 类的一个实例。就像文档和其它状态相关的值一样，它们是不可变的 — 想改变选区，就得创建一个新的选区对象让新的状态关联它&lt;/p&gt;

&lt;p&gt;选区至少包含一个开始（&lt;code&gt;.from&lt;/code&gt;）和一个结束（&lt;code&gt;.to&lt;/code&gt;）做为当前文档的位置指针。许多选区还区分选区的 &lt;code&gt;anchor&lt;/code&gt;（不可移动的）和 &lt;code&gt;head&lt;/code&gt;（可移动的），因此这两个属性在每个选区对象上都存在&lt;/p&gt;

&lt;p&gt;最常见的选区类型是文本选区（text selection），它用于常规的光标（当 &lt;code&gt;anchor&lt;/code&gt; 和 &lt;code&gt;head&lt;/code&gt; 一样时）或者选择的文本。文本选区两端必须是内联位置，比如 指向内联内容的节点&lt;/p&gt;

&lt;p&gt;核心库同样也支持节点选区（node selections），当一个文档节点被选择，你就能得到它，比如，当你按下 ctrl 或者 cmd 键的同时再用鼠标点击一个节点。这样就会产生一个节点开始到结束的选区&lt;/p&gt;

&lt;h3 id=&#34;事务-transactions-1&#34;&gt;事务 Transactions&lt;/h3&gt;

&lt;p&gt;在正常的编辑过程中，新状态将从它们之前的状态派生而来。但是某些情况例外，例如 你想要创建一个全新的状态来初化化一个新文档&lt;/p&gt;

&lt;p&gt;通过将一个事务应用于现有状态，来生成新状然后进行状态更新。从概念上讲，它们只发生一次：给定旧状态和事务，为状态中的每个组件计算一个新值，并将它们放在一个新的状态值中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let tr = state.tr
console.log(tr.doc.content.size) // 25
tr.insertText(&amp;quot;hello&amp;quot;) // Replaces selection with &#39;hello&#39;
let newState = state.apply(tr)
console.log(tr.doc.content.size) // 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Transaction&lt;/code&gt; 是 &lt;code&gt;Transform&lt;/code&gt; 的子类，它继承了构建一个文档的方法，即 应用步骤到初始文档中。另外一点，事务会追踪选区和其它状态相关的组件，它提供了一些和选区相关的便捷方法，例如 &lt;code&gt;replaceSelection&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建事务的最简单方法是使用编辑器状态对象上的 &lt;code&gt;tr getter&lt;/code&gt;。这将基于当前状态创建一个空事务，然后你可以向其添加步骤和其他更新&lt;/p&gt;

&lt;p&gt;默认情况下，旧选区通过每个步骤映射以生成新选区，但可以使用 &lt;code&gt;setSelection&lt;/code&gt; 显式设置新选区&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let tr = state.tr
console.log(tr.selection.from) // → 10
tr.delete(6, 8)
console.log(tr.selection.from) // → 8 (moved back)
tr.setSelection(TextSelection.create(tr.doc, 3))
console.log(tr.selection.from) // → 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样地，在文档或选区更改后会自动清除激活的标记集，并可使用 &lt;code&gt;setStoredMarks&lt;/code&gt; 或 &lt;code&gt;ensureMarks&lt;/code&gt; 方法设置&lt;/p&gt;

&lt;p&gt;最后，&lt;code&gt;scrollIntoView&lt;/code&gt; 方法可用于确保在下次绘制状态时，选区内容将滚动到视图中。大多情况下都需要执行此操作&lt;/p&gt;

&lt;p&gt;与 &lt;code&gt;Transform&lt;/code&gt; 方法一样，许多 &lt;code&gt;Transaction&lt;/code&gt; 方法都会返回事务本身，以方便链式调用&lt;/p&gt;

&lt;h3 id=&#34;插件-plugins-1&#34;&gt;插件 Plugins&lt;/h3&gt;

&lt;p&gt;当创建一个新状态时，你可以指定一个插件数组挂载到上面。这些插件将被应用在这个新状态以及它的派生状态上，这会影响到事务的应用以及基于这个状态的编辑器行为&lt;/p&gt;

&lt;p&gt;插件是 &lt;code&gt;Plugin&lt;/code&gt; 类的实例，可以用来实现很多功能，最简单的一个例子就是给编辑器视图添加一些属性，例如 处理某些事件。复杂一点的就如添加一个新的状态到编辑器并基于事务更新它&lt;/p&gt;

&lt;p&gt;创建一个插件，你可以传入一个对象来指定它的行为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let myPlugin = new Plugin({
  props: {
    handleKeyDown(view, event) {
      console.log(&amp;quot;A key was pressed!&amp;quot;)
      return false // We did not handle this
    }
  }
})

let state = EditorState.create({schema, plugins: [myPlugin]})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个插件需要他自己的状态槽时，可以定义一个 &lt;code&gt;state&lt;/code&gt; 属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let transactionCounter = new Plugin({
  state: {
    init() { return 0 },
    apply(tr, value) { return value + 1 }
  }
})

function getTransactionCount(state) {
  return transactionCounter.getState(state)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例中的插件定义了一个非常简单的状态，它只计算已经应用于某个状态的事务数。辅助函数使用插件的 &lt;code&gt;getState&lt;/code&gt; 方法，该方法可用于从编辑器的状态对象中（插件作用域外）获取插件状态&lt;/p&gt;

&lt;p&gt;因为编辑器状态是持久化（不可变）的对象，并且插件状态是该对象的一部分，所以插件状态值必须是不可变的。即需要更改，他们的 &lt;code&gt;apply&lt;/code&gt; 方法必须返回一个新值，而不是更改旧值，并且其他代码是不可以更改它们的&lt;/p&gt;

&lt;p&gt;可对于插件而言向事务添加一些额外信息是非常有用的。例如，撤销历史记录在执行实际撤消时会标记生成的事务，以便在插件可以识别到，而不仅仅是生成一个新事务，将它们添加到撤消堆栈，我们需要单独处理它，从撤消（undo）堆栈中删除顶部项，然后同时将此事务添加到重做（redo）堆栈&lt;/p&gt;

&lt;p&gt;为此，事务允许附加元数据（metadata）。我们可以更新我们的事务计数器插件，过滤那些被标记过的事务，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let transactionCounter = new Plugin({
  state: {
    init() { return 0 },
    apply(tr, value) {
      if (tr.getMeta(transactionCounter)) return value
      else return value + 1
    }
  }
})

function markAsUncounted(tr) {
  tr.setMeta(transactionCounter, true)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;metadata 的属性键可以是字符串，但是要避免命名冲突，建议使用插件对象。有一些属性名库中已经定义过了，比如：&lt;code&gt;addToHistory&lt;/code&gt; 可以设置成 &lt;code&gt;false&lt;/code&gt; 表示事务不可以被撤消，当处理一个粘贴动作时，编辑器将在事务上设置 &lt;code&gt;paste&lt;/code&gt; 属性为 &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;视图组件-the-view-component&#34;&gt;视图组件 The view component&lt;/h2&gt;

&lt;p&gt;ProseMirror 编辑器视图是一个 UI 组件，它向用户显示编辑器状态，并允许它们进&lt;/p&gt;

&lt;p&gt;核心视图组件使用的 &lt;em&gt;编辑操作&lt;/em&gt; 的定义相当狭义 — 它用来直接处理与编辑器界面的交互，比如 输入、点击、复制、粘贴、拖拽，除此之外就没了。这表示核心视图组件并不支持一些高级一点的功能，像 菜单、快捷键绑定 等。想实现这类功能必须使用插件&lt;/p&gt;

&lt;h3 id=&#34;可编辑的-dom-editable-dom&#34;&gt;可编辑的 DOM Editable DOM&lt;/h3&gt;

&lt;p&gt;浏览器允许我们指定 DOM 的某些部分是可编辑的，这具有允许我们可以在上面聚焦或者创建选区，并且可以输入内容。视图创建其文档的 DOM 展示（默认情况下使用模式的 &lt;code&gt;toDOM&lt;/code&gt; 方法），并使其可编辑。当聚焦到可编辑的元素时，ProseMirror 确保 DOM 选区对应于编辑器状态中的选区&lt;/p&gt;

&lt;p&gt;它还会注册很多我DOM在事件处理程序，并将事件转换为适当的事务。例如，粘贴时，粘贴的内容将被解析为 ProseMirror 文档切片，然后插入到文档中&lt;/p&gt;

&lt;p&gt;很多事件也会按原生方式触发，然后才会由 ProseMirror 的数据模型重新解释。浏览器很擅长处理光标和选区等问题（当需要两向操作时则变得困难无比），所以大多数与光标相关的键和鼠标操作都由浏览器处理，之后 ProseMirror 会检查当前 DOM 选区对应着什么样的文本选区类型。如果该选区与当前选区不同，则通过调度一次事务来更新选区&lt;/p&gt;

&lt;p&gt;甚至像输入这种动作通常都留给浏览器处理，因为干扰它往往会破坏诸如 拼写检查，某些手机上单词自动首字母大写，以及其它一些设配原生的功能。当浏览器更新 DOM 时，编辑器会注意到，并重新解析文档的更改的部分，并将差异转换为一次事务&lt;/p&gt;

&lt;h3 id=&#34;数据流-data-flow&#34;&gt;数据流 Data flow&lt;/h3&gt;

&lt;p&gt;编辑器视图展示给定的编辑器状态，当发生某些事件时，它会创建一个事务并广播它。然后，这个事务通常用于创建新状态，该状态调用它的 &lt;code&gt;updateState&lt;/code&gt; 方法将状态返回给视图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/28003/16/976/56676/5c0e39efEba5293ce/3ad15f7825aa70c8.png&#34; alt=&#34;prosemirror-4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样就创建了一个简单的循环数据流，在 JavaScript 的世界，通常会立即处理事件处理器（可以理解成命令式的触发事件后直接操作 DOM），后者往往会创建更复杂的数据流网络（数据流可能是双向的，不容易理解与维护）&lt;/p&gt;

&lt;p&gt;由于事务是通过 &lt;code&gt;dispatchTransaction&lt;/code&gt; 属性来调度的，所以拦载事务是可以的做到的，为了将这个循环数据流连接到一个更大的周期 — 如果你的整个应用程序使用这样的数据流模型，就像类似 Redux 的体系结构一样，你可以使 ProseMirror 的事务与主动作调度（main action-dispatching）周期集成起来，将 ProseMirror 的状态保留在你应用程序的 &lt;code&gt;store&lt;/code&gt; 中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// The app&#39;s state
let appState = {
  editor: EditorState.create({schema}),
  score: 0
}

let view = new EditorView(document.body, {
  state: appState.editor,
  dispatchTransaction(transaction) {
    update({type: &amp;quot;EDITOR_TRANSACTION&amp;quot;, transaction})
  }
})

// A crude app state update function, which takes an update object,
// updates the `appState`, and then refreshes the UI.
function update(event) {
  if (event.type == &amp;quot;EDITOR_TRANSACTION&amp;quot;)
    appState.editor = appState.editor.apply(event.transaction)
  else if (event.type == &amp;quot;SCORE_POINT&amp;quot;)
    appState.score++
  draw()
}

// An even cruder drawing function
function draw() {
  document.querySelector(&amp;quot;#score&amp;quot;).textContent = appState.score
  view.updateState(appState.editor)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;高效更新-efficient-updating&#34;&gt;高效更新 Efficient updating&lt;/h3&gt;

&lt;p&gt;一种简单的实现 &lt;code&gt;updateState&lt;/code&gt; 的方法是在每次调用文档时重绘文档。但对于大型文档而言，这会变得很慢&lt;/p&gt;

&lt;p&gt;由于在更新期间，视图可以访问到旧文档和新文档，可以用它们来做对比，单独保留没发生变化的节点对应的 DOM 部分。 ProseMirror 就是这么做的，这将使得常规的更新动作只需要做很少的工作&lt;/p&gt;

&lt;p&gt;在某些情况下，例如 通过浏览器的编辑操作添加到 DOM 的更新文本。确保DOM 和状态一致，根本不需要任何 DOM 更改（当以一个事务被取消，修改时，视图将撤消 DOM 更改以确保 DOM 和状态保持同步）&lt;/p&gt;

&lt;p&gt;类似地，DOM 选区仅在实际与状态中的选区不同步时才会更新，这是为了避免破坏浏览器在选区中的各种「隐藏 hidden」状态（例如，当你使用向下或向上箭头空过短行时，你的水平位置会回到你进入下一条长行的位置）&lt;/p&gt;

&lt;h3 id=&#34;属性-props&#34;&gt;属性 Props&lt;/h3&gt;

&lt;p&gt;大体上讲 Props 很有用，这是从 React 学过来的。属性就像是 UI 组件中的参数。理想情况下，组件的属性完全定义其行为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let view = new EditorView({
  state: myState,
  editable() { return false }, // Enables read-only behavior
  handleDoubleClick() { console.log(&amp;quot;Double click!&amp;quot;) }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，当前的状态就是一个属性。即使一段代码控制了组件并更新某属性，它也不是真正意义上的状态，因为组件 &lt;strong&gt;自己&lt;/strong&gt; 并没有改变它们，&lt;code&gt;updateState&lt;/code&gt; 方法也只是更新状态中某个属性的一种简写&lt;/p&gt;

&lt;p&gt;插件可以声明除了 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;dispatchTransaction&lt;/code&gt; 以外的任意属性，它们可以直接传给视图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function maxSizePlugin(max) {
  return new Plugin({
    props: {
      editable(state) { return state.doc.content.size &amp;lt; max }
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个给定的属性被多次声明时，它的处理方式取决于属性类型。直接传入的的属性优先，然后每个插件按顺序执行。对于一些属性而言，比如 &lt;code&gt;domParser&lt;/code&gt;，只会使用第一次声明的值。如果是事件处理函数，可以返回一个布尔值来告诉底层事件系统是否要执行自己的逻辑（比如 事件处理函数反回 false，这表示底层事件上绑定的相同事件处理函数将不会被处理），有的属性，像 attributes 则会做合并然后使用&lt;/p&gt;

&lt;h3 id=&#34;装饰器-decorations&#34;&gt;装饰器 Decorations&lt;/h3&gt;

&lt;p&gt;装饰使你可以控制视图绘制文档的方式。它们是通过从 装饰器 属性返回值创建的，有三种类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点装饰器&lt;/strong&gt; Node decorations - 将样式或其他 DOM 属性添加到单个节点的 DOM 展示中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;挂件装饰器&lt;/strong&gt; Widget decorations - 在指定位置插入一个 DOM 节点，该节点不是实际文档的一部分&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内联装饰器&lt;/strong&gt; Inline decorations - 添加样式或属性，就像节点装饰器一样，但是会添加到给定范围内的所有内联节点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了能够有效地绘制和比较装饰器，它们需要作为装饰数组提供（这是一种模仿实际文档的树形数据结构）。你可以使用静态 &lt;code&gt;create&lt;/code&gt; 方法创建，提供文档和装饰对象数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let purplePlugin = new Plugin({
  props: {
    decorations(state) {
      return DecorationSet.create(state.doc, [
        Decoration.inline(0, state.doc.content.size, {style: &amp;quot;color: purple&amp;quot;})
      ])
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你有很多装饰器，那么每次重新绘制时都要重新创建这些装置成本会很高。这种情况下，维护装饰器的推荐方法是将数组放在插件的状态中，通过更改将其映射到之前的状态，并且只在需要时进行更改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let specklePlugin = new Plugin({
  state: {
    init(_, {doc}) {
      let speckles = []
      for (let pos = 1; pos &amp;lt; doc.content.size; pos += 4)
        speckles.push(Decoration.inline(pos - 1, pos, {style: &amp;quot;background: yellow&amp;quot;}))
      return DecorationSet.create(doc, speckles)
    },
    apply(tr, set) { return set.map(tr.mapping, tr.doc) }
  },
  props: {
    decorations(state) { return specklePlugin.getState(state) }
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的插件将其状态初始化为装饰器数组，该装饰器数组将会执行每 4 个位置添加黄色背景。这个例子可能并不是非常有用，但有点类似于突出显示搜索匹配或注释区域的场景&lt;/p&gt;

&lt;p&gt;当事务应用于状态时，插件状态的 apply 方法将装饰器数组向前映射，使装饰器保持原位并「适应」新文档形状。通过利用装饰器数组的树形结构使得映射方法（典型的局部变化）变得高效 - 树形结构中只有变化的部分才会被处理或者重建&lt;/p&gt;

&lt;p&gt;在插件的实际使用过程中，apply 方法也可以根据你基于新事件添加或删除装饰的位置而定，或者是通过检测事务中的更新，或基于特定的附加到事务的插件元数据&lt;/p&gt;

&lt;p&gt;最后，装饰属性只是返回插件状态，这就导致装饰器会展示在视图中&lt;/p&gt;

&lt;h3 id=&#34;节点视图-node-views&#34;&gt;节点视图 Node views&lt;/h3&gt;

&lt;p&gt;还有一种方法可以影响编辑器视图绘制文档的方式。节点视图可以为文档中的各个节点定义一种微型的 UI 组件。它们允许你展示 DOM，定义更新方式，并编写自定义代码以及响应事件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let view = new EditorView({
  state,
  nodeViews: {
    image(node) { return new ImageView(node) }
  }
})

class ImageView {
  constructor(node) {
    // The editor will use this as the node&#39;s DOM representation
    this.dom = document.createElement(&amp;quot;img&amp;quot;)
    this.dom.src = node.attrs.src
    this.dom.addEventListener(&amp;quot;click&amp;quot;, e =&amp;gt; {
      console.log(&amp;quot;You clicked me!&amp;quot;)
      e.preventDefault()
    })
  }

  stopEvent() { return true }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的示例为图片节点定义了视图对象，为图像创建了自定义的 DOM 节点，添加了事件处理程序，并使用 stopEvent 方法声明 ProseMirror 应忽略来自该DOM 节点的事件&lt;/p&gt;

&lt;p&gt;通常你可能会有与节点交互以影响文档中的实际节点的需求。但是要创建更改节点的事务，首先需要知道该节点的位置。为此，节点视图将传递一个 getter 函数，该函数可用于查询文档中当前节点的位置。让我们修改示例，实现单击节点查询你输入图像的 alt 文本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let view = new EditorView({
  state,
  nodeViews: {
    image(node, view, getPos) { return new ImageView(node, view, getPos) }
  }
})

class ImageView {
  constructor(node, view, getPos) {
    this.dom = document.createElement(&amp;quot;img&amp;quot;)
    this.dom.src = node.attrs.src
    this.dom.alt = node.attrs.alt
    this.dom.addEventListener(&amp;quot;click&amp;quot;, e =&amp;gt; {
      e.preventDefault()
      let alt = prompt(&amp;quot;New alt text:&amp;quot;, &amp;quot;&amp;quot;)
      if (alt) view.dispatch(view.state.tr.setNodeMarkup(getPos(), null, {
        src: node.attrs.src,
        alt
      }))
    })
  }

  stopEvent() { return true }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;setNodeMarkup&lt;/code&gt; 是一个方法，可用于更改给定位置的节点的类型或属性集。在示例中，我们使用 getPos 查找图像的当前位置，并使用新的 alt 文本为其提供新的属性对象&lt;/p&gt;

&lt;p&gt;节点更新后，默认行为是保持节点外部 DOM 结构不变，并将其子项与新的子元素集进行比较，根据需要更新或替换它们。节点视图可以使用自定义行为覆盖它，这允许我们执行类似于根据内容更改段落类（css class）属性的操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let view = new EditorView({
  state,
  nodeViews: {
    paragraph(node) { return new ParagraphView(node) }
  }
})

class ParagraphView {
  constructor(node) {
    this.dom = this.contentDOM = document.createElement(&amp;quot;p&amp;quot;)
    if (node.content.size == 0) this.dom.classList.add(&amp;quot;empty&amp;quot;)
  }

  update(node) {
    if (node.type.name != &amp;quot;paragraph&amp;quot;) return false
    if (node.content.size &amp;gt; 0) this.dom.classList.remove(&amp;quot;empty&amp;quot;)
    else this.dom.classList.add(&amp;quot;empty&amp;quot;)
    return true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图片标签不会有子内容，所以在我们之前的例子里，我们并不需要关心它是如何渲染的，但是段落有子内容。Node view 支持两种处理内容的方式：要么你让 ProseMirror 库来管理它，要么完全由你自己来管理。如果你提供一个 &lt;code&gt;contentDOM&lt;/code&gt; 属性，ProseMirror 将把节点渲染到这里并处理内容更新。如果你不提供这个属性，内容对于编辑器将变成一个黑盒，内容如何展示如何交互都将取决于你&lt;/p&gt;

&lt;p&gt;在这种情况下，我们希望段落内容的行为类似于常规可编辑文本，因此contentDOM 属性被定义为与 dom 属性相同，因为内容需要直接渲染到外部节点中&lt;/p&gt;

&lt;p&gt;魔术发生在 &lt;code&gt;update&lt;/code&gt; 方法中。首先，该方法负责决定是否可以更新节点视图以显示新节点。此新节点可能是编辑器更新算法尝试绘制的任何内容，因此你必须验证此节点有对应的节点视图来处理它&lt;/p&gt;

&lt;p&gt;示例中的 &lt;code&gt;update&lt;/code&gt; 方法首先检查新节点是否为段落，如果不是，就退出。然后它确保 &lt;code&gt;empty&lt;/code&gt; 类存在或不存在，具体取决于新节点的内容，返回true，则表示更新成功（此时节点的内容将被更新）&lt;/p&gt;

&lt;h2 id=&#34;命令-commands-1&#34;&gt;命令 Commands&lt;/h2&gt;

&lt;p&gt;在 ProseMirror 的术语中，命令是实现编辑操作的功能，用户可以通过按某些组合键或与菜单交互来执行命令&lt;/p&gt;

&lt;p&gt;出于实际原因考虑，命令的接口稍微有点复杂。一个接收 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;dispatch&lt;/code&gt; 参数的函数，该函数返回一个布尔值。下面是一个非常简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false
  dispatch(state.tr.deleteSelection())
  return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个命令非正常执行时应该返回 false，表示什么都不会发生。相反如果返正常执行，则应该调度一个事务并且返回 true。确实是这样的，当一个命令被绑定到一个健位并执行时，keymap 插件中对应于这个健位的事件将会被阻止&lt;/p&gt;

&lt;p&gt;为了能够查询一个命令对于一个状态下是否具有&lt;strong&gt;可执行性&lt;/strong&gt;（可执行但又不通过执行来验证），&lt;code&gt;dispatch&lt;/code&gt; 参数是可选的 — 当命令被调用并且没传入 dispatch 参数时，如果命令具有可执行性，那就应该什么也不做并返回 true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false
  if (dispatch) dispatch(state.tr.deleteSelection())
  return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了能够知道一个选区否可以被删除，你可以调用 &lt;code&gt;deleteSelection(view.state, null)&lt;/code&gt;，然而如果你想真正执行这个命令就应该这样调 &lt;code&gt;deleteSelection(view.state, view.dispatch)&lt;/code&gt;。菜单栏就是用这个来决定菜单按钮的可用性的&lt;/p&gt;

&lt;p&gt;这种行式下，命令并不需要访问实际的编辑器视图 — 大多数命令都不需要，这样的话命令就可以在设置中应用和测试而不必关心视图是否可用。但是有的命令则偏偏需要与 DOM 交互 — 可能需要查询指定的位置是否在文本块儿后面，或者打开一个相对于视图定位的对话框。为了解决这种需求，命令还提供了第三个（整个编辑器视图）参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function blinkView(_state, dispatch, view) {
  if (dispatch) {
    view.dom.style.background = &amp;quot;yellow&amp;quot;
    setTimeout(() =&amp;gt; view.dom.style.background = &amp;quot;&amp;quot;, 1000)
  }
  return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子可能并不是合适，因为命令并没有调度一次事务 — 调用他们可能会产生副作用，所以 *通常* 需要调度一次事务，但是也可能不需要，比如弹出一个层（因为这个层不在编辑器视图里面，并不属于编辑器的状态，所以调度事务就显得多余了）&lt;/p&gt;

&lt;p&gt;prosemirror-commands 模块提供了很多编辑器命令，从简单如 &lt;code&gt;deleteSelection&lt;/code&gt; 命令到复杂如 &lt;code&gt;joinBackward&lt;/code&gt; 命令，后者实现了块级节点的拼合，当你在文本块开始的地方触发 backspace 键的时候就会发生。它也会附加一些基本的快捷键绑定&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chainCommands&lt;/code&gt; 函数可以合并一系列的命令并执行直到某个命令返回 true&lt;/p&gt;

&lt;p&gt;举个例子，基础的快捷键绑定模块中，backspace 会被绑定到一个&lt;code&gt;命令链&lt;/code&gt;上：1. &lt;code&gt;deleteSelection&lt;/code&gt; 当选区不为空时删除选区；2. joinBackward 当光标在文本块开始的地方时；3. selectNodeBackward 选择选区前的节点，以防骨架中不允许有常规的拼合操作。当这些都不适用时，允许浏览器运行自己的 backspace 行为，这对于清除文本块内容是合理的&lt;/p&gt;

&lt;p&gt;命令模块还导出许多命令构造器，例如 &lt;code&gt;toggleMark&lt;/code&gt;，它采用标记类型和可选的一组属性，并返回一个命令函数，用于切换当前选区上的标记&lt;/p&gt;

&lt;p&gt;其他一些模块也会导出命令函数 — 例如，从 history 模块中 &lt;code&gt;undo&lt;/code&gt; 和 &lt;code&gt;redo&lt;/code&gt;。要自定义编辑器，或允许用户与自定义文档节点进行交互，你可能还需要编写自定义命令&lt;/p&gt;

&lt;h2 id=&#34;协作编辑-collaborative-editing&#34;&gt;协作编辑 Collaborative editing&lt;/h2&gt;

&lt;p&gt;实时协作编辑允许多人同时编辑同一文档。它们所做的更改会立即应用到本地文档，然后发送给对等（pears）方，这些对等方会自动合并这些更改（无需手动解决冲突），以便编辑动作可以不间断地进行，文档也会不断地被合并&lt;/p&gt;

&lt;p&gt;这一节将介绍如何给 ProseMirror 嫁接上协作编辑的功能&lt;/p&gt;

&lt;h3 id=&#34;算法-algorithm&#34;&gt;算法 Algorithm&lt;/h3&gt;

&lt;p&gt;ProseMirror 的协作编辑使用了一种中央集权式的系统，它会决定哪个变更会被应用。如果两个编辑器同时发生变更，他们两都将带着自己的变更进入系统，系统会接受其中之一，并且广播到其它编辑器中，另外一方的变更将不会被应用，当这个编辑器接收到新的变更时，它将被基于其它编辑器之上执行本地变更的 rebase 操作，然后再次提交更新&lt;/p&gt;

&lt;h3 id=&#34;权鉴-the-authority&#34;&gt;权鉴 The Authority&lt;/h3&gt;

&lt;p&gt;集权式的系统的角色其实是相对简单的，它只须做到以下几点…&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;跟踪当前文档的版本&lt;/li&gt;
&lt;li&gt;接受编辑器的变更，当变更被应用时，添加到变更列表中&lt;/li&gt;
&lt;li&gt;当给定一个版本时，提供一种编辑器接受变更的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;让我们实现一个简单的集权式的系统，它在与编辑器相同的 JavaScript 环境中运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Authority {
  constructor(doc) {
    this.doc = doc
    this.steps = []
    this.stepClientIDs = []
    this.onNewSteps = []
  }

  receiveSteps(version, steps, clientID) {
    if (version != this.steps.length) return

    // Apply and accumulate new steps
    steps.forEach(step =&amp;gt; {
      this.doc = step.apply(this.doc).doc
      this.steps.push(step)
      this.stepClientIDs.push(clientID)
    })
    // Signal listeners
    this.onNewSteps.forEach(function(f) { f() })
  }

  stepsSince(version) {
    return {
      steps: this.steps.slice(version),
      clientIDs: this.stepClientIDs.slice(version)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当编辑器试着提交他们的变更到系统时，可以调用 &lt;code&gt;receiveSteps&lt;/code&gt; 方法，传递他们接收到的最新版本号，同时携带着新的变更及他们自己的 client ID（用来识别变更来自哪里）&lt;/p&gt;

&lt;p&gt;当这步骤被接收，客户端就会知道被接收了。因为系统会通知他们新的可用步骤，然后发送给他们自己的步骤。真正的实现中，做为优化项，你也可以调用 &lt;code&gt;receiveSteps&lt;/code&gt; 返回一个状态码，然后立即确认发送的步骤，但是这里用到的东西必须要在不可靠的网络环境下保证同步&lt;/p&gt;

&lt;p&gt;这种权限的实现保持了一系列不断增长的步骤，其长度表示当前版本&lt;/p&gt;

&lt;h3 id=&#34;协作模块-the-collab-module&#34;&gt;协作模块 The &lt;code&gt;collab&lt;/code&gt; Module&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;collab&lt;/code&gt; 模块导出一个 &lt;code&gt;collab&lt;/code&gt; 函数，该函数返回一个插件，负责跟踪本地变更，接收远程变更，并对于何时必须将某些内容发送到中央机构做出指示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {EditorState} from &amp;quot;prosemirror-state&amp;quot;
import {EditorView} from &amp;quot;prosemirror-view&amp;quot;
import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;
import collab from &amp;quot;prosemirror-collab&amp;quot;

function collabEditor(authority, place) {
  let view = new EditorView(place, {
    state: EditorState.create({schema, plugins: [collab.collab()]}),
    dispatchTransaction(transaction) {
      let newState = view.state.apply(transaction)
      view.updateState(newState)
      let sendable = collab.sendableSteps(newState)
      if (sendable)
        authority.receiveSteps(sendable.version, sendable.steps,
                               sendable.clientID)
    }
  })

  authority.onNewSteps.push(function() {
    let newData = authority.stepsSince(collab.getVersion(view.state))
    view.dispatch(
      collab.receiveTransaction(view.state, newData.steps, newData.clientIDs))
  })

  return view
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;collabEditor&lt;/code&gt; 函数创建一个加载了&lt;code&gt;collab&lt;/code&gt; 插件的编辑器视图。每当状态更新时，它都会检查是否有任何内容要发送给系统。如果有，就发送&lt;/p&gt;

&lt;p&gt;它还注册了一个当新的步骤可用时系统应该调用的函数，并创建一个事务来更新我们的本地编辑器反映这些步骤的状态&lt;/p&gt;

&lt;p&gt;当一组步骤被系统拒绝时，它们将一直保持未确认状态，这个时间段应该会比较短，持续到我们从系统收到新的步骤之后。接着，因为 &lt;code&gt;onNewSteps&lt;/code&gt; 回调调用 &lt;code&gt;dispatch&lt;/code&gt;，&lt;code&gt;dispatch&lt;/code&gt; 再调用我们的 &lt;code&gt;dispatchTransaction&lt;/code&gt; 函数，代码才会将尝试再次提交其更改&lt;/p&gt;

&lt;p&gt;这基本上就是的所有协作模块的功能了。当然，对于异步数据通道（例如上面的演示代码中的长轮询或 Web套接字），你需要更复杂的通信和同步代码，而且你也可能需要集权系统在某些情况下开始抛出步骤，而不至于内存被消耗完。但是这个小例子大概也描述清楚了实现过程&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么前端工程师需要关注设计</title>
      <link>https://keelii.com/2018/12/02/why-frontend-dev-should-care-design/</link>
      <pubDate>Sun, 02 Dec 2018 19:10:24 +0000</pubDate>
      
      <guid>https://keelii.com/2018/12/02/why-frontend-dev-should-care-design/</guid>
      <description>

&lt;p&gt;在很久之前我就说过同样的话，表达过我觉得做为前端工程师而言设计素养的重要性，今天我想聊天为什么我有这种观点&lt;/p&gt;

&lt;h2 id=&#34;泛化的设计&#34;&gt;泛化的设计&lt;/h2&gt;

&lt;p&gt;实际上生活中设计是中无处不在的，大到建筑工程、工业设计，小到网页设计、产品设计。我认为设计的本质就是 &lt;strong&gt;理解你（或者你的用户）内心想法的一个过程&lt;/strong&gt;，在完成了一个物件的物理功能后，你需要考虑它的适用场景及多数用户的实用需求&lt;/p&gt;

&lt;p&gt;我在北京呆了很多年，你要问我对北京的印象是什么颜色，我会毫不犹豫的告诉你「蓝色」。有的人会认为是雾霾的灰色、有的人会认为是天安门的红色。为什么我的印象是蓝色呢，因为在北京无论你去哪儿都会选择公共交通，所有的交通标识牌都是蓝背景加白前景色，环路上的路标、地铁标、普通道路的路标，到处都会有蓝色的标识牌。使用蓝色的好处在于 &lt;strong&gt;标识性强&lt;/strong&gt;，尤其对我这种视觉异常的人特别友好。但是却缺乏美感，因为要照顾大多数人的体验&lt;/p&gt;

&lt;p&gt;我也常去西安，你要问我对西安的印象是什么颜色，我也会告诉你是「暗红」。西安的地铁标识牌就是这种暗红，我也不太确定这种颜色准确的叫法，赤红或者朱红？总之这种颜色和西安这个城市的调性很搭。无论是古城门上的各种架梁、门柱、瓦石的着色，还是现代的地铁标识颜色，到处都有暗红色的设计。西安地铁标的设计虽然说是和整个城市的气质具有一致性，但是 &lt;strong&gt;识别性很差&lt;/strong&gt;，尤其城市里面绿化比较好，树木多的时候绿色和这种红色标识交错在一起是很难分辨的&lt;/p&gt;

&lt;p&gt;从这个例子中我们可以了解到，其实设计并不是那种只存在于理论或者艺术世界里面的东西，大多数的设计都源于生活。都表达了人们对于生活的思考与理解&lt;/p&gt;

&lt;h2 id=&#34;狭义的设计&#34;&gt;狭义的设计&lt;/h2&gt;

&lt;p&gt;狭义点讲前端工程师（程序员）们的日常是程序设计或者软件设计。有一个关于用户体验的真相是：大多数用户当他们不喜欢你的产品时，他们会 &lt;strong&gt;直接离开并放弃&lt;/strong&gt;。用户的选择是正向的，他会因为你的软件好用选择，但 &lt;strong&gt;并不一定&lt;/strong&gt; 会因为你的软件不好而批评反馈。所以我一直认为很多所谓的为了提高用户体验的调查问卷并没有什么作用。相反的很多反馈都是没有经过深思熟虑，或者是很个人的需求，这反倒会影我们的判断&lt;/p&gt;

&lt;p&gt;所以说代码设计的的好不好，交互是否流畅，体验是否极致。这个门槛的最后一步就在前端&lt;/p&gt;

&lt;p&gt;当然后端也很重要，后端的重要性是我们在这聊设计聊体验的前提。「仓廪实而知礼节」，很多前端在知乎提问类似「Node.JS 和 Java 相比…」的话题的时候却从来没想过这个问题，不过这个话题就不细聊了&lt;/p&gt;

&lt;p&gt;前端需要关注设计，原因有二：&lt;/p&gt;

&lt;p&gt;一、离用户更近。这个毫无疑问，前端在整个软件的系统栈里面是最顶部一个元素，他们写出来的代码第一用户是自己，一个功能好不好用前端会有第一知觉。同时这个也依赖于工程师对于设计体验的素养。很多东西是没法区分 &lt;strong&gt;逻辑上的好坏&lt;/strong&gt;，同时有些东西应该是 &lt;strong&gt;不言而喻&lt;/strong&gt; 的：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;页面的链接到底应该在当前面页打开还是新页签&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这就是一个典型的没法从逻辑上区分好坏的问题。当然所有页面都新窗口打开肯定是不对的。我认为 &lt;code&gt;&amp;lt;base target=&amp;quot;_blank&amp;quot;/&amp;gt;&lt;/code&gt; 在任何时时候都不应该被使用。看看自己每天使用的浏览器 tab 页的个数就明白了。实际使用的时候要根据用户的场景、喜好、链接去向内容、技术实现等各方面因素综合考虑，*一刀切* 的做法绝对是错误的&lt;/p&gt;

&lt;p&gt;&lt;em&gt;弹出层、hover 提示 应该是尽量少的使用&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这就是不言而喻的，因为在 PC 端用户的鼠标是最常用的输入设备。鼠标的 &lt;code&gt;mouseover&lt;/code&gt; 事件会产生很多误操作，浮层的显示这会骚扰用户的视觉。当然技术上我们可以通给 &lt;code&gt;mouseover&lt;/code&gt; 事件添加延迟的方式来避免误操作的机率，但是我认为这是一种 *打补丁* 的解决方法，因为当一个提示信息足够重要的时候，任何延迟都是错误的，更何况打补丁还有副作用&lt;/p&gt;

&lt;p&gt;最近刚好发现一个笔记类应用「www.notion.so」，初次使用的时候感觉真的非常棒。设计精美、交互流畅、动画细腻，好的产品不就应该是这样的么&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t29341/339/962472864/379822/48eff2bb/5c03552aN432640ea.png&#34; alt=&#34;motion.so-optmz&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是当你深入使用的时候你会发现这个页面上充满了各个的 hover 效果，提示信息、状态切换等。它几乎在所有的图标上都加了 功能提示或快捷键的 hover 提示，这个在我看来就非常的骚扰用户。就比如左侧菜单的收起按钮使用了左箭头的图标「＜」，这种图标就是不言而喻的，不需要再用 tooltip 来提示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t30091/247/977323550/330695/a320c333/5c03914aNcce71c64.gif&#34; alt=&#34;hovers&#34; /&gt;&lt;/p&gt;

&lt;p&gt;二、审美需求。这一点其实上是所有人都需要关注的，很多程序员在使用 macOS 一段时间后就再也没法忍受 windows 的界面了。单从审美诉求这一项讲，macOS 体现出来的简洁、专注是 windows 系统没有的。结合上面的问题可以思考下：*为什么 macOS 系统的鼠标 hover 的交互很少？*我觉得应该是操作系统给用户带来的那种稳定、可靠的感觉。当你专注的做一件事情的时候最好不要有任何形式的打扰，像系统通知、气泡提醒什么的应该完全被禁止&lt;/p&gt;

&lt;p&gt;很多人会认为程序员不需要审美，因为他们实现功能就行了。事实上甚至很多程序员也可能是这么想的。但是他们并没有意识到一点，即使是那种特别不关心审美的人也有基本审美的需求，或者说一个长像其丑无比的人也有基本审美的需求，爱美之心人皆有之。只是程序员这类群体写代码太久就会进入特别专注的状态，只在乎代码，忘了其它一些同样有价值的东西&lt;/p&gt;

&lt;p&gt;我想表达的意思并不是说这样不好，而是我认为在专注技术的前提下了解一些设计方面的东西会让我们理解别人（用户）的想法，这其实也是一种与外界的沟通形式，也能弥补程序员天生的弱点&lt;/p&gt;

&lt;h2 id=&#34;设计的规则&#34;&gt;设计的规则&lt;/h2&gt;

&lt;p&gt;很多对设计一知半解的人会说一句别人经过实践总结出来的真理：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rules are meant to be broken — 规则就是用来被打破的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在《写给大家看的设计书》中就讲过这个问题，我是比较同意作者的观点，即：打破规则的前提应该是你足够了解规则是什么，意味着什么&lt;/p&gt;

&lt;p&gt;同时书中开篇分享了另外一个观点，我也很赞同：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当你能叫出一个东西的名字后，这个东西就无处不在了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个估计很多人都会有这种体验，某一天某个人说了一个你以前从来没听过的词儿，然后你觉得这个词很新鲜，接着在后来一段时间内这个词就会不段的出现在你的周围&lt;/p&gt;

&lt;p&gt;作者的意思是，其实就是设计在很多人眼中遙不可及并不是因为它很高深，而是你没听过、没见过一些设计规则&lt;/p&gt;

&lt;p&gt;后面的东西就不聊了，读者有兴趣可以读下原著，书中提到的几个原则至今都在我的脑海里：亲密、对齐、重复、对比&lt;/p&gt;

&lt;p&gt;&lt;em&gt;封面图：&lt;a href=&#34;https://www.pexels.com/photo/black-pencils-and-design-word-6444/&#34;&gt;https://www.pexels.com/photo/black-pencils-and-design-word-6444/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么一些高赞公众号文章成为现代鸦片</title>
      <link>https://keelii.com/2018/11/25/why-some-wechat-article-become-modern-opium/</link>
      <pubDate>Sun, 25 Nov 2018 19:10:24 +0000</pubDate>
      
      <guid>https://keelii.com/2018/11/25/why-some-wechat-article-become-modern-opium/</guid>
      <description>

&lt;p&gt;单看这篇文章的标题可能会有点言重，但是我更愿意记录下来给自己当做警钟。同时这也不是一篇聊历史的文章&lt;/p&gt;

&lt;h2 id=&#34;起因&#34;&gt;起因&lt;/h2&gt;

&lt;p&gt;为什么会谈到这个话题，是因为最近新闻实在太多，无论是「金马奖台独」、「俞敏洪关于堕落的演讲」还是「D&amp;amp;G辱华」。每一次舆论的风口浪尖上总是会有一些公众号 &lt;em&gt;站出来表达立场&lt;/em&gt; ，我并不打算聊这三件事情中的任何一件，我想聊聊我对于公众号的一些反醒及看法&lt;/p&gt;

&lt;p&gt;事实上最开始公众号流行的时候，我也会跟风转发一些高赞文章。比如当年咪蒙写的《致贱人：我凭什么要帮你》。当我看完这篇文章时第一感觉就是：太解气、太过瘾了，浑身上下产生了一种从心理到生理上的一种爽快感&lt;/p&gt;

&lt;p&gt;现在想起来当时的感觉应该和吸鸦片没有什么两样，但当我回过头来再看这件事情的时候我会觉得这文章无论对于我自己还是观众来说都没有半点益处。就像文章里面提到的那种伸手党，你帮了他他还觉得理所应当的人，这种人在现实生活中总会存在，不会因为转了这篇文章而消失、更不会因为你骂他两句他就幡然醒悟。所以我觉得与其痛述现实与之争长短，不如静下心来，多看书学习，用提高自己的方式拉开与它们的距离&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;然后我也想分析下这类的文章为什么能受到很多人的追捧（*下面的分析并不针对指定公众号*）&lt;/p&gt;

&lt;h2 id=&#34;人个的情绪宣泄&#34;&gt;人个的情绪宣泄&lt;/h2&gt;

&lt;p&gt;虽然公众号名曰「公众」，但是我认为 &lt;strong&gt;个人公众号&lt;/strong&gt; 是挺私人的东西。大多数人发的内容都是和自身经历相关的，不具有事实客观性，大家都在聊自己的观点&lt;/p&gt;

&lt;p&gt;比较会写文章的那类公众号发展一段时间，会有很多粉丝，他们写的一些东西因为本质上就是私人的一些想法，写的多了总会不自觉的迎合上某些观众的心理。再加上互联网肆虐的传播途径从而行成蝴蝶效应。再后来他们会成立所谓的「xx 公司」来专门运营公众号，但是本质上并没有提高内容的质量。慢慢的公众号成了一种娱乐、八卦的媒体&lt;/p&gt;

&lt;p&gt;很多观众也不具备独立思考的能力，大家对于文章好块的判断通常是感性的，通常是某些字眼、句子触动了内心深处的某个地方。由此产生的点赞或是转发完全属于一种 &lt;strong&gt;生理反射&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;大家都会说当你被一只狗咬一口的时候你不应该咬回去，因为你是人，你会思考… — 但事实是任何人被狗咬的第一反应就是回踹他两脚或者更甚&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这就解释了我们很多时候平心静气讲道理的时候都很懂，都能说得头头是道。但真正自己处于指定条件下的时候也不免产生非理智行为，尤其是被情绪控制的时候&lt;/p&gt;

&lt;p&gt;其实再深入点，对于专业的写手来讲，他们很懂得利用大众的心态与喜好，很容易就能写出来一些据有煽动性言论。举例个不太恰当的例子，如果让我写一篇关于「D&amp;amp;G辱华」事件的文章，在尽可能获取更高点赞的前提下我完全可以把这篇文章写得非常有煽动性，让多数人看了捶胸顿足、拍案叫绝。但是我不会，因为相对于做好事来讲，做坏事简直太简单了，没什么技术含量&lt;/p&gt;

&lt;p&gt;所以我认为一些公众号及其观众大多数都是在宣泄私人的情绪，没有什么正常的逻辑推理，更没有什么值得思考的东西&lt;/p&gt;

&lt;h2 id=&#34;政治正确&#34;&gt;政治正确&lt;/h2&gt;

&lt;p&gt;接着上面的蝴蝶效应讲。其实上面的现象并不是最可怕，最让人无解的是当蝴蝶效应延伸到大多数人的脑子里面时，整个事情就完全变味儿了。人们会上升到政治正确、非主流、异教徒的观念&lt;/p&gt;

&lt;p&gt;中国人喜欢大一统，因为大一统的观点才是权威的、名正言顺的。所谓的「一家之言」反而会遭到质疑，或者说 *政治不正确*，甚至被认为是 freak，然后接着拿的两样观点做对比。结果就是「我的观点永远是伟大、光荣、正确的，你的观点就是错的、可耻的、应该被消灭的」&lt;/p&gt;

&lt;p&gt;我们去看诸葛亮的《后出师表》，开头第一句就是「先帝深虑汉、贼不两立，王业不偏安」。我就特别奇怪，为什么非要分 汉、贼 呢？可能在对方看来你才是贼，「不两立」&lt;strong&gt;在现在看来&lt;/strong&gt; 就更可笑了，怎么就不能两立了，各安一方水土、各抚一方百姓 不好吗？王业不偏安，那么你的王是王，别人的王就不是王了？&lt;/p&gt;

&lt;p&gt;当然我上面讲的是在现在看来，在古代群雄逐鹿的时代不是你死就是我亡。可那是当时的实世。现如今都 21 世纪了，全世界都在讲求同存异、自由平等，为什么很多人就是接受不了新的观点与想法，接受不了异已呢&lt;/p&gt;

&lt;h2 id=&#34;情绪宣泄的必要性&#34;&gt;情绪宣泄的必要性&lt;/h2&gt;

&lt;p&gt;人类是感情动物，不是机器。有情绪就需要表达与宣泄。就我自己职业而言，属于程序员这种被认为没有感情需求的一类人。但事实是即使是程序员这类不懂沟通交流的人群，在实际生活中也需要表达，也需要沟通与被肯定。就好比大家觉得男人本质上就是动物，没有情绪一样。这是一个极其错误的观点，只是他们更喜欢把自己的感情深藏在内心罢了&lt;/p&gt;

&lt;p&gt;情绪宣泄并不是某类人的特殊需求，言论自由同样是每个人天生的权利。无论是家庭、工作还是社会中，人们总会积累到一些负面情绪，同时总会在某一角色中表现出来&lt;/p&gt;

&lt;h2 id=&#34;什么样的文章才是好的&#34;&gt;什么样的文章才是好的&lt;/h2&gt;

&lt;p&gt;我认为下面三种文章是我比较认同的：&lt;/p&gt;

&lt;p&gt;一、没有结论，只有论点和客观事实。结论交给观众，每个人自然有属于自己的判断&lt;/p&gt;

&lt;p&gt;二、有论点、有结论，并且结论根据客观事实逻辑出来。这类文章即使结论有感情色彩，对观众来讲也会产生好的引导、或者说观众也能自我判断&lt;/p&gt;

&lt;p&gt;三、看完后能让人反省思考。我认为单纯的读书、学习只能提高自己的知识水平，并不能综合性的提升自我意识与自我修养（学而不思则罔，思而不学则殆），只有不断的反省思考才能让人健全&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后分享一段讨论传统文化是否阻碍科技发展的视频：&lt;/p&gt;

&lt;p&gt;关注微信公众号「肆零玖陆」查看视频&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我们的文化传统是不提倡怀疑、不提倡批判、不提倡分析、不提倡实证，哪来的科学，哪儿来的科学精神&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;封面图：&lt;a href=&#34;https://www.pexels.com/photo/blur-capsule-close-close-up-209495/&#34;&gt;https://www.pexels.com/photo/blur-capsule-close-close-up-209495/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>国内外购物网站的差异</title>
      <link>https://keelii.com/2018/11/17/differences-between-cn-and-us-of-online-shopping-site/</link>
      <pubDate>Sat, 17 Nov 2018 19:10:24 +0000</pubDate>
      
      <guid>https://keelii.com/2018/11/17/differences-between-cn-and-us-of-online-shopping-site/</guid>
      <description>

&lt;p&gt;最近由于工作内容需要特地了解了一下国外在线购物网站的一些特点，过程中发现一些比较有意思的地方，记录下来同时聊聊我的感受&lt;/p&gt;

&lt;p&gt;我很少上国外购物网站买东西。毕竟做为个人来讲跨境消费是非常不方便的。但是我会通过信用卡购买一些服务类的产品，像虚拟服务器、域名、正版软件等。大概算是有一点国外网站的消费经历&lt;/p&gt;

&lt;p&gt;我研究了美国 TOP 10 的线上购物网站，类型上大概分三种：&lt;/p&gt;

&lt;h2 id=&#34;综合类&#34;&gt;综合类&lt;/h2&gt;

&lt;p&gt;像 Amazon, Ebay 这种属于综合类的线上购物网站，大部分的人会上这样的网站购物，因为商品种类齐全，覆盖面广。而且这类网站通常都是电商的先驱，用户早就行成了消费习惯。所以它们能占市场的很大份额&lt;/p&gt;

&lt;h2 id=&#34;垂直类&#34;&gt;垂直类&lt;/h2&gt;

&lt;p&gt;一般是某个特定商品分类领域，或者比较小众的网站。例如：Newegg - 消费电子、Esty - 手工艺、Sears - 工具/器具、ModCloth - 非主流女装、Rockler - 木工五金。这类网站的特点就是目标用户比较小众，网站的设计风格也非常个性化。newegg 是数码极客风，Esty 是小清新路线，Sears 是实用主义，ModCloth 是潮流与时尚，Rockler 是匠人。每个网站都有它特定的气质。Rockler 比较有代表性，在国内很难想像有买五金制品的网站，在 Rockler 甚至可以买到木头原材料，估计是因为国外人工成本高，很多家庭常用的东西都是自己做，所以才存在这种小众类目购物网站&lt;/p&gt;

&lt;h2 id=&#34;渠道类&#34;&gt;渠道类&lt;/h2&gt;

&lt;p&gt;这个分类可能国人没啥概念，渠道就表示线上、线下百货零售等。Walmart(沃尔玛)、Best Buy(百思买)、Target(塔吉特)。这其中数沃尔玛最典型，沃尔玛是一家美国的跨国零售企业，一个典型的家族企业。已经连续 N年在「财富世界500强」排名第一。可以说是美国零售企业的鼻祖了。这类网站的特点就是它们的线下零售渠道非常成熟，沃尔玛全球员工就超过两百万，线上对于它们来说只是多了一种销售途径。线上的销售完全可以靠自己的品牌影响力来推广&lt;/p&gt;

&lt;p&gt;在实际体验过这些网站后，我汇总出了如下几个和国内网站有鲜明区别的地方：&lt;/p&gt;

&lt;h2 id=&#34;一-见图知意&#34;&gt;一、见图知意&lt;/h2&gt;

&lt;p&gt;国外购物网站上一个最主要的特点：图片特别大，而且图片中除了商品以外没有别的干扰元素。比如下面这个母婴类目首页的导航图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t27766/157/1846789565/232488/e8057cb4/5befdb3aNb3e9b6c5.jpg&#34; alt=&#34;1-baby&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看一眼大概就能知道分别是：贴身寝具/尿不湿、儿童服饰、婴儿用的安全器具。这是一个引导页，图片上不会有具体商品信息&lt;/p&gt;

&lt;p&gt;他们的的频道页（首页、类目展示页）很少有具体的商品展示，频道页只做一个大概的分类引导，页面很短，一般就是几张简单的图片，一眼就知道这个分类卖些什么东西。如果有感兴趣的内容就点到下一个具体类目进行筛选&lt;/p&gt;

&lt;p&gt;对比国内的频道页都是以楼层的概念陈列商品列表：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;天猫：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t27016/6/1877215244/218953/545e30f8/5befe09cN27258cb2.jpg&#34; alt=&#34;2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;京东：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t26719/241/1900487066/122604/c6b8ecd7/5befe110Nc4bee940.jpg&#34; alt=&#34;3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可能国内用户都习惯了杂货铺的体验，大家喜欢在一堆东西里面挑选购物的感觉吧。&lt;/p&gt;

&lt;h2 id=&#34;二-目的明确&#34;&gt;二、目的明确&lt;/h2&gt;

&lt;p&gt;大部分人上购物网站的目的就是要购买某样商品，我们现在很多人网上购物本来想买 A，结果国内网站一顿干扰+瞎推荐引导买了 B 或者什么都没买，这难道不是倒行逆施么&lt;/p&gt;

&lt;p&gt;以买衣服为例，我们看看国外网站的列表页是怎么展示商品的：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Target 的女士毛衣列表&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t28819/338/343314321/120843/2178ef25/5befe81fN2f2191e1.jpg&#34; alt=&#34;4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Modcloth 的女士连衣裙列表&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t26242/277/1886054701/161109/83518a14/5befe90fN2c5ee49b.jpg&#34; alt=&#34;5&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;亚马逊的女士连衣裙列表&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t30616/134/329588485/146048/60789f18/5befea0bN2c2312e8.jpg&#34; alt=&#34;6&#34; /&gt;&lt;/p&gt;

&lt;p&gt;总体上给人的感觉是列表页非常清楚、简单。一眼扫过去就能知道衣服穿上的效果。而且图片中的人物也比较素雅普通，尤其 Modcloth 网站上，不同肤色、不同形体、不同风格会让你感觉到这就是平常人穿搭效果&lt;/p&gt;

&lt;p&gt;另外我发现亚马逊比较特殊，很多模特都不会露脸。猜测可能是为了排除人物形象对商品的干扰？&lt;/p&gt;

&lt;p&gt;再看看国内网站是怎么做的：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;天猫的连衣裙列表&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t26797/231/1839438911/255736/494048cd/5befedcaNd7706a3d.jpg&#34; alt=&#34;7&#34; /&gt;&lt;/p&gt;

&lt;p&gt;天猫的这个列表就明显过于突出模特的妆容和身材，根本感觉不到这件衣服的材质、面料、风格以及实际穿在身上的效果，而且一张图片里面的元素太多了，品牌 logo、背景、配饰都干扰了用户的视觉&lt;/p&gt;

&lt;p&gt;&lt;em&gt;京东的女装当季热卖&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img11.360buyimg.com/devfe/jfs/t30151/331/327872197/211139/31fb4643/5befef3cN3f72cb58.jpg&#34; alt=&#34;8&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图 3 和图 5 到底买的是衣服还是包包让人无比的困惑，图 1 更离谱，到底卖是手上的配饰还是裤子还是衣服根本说不清楚&lt;/p&gt;

&lt;p&gt;大多国内网站的服装列表基本上都会在左/右上角标出来 &lt;strong&gt;品牌&lt;/strong&gt; 这个是真正的中国用户习惯，大家买东西就看品牌，衣服好不好不重要么？品牌意识在国内真的是根深蒂固。以我们上面的例子为例，我列出的是天猫和京东网站上卖的东西，很多人买完商品觉得不好的时候会觉得是天猫或者京东不好。这是一个值得思考的问题&lt;/p&gt;

&lt;p&gt;总结起来国内的衣服卖的是 &lt;em&gt;模特&lt;/em&gt; 和 *品牌*，国外衣服更注重 &lt;em&gt;穿搭效果&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-推荐少&#34;&gt;三、推荐少&lt;/h2&gt;

&lt;p&gt;国外网站上推荐相关的内容比较少，顶多会有一个 you may like 的推荐商品模块，推荐的东西比较少而且通常在不显眼的地方。其实本来就应该如此，所谓的推荐、个性化应该是建立在尊重用户原始的购买目的之上的点睛之笔。比如我买了个 iPhone 电池，网站推荐给我一个螺丝刀我就会觉得很贴心，反之就不行&lt;/p&gt;

&lt;p&gt;再比如有人攒钱买个苹果笔记本，那在一段时间内就别再给人家推荐笔记本类的商品了嘛。大多数情况这种推荐是毫无意义的。大家整天在吹人工智能、大数据推荐什么的。但是这个简单的逻辑都做不到那人工智能就变成了人工智障了吗&lt;/p&gt;

&lt;h2 id=&#34;四-支付方式&#34;&gt;四、支付方式&lt;/h2&gt;

&lt;p&gt;国外网站一般就提供两种支付方式：信用卡、PayPal。像 Apple Pay, Android Pay 什么的都是非主流。除非有对中国的业务才有可能提供支付宝这种支付方式。国内的移动端支付方式可以说是碾压性的优势，大家会觉得国外的支付方式简直就是停留在原始社会&lt;/p&gt;

&lt;h2 id=&#34;五-促销方式&#34;&gt;五、促销方式&lt;/h2&gt;

&lt;p&gt;国外的购物网站促销都比较单一，不像国内有各种的玩法。一般来说有三种：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优惠码&lt;/strong&gt; (Gift code)：通常用在一些特殊的日子，类似国内的店庆一样。优惠码在一段时间内所有用户通用，比如使用 &lt;em&gt;happy2018&lt;/em&gt; 就能获得 80% off 的优惠&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;礼品卡&lt;/strong&gt; (Gift card) ：类似于购物网站的虚拟货币。这个就有点意思了，很多外国人会直接送亲戚朋友礼品卡而不是实物。他们会认为大家的需求不一样，我给你买的东西你不一定喜欢，还不如直接送张购物卡，你爱买啥买啥，你高兴我也不发愁送啥&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;黑五大促&lt;/strong&gt; (Black friday)：黑五的促销一般都是实打实的打折甚至半价，不玩虚的，用国内的标语就是：*在黑五那天你买不到吃亏，买不了上当，明码标价，老外诚不欺我*。这不快到 2018 的黑五了，Google Pixel 3 促销第二台半价 (Buy a Pixel &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; XL, get another up to 50% off)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么 Youtube 广告更好看</title>
      <link>https://keelii.com/2018/11/04/why-youtube-ad-better/</link>
      <pubDate>Sun, 04 Nov 2018 19:10:24 +0000</pubDate>
      
      <guid>https://keelii.com/2018/11/04/why-youtube-ad-better/</guid>
      <description>

&lt;style&gt;
&lt;/style&gt;

&lt;p&gt;马上要到双十一大促了，无论你喜不喜欢，各种广告、短信都扑面而来。当大部分广告都在高呼打折、特价买买买的时候，大家似乎都忘记了自己想要买什么了。&lt;/p&gt;

&lt;p&gt;提到广告首先让我印象深刻的是 youtube 视频网站的广告。youtube 的广告一般大概两分钟，每次看到新广告总能让人感觉特别惊喜，同样的视频网站，国内的优酷、腾迅视频却很少让人记住。&lt;/p&gt;

&lt;p&gt;于是我做了个简单的分析，总结出来我认为 youtube 广告更棒的几个原因：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;观看 youtube 需要视频需要科学上网，没法观看的可以关注公众号 肆零玖陆 对应有文章更新&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;广告质量高&#34;&gt;广告质量高&lt;/h2&gt;

&lt;p&gt;这个是毋庸置疑的，无论大众的审美如何，人们天生喜欢看到美的东西，能传递思想形成共鸣东西。即使广告也不例外，好广告最基础的一点就是要让用户看完之后知道你传达的信息是什么，似有似无、估做深沉的广告毫无意义。&lt;/p&gt;

&lt;p&gt;如果你是个程序员并且经常上 youtube 的话，你一定会看过 Wix 这个广告。它是一个网站，使用它可以让你快速的制作属于自己的网页、博客等。我们来欣赏一下 Wix 的广告：&lt;/p&gt;

&lt;p class=&#34;video-wrap&#34;&gt;
&lt;iframe width=&#34;100%&#34; src=&#34;https://www.youtube.com/embed/Fueho8FMaZ8&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/p&gt;

&lt;p&gt;这个广告无论从内容传达、产品特点、动感音效还是品牌效应都一应俱全，看完之后不仅印象深刻，而且即使你不怎么懂英文也知道 wix 是用来做什么的。&lt;/p&gt;

&lt;p&gt;广告一开始就开门见山告诉你：&lt;/p&gt;

&lt;p&gt;「With Wix you can create professional website that looks stunning, Just go to wix.com…」&lt;/p&gt;

&lt;p&gt;不到 4 秒的时间就把整个广告的主功能告诉你了（猜想可能是因为 youtube 广告 5 秒之后可以跳过），接着音乐节奏一变，开始演示一些常用功能，如果你是第一次看这个广告那这部分还是挺有效的「入门指引」，如果你看到过很多次这个广告，那现在你跳过去也不会错过什么，因为第一句话已经达到了效果，对于跳过的用户后面的部分自然是没有意义的。&lt;/p&gt;

&lt;p&gt;所谓的品牌效应就是看过很多次以后你脑子里面的那几个字，如果你还看过这个广告的其它版本，你就会发现有几个频繁出现的关键字「professional, stunning, website」，这就是广告想告诉用户的最重要的信息了&lt;/p&gt;

&lt;p&gt;还有类似 Grammarly 这样的广告，简洁清新的设计风格，让你一看就懂：&lt;/p&gt;

&lt;p class=&#34;video-wrap&#34;&gt;
&lt;iframe width=&#34;1382&#34; height=&#34;779&#34; src=&#34;https://www.youtube.com/embed/15NXrnyT2HM&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/p&gt;

&lt;h2 id=&#34;推荐关联强&#34;&gt;推荐关联强&lt;/h2&gt;

&lt;p&gt;推荐关联性强，这一点不得不说，youtube 上的广告真的是覆盖面非常广泛，如果你经常在 youtube 上看一些编程方面的视频，它就会推荐给你很多技术相关的广告，前两天突然给我推送了一个 React Native 组件的广告，我们来欣赏下：&lt;/p&gt;

&lt;p class=&#34;video-wrap&#34;&gt;
&lt;iframe width=&#34;100%&#34; src=&#34;https://www.youtube.com/embed/g13hxWfSisY&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/p&gt;

&lt;p&gt;这个广告相比而言更小众了，估计不是做前端的根本看不懂是个啥意儿了。其实就是他们做了一些 React Native 的商业化组件，种类多，你可以付钱直接购买使用，不用自己开发。&lt;/p&gt;

&lt;p&gt;可能是因为我经常看一些人文历史方面的视频，youtube 还推送过一些公益性质的文化传播类的广告比如这个「中文化遗产保护的合作关系」:&lt;/p&gt;

&lt;p class=&#34;video-wrap&#34;&gt;
&lt;iframe width=&#34;100%&#34; src=&#34;https://www.youtube.com/embed/0tSTRc0Rsn4&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/p&gt;

&lt;p&gt;这让我无比惊讶。一方面在于这种细分领域而且还是我特别了解的东西居然也有商业化的广告，另一方面也感叹 youtube 的推荐确实非常准确。而且我时常感觉以前在 google 搜索上搜索关键词后，再上 youtube 居然能推给我新的相关广告。当然这种推荐有可能会影响到你的隐私，不过由于 &lt;em&gt;GDPR&lt;/em&gt; 的原因，国外的网站现在基本上都有了不记录用户操作历史的一些选择。这个对于多数人来讲都是有好处的，因为对于用户来讲他们 &lt;strong&gt;始终&lt;/strong&gt; 是有选择的。推荐这个话题很大，有时间单独写写&lt;/p&gt;

&lt;h2 id=&#34;不骚扰-有选择&#34;&gt;不骚扰，有选择&lt;/h2&gt;

&lt;p&gt;这一条对于国内用户来讲尤其重要，要知道腾迅视频不开会员每次打开都是有 40~90 秒不能跳过的广告哦，爱奇艺，稍好点的是一定时间内再看新视频就不会播广告了。而且我发现国内的视频网站广告都 &lt;strong&gt;出奇的统一&lt;/strong&gt;，要么是名牌汽车、婴儿牛奶，要么是可口可乐、肯德基汉堡。都是大家挺熟悉的东西。完全没有新鲜感。&lt;/p&gt;

&lt;p&gt;再看 youtube 的广告，说起来其实我也没搞懂 youtube 广告的展示逻辑，有的时候点进去完全没广告，有时候每次点进去都会有。但是值得一提的是 youtube 的广告不仅和你的喜好有关，而且和广告所在的视频内容也相关。比如你看一个手机的开箱视频，那广告很可能就是和手机相关的，比如摄影照像相关。如果你不喜欢 5 秒后跳过，一段时间内就不会再有广告了。虽然 youtube red 可以让你付费免去所有广告，但是对于我这种视频观看量级还是用不到的，能用到的前提也得是没有科学上网的成本。&lt;/p&gt;

&lt;h2 id=&#34;真正能产生转换的广告&#34;&gt;真正能产生转换的广告&lt;/h2&gt;

&lt;p&gt;最后再附送一条之前真正让我产生转换率的广告，也是 youtube 推荐的，起初我并不知道这是个什么东西，看完之后莫名的被吸引，然后去搜索相关资料，了解了这个品牌的一些设计理念，刚好赶上七夕，所以就顺利成章的形成了一次「冲动」购买&lt;/p&gt;

&lt;p class=&#34;video-wrap&#34;&gt;
&lt;iframe width=&#34;100%&#34; src=&#34;https://www.youtube.com/embed/PGmEERI3vTE&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>谈谈技术驱动与尊重技术</title>
      <link>https://keelii.com/2018/10/27/technology-driven-and-respect/</link>
      <pubDate>Sat, 27 Oct 2018 19:10:24 +0000</pubDate>
      
      <guid>https://keelii.com/2018/10/27/technology-driven-and-respect/</guid>
      <description>&lt;p&gt;很多从事 IT 互联网公司工作的人（尤其是程序员）会常常提到「技术驱动与技术重视」的问题，大部分人在面临职业选择的时候也优先选择那些所谓的「技术驱动」型的公司。因为在这种公司里面技术氛围好，对自己的职业发展有帮助。&lt;/p&gt;

&lt;p&gt;这种想法肯定是无可厚非的。本文试着从大环境与自我两方面聊一下这个话题&lt;/p&gt;

&lt;p&gt;*首先*。在大家聊到这个话题时往往都 &lt;em&gt;出奇一致&lt;/em&gt; 的认为国内没有技术驱动型公司。因为大众对技术的认识很少，很多人对于程序员的第一印象是「修电脑」。&lt;/p&gt;

&lt;p&gt;当然你可能会觉得「不会呀，我周围都是一些非常专业的同事，我也在一家很重视技术的公司工作，我的工作内容大家都认可」，这么认为当然也是对的，但是我想说是的大众的意识问题。&lt;/p&gt;

&lt;p&gt;为什么大家会有这种「偏见」，在我看来根本原因就是一种 &lt;strong&gt;普世的价值观对于偏才的误解&lt;/strong&gt;。因为大众喜欢看到一个十全十美的东西。儒家的思想提倡自我的实现，君子应该如何如何…，君子应该是上知天闻下知地理，既洞明学问，又练达人情。但事实上并非如此。诸葛亮就是一个很好的例子，大众认可的是他小说中的角色，一个样样精通的人，政治、军事、管理各个领域都很精通，但事实上诸葛亮除了人长得帅气，有政治才能以外并没有别的什么长处&lt;/p&gt;

&lt;p&gt;大家喜欢全才而不是偏才，这也是《论语》中讲「君子不器」的道理。就是说君子不能像固定的器具/东西一样只有一个功能。上学的时候老师会告诉你不能偏科，学校会要求你德智体美劳全面发展。这是一种美好的愿望，但是真的有几个人会成为大家眼里的完人呢。我始终认为每个人都是不一样的，与其要求成为大众一致认为的完美，不如让自己成就真实的自我。&lt;/p&gt;

&lt;p&gt;再回到现在，为什么人们开始崇尚「工匠精神」，科技发展飞速的今天，大家才意识到技术的重要性，才意识到「科学技术是第一生产力」，只有掌握了核心技术才有能力去创造更多的价值，然而任何一样好的技术，一定是经过了几代人的努力长时间的积累实践才最终产业化。我们现在社会缺乏的恰恰是这种持之以恒的精神。&lt;/p&gt;

&lt;p&gt;在我看来工匠精神就是那种对做事要求特别专业、极致，实现自我价值的同时影响别人的一类人，这类人（比如说程序员）他们在用大量的时间去学习了专业知识，但是却疏于交际、不善言谈、或者说除了专业知识其他能力很弱。如果周围的环境能给予足够的理解于支持，比如说刚刚过去的程序员节就是个很好的例子，我觉得那个时候才会出现真正的技术驱动&lt;/p&gt;

&lt;p&gt;*其次*。上面讲的都是大环境，事实上通常是无法改变的，那么程序员是不是应该自己反思下如何提升自己来获得外界的支持于尊重。很多时候大家在要一样东西时会觉得「本来就是这样」，程序员就应该被放在一个被尊重的地方，一个认可技术的公司。但是这种尊重与认可怎么可能凭空而来呢，所谓的尊重应该是通过自己的专业能力换来的。别人眼中的你也是自己塑造出来的才对。要想大家重视技术，首先自己得重视技术，能用技术做到别人做不到的事情，这才是技术的价值。如果你自己写代码不追求极致，得过且过那就必然会成为被淘汰的对象&lt;/p&gt;

&lt;p&gt;可能会有很多人认为写代码对于自己来说只是为了赚钱生活，并不追求极致。这当然也是非常合理且正常的，因为并不是每个人的工作都是自己选择的、喜欢的。但是我比较认同的是一种做事情的态度。环顾你周围的那些优秀的人，你会发现他们无论做什么事都会做的像模像样，即使他们做一些非擅长领域的事情，也可以做的非常优秀甚至出彩。&lt;/p&gt;

&lt;p&gt;所以说编程对于大家来说 for fun 还是 for 饭并不重要，重要的是大家的态度&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>《IT 狂人》中的摇滚精神</title>
      <link>https://keelii.com/2018/10/21/rock-and-roll-in-the-it-crowd/</link>
      <pubDate>Sun, 21 Oct 2018 19:10:25 +0000</pubDate>
      
      <guid>https://keelii.com/2018/10/21/rock-and-roll-in-the-it-crowd/</guid>
      <description>&lt;p&gt;前几天听说《生活大爆炸》将于 2019 年 5 月完成终结季（12季），一时间让我想起上大学那会刚开始看这部美剧的。起初是因为大学生活确实过的没意思，也是无意中在腾讯视频上点进去的。刚开始我是从第二季开始看的，后来大学毕业参加工作后就很少看了，一方面工作后确实时间少，一方面看大爆炸时间长了也会有一些审美疲劳，感觉里面的内容不再那么有意思。&lt;/p&gt;

&lt;p&gt;说到有意思这又让我忽然想起来另外一部同样题材的情景喜剧（英剧）《The IT crowed》，这是一部给我留下深刻印象的英国喜剧。讲的是一个公司里的 IT 部门两个技术极客和一个女经理之间发生的一些有趣的事情&lt;/p&gt;

&lt;p&gt;如果你同时看过这两部剧的话你会发现他们之间有很大的差别，美式幽默和英式的幽默完全不是一个风格。英式幽默特别夸张、无理头，甚至讽刺、搞怪。他会用一些你很难想象的非常夸张的表现手法，比如在第一季中的「火焰屏保」&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/3755/16/10751/846454/5bcc3e51E9179c795/3e57d0b0706e52ab.png&#34; alt=&#34;it-crowed-火焰屏保&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一本正经的胡说八道，却让人笑到抽&lt;/p&gt;

&lt;p&gt;还有 &lt;strong&gt;灭火器着火&lt;/strong&gt;。我从来没见过甚至听过有比灭火器着火更离谱且搞笑的事情了吧&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t1/3296/27/10678/875307/5bcc3eafEf75c2af6/a6fa72572495df69.png&#34; alt=&#34;it-crowed-灭火器着火&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这还不算，镜头一转&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/9182/24/944/574450/5bcc3f27E12b1667d/fcb6c97d159f403d.png&#34; alt=&#34;it-crowed-灭火器made-in-britain&#34; /&gt;&lt;/p&gt;

&lt;p&gt;「Made in Britain - 英国制造」，这算是把自己国家完整的黑了一把&lt;/p&gt;

&lt;p&gt;其实了解英国文化的人应该会懂，英国人特别喜欢讽刺，即使自己国家的东西也可以拿来嘲讽娱乐。剧中这种讽刺还有很多，比如 *0118 999 881 999 119 725* 这居然是一个电话号码！没错，而且还是 &lt;strong&gt;紧急服务&lt;/strong&gt; 电话&lt;strong&gt;，&lt;/strong&gt;有没有搞错，紧急服务哎。这个电话号码在剧中被演绎包装成了一个政府应急服务的广告，其实就是在讽刺政府的工作效率低下。你很难想象一个老年人从楼梯上摔下去快不行的时候打这个电话的场景&lt;/p&gt;

&lt;p&gt;英式的幽默也很注重反转与对比，比如 Moss 和 Ray 翘班的那集。前脚说「我们是同事，我不会丢下你不管的…」后脚撒腿就跑的场景，诸如此类的场景剧中随处可见。以至于我有时候会隐约觉得这种英式幽默和东北人骨子里的那种搞笑爽快的性格非常相似&lt;/p&gt;

&lt;p&gt;在我看来这部剧中的很多元素都来自于英国文化中的 &lt;strong&gt;摇滚精神&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面说过大学时间很无聊，当年我也实在是没事儿干，去图书馆看过一些摇滚乐方面的东西，所以我在看这剧的时候很有感触&lt;/p&gt;

&lt;p&gt;摇滚乐发源于上世纪 60 年代至 90 年代末期，大家对早期摇滚印象深刻的可能就几个人：美国的猫王（埃尔维斯·普雷斯利），英国的甲壳虫（披头士），再到后来的朋克风平克·弗洛伊德，再到我们这一代人熟悉的迈克杰·克逊、邦·乔维等。你会发现摇滚发展了这么多年，但是摇滚的核心并没变，在我看来摇滚精神就是那种追求自由的孤独感。事实上尤其在国内，大部分人对于摇滚的印象就是吵闹、杂乱、满嘴飙脏话的阶段。大家并没有意识到实际上每个人心中都有摇滚精神体现的。对于生活追求、自由的渴望、世道不公的控诉 — 这些都是。其实摇滚乐是很简单的，有节奏的东西就是摇滚的，而且摇滚的本质就是激发人们听觉（对声音）的原始动力，这是一种特别原生、特别真实的表现方式&lt;/p&gt;

&lt;p&gt;引用一句谢天笑的《命运还是巧合》中的一句歌词：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;「命运给了我一双眼睛，放在我的心里，从此为勇敢者哭泣，为不平的世界叹息…」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;话题再转到这部剧上，我在这部剧中看到很多摇滚的元素，无论是剧情的设计和演员演技（哥特男）、服饰（珍的狂暴发型）都充满了摇滚风&lt;/p&gt;

&lt;p&gt;同时这又是一部 IT 技术方面的喜剧，这个题材能设计出完美的搞 IT 的程序员的角色是非常不容易的。导演虽然是拍喜剧的，但是他对演员角色的理解相当深刻，并且深谙程序员的套路，就如 Roy 经常提起电话时的一句反馈「Have you tried turning it off and on again-重启试试」，看这句话懂的人自然就懂了，正所谓「运维有三宝 注销、重启、装系统」。还有就是细心的人会发现这部剧里面的片头曲非常有意思，只有两种音调，以不同的音阶搭配，听起来非常有节奏感觉，是不是就象征着程序员世界中的二进制 0 和 1 呢&lt;/p&gt;

&lt;p&gt;其实最令我印象深刻的是 2013 特别篇中的「The Internet」，这一节中可以说完美的体现了导演对于程序员心理理解，再加上旁观者傻白甜的举动行成了鲜明的对比。当 Moss 对珍说「This, Jan is The Internet - 珍，这就是 Internet」的时候程序员估计会笑喷了吧&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t1/3872/18/10568/253979/5bcc3f95E69534c32/897afbf3f66a4e07.jpg&#34; alt=&#34;it-crowed-this-is-the-interinet&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这一集是真正意义上的完完全全从程序员的视角拍摄的一集，看过之后你会有一种这集就是为自己拍的的感觉。这种感觉是在其它剧或者电影里面没有的。一开始看似无理头的搞怪，最后逐渐发酵 Jen 居然拿到公司去给一大帮人讲这个盒子上的东西就是整个 Internet，荒唐的是居然大家都信了！再到最后的 Internet 被摔整个「闹剧」结束。整集看下来过瘾的同时也无比的感叹导演对剧本的精准设计和演员出色的演技。反观国内大多数人对程序员的认知还在「牛仔裤、格子衬衫」的阶段吧&lt;/p&gt;

&lt;p&gt;要看完全懂这部剧得有一点关于英国文化关于摇滚的一点认识。英国有很多著名的摇滚乐队，像前面讲到的披头士、弗洛伊德以及滚石、性手枪等一系列的优秀摇滚乐队。这些已经成为了英国人的历史文化基因，摇滚到疯狂的程序被写到了英国人的骨子里。你很难想象 2012 伦敦奥运会开幕式上居然出现一个中年男子抱着一部电吉他在那搞演唱会。你会发现这个国家对于文化的传承有多么的重视，同时对于大众的批判性讽刺性思维有多高的认同与「容忍」程度&lt;/p&gt;

&lt;p&gt;事实上，我觉得程序员这种对技术追求到 nerd 的程度的人群有着非常强烈的摇滚精神，像摇滚一样不顾一切疯狂的追求真理，讨厌任何规矩与束缚。很多时候尤其在一个不重视技术的国家里面（预告下次话题），虽然周围的人对程序员有很深刻的偏见，但是骨子里的那种摇滚精神才使他们真正与众不同&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>