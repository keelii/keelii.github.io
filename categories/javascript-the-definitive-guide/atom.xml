<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript_the_definitive_guide | Something]]></title>
  <link href="http://keelii.github.io/categories/javascript-the-definitive-guide/atom.xml" rel="self"/>
  <link href="http://keelii.github.io/"/>
  <updated>2016-06-29T17:59:12+08:00</updated>
  <id>http://keelii.github.io/</id>
  <author>
    <name><![CDATA[keelii]]></name>
    <email><![CDATA[keeliizhou@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 7 - 数组]]></title>
    <link href="http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-6/"/>
    <updated>2016-06-23T19:10:28+08:00</updated>
    <id>http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-6</id>
    <content type="html"><![CDATA[<p>数组是值的 <strong>有序集合</strong>。每个值（任意 JavaScript 数据类型）叫做一个元素，元素在数组中的位置叫索引。JavaScript 数组是无/弱类型的（untyped），数组元素可以是任意类型</p>

<p>JavaScript 数组是 <strong>动态的</strong>，根据需要它们会增长或缩减，创建的时候不须要声明一个固定的大小</p>

<p>JavaScript 数组可能是 <strong>稀疏的</strong>，数组元素索引不一定要连续</p>

<p>JavaScript 数组是 JavaScritp 对象的特殊形式。数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要 <strong>快很多</strong></p>

<!--more-->


<h2>创建数组</h2>

<pre><code class="javascript">var empty = [];             // 使用数组直接量创建一个空数组
var primes = [2, 3, 5, 7, 11];
var base = 1024；
var misc = [1.2, true, "a", base + 1, [1,2,3], { a: 1}]     // 元素可以是任意值，甚至表达式
var count = [1, ,3];            // 数组有三个元素中间那个值为 undefined

var a = new Array();        // 调用构造函数 Array() 也可以创建数组
var a = new Array(10);
a.length;                   // =&gt; 10 创建一个长度为 10 的数组
var a = new Array(1, 2, 3);
a;                          // =&gt; [1, 2, 3]
</code></pre>

<h2>数组元素的读和写</h2>

<p>使用方括号 [] 操作符来访问数组中的一个元素，方括号左边是数组的引用，右边是一个返回 <strong>非负整数值</strong> 的任意表达式</p>

<pre><code class="javascript">var a = ["world"];
a[0]                    // =&gt; "world"
a[1] = 3.14             // =&gt; 写入第 1 个元素 3.14
a                       // =&gt; ["world", 3.14]
i = 2;
a[i] = 3;               // =&gt; 写入第 2 个元素
a[i+1] = "hello";       // =&gt; 写入第 2 个元素
</code></pre>

<p>可以使用负数或者非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样如果如果凑巧使用了非负整数的字符串，它就当做数组索引，而非对象属性</p>

<pre><code class="javascript">a[-1.23] = true             // 给数组 a 创建一个名为 "-1.23" 的属性
a["1000"] = 0               // 这是数组的第 1001 个元素
a[1.000]                    // 和 a[1] 相等
</code></pre>

<p>事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组 <strong>没有越界</strong> 错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到 undefined 值，这一点类似于对象</p>

<h2>稀疏数组（Sparse Arrays）</h2>

<p>通常，数组的 length 属性代表数组中的元素个数。如果是稀疏数组，length 属性值大于元素个数。当在数组直接量中省略值是不会创建稀疏数组。省略的元素是存在的只是值为 undefined。使用 Array() 构造函数或者手动指定 length 大于当前的数组可以创建稀疏数组</p>

<pre><code class="javascript">a = new Array(5);       // 数组没元素，但 a.length 是 5
a = [];
a[1000] = 0;            // 赋值添加一个元素，但设置 length 为　1001
var a1 = [,,,];         // 数组是 [undefined, undefined, undefined]
var a2 = new Array(3);
var a3 = [1,,3];
0 in a1                 // =&gt; true 非稀疏数组
0 in a2                 // =&gt; false 稀疏数组
1 in a3                 // =&gt; false 稀疏数组
</code></pre>

<p>在一些旧版的实现中，[1,,3] 和 [1, undefined, 3] 却是一模一样的</p>

<h2>数组的长度</h2>

<p>每个数组都有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密数组，length 属性值代表数组中元素的个数，其值比数组中最大的索引大 1</p>

<p>数组有两个 <strong>特殊行为</strong>：</p>

<ol>
<li>如果为一个数组元素赋值，它的索引 i 大于或者等于现有数组的长度时，length 属性的值将设置为 i + 1</li>
<li>如果设置一个数组的 length 属性小于这个数组长度的非负整数 n 时，当前数组中那些索引值大于或等于 n 的元素将被从中删除</li>
</ol>


<pre><code class="javascript">a = [1,2,3,4,5];
a.length = 3;
a                   // =&gt; [1,2,3]
a.length = 0;
a.length = 5;       // 长度为 5，类似 new Array(5)
</code></pre>

<p>数组也继承了对象的一些方法，比如 Object.defineProperty(), 可以使用这个方法让数组的 length 属性变成只读</p>

<pre><code class="javascript">a = [1,2,3]
Object.defineProperty(a, "length", {
    writable: false
});
a.length = 0
a                   // =&gt; [1,2,3] 不会改变
</code></pre>

<h2>数组元素的添加和删除</h2>

<p>可以给新的索引赋值来添加元素，也可以调用 Array 对象的内置方法 push() 来在数组 <strong>末尾</strong> 增加一个或者多个元素，或者用 unshift() 给数组头部插入一个元素，并且将其它元素依次移动到更高的索引处</p>

<pre><code class="javascript">a = []
a[0] = "zero"
a[1] = "one"
a               // =&gt; ["zero", "one"]

a = []
a.push("zero")
a.push("one", "two")
a               // =&gt; ["zero", "one", "two"]
a.unshift(0)
a               // =&gt; [0, "zero", "one", "two"]
</code></pre>

<p>可以使用 delete 运算符来删除数组元素，效果和对数组元素赋值 undefined 类似，使用 delete 删除数组后数组的长度是不变的</p>

<h2>数组遍历</h2>

<p>使用 for 循环是遍历数组元素最常见的方法，for/in 也可以但并不推荐</p>

<pre><code class="javascript">var keys = Object.keys(o);
var values = [];
for (var i = 0; i &lt; keys.length; i++) {
    var key = keys[i];
    values[i] = o[key]
}

for (var i = 0; i &lt; keys.length; i++) {
    if (!a[i]) continue;    // 跳过 null, undefined 和不存在的元素
}
for (var i = 0; i &lt; keys.length; i++) {
    if (!(i in a)) continue;    // 只跳过不存在的元素
}
for (var i in a) {
    if (!a.hasOwnProperty(i)) continue; // 跳过继承属性
}
</code></pre>

<p>ECMAScript 5 定义了一些遍历数组元素的新方法，比如 forEach()</p>

<pre><code class="javascript">[1,2,3,4,5].forEach(function(x) {
    console.log(x);
});
</code></pre>

<h2>多维数组</h2>

<p>JavaScript 并不支持真正的多维数组，但可以模拟出来</p>

<pre><code class="javascript">var table = new Array(10);
for (var i = 0; i &lt; table.length; i++) {
    table[i] = new Array(10);
}

for (var row = 0; row &lt; table.length; row++) {
    for (var col = 0; col &lt; table[row].length; col++) {
        table[row][col] = row * col;
    }
}

table[5][7];        // =&gt; 35
</code></pre>

<h2>数组方法</h2>

<p>将所有元素都转化为字符串并通过分隔符链接起来，分隔符默认是逗号「,」</p>

<p>与之相反的 split 方法则是把字符串按分割符分割开来并返回数组，并且分割符可以是正则表达式</p>

<pre><code class="javascript">var a = [1,2,3];
a.join();               // =&gt; "1,2,3"
a.join(" ")             // =&gt; "1 2 3"
a.join("")              // =&gt; "123"
new Array(10).join('-') // =&gt; "----------"

var str = "Hello world";
str.split(' ')          // =&gt; ["Hello", "world"]
var str = "0a1b2c3d";
str.split(/\d/g);       // =&gt; ["", "a", "b", "c", "d"]
</code></pre>

<h3>reverse()</h3>

<p>反转数组元素</p>

<pre><code class="javascript">var a = [1,2,3];
a.reverse();        // =&gt; [3,2,1]
</code></pre>

<h3>sort()</h3>

<p>将数组中的元素排序并返回排序后的数组。不带参数调用 sort() 时，数组元素以字母表顺序排序，如果数组包含 undefined 元素，它们会被排到数组的尾部</p>

<pre><code class="javascript">var a = ["banana", "cherry", "apple"]
a.sort();               // =&gt; ["apple", "banana", "cherry"]
</code></pre>

<p>sort 方法可以接收一个函数参数，该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小于 0 的数值</p>

<pre><code class="javascript">var a = [3,4,1,2]
a.sort()            // [1,2,3,4]
a.sort(function(a, b) {
    return b - a
})                  // [4,3,2,1]
</code></pre>

<h3>concat()</h3>

<blockquote><p>Array.concat(value1, value2, &hellip;, valueN)</p></blockquote>

<p>创建并返回一个新数组，它的元素包括调用 concat 的原始数组元素和 concat 的每个参数</p>

<pre><code class="javascript">var a = [1,2,3]
a.concat(4,5)           // =&gt; [1,2,3,4,5]
a.concat([4,5])         // =&gt; [1,2,3,4,5]
a.concat([4,5], [6,7])  // =&gt; [1,2,3,4,5,6,7]
a.concat(4, [5, [6,7]]) // =&gt; [1,2,3,4,5,[6,7]]
</code></pre>

<h3>slice()</h3>

<blockquote><p>Array.slice([begin[, end]])</p></blockquote>

<p>返回指定数组的一个片段或子数组，它的两个参数分别指定了片段的开始和结束的 <strong>位置</strong>，如果只指定一个参数（开始位置），返回的数组将包含从开始位置到数组结尾的所有元素，如果参数中出现了负数，它表示相对于数组中最后一个元素的位置，slice 不会修改原数组</p>

<pre><code class="javascript">var a = [1,2,3,4,5]
a.slice(0, 3)       // =&gt; [1,2,3]
a.slice(3)          // =&gt; [4,5]
a.slice()           // =&gt; [1,2,3,4,5]
a.slice(1, -1)      // =&gt; [2,3,4]
a.slice(-3, -2)     // =&gt; [3]
</code></pre>

<h3>splice()</h3>

<blockquote><p>Array.splice(start, deleteCount[, item1[, item2[, &hellip;]]])</p></blockquote>

<p>splice 方法是在数组中插入或删除元素的通用方法，会 <strong>修改</strong> 调用的数组</p>

<p>splice 能够从数组中删除元素、插入元素到数组中或者 <strong>同时完成</strong> 这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其它部分仍然保持连续。splice 第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。splice 返回一个由删除元素组成的数组</p>

<pre><code class="javascript">var a = [1,2,3,4,5,6,7,8]
a.splice(4)             // =&gt; [5,6,7,8]
a                       // =&gt; [1,2,3,4]
a.splice(1,2)           // =&gt; [2,3]
a                       // =&gt; [1,4]
a.splice(1,1)           // =&gt; [4]
a                       // =&gt; [1]
</code></pre>

<p>splice 前两个参数指定了需要删除的数组元素。其后任意个数参数指定了需要插入到数组中的元素</p>

<pre><code class="javascript">var a = [1,2,3,4,5]
a.splice(2, 0, "a", "b")        // =&gt; 0
a                               // =&gt; [1,2,"a","b",3,4,5]
a.splice(2, 2, [1,2], 3)        // =&gt; ["a", "b"]
a                               // =&gt; [1,2,[1,2],3,3,4,5]
</code></pre>

<h3>push() 和 pop()</h3>

<p>push 和 pop 方法谲诈将数组当做 <a href="https://cloud.githubusercontent.com/assets/458894/16374650/f8b0fa6c-3c89-11e6-9e61-bc391f7f3cf4.png">栈</a> 来使用，push 方法在数组尾部添加一个或者多个元素，并返回新的数组长度。pop 删除数组的最后一个元素，减小数组长度并返回它删除的值</p>

<pre><code class="javascript">var stack = [];
stack.push(1,2)         // =&gt; 2 stack: [1,2]
stack.pop(1,2)          // =&gt; 1 stack: [2]
stack.push(3)           // =&gt; 2 stack: [1,3]
</code></pre>

<h3>unshift() 和 shift()</h3>

<p>unshift 在数组的头部添加一个或者多个元素，shift 删除数组的第一个元素并将其返回</p>

<p>需要注意的是，当使用多个参数调用 unshift() 的时候，参数是一次性插入的，而非一次一个插入。这会影响插入到数组中元素的位置</p>

<pre><code class="javascript">var a = [4,5,6];
a.unshift(3)
a               // =&gt; [3,4,5,6]
a.unshift(1,2)
a               // =&gt; [1,2,3,4,5,6]如果一次一个插入的话结果应该是 [2,1,3,4,5]
</code></pre>

<h2>ECMAScript 5 的数组方法</h2>

<h3>forEach()</h3>

<p>forEach() 从头至尾遍历数组，为每个元素调用指定的函数。传递函数作为 forEach() 的第一个参数，然后 forEach() 使用三个参数调用该当函数：数组元素、元素的索引和数组本身。forEach() 无法在所有元素都传递给调用的函数之前终止遍历，除非 forEach() 方法放在一个 try 块中，并抛出一个异常</p>

<pre><code class="javascript">[1,2,3,4,5].forEach(function(value, index, arr) { arr[i] = v + 1 });
// =&gt; [2,3,4,5,6]
</code></pre>

<h3>map()</h3>

<p>map() 方法将调用数组的每个元素传递给指定的函数，并返回一个数组。如果是稀疏数组，返回的也是相同方式的稀疏数组</p>

<pre><code class="javascript">a = [1,2,3]
b = a.map(function(x) { return x*x })
b               // [1, 4, 9]
</code></pre>

<h3>filter()</h3>

<p>filter() 方法返回数组元素是调用数组的一个 <strong>子集</strong>。传递的函数是用来逻辑判定的（true 或 false），如果返回 true 或者能转化为 true 的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中，<strong>filter() 会跳过稀疏数组中缺少的元素</strong>，总是返回稠密的</p>

<pre><code class="javascript">a = [5,4,3,2,1]
smallvalues = a.filter(function(x) { return x &lt; 3 })    // [2, 1]
</code></pre>

<h3>every() 和 some()</h3>

<p>数组的逻辑判定，它们对数组元素应用指定的函数进行判定，返回 true 或 false</p>

<pre><code class="javascript">a = [1,2,3,4,5]
a.every(function(x) { return x &lt; 10 })      // =&gt; true 数组元素都少于 10
a.some(function(x) { return x%2 === 0 })    // =&gt; true 数组中有一些值是偶数
</code></pre>

<p>注意，一旦 every() 和 some() 确认应该返回什么值时它们就会停止遍历数组元素（可以认为是惰性判断）。即：</p>

<ul>
<li>some() 在判定函数第一次返回 true 后就返回 true，不再进行遍历操作</li>
<li>every() 在判定函数第一次返回 false 后就返回false，不再进行遍历操作</li>
</ul>


<h3>reduce() 和 reduceRight()</h3>

<blockquote><p>Array.reduce(callback, [initialValue])</p></blockquote>

<p>reduct() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值，这在 <strong>函数式编程（functional programming）</strong> 中是很常见的操作，也可以称为「注入」和「折叠」，他们只是执行化简操作的顺序不一样，一个从左到右，一个从右到左</p>

<pre><code class="javascript">var a = [1,2,3,4,5]
var sum = a.reduce(function(x, y) { return x + y }, 0)          // 数组求和
/**
+---------------------------------+
|                                 |
|     x      +     y     return   |
|                                 |
|   init: 0     a[0]: 1    1      |
|                                 |
|     1         a[1]: 2    3      |
|                                 |
|     3         a[2]: 3    6      |
|                                 |
|     6         a[3]: 4    10     |
|                                 |
|     10        a[4]: 5    15     |
|                                 |
+---------------------------------+
*/
var product = a.reduce(function(x, y) { return x * y }, 1)      // 数组求积
</code></pre>

<p>reduce 需要两个参数。第一个是执行化简操作的函数，它的任意就是用某种方法把两个值组合或化简为一个值，并返回化简后的值，第二个参数是传递给函数的初始值，如果没有指定初始值，它将使用数组的第一个元素作为其初始值。<strong>这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为 x,y</strong></p>

<h3>indexOf() 和 lastIndexOf()</h3>

<blockquote><p>Array.indexOf(searchElement[, fromIndex = 0])</p></blockquote>

<p>搜索整个数组中指定值的索引，没找到就返回 -1。indexOf() 从头至尾搜索，而 lastIndexOf() 则反向搜索。它们都接收第二个参数，指定数组中的一个索引，从这个索引处开始搜索</p>

<pre><code class="javascript">a = [0,1,2,1,0]
a.indexOf(1)        // =&gt; 1
a.lastIndexOf(1)    // =&gt; 3
a.indexOf(3)        // =&gt; -1

// 在数组中查找所有出现的 x，并返回一个包含匹配索引的数组
function findall(a, x) {
    var results = [];
    var len = a.length;
    var pos = 0;

    while(pos &lt; len) {
        pos = a.indexOf(x, pos);
        if (pos === -1) break;

        results.push(pos)
        pos = pos + 1;
    }

    return results;
}
findall([1,2,3,1,3,2], 1)       // =&gt; [0, 3]
</code></pre>

<h2>数组类型</h2>

<p>ECMAScript 5 中可以使用 Array.isArray() 函数来判断是否为数组，在 ECMAScript 5 之前判断却没这么简单，因为 typeof 运算符操作数组返回的是「对象」，一般用下面的方法下判断是否是数组</p>

<pre><code class="javascript">var isArray = Array.isArray || function(o) {
    return typeof o === "object" &amp;&amp;
            Object.prototype.toString.call(0) === '[object Array]';
};
</code></pre>

<h2>类数组对象</h2>

<p>JavaScript 数组的一些特性是其他对象没有的：</p>

<ul>
<li>当有新的元素添加到列表中时，自动更新 length 属性</li>
<li>设置 length 为一个较小值将截断数组</li>
<li>从 Array.prototype 中继承一些有用的方法</li>
<li>其类属性为「Array」</li>
</ul>


<p>以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的「元素」</p>

<pre><code class="javascript">var a = {}

var i = 0;
while (i &lt; 10) {
    a[i] = i * i;
    i++;
}
a.length = i;
a               // =&gt; { 0: 0, 1: 1, 2: 4, 3: 9 ..., length: 10 }

// 现在就可以当成真正的数组遍历它
var total = 0;
for (var j = 0; j &lt; a.length; j++) {
    total+=a[j]
}
</code></pre>

<p>Arguments 对象就是一个类数组对象，DOM 方法 document.getElementsByTagName() 也返回类数组对象，它们都有数组的一些特性，比如索引访问、length 属性，但它们并不是真正的数组</p>

<pre><code class="javascript">function isArrayLike(o) {
    if ( o &amp;&amp;
        typeof o === "object" &amp;&amp;
        isFinite(o.length) &amp;&amp;
        o.length &gt;= 0 &amp;&amp;
        o.length === Math.floor(o.length) &amp;&amp;
        o.length &lt; 4294967296 ) {       // 数组长度的最大值 2^32
        return true;
    } else {
        return false;
    }
}
</code></pre>

<p>JavaScript 数组方法是 <strong>特意定义为通用的</strong>，它们不仅可以应用在数组而且可以应用在类数组对象上，一般使用 Array.prototype.method.call 来使用</p>

<pre><code class="javascript">var a = {"0": "a", "1": "b", "2": "c", length: 3};
Array.prototype.join.call(a, "+")           // =&gt; "a+b+c"
</code></pre>

<h2>作为数组的字符串</h2>

<p>在 ECMAScript 5 中，字符串的行为类似于 <strong>只读</strong> 的数组。除子用 charAt() 方法来访问单个字符以外，还可以使用方括号：</p>

<pre><code class="javascript">var s = "test";
s.charAt(0)         // =&gt; "t"
s.[1]               // =&gt; "e"
</code></pre>

<p>字符串的行为类似于数组的事实使得通用的数组方法可以应用到字符串上。不过请记住，字符串是 <strong>不可变值</strong>，当把它们作为数组看待时，它们是只读的。所以诸如：push(), sort(), reverse 等 <strong>会修改数组</strong> 的方法 如果被使用在字符串上是无效的，而且会导致错误并且没有相关提示</p>

<pre><code class="javascript">s = "JavaScript"
Array.prototype.join.call(s, " ")       // =&gt; "J a v a S c r i p t"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 6 - 对象]]></title>
    <link href="http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-5/"/>
    <updated>2016-06-23T19:10:28+08:00</updated>
    <id>http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-5</id>
    <content type="html"><![CDATA[<p>对象是 JavaScript 的基本数据类型。是一种复合值：将很多值聚合在一起。对象可以看做是无序集合，每个属性都是一个名/值对。这种基本数据结构还有很多叫法，比如「散列」（hash）、「散列表」（hashtable）、「字典」（dictionary）、「关联数组」（associative array）。JavaScript 还可以从一个称为 <strong>原型</strong> 的对象继承属性</p>

<p>JavaScript 对象是动态的 —— 可以新增属性也可以删除属性，除了字符串、数字、布尔值、null 和 undefined 之外，JavaScript 中的值都是对象</p>

<p>对象是可变的，通过引用操作对象原对象也会受到影响</p>

<!--more-->


<p>属性包括名字和值。名字是可以包含空字符串在内的 <strong>任意字符串</strong>，值可以是任意 JavaScript 值，或者（在 ECMAScript 5中）可以是一个 getter 或者 setter （或都有），每个属性还有一些与之相关的值称为「属性特性」（property attribute）：</p>

<ul>
<li>可写（writable）</li>
<li>可枚举（enumerable）</li>
<li>可配置（configurable），表明是否可以删除或者修改</li>
</ul>


<p>ECMAScript 5 之前，<strong>通过代码给对象创建的所有属性都是可写、可枚举和可配置的</strong></p>

<p>除了包含属性之外，每个对象还拥有三个相关的对象特性（object attribute）：</p>

<ul>
<li>对象的原型（prototype）指向另外一个对象，本对象的属性继承自它的原型对象</li>
<li>对象的类（class）是一个标识对象类型的字符串</li>
<li>对象的扩展标记（extensible flag）指明了（在 ECMAScript 5 中）是否可以向该对象添加新属性</li>
</ul>


<p>下面这些术语用来区分三类 JavaScript 对象和两类属性：</p>

<ul>
<li>内置对象（native object），由 ECMAScript 规范定义的对象或类。例如 数组、日期</li>
<li>宿主对象（host object），由 JavaScript 解释器所嵌入的宿主环境（比如浏览器）定义的。比如浏览器中的 HTMLElement，document</li>
<li>自定义对象（user-defined object），由运行中的 JavaScript 代码创建的对象</li>
<li>自有属性（own property），直接在对象中定义的属性</li>
<li>继承属性（inherited property）是在对象的原型对象中定义的属性</li>
</ul>


<h2>创建对象</h2>

<h3>对象直接量</h3>

<pre><code class="javascript">var empty = {}
var point = { x:0, y:0 }
var point2 = { x:point.x, y:point.y + 1 }
var book = {
    "main title": "JavaScript",
    "for": "all audiences",
    author: {
        firstname: "David",
        surname: "Flanagan"
    }
}
</code></pre>

<p>在 ECMAScript 5 中，保留字可以用做不带引号的属性名。然后对于 ECMAScript 3 来说，使用保留字作为属性名必须使用引号引起来。ECMAScript 5 中属性最后一个逗号会被忽略，但在 IE 中则报错</p>

<h3>通过 new 创建对象</h3>

<p>new 运算符创建并初始化一个新对象。new 后跟随一个函数调用。这里的函数称做构造函数（constructor），用来初始化一个新创建的对象。JavaScript 语言核心的原始类型都包含内置构造函数（另一方面也证实了 JavaScript 中一切皆对象）</p>

<pre><code class="javascript">var o = new Object();
var a = new Array();
var d = new Date();
var r = new RegExp('js');
</code></pre>

<h3>原型</h3>

<p>每一个 JavaScript 对象（null 除外）都和另一个对象相关联，这个对象就是「原型」，每一个对象都从原型继承属性</p>

<p>通过 new 创建的对象原型就是构造函数的 prototype 属性值，通过 new Object() 创建的对象也继承自 Obejct.property</p>

<p>没有原型对象的为数不多，Obejct.prototype 就是其中之一。它不继承任何属性，普通对象都具有原型。所有的内置构造函数都具有一个继承自 Object.prototype 的原型。例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性现时继承自 Date.prototype 和 Object.prototype，这一系列链接的原型对象就是所谓的「原型链」（prototype chain）</p>

<h3>Object.create()</h3>

<p>ECMAScript 5 定义了一个名为 Obejct.create() 的方法，用来创建一个新对象，其中第一个参数是这个对象的原型，第二个可选参数用来对对象的属性进行进一步描述，Object.create() 是一个 <strong>静态函数</strong>，不是提供给对象调用的方法</p>

<pre><code class="javascript">var o1 = Object.create({ x:1, y:2 });       // o1 继承了属性 x 和 y
var o2 = Obejct.create(null);               // o2 不继承任何属性和方法
</code></pre>

<p>在 ECMAScript 3 中可以用类似代码来模拟原型继承：</p>

<pre><code class="javascript">function inherit(p) {
    if (p == null) throw TypeError();
    if (Object.create) return Object.create(p);

    var t = typeof p;
    if (t !== "object" &amp;&amp; t !== "undefined") throw TypeError();

    function f() {}
    f.prototype = p;

    return new f();
}

var o = { x: "test o" }

var c = inherit(o);

c.x = "test c";

console.log(c.x);       // =&gt; "test c"
console.log(o.x);       // =&gt; "test o"
</code></pre>

<h2>属性的查询和设置</h2>

<pre><code class="javascript">var author = book.author;           // 取得 book 的 author 属性
var title = book["main title"];     // 使用 [] 访问属性时 [] 内必须是一个计算结果为字符串的表达式

book.edition = 6;                   // 给 book 创建一个名为 edition 的属性，「.」号运算符后的标识符不能是保留字
</code></pre>

<h3>作为关联数组的对象</h3>

<p>当通过 [] 来访问对象属性时，属性名通过字符串来表示。字符串是 JavaScript 的数据类型，在程序运行时可以修改创建它们。因此，可以在 JavaScript 中使用下面这种代码来动态添加/查找属性：</p>

<pre><code class="javascript">var addr = "";
for (i = 0; i &lt; 4; i++) {
    addr += customer["address" + i] + '\n';
}
</code></pre>

<h3>继承</h3>

<p>假设要查询对象 o 的属性 x，如果 o 中不存在 x，那么将会继续在 o 的原型对象中查询属性 x。如果原型对象中也没有 x，但这个原型对象还有原型，那么继续在这个原型对象的原型上执行查找，直到找到 x 或者找到一个原型是 null 的对象为止。可以看出来，原型的属性构成了一个「链接」，通过这个「链」可以实现属性的继承</p>

<pre><code class="javascript">var o = {}
o.x = 1;

var p = inherit(o);
p.y = 2;

var q = inherit(p);
q.z = 3;

var s = q.toString();   // =&gt; "[object Object]"
q.x + q.y               // =&gt; 3
</code></pre>

<h3>属性访问错误</h3>

<p>属性访问并不总是返回或设置一个值，下页场景给对象 o 设置 属性 p 会失败：</p>

<ul>
<li>o 中的属性 p 是只读的（defineProperty() 方法中有一个例外，可以对可配置的只读属性重新赋值）</li>
<li>o 中不存在自有属性 p：o 没有使用 setter 方法继承属性 p，并且 o 的可扩展性（extensible attribute）是 false。如果 o 中不存在 p，而且没有 setter 方法可供调用，则 p 一定会添加至 o 中。如果 o 不是可扩展的，那么在 o 中不能定义新的属性</li>
</ul>


<h2>删除属性</h2>

<p>使用 delete 运算符可以删除对象的属性，delete 运算符只能删除 <strong>自有属性</strong>，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）</p>

<p>如果删除成功或者删除了一个没有影响的值（不存在的属性），delete 表达式返回 true。当 delete 运算符的操作数不是一个对象的属性的时候也返回 true</p>

<pre><code class="javascript">var o = { x: 1 }
delete o.x;             // =&gt; true
delete o.x;             // =&gt; true x 并不存在
delete o.toString;      // =&gt; true toString 是继承属性
delete 1                // =&gt; true 不是对象属性
this.b = 1;
delete b;               // =&gt; true 删除全局对象上的变量 b

delete Object.property  // =&gt; false
var x = 1;
delete this.x;          // =&gt; false 不能删除这个属性，因为是通过 var 声明的
function f() {}
delete f                // =&gt; false 不能删除全局函数
</code></pre>

<h2>检测属性</h2>

<p>可以通过 in 运算符、hasOwnProperty() 方法和 propertyIsEnumerable() 方法来检测对象是否存在某属性，propertyIsEnumerable 只有检测到是自有属性且这个属性的可枚举性为 true 时它才返回 true</p>

<pre><code class="javascript">var o = { x: 1 };
"x" in o;                          // =&gt; true
"y" in o;                          // =&gt; false
"toString" in o                    // =&gt; true

o.hasOwnProperty("x")              // =&gt; true
o.hasOwnProperty("y")              // =&gt; false
o.hasOwnProperty("toString")       // =&gt; false

var o = inherit({ y: 2});
o.x = 1;
o.propertyIsEnumerable("x")        // =&gt; true
o.propertyIsEnumerable("y")        // =&gt; false
o.propertyIsEnumerable("toString") // =&gt; false
</code></pre>

<p>还可以通过判断属性是否是 undefined 来模拟 in 运算符</p>

<pre><code class="javascript">o.x !== undefined;                 // =&gt; true
o.y !== undefined;                 // =&gt; false
o.toString !== undefined;          // =&gt; true
</code></pre>

<p>然而有一种场景只能使用 in 运算符而不能通过只判断 undefined 的方式。<strong>in 可以区分不存在的属性和存在但值为 undefined 的属性</strong></p>

<pre><code class="javascript">var o = { x: undefined }
o.x !== undefined           // =&gt; false 存在 x，只是值为 undefined
o.y !== undefined           // =&gt; false
"x" in o                    // =&gt; true
"y" in o                    // =&gt; false
delete o.x                  // =&gt; true
"x" in o                    // =&gt; false delete 后 o 完全不存在了
</code></pre>

<h2>枚举属性</h2>

<p>许多工具库给 Object.prototype 添加了新的方法或者属性（通常不建议这么做），这些方法和属性可以被所有对象继承并使用。然而在 ECMAScript 5 标签之前，这些添加的方法是 <strong>不能定义为不可枚举的</strong>，因此它们都可以在 for/in 循环枚举出来。为了避免这和践情况，需要过滤 for/in 循环返回的属性，下面两种方法是最常见的：</p>

<pre><code class="javascript">Object.prototype.test = 1;
var o = { a: 1, b:2, c: function() {} };
for (p in o) {
    if (!o.hasOwnProperty(p)) continue;
    console.log(p);
}
for (p in o) {
    if (typeof o[p] === "function") continue;
}
</code></pre>

<p>除了 for/in 循环之外，ECMAScript 5 定义了两个用以枚举属性名称的函数。第一个是 Object.keys()，它返回一个数组，由对象中的 <strong>可枚举的自有属性名称</strong> 组成，第二个是 Object.getOwnPropertyNames()，它和上面的方法类似，只是它返回对象的 <strong>所有自有属性名称</strong>，不仅仅是可枚举的属性</p>

<h2>属性 getter 和 setter</h2>

<p>在 ECMAScript 5 中，属性的值可以用一个或两个方法替代，这两个方法就是 getter 和 setter。由它们定义的属性称做「存取器属性」（accessor property），不同于「数据属性」（data property），数据属性只有一个简单的值</p>

<p>当程序查询存取器属性的值时，JavaScript 调用 getter 方法（无参数）。这个方法返回属性的存取表达式值。当程序设置一个存取器属性的值时，调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责「设置」属性值。可以忽略 setter 方法的返回值</p>

<p>使用存取器属性写入的属性不具有可写性（writable）。如果属性同时具有 getter 和 setter 方法，那么它是一个读/写属性。哪果它只有 getter 方法，那么它是一个只读属性。如果只有 setter 方法，那么它是一个只写属性，读取只写属性总是返回 undefined</p>

<pre><code class="javascript">var p = {
  x: 1.0,
  y: 1.0,

  get r() {
    return Math.sqrt(this.x*this.x + this.y*this.y);
  },
  set r(newValue) {
    var oldValue = Math.sqrt(this.x*this.x + this.y*this.y);
    var ratio = newValue/oldValue;

    this.x *= ratio;
    this.y *= ratio;
  },
  get theta() {
    return Math.atan2(this.y, this.x)
  }
};
p.r             // =&gt; 1.4142135623730951
</code></pre>

<h2>属性的特性</h2>

<p>除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。ECMAScript 3 程序创建的属性都是可写、可枚举、可配置的，且无法对这些特性做出修改。ECMAScript 5 中却提供了查询和设置这些属性鹅的 API，这些 API 对于库的开发者来说非常重要，因为：</p>

<ul>
<li>可以通过这些 API 给原型对象添加方法，并将它们设置成不可枚举的，<strong>让它们看起来更像内置方法</strong></li>
<li>可以通过这些 API 给对象定义不修改或删除的属性借此「锁定」这个对象</li>
</ul>


<p><strong>数据属性</strong> 的 4 个属性分别是它的值（value）、可写性（writable）、可枚举性（enumerable）和可配置性（configurable）</p>

<p><strong>存取器属性</strong> 不具有值（value）特性和可写性，它们的可写性是由 setter 方法存在与否决定，因此存取器属性的 4 个特性是读取（get）、写入（set）、可枚举性和可配置性</p>

<p>为了实现属性特性的查询和设置操作，ECMAScript 5 中定义了一个名为「<strong>属性描述符</strong>」（property descriptor）的对象，这个对象代表那 4 个特性。描述符对象的属性和它们所描述的属性特性是同名的。因此，数据属性的描述符对象的属性有 value, writable, enumerable 和 configurable。存取器属性描述符对象则用 get, set 属性代替 value, writable。其中 writable、enumerable 和 configurable 都是布尔值，get、set 都是函数值</p>

<p>通过调用 Object.getOwnPropertyDescriptor() 可以获得某个对象特定属性的属性描述符</p>

<pre><code class="javascript">// =&gt; {value: 1, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor({ x: 1}, "x")
var random = {
    get octet() {
        return Math.floor(Math.random() * 256)
    },
    get uint16() {
        return Math.floor(Math.random() * 65536)
    },
    get int16() {
        return Math.floor(Math.random() * 65536 - 32768)
    }
}
// =&gt; {set: undefined, get: function, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor(random, "octet")
// =&gt; undefined
Object.getOwnPropertyDescriptor({}, "x")
</code></pre>

<p>从函数名字就可以看出来 Object.getOwnPropertyDescriptor() 只能得到自有属性的描述符。继承属性的特性需要遍历原型链</p>

<p>要想设置属性的特性，或者让新建属性具有某种特性，则需要调用 Object.defineProperty()，传入要修改的对象、要创建或者修改的属性的名称以前属性描述符对象：</p>

<pre><code class="javascript">var o = {};
Object.defineProperty(o, "x", {
    value: 1,
    writable: true,
    enumerable: false,
    configurable: true
});
// x 属性存在但不可枚举
Object.keys()       // =&gt; []

Object.defineProperty(o, "x", { writable: false })
o.x = 2             // 试图更改这个属性的值，会操作失败不报错，严格模式中则抛出类型错误异常
o.x                 // =&gt; 1

// 将 x 从数据属性修改为存取器属性
Object.defineProperty(o, "x", { value: 2 })
Object.defineProperty(o, "x", { get: function() { return 0} }
o.x                 // =&gt; 0
</code></pre>

<p>传入 Object.defineProperty() 的属性描述符对象 <strong>不必</strong> 包含所有 4 个特性。对于创建属性来说，默认的特性值是 false 或 undefined。对于修改的已有属性来说，默认的特性值没有做任何修改。注意，这个方法要么修改已有属性要么新建自胡属性，但 <strong>不能修改继承属性</strong>，想要同时修改或者创建多个属性则需要使用 Object.defineProperties()，使用方法可以参考 MDN <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">相关 api</a></p>

<p>对于那些不允许创建或者修改的属性来说，如果用 Object.defineProperty() 对其操作就会抛出类型错误异常，比如给一个不可扩展的对象新增属性就会抛出类型错误异常。<strong>可写性控制着对特定值特性的修改，可配置性控制着对其它特性的修改</strong>，使用的时候以下情况会抛出类型错误异常：</p>

<ul>
<li>如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性</li>
<li>如果属性是不可配置的，则不能修改它的可配置性和可枚举性</li>
<li>如果存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性</li>
<li>如果数据属性是不可配置的，则不能将它转换为存取器属性</li>
<li>如果数据属性是不可配置的，则不能将它的可写性从 false 修改为 true，但可以从 true  修改为 false</li>
<li>如果数据属性是不可配置且不可写的，则不能修改它的值，然而 <strong>可配置但不可写的属性值是可以修改的</strong></li>
</ul>


<pre><code class="javascript">// 给 Object.prototype 添加一个不可枚举的 extend() 方法
// 这个方法继承自调用它的对象，将作为参数什入的对象属性都复制
Object.defineProperty(Object.prototype, "extend", {
    writable: true,
    enumerable: false,
    configurable: true,
    value: function(o) {
        var names = Object.getOwnPropertyNames(0);

        for (var i = 0, l = names.length; i &lt; l; i++) {
            if (names[i] in this) continue;

            var desc = Object.getOwnPropertyDescriptor(o, name[i]);
            Object.defineProperty(this, names[i], desc)
        }
    }
});
</code></pre>

<p><strong>getter 和 setter 的老式 API</strong></p>

<p>在ECMAScript 5标准被采纳之前，大多数 JavaScript 的实现（IE 除外）已经可以支持对象直接量语法中的 get 和 set 写法。这些实现提供了非标准的老式 API 用来查询和设置 getter 和 setter。这些 API 由 4 个方法组成，所有对象都拥有这些方法。<code>__lookupGetter__()</code> 和 <code>__lookupSetter__()</code> 用以返回一个命名属性的 getter 和 setter 方法，<code>__defineSetter__()</code> 和 <code>__defineGetter__()</code> 用以定义 getter 和 setter</p>

<h2>对象的三个属性</h2>

<p>每个对象都胡与之相关的 <strong>原型</strong>（prototype）、<strong>类</strong>（class）和 <strong>可扩展性</strong>（extensible attribute）</p>

<h3>原型属性</h3>

<p>原型属性是在实例对象创建之初就设置好的，ECMAScript 5 中，对象作为参数传入 <code>Object.getPrototypeOf()</code> 可以查看它的原型，在 ECMAScript 3 中，则没有与之等价的函数，但经常使用表达式 o.constructor.prototype 来检测一个对象的原型。通过 new 表达式创建的对象，通常继承一个 constructor 属性，这个属性指代创建这个对象的构造函数</p>

<p>要想检测一个对象是否是另一个对象的原型（或者处于原型链中），请使用 isPrototypeOf() 方法，这个方法和 instanceof 运算符非常类似，例如：</p>

<pre><code class="javascript">var p = { x:1 };
var o = Object.create(p);
p.isPrototypeOf(o)                  // =&gt; true
Object.prototype.isPrototypeOf(o)   // =&gt; true
</code></pre>

<h3>类属性</h3>

<p>对象的类属性是一个字符串，用以表示对象的类型信息。ECMAScript 3/5 都未提供设置这个属性的方法，并只有一种间接的方法可以查询它。默认的 toString() 方法（继承自 Object.prototype），返回了如下这种格式的字符串：</p>

<blockquote><p>[object class]</p></blockquote>

<p>所以可以通过 toString() 方法返回的字符串截取处理取到 class 名，不过很多对象继承的 toString() 方法被重写了，为了能调用正确的 toString() 版本，必须间接地调用 Function.call() 方法</p>

<pre><code class="javascript">function classof(o) {
    if (o === null) return "Null";
    if (o === undefined) return "Undefined";
    return Object.prototype.toString.call(o).slice(8, -2);
}
classof(null)     // =&gt; "Null"
classof(1)        // =&gt; "Number"
classof("")       // =&gt; "String"
classof(true)     // =&gt; "Boolean"
classof({})       // =&gt; "Object"
classof([])       // =&gt; "Array"
classof(/./)      // =&gt; "Regexp"
classof(new Date) // =&gt; "Date"
function f() {}
classof(new f())  // =&gt; "Object"
</code></pre>

<h3>可扩展属性</h3>

<p>可扩展性用以表示是否可以给对象是添加新属性。所有内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展属性是由 JavaScript 引擎定义的，ECMAScript 5 中，所有的内置对象和自定义对象都是可扩展的，除非将它们转换为不可扩展的，宿主对象的可扩展性也是由实现 ECMAScript 5 的 JavaScript 引擎定义的</p>

<p>ECMAScript 5 定义了用来查询和设置对象可扩展性的函数：Object.isExtensible()，如果将对象转换为不可扩展的，需要调用 Object.preventExtensions()，不过一量旦将对象转换为不可扩展的，就无法再转换回去了。</p>

<p>Object.seal() 和 Object.preventExtensions() 类似，除了能将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的，也就是说不能给对象添加新的属性，已有的属性也不能删除或配置，已封闭（sealed）的对象是不能解封的，可以使用 Object.isSealed() 来检测对象是否封闭</p>

<p>Object.freeze() 将更严格地锁定对象 —— 「冻结」，它还可以将它自有的所有数据属性设置为只读，可以使用 Object.isFrozen() 来检测对象是否冻结</p>

<h2>序列化对象</h2>

<p>对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript 5 提供了内置函数 JSON.stringify 和 JSON.parse() 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON的全称是「JavaScript Object Notation」—— JavaScript 对象表示法，正如其名，它的语法和 JavaScript 对象与数组直接量的语法非常相近</p>

<p>ECMAScript 3 环境中可以引用 <a href="https://github.com/douglascrockford/JSON-js">json2</a> 类库来支持这两个序列化函数</p>

<p>JSON 语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值，函数、RegExp、Error 对象和 undefined 值不能序列化和不愿。JSON.stringify() <strong>只能序列化对象可枚举的自有属性</strong>，关于 JSON 对象更多 API 可以参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify</a></p>

<h2>对象方法</h2>

<h3>toString() 方法</h3>

<p>toString() 方法没有参数，在需要将对象转换为字符串的时候，JavaScript 都调用这个方法</p>

<pre><code class="javascript">var s = { x: 1, y: 1 }
s.toString();       // =&gt; "[object Ojbect]"
</code></pre>

<h3>toLocaleString() 方法</h3>

<p>返回一个对象的本地化字符串。Object 中默认的 toLocaleString() 方法并不做任何本地化自身操作，它仅调用 toString() 方法并返回值。Date 和 Number 类对 toString() 方法做了定制，可以用它对数字、日期和时间做本地化的转换</p>

<h3>toJSON() 方法</h3>

<p>Object.prototype 实际上不有定义 toJSON() 方法，但对于需要执行序列化的对象来说，JSON.stringify() 方法会调用 toJSON() 方法，如果存在则调用它，返回值即是序列化的结果，而不是原始对象，参见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toJSON">Date.toJSON</a></p>

<h3>valueOf() 方法</h3>

<p>valueOf() 和 toString() 方法非常类似，但往往当 JavaScript 需要 <strong>将对象转换为某种原始值而非字符串</strong> 的时候才会用到它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript 就会自动调用这个方法，同样有些内置类自定义了 valueOf() 方法，比如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/valueOf">Date.valueOf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 5 - 语句]]></title>
    <link href="http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-4/"/>
    <updated>2016-06-23T19:10:28+08:00</updated>
    <id>http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-4</id>
    <content type="html"><![CDATA[<p>表达式在 JavaScript 中是短语（phrases），那么语句（statements）就是 JavaScript 整句或命令，语句以分号结束。表达式计算出一个值，语句用来执行以使某件事情发生</p>

<!--more-->


<h2>表达式语句</h2>

<p>赋值语句、递增/减运算、delete 运算符删除对象属性、函数调用都是表达式语句</p>

<pre><code class="javascript">gretting = "Hello " + name;
i *= 3;
count++;
delete o.x;
alert(greeting)
window.close();
Math.cos(x)
cs = Math.cos(x);
</code></pre>

<h2>复合语句和空语句</h2>

<p>逗号运算符将几个表达式连接在一起形成一个表达式，同样，JavaScript 中还可以将多条语句联合在一起，形成一条复合语句（compound statement）。只须用花括号括起来即可，下面几行代码就可以当成一条单独语句</p>

<pre><code class="javascript">{
    x = Math.PI;
    cx = Math.cos(x);
    console.log("cos(x) = " cx);
}
</code></pre>

<p>需要注意的两点：</p>

<ul>
<li>语句块的结尾不需要分号。块中的原始语句 <strong>必须</strong> 以分号结束</li>
<li>语句块中的行缩进不是必须的，但是合理的缩进更容易理解</li>
<li>语句块并没有块级作用域名，语句块中声明的变量不是语句块私有的</li>
</ul>


<p>空语句（empty statement）允许包含 0 条语句，空语句在初化一个数组时偶尔会用到</p>

<pre><code class="javascript">var a = Array(50);
a                                           // =&gt; [undefined,,,,undefined]
for (i = 0; i &lt; a.length; a[i++] = 0) ;     // 初始化一个数组，注意末尾的分号不能少
a                                           // =&gt; [0,,,0]
</code></pre>

<p>这个循环中，所有操作都在表达式 a[i++]=0 中完成，这里并不需要任何循环体。然而 JavaScript 需要循环体中 <strong>至少包含一条语句</strong>，因此，这里只使用了一个单独的分号来表示一条空语句</p>

<h2>声明语句</h2>

<p>var 和 function 都是声明语句，声明语句本身什么也不做，只用来更好地组织代码的语义</p>

<h3>var</h3>

<p>var 语句用来声明一个或者多个变量，用法如下：</p>

<pre><code class="javascript">var name_1 [= value_1] [,..., name_n [= value_n]]
</code></pre>

<p>如果 var 语句出现在函数体内，那么它定义的是一个 <strong>局部变量</strong>，其作用域就是这个函数，如果在顶层代码中使用 var 语句，它声明的是 <strong>全局变量</strong>，整个程序中都是可用的</p>

<p>全局变量是全局对象的属性。然而通过 var 声明的全局变量 <strong>无法</strong> 通过 delete 删除</p>

<p>如果 var 语句中的变量没有指定初始化表达式，那么这个变量的值初始为 undefined</p>

<h3>function</h3>

<p>函数声明的语句的语法如下：</p>

<pre><code class="javascript">function fun_name([arg1 [, arg2 [..., argn]]]) {
    statements
}
</code></pre>

<pre><code class="javascript">var f = function(x) { return x+1; };        // 通过 var 声明函数
function f(x) { return x+1; }
</code></pre>

<h2>条件语句</h2>

<h3>if</h3>

<pre><code class="javascript">if (expression) {
    statement
}
</code></pre>

<p>这种形式中，需要计算 expression 的值，如果结果是真值，那么就执行 statement</p>

<p>为了避免歧义，建议 <strong>总是</strong> 给 if 语句添加花括号</p>

<h3>else if</h3>

<pre><code class="javascript">if (expression) {
    statement
} else if (expression) {
    statement
}
</code></pre>

<h3>switch</h3>

<pre><code class="javascript">switch(expression) {
    statement
}
</code></pre>

<h2>循环</h2>

<h3>while</h3>

<pre><code class="javascript">var count = 0;
while (count &lt; 10) {
    console.log(count);
    count++
}
</code></pre>

<h3>do/while</h3>

<pre><code class="javascript">function printArray(a) {
    var len = a.length, i = 0;
    if (len == 0) {
        console.log('Empty Array);
    } else {
        do {
            console.log(a[i]);
        } while(++i &lt; len);
    }
}
</code></pre>

<h3>for</h3>

<p>for 循环的 <strong>执行顺序</strong> 是：</p>

<ol>
<li>initialize</li>
<li>test 条件为真</li>
<li>statement</li>
<li>increment</li>
</ol>


<pre><code class="javascript">for (initialize; test; increment) {
    statement
}
</code></pre>

<p>多数情况下与之等价的 while 循环写法：</p>

<pre><code class="javascript">initialize;
while(test) {
    statement
    increment;
}
</code></pre>

<h3>for/in</h3>

<pre><code class="javascript">for (variable in object) {
    statement
}
</code></pre>

<p>variable 通常是一个变量名（也可以是个表达式），也可以是一个可以产生左值的表达式或者一个通过 var 语句声明的变量，总之必须是一个适用于赋值表达式左侧的值。object 是一个 <strong>表达式</strong>，这个表达式计算结果是一个对象</p>

<p>在执行 for/in 语句的过程中，JavaScript 解释器首先计算 object 表达式。如果表达式为 null 或者 undefined，解释器将会跳过循环并执行后续代码（ECMAScript 3 可能会抛出一个类型错误异常）。如果表达式等于一个原始值，这个原始值将会转换为与之对应的 <a href="/2016/06/16/javascript-definitive-guide-note-2/">包装对象</a>（wrapper object）否则，expression 本身已经是对象了。JavaScript 会依次遍历 <strong>可枚举</strong> 的对象属性来执行循环体语句</p>

<p>for/in 循环并不会遍历对象的所有属性，只有「可枚举」（emumerable）的属性才会遍历到。JavaScript 语言核心所定义的内置方法就 <strong>不是</strong>「可枚举的」，比如，所有对象都有方法 toString()，但 for/in 循环并不枚举 toString 这个属性，还有很多内置属性也是不可枚举的（nonenumerable）。而代码中定义的所有属性和方法都是可枚举的</p>

<p><strong>属性枚举的顺序</strong></p>

<p>ECMAScript 规范并没有指定 for/in 循环按照何种顺序来枚举对象属性。但实际上，主流浏览器厂商的 JavaScript 实现是按照 <strong>属性定义的先后顺序</strong> 来枚举简单对象的属性</p>

<h2>跳转</h2>

<p>JavaScript 中另一类语句是跳转语句（jump statement）。通常有 break, continue, return, throw</p>

<h3>标签语句</h3>

<p>语句是可以添加标签的，标签由语句前的标识符和冒号组成：</p>

<pre><code class="javascript">indetifier: statement
</code></pre>

<p>标识符必须是一个合法的 JavaScript 标识符</p>

<pre><code class="javascript">mainloop: while(token != null) {
    // statement
    continue mainloop;
}
</code></pre>

<h3>break 语句</h3>

<p>单独使用 break 语句的作用是立即退出最内层的 <strong>循环</strong> 或者 <strong>switch 语句</strong>，break 关键字后面也可以跟一个语句标签，当 break 和标签一块使用时，程序将跳转到这个标签所标识的语句块的结束</p>

<p><strong>不管 break 语句带不带标签，它的控制权都无法超过函数的边界</strong></p>

<h3>continue 语句</h3>

<p>类似于 break，但是它不退出循环，而是转而执行下一次循环。continue 语句只能在循环体内使用，其它地方使用会报错</p>

<p>在不同类型的循环中，continue 的行为也是有所区别：</p>

<ul>
<li>在 while 循环中，在循环开始处指定的 expression 会重复检测，如果检测结果为 true，循环休会从头开始执行</li>
<li>在 do/while 循环中，程序的执行直接跳到循环结尾处，这里会重新判断循环条件，之后才会继续下一次循环</li>
<li>在 for 循环中，首先计算自增表达式，然后再次检测 test 表达式，用以判断是否执行循环体</li>
<li>在 for/in 循环中，循环开始遍历下一个属性名，这个属性名赋给了指定的变量</li>
</ul>


<p>需要注意的是 continue 语句在 while 和 for 循环中的区别，while 循环直接进入一下轮的循环条件判断，但 for 循环首先计算其 increment 表达式，然后判断循环条件，所以 for 循环并不能完全等价模拟出 while 循环</p>

<pre><code class="javascript">// while 语句中的写法会造成死循环，for 语句则不会
// for 语句中的 increment 表达式总是会执行到
var i = 0;
while (i &lt; 10) {
    if (i &lt; 5 ) {
        continue;
    }
    console.log(i);
    i++;
}

for (var k = 1; k &lt; 10; k++) {
    if (k &lt; 5) {
        continue;
    }
    console.log(k);
}
</code></pre>

<h3>return 语句</h3>

<pre><code class="javascript">return expression;
</code></pre>

<p>return 语句 <strong>只能</strong> 出现在函数体内，如果不是的话会报语法错误。当执行到 return 语句的时候，函数终止执行，并返回 expression 的值给调用程序，例如：</p>

<pre><code class="javascript">function square(x) { return x*x; }
square(2)   // =&gt; 4
</code></pre>

<p>return 可以单独使用而不必带有 expression，这样的话函数会向调用程序返回 undefined</p>

<h3>throw 语句</h3>

<p>所谓异常（exception）是当发生了落地生根异常情况或错误时产生的一个信号。抛出异常（throw exception），就是用信号通知发生错误或者异常头部。捕获（catch）异常是指处理这个信号，即采取必要的手段从异常中恢复</p>

<pre><code class="javascript">throw expression;
</code></pre>

<p>expression 的值可以是任意类型的。当 JavaScript 解释器抛出异常的时候通常采用 Error 类型和其子类型</p>

<pre><code class="javascript">function factorial(x) {
    // 如果输出参数是非法的，则抛出一个异常
    if (x &lt; 0) throw new Error('x 不能是负数');
    for (var f = 1; x &gt; 1; f*= x, x--) ;
    return f;
}
</code></pre>

<p>当异常招聘时，JavaScript 解释器会 <strong>立即停止</strong> 当前正在执行的逻辑，并跳转到 <strong>就近的</strong> 异常处理程序。异常钼是程序是用 try/catch/finally 语句的 catch 从句编写的，JavaScript 会沿着方法的词法结构和调用栈向上传播</p>

<h3>try/catch/finally 语句</h3>

<p>try 从句定义了需要处理的异常所有代码块。catch 从句跟在其后，当 try 块内某处发生了异常时，调用 catch 内的代码逻辑。catch 从句后跟随 finally 块，后者中放置清理代码，不管 try 块中是否产生异常，finally 块内的逻辑总是会执行。尽管 catch 和 finally 都是可先的，但 try 从句需要至少二者之一（catch/finally）与之组成完整的语句。</p>

<p>try, catch 和 finally 语句块都 <strong>必须</strong> 使用花括号括起来，即使只有一条语句</p>

<pre><code class="javascript">try {
    // 通常来讲，这里的代码会从头执行到尾而不会产生任何问题，
    // 但有时会招聘一个异常，要么是由 throw 语句直接抛出，要
    // 么是通过调用一个方法间接抛出异常
} catch (e) {
    // 当且仅当 try 语句块抛出了异常，才会执行这里的代码
    // 这里可以通过局部变量 e 来警告对 Error 对象或者抛出的其他值的引用
    // 还可以通过 throw 语句重新抛出异常
} finally {
    // 不管 try 语句是否抛出了异常，这里的逻辑总是会执行，终止 try 语句块的方式有：
    // 1. 正常终止，执行完语句块的最后一条语句
    // 2. 通过 break, continue 或 return 语句终止
    // 3. 抛出一个异常，异常被 catch 从句捕获
    // 4. 抛出一个异常，异常未被捕获，继续向上传播
}
</code></pre>

<p>一般来说 JavaScript 使用 try/catch 语句的时候很少使用 finally。通常在一些后端语言 IO 操作中使用 finally 的比较多，比如打开一个文件，出现异常或者正常执行完 try 从句都需要关闭文件句柄</p>

<h2>其它语句类型</h2>

<p>with, debugger 和 use strict</p>

<h3>with 语句</h3>

<p>with 语句用于临时扩展作用域链，语法如下：</p>

<pre><code class="javascript">with (object) {
    statement
}
</code></pre>

<p>这条语句将 object 添加到 <strong>作用域链的头部</strong>，然后执行 statement，最后把作用域链恢复到原始状态</p>

<p>严格模式中是禁止使用 with 语句的，并且在非严格模式里也是 <strong>不推荐</strong> 使用 with 语句的。使用 with 语句的 JavaScript 代码非常难于优化，并且和没有使用 width 语句的代码相比，运行更慢</p>

<p>在对象嵌套层次很深的时候通常会使用 with 语句来简化代码编写。比如：</p>

<pre><code class="javascript">document.forms[0].address.value = 'a'
document.forms[0].name.value = 'b'
document.forms[0].job.value = 'c'

// 等价于
with (document.forms[0]) {
    address.value = 'a'
    name.value = 'b'
    job.value = 'c'
}
// 使用 with 语句减少了对象访问前缀，但是仍然可以不使用 with 解决这个问题
// 使用变量 f 缓存对象引用
var f = document.forms[0];
f.address.value = 'a'
f.name.value = 'b'
f.job.value = 'c'
</code></pre>

<p>只有在查找标识符的时候才会用到作用域链，创建新的变量的时候不使用</p>

<pre><code class="javascript">var d = 0;
var o = { a: 1, b: 2, c: 3};

with(o) {
   a = 2;
   d = 1
}
d           // =&gt; 1
o           // =&gt; {a: 2, b: 2, c: 3}
</code></pre>

<h3>debugger 语句</h3>

<p>debugger 语句通常什么也不做。当调试程序可用并运行的时候，JavaScript 解释器将会（非必需）以调试模式运行。这条语句用来产生一个断点（breakpoint），JavaScript 代码的挂靠会停止在断点的位置，这时可以使用调试器转出当前的变量、调用栈等</p>

<p>ECMAScript 5 中，debugger 语句正式加入到了语言规范里，在此之前注流浏览器厂商基本都已经实惠过了</p>

<h3>&lsquo;use strict&rsquo;</h3>

<p>&lsquo;use strict&rsquo; 是 ECMAScript 5 引入的一条指定。非常类似语句但不是，区别在于：</p>

<ul>
<li>它 <strong>不包含</strong>任何语言的关键字，指令仅仅是一个包含一个特殊字符串直接量的表达式，它是一条没有副作用的表达式语句，什么也没做</li>
<li>它只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。但不必一定出现在脚本或者函数休内的首行</li>
</ul>


<p>使用 &lsquo;use strict&rsquo; 指令的目的是说明（脚本或函数中）后续的代码将会解析为严格代码</p>

<p>严格代码以 <strong>严格模式</strong> 执行，严格模式悠了语言的重要缺陷，并提供健壮的查氏功能和增强的安全机制，和非严格模式的区别如下：</p>

<ul>
<li>严格模式中 <strong>禁止</strong> 使用 width 语句</li>
<li>严格模式中，所有的变量都要先声明，如果给一个未声明的变量、函数、函数参数、catch 从句参数或全局对象的属性赋值，将会抛出一个引用错误异常</li>
<li>严格模式中，调用的函数（不是方法）中的一个 this 值是 undefined（非严格模式下 this 值总是全局对象），可以利用这个特性来判断当前的 JavaScript 是否支持严格模式 <code>var hasStrictMode = (function() { "use strict"; return this === undefined }())</code></li>
<li>严格模式中，给只读属性赋值和给不可扩展的对象创建新成员都将抛出一个类型错误异常（非严格模式中不会报错）</li>
<li>严格模式中，传入 eval() 的代码不能在调用程序所在的上下文中声明变量或定义函数，非严格模式中可以</li>
<li>严格模式中，函数里的 arguments 对象拥有传入函数值的 <strong>静态副本</strong>。非严格模式下，arguments 里的数组元素和函数参数都指向同一个值的引用</li>
<li>严格模式中，当 delete 运算符后跟随非法的标识符（变量、函数、当函数参数）时，将会抛出一个语法错误异常</li>
<li>严格模式中试图删除一个 <strong>不可配置</strong> 的属性将抛出一个类型错误异常（非严格模式中，返回 false）</li>
<li>严格模式中，一个对象直接量中定义两个或多个 <strong>同名属性</strong> 将产生一个语法错误</li>
<li>严格模式中，函数声明中存在两个或多个同名参数将产生一个语法错误</li>
<li>严格模式中，<strong>不允许使用八进制</strong> 整数直接量（以 0 为前缀）</li>
<li>严格模式中，标识符 eval 和 arguments 当做关键字，它们的值是不能更改的，不能给它们赋值，也不能把它们声明为变量、函数名</li>
<li>严格模式中，限制了对调用栈的检测能力，在严格模式的函数中，arguments.caller 和 arguments.callee 都会抛出一个类型错误异常</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 4 - 表达式和运算符]]></title>
    <link href="http://keelii.github.io/2016/06/20/javascript-definitive-guide-note-3/"/>
    <updated>2016-06-20T19:10:28+08:00</updated>
    <id>http://keelii.github.io/2016/06/20/javascript-definitive-guide-note-3</id>
    <content type="html"><![CDATA[<p>表达式（expression）是 JavaScript 中的一个短语（phrases），JavaScript 解释器会将其计算（evaluate）出一个结果。程序中的常量、变量名、数组访问等都是表达式</p>

<p>简单表达式组合成复杂表达式最常用的方法就是使用运算符（operator）</p>

<!--more-->


<h2>原始表达式</h2>

<p>是最简单的表达式是「原始表达式」（primary expression）。是表达式的 <strong>最小单位</strong> ———— 不再包含其他表达式。常量、直接量、关键字、变量都是原始表达式</p>

<pre><code>1.23
"hello"
/pattern/

true
false
null
this

i
sum
undefined
</code></pre>

<h2>对象和数组的始化表达式</h2>

<p>对象和数组的始化表达式实际上是一个新创建的对象和数组，这些表达式有时也称做「对象直接量」和「数组直接量」</p>

<pre><code class="javascript">[]
[1+2, 3+4]

var sparseArray = [1,,,,,5]           // 数组分割逗号之前的元素可以省略，空位默认填充 undefined
var matrix = [[1,2,3], [4,5,6], [7,8,9]]

var p = { x: 2.3, y: -1.2}
var q = {}
q.x = 2.3; q.y = -1.3
</code></pre>

<p>JavaScript 对数组始化表达式进行求值的时候，数组初始化表达式中的元素表达式也都会各自计算一次。也就是说，数组初始化表达式每次计算的值有可能是不同的</p>

<h2>函数定义表达式</h2>

<pre><code class="javascript">var square = function(x) { return x*x }
</code></pre>

<h2>属性访问表达式</h2>

<pre><code class="javascript">// expression.identifier
// expression[expression]

var o = { x:1, y:{z:3} };
var a = [0, 4, [5, 6]];
o.x             // =&gt; 1 表达式 o 的 x 属性
o.y.z           // =&gt; 3 表达式 o.y 的属性 z
o["x"]          // =&gt; 1 对象 o 的 x 属性
a[1]            // =&gt; 4 表达式 a 中索引为 1 的元素
a[2]["1"]       // =&gt; 6 表达式 a[2] 中索引为 1 的元素
a[0].x          // =&gt; 1 表达式 a[0] 的 x 属性
</code></pre>

<p>不管使用哪种形式的属性访问表达式，在「.」和「[」 <strong>之前的表达式总是会首先计算</strong>。如果计算结果是 null 或者 undefined，表达式会抛出一个类型错误异常，因为这两个值都不能包含任意属性。如果运算结果不是对象（或者数组），JavaScript 会将其转换为对象。如果对象表达式后跟随一对方括号，则会计算方括号内的表达式的值并将它转换为字符串，<strong>不论哪种情况</strong>，如果命名的属性不存在，那么整个属性访问表达式的值就是 undefined</p>

<h2>调用表达式</h2>

<p>JavaScript 中的调用表达式（invocation expression）是一种调用（或者执行）函数或者方法的语法表示。它以一个函数表达式开始，后面跟随一对圆括号，括号内是一个以逗号隔开的参数列表</p>

<pre><code class="javascript">f(0)
Math.max(x, y, z)
a.sort()
</code></pre>

<h2>对象创建表达式</h2>

<pre><code class="javascript">new Object()
new Point(2, 3)

// 如果不需要传入参数给构造函数，圆括号可以省略
new Object
new Date
</code></pre>

<h2>运算符概述</h2>

<p>JavaScript 中的运算符用于自述表达式、比较表达式、逻辑表达式、赋值表达式等。大多数运算符都是由标点符号表示的，比如：「+」和「= 」，另外的一些运算符则是由关键字表示的，比如：delete 和 instanceof。</p>

<p><em>表4-1</em></p>

<table>
<thead>
<tr>
<th> 运算符      </th>
<th> 操作                   </th>
<th style="text-align:center;"> A      </th>
<th style="text-align:center;"> N     </th>
<th> 类型             </th>
</tr>
</thead>
<tbody>
<tr>
<td> ++          </td>
<td> 前/后增量              </td>
<td style="text-align:center;"> R      </td>
<td style="text-align:center;"> 1     </td>
<td> lval→num         </td>
</tr>
<tr>
<td> &ndash;          </td>
<td> 前/后增量              </td>
<td style="text-align:center;"> R      </td>
<td style="text-align:center;"> 1     </td>
<td> lval→num         </td>
</tr>
<tr>
<td> -           </td>
<td> 求反                   </td>
<td style="text-align:center;"> R      </td>
<td style="text-align:center;"> 1     </td>
<td> num→num          </td>
</tr>
<tr>
<td> +           </td>
<td> 转换为数字             </td>
<td style="text-align:center;"> R      </td>
<td style="text-align:center;"> 1     </td>
<td> num→num          </td>
</tr>
<tr>
<td> ~           </td>
<td> 按位求反               </td>
<td style="text-align:center;"> R      </td>
<td style="text-align:center;"> 1     </td>
<td> int→int          </td>
</tr>
<tr>
<td> !           </td>
<td> 逻辑非                 </td>
<td style="text-align:center;"> R      </td>
<td style="text-align:center;"> 1     </td>
<td> bool→bo          </td>
</tr>
<tr>
<td> delete      </td>
<td> 删除属性               </td>
<td style="text-align:center;"> R      </td>
<td style="text-align:center;"> 1     </td>
<td> lval→bool        </td>
</tr>
<tr>
<td> typeof      </td>
<td> 检测操作数类型         </td>
<td style="text-align:center;"> R      </td>
<td style="text-align:center;"> 1     </td>
<td> any→str          </td>
</tr>
<tr>
<td> void        </td>
<td> 返回 undefined 值      </td>
<td style="text-align:center;"> R      </td>
<td style="text-align:center;"> 1     </td>
<td> any→undef        </td>
</tr>
<tr>
<td> *, /, %     </td>
<td> 乘、除、求余           </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> num,num→num      </td>
</tr>
<tr>
<td> +, -        </td>
<td> 加减                   </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> num,num→num      </td>
</tr>
<tr>
<td> +           </td>
<td> 字符串链接             </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> str,str→str      </td>
</tr>
<tr>
<td> &lt;&lt;          </td>
<td> 左移位                 </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> int,int→int      </td>
</tr>
<tr>
<td> >>          </td>
<td> 有符号右移             </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> int,int→int      </td>
</tr>
<tr>
<td> >>>         </td>
<td> 无符号右移             </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> int,int→int      </td>
</tr>
<tr>
<td> &lt;, &lt;=,>, >= </td>
<td> 比较顺序               </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> num,num→bool     </td>
</tr>
<tr>
<td> &lt;, &lt;=,>, >= </td>
<td> 比较在字母表中的顺序   </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> str,str→bool     </td>
</tr>
<tr>
<td> instanceof  </td>
<td> 测试对象类             </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> obj,func→bool    </td>
</tr>
<tr>
<td> in          </td>
<td> 测试属性是否存在       </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> str,obj→bool     </td>
</tr>
<tr>
<td> ==          </td>
<td> 判断相等               </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> any,any→bool     </td>
</tr>
<tr>
<td> !=          </td>
<td> 判断不等               </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> any,any→bool     </td>
</tr>
<tr>
<td> ===         </td>
<td> 判断恒等               </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> any,any→bool     </td>
</tr>
<tr>
<td> !==         </td>
<td> 判断非恒等             </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> any,any→bool     </td>
</tr>
<tr>
<td> &amp;           </td>
<td> 按位与                 </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> int,int→int      </td>
</tr>
<tr>
<td> ^           </td>
<td> 按位异或               </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> int,int→int      </td>
</tr>
<tr>
<td> |          </td>
<td> 按位或                 </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> int,int→int      </td>
</tr>
<tr>
<td> &amp;&amp;          </td>
<td> 按位与                 </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> any,any→any      </td>
</tr>
<tr>
<td> ||        </td>
<td> 逻辑或                 </td>
<td style="text-align:center;"> L      </td>
<td style="text-align:center;"> 2     </td>
<td> any,any→any      </td>
</tr>
<tr>
<td> ?:          </td>
<td> 条件运算符             </td>
<td style="text-align:center;"> R      </td>
<td style="text-align:center;"> 3     </td>
<td> bool,any,any→any </td>
</tr>
<tr>
<td> =           </td>
<td> 变量赋值或对象属性赋值 </td>
<td style="text-align:center;"> R      </td>
<td style="text-align:center;"> 2     </td>
<td> lval,any→any     </td>
</tr>
<tr>
<td> *=, /=, %=, += <br> -=, &amp;=, ^=, | = <br> &lt;&lt;=, >>=, >>>= </td>
<td> 运算且赋值 </td>
<td style="text-align:center;"> R </td>
<td style="text-align:center;"> 2 </td>
<td> lval,any→any </td>
</tr>
</tbody>
</table>


<h3>操作数的个数</h3>

<p>运算符可以根据操作数的个数进行分类，JavaScript 中的大多数运算符（比如「*」乘法运算符）是一个二元运算符（binary operator），将两个表达式合并成一个稍复杂的表达式。JavaScript 同样支持一元运算符（unary operator），表达式 -x 中的「-」运算符就是一个一元运算符，是将操作数 x 求负值。JavaScript 支持一个三元运算符（ternary operator），条件判断运算符「?:」，它将三个表达式合并成一个表达式</p>

<h3>操作数的类型和结果类型</h3>

<p>JavaScript 运算符通常会根据需要对操作数进行类型转换。乘法运算符「*」希望操作数为籽安，但是表达式 &ldquo;3&rdquo; * &ldquo;5&rdquo; 却是合法的，因为 JavaScript 会将操作数转换为数字。结果是数字类型的 15</p>

<p>一些运算符对操作数类型有着不同程度的依赖。比如加法运算符「+」可以对数字进行加法，也可以做字符串连接。同样「&lt;」比较运算符可以进行数值大小比较，也可以比较字符在字母表中的次序先后</p>

<h3>左值（lvalues）</h3>

<p>左传是一个古老的术语，它指「表达式只能出现在赋值运算符的左侧」。在 JavaScript 中，变量、对象属性、数组元素均是左值，ECMAScript 规范中允许内置函数返回一个左值，但自定义函数则不能</p>

<h3>运算符的副作用（opreator side effects）</h3>

<p>计算一个简单的表达式（比如 2*3）不会对程序的运行状态造成任何影响，程序后续执行的计算也不会受到该计算的影响。而有一些表达式则具有很多副作用，赋值运算符是最明显的一个例子：如果给一个变量或者属性赋值，那么那些使用这个变量或者属性的表达式的值都会发生改变。「++」和「&ndash;」与些类似，因为它们包含 <strong>隐式的</strong> 赋值。delete 运算符同样有副作用删除一个属性就像（但不完全一样）给这个属性赋值 undefined</p>

<h3>运算符优先级</h3>

<p>如果你不确定你所使用的运算符的优先级，最简单的方法就是使用圆括号来强行指定运算次序</p>

<h3>运算符的结合性</h3>

<p>表 4-1 标题为 A 的列说明了运算符的结合性。<strong>L 指从左至右结合，R 指从右至左结合</strong>。结合性指定了在多个具有同样优先级的运算符表达式中的运算顺序。</p>

<pre><code class="javascript">w = x - y - z;              // 减法运算符具有从左至右的结合性
x = ~-y                     // 等价于 ~(-y)
w = x = y = z               // 等价于 w = (x = (y = z))
q = a?b:c?d:e?f:g           // 等价于 q = a?b:(c?d:(e?f:g))
</code></pre>

<h3>运算顺序</h3>

<p>运算符优先级和结合性规定了它们在复杂的表达式中的运算顺序，但并没有规定子表达式的计算过程中的运算顺序。JavaScript 总是严格按照从左至右的顺序来计算表达式。例如，在表达式 w = x + y * z 中，将首先计算子表达式 w， 然后计算 x, y 和 z，然后，y,z 相乘，再加上 x 的值，最后赋值给表达式 w 所指代的变量或者属性</p>

<p>假设存在 a = 1，那么「b = (a++) + a」将如何计算呢？</p>

<ol>
<li>计算 b</li>
<li>计算 a++ （假设为 c）</li>
<li>计算 a</li>
<li>计算 c + a</li>
<li>将 c + a 的结果赋值给 b</li>
</ol>


<p>按照「++」的定义，第 [2] 步中 a++ 的结果依然是 1，即 c 为 1，随后 a 立即增 1， 因此在执行第 [3] 步时，a 的值已经是 2。所以 b 的结果为 3</p>

<h2>算术表达式</h2>

<p>所有那些无法转换数字的操作数都转换为 NaN 值，如果操作数（或者转换结果）是 NaN 值，算术运算的结果也是 NaN。</p>

<h3>「+」运算符</h3>

<p>加号的转换规则 <strong>优先</strong> 考虑字符串链接，如果其中一个操作数是字符串或者转换为字符串的对象，另外一个操作数将会转换为字符串，加法将进行字符串的连接操作</p>

<p><strong>加法操作符的行为表现为：</strong></p>

<p>如果其中一个操作数是对象，则对象会遵循对象到原始值的转换规则转换成原始类值：日期对象通过 toString() 方法执行转换，其它对象则通过 valueOf() 方法执行转换（如果 valueOf 谅坂加一个原始值的话）。由于多数对象都不具备可用的 valueOf() 方法，因为它们会通过 toString() 方法来执行转换</p>

<ul>
<li>在进行了对象到原始值的转换后，如果其中一个操作数是字符串的话，另外一个操作数也会被转换为字符串，然后进行字符串连接</li>
<li>否则，两个操作数都将转换为数字（或者 NaN），然后进行加法操作</li>
</ul>


<pre><code class="javascript">1 + 2                   // =&gt; 3
"1" + "2"               // =&gt; "12"
"1" + 2                 // =&gt; "12"
1 + {}                  // =&gt; "1[object Object]"
true + true             // =&gt; 2
2 + null                // =&gt; 2
2 + undefined           // =&gt; NaN

1 + 2 + " blind mice"    // =&gt; "3 blind mice"
1 + (2 + " blind mice")  // =&gt; "12 blind mice"
</code></pre>

<h3>一元运算符</h3>

<p>一元运算符作用于一个单独的操作数，并产生一个新值。在 JavaScript 中一元运算符有很高的优先级，而且都是 <strong>右结合</strong>（right-associative），「+」和「-」是一元运算符，也是二元运算符</p>

<h3>一元加法（+）</h3>

<p>一元加运算符把操作数转换为数字（或者 NaN），并返回这个转换后的数字。如果操作数本身就是数字，则直接返回这个数字</p>

<h3>一元减（-）</h3>

<p>当「-」胜仗和一元运算时，它会根据需要把操作数转换为数字，然后改变运算结果的符号</p>

<h3>递增（++）</h3>

<p>递增「++」运算符对其操作数进行增量（加一）操作，操作数是一个左传（lvalue）（变量、数组元素或对象属性）。运算符将操作数转换为数字，然后给数字加 1，并将加 1 后的数值重新赋值给变量、数组或者对象属性</p>

<p>递增「++」运算符的返回值 <strong>依赖于</strong> 它相对于操作数的位置。当运算符在操作数之前，称为「前增量」（pre-increment）运算符，它对操作数进行增量计算，并返回计算后的值。当运算符在操作数之后，称为「后增量」（post-increment）运算符，它对操作数进行增量计算，但返回未做增量计算的（unincremented）值</p>

<pre><code class="javascript">var i = 1, j = ++i;     // i,j 都是 2
var i = 1, j = i++;     // i 是 2， j 是 1
</code></pre>

<h3>递减（&ndash;）</h3>

<p>同递增</p>

<h3>位运算符</h3>

<p>位运算符可以对由数字表壳的二进制数据进行更低层级的按位运算</p>

<p>位运算要求它的操作数是整数，这些整数表示为 32 位整数而不是 64 位。必要时运算符先将操作数转换为数字，并将数字强制表示为 32 位整型，这时会魅力原格式中的小数部分和任何超过 32 位的二进制位。移位运算符要求右操作数在 0 ~ 31 之前。在将其操作数转换为无符号的 32 位整数后，它们将作序第 5 位之后的二进制位，以便生成一个位数正确的数字。需要注意的是，位运算符会将 NaN, Infinity, -Infinity 都转换为 0</p>

<h2>关系表达式</h2>

<h3>相等和不等运算符</h3>

<p>「==」和「===」运算符用于比较两个值是否相等，两个运算符 <strong>允许任意类型</strong> 的操作数，如果操作数相等返回 true，否则返回 false。「===」也称为严格相等（strict equality）运算符，有时也称做恒等运算符（identity operator）</p>

<p><strong>严格相等运算符</strong>「===」首先计算期操作数的值，然后比较这两个值，比较过程 <strong>没有任何类型转换</strong>：</p>

<ul>
<li>如果两个值类型不相同，则它们不相等</li>
<li>如果两个值都是 null 或著都是 undefined，则它们不相等</li>
<li>如果两个值都是布尔值 true 或 false，则它们相等</li>
<li>如果其中一个值是 NaN，或者两个值都是 NaN，则它们不相等。NaN 和其他任何值都不相等，<strong>包括它本身</strong></li>
<li>如果两个值为数字且数值相等。如果一个值为 0，另一个值为 -0，则它们同样相等</li>
<li>如果两个值为字符串，且所售的对应位上的 16 位数完全相等，则它们相等。如果它们的长度或内容不同，则不相等。</li>
<li>如果两个引用值指向同一个对象、数组或者函数，则它们是相等的。如果指向不同的对象，则不相等，尽管两个对象可能具有完全一样的属性</li>
</ul>


<p><strong>相等运算符</strong>「==」和恒等类似，但是如果操作数不是同一类型，相等运算符会尝试进行一些类型转换，然后比较：</p>

<ul>
<li>如果两个操作数的类型相同，则和上文所述的严格相等规则一样</li>
<li>如果两个操作数类型不同，相等操作符也可能会认为它们相等。检测相等规则如下：

<ul>
<li>如果一个值是 null，另一个是 undefined，则它们相等</li>
<li>如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后比较</li>
<li>如果其中一个值是 true，则将其转换为 1 再进行比较。false 为 0</li>
<li>如果一个值是对象，另一个值是数字或者字符串，则使用「转换规则」将对象转换为原始值，然后再比较</li>
<li>其他不同类型之前的比较均不相等</li>
</ul>
</li>
</ul>


<h3>比较运算符</h3>

<p>比较运算符用来检测两个操作数的大小关系（数值大小或者字母表顺序），例如：&lt;, >, &lt;=, >=</p>

<p>比较运算符的操作数可能是任意类型。然而 <strong>只有数字和字符串才能真正执行比较操作</strong>，因此那些不是数字和字符串的操作都将进行类型转换，规则如下：</p>

<ul>
<li>如果操作数为对象，那么这个对象将依照「转换规则」转换为原始值</li>
<li>在对象转换为原始值之后，如果至少有一个操作数不是字符串，那么两个操作数都将转换为数字进行数值比较。0 和 -0 是相等的。Infinity 比其它任何数字都大（除它本身），如果一个操作数是（或者转换后是）NaN，那么比较操作符 <strong>总是</strong> 返回 false</li>
</ul>


<p>需要注意的是，JavaScript 字符串是一个由 16 位整数值组成的序列，字符串的比较也只是两个字符的数值比较。字符串的比较是区分大小写的，所有的大写 ASCII 字母都「小于」小写的 ASCII 字母。比如比较「Zoo」和「aardvark」，结果为 true</p>

<pre><code class="javascript">1 + 2               // =&gt; 3
"1" + 2             // =&gt; "12"
"11" &lt; "3"          // =&gt; true 字符串的比较
"11" &lt; 3            // =&gt; false 转换后数字的比较
"one" &lt; 3           // =&gt; false 数字的比较，"one"转换成 NaN
</code></pre>

<p>注意比较运算符（&lt;=, >=）并没有严格「大、小」于的说法</p>

<h3>in 运算符</h3>

<p>in 运算符希望它的左操作数是一个字符串或者可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为右操作数值的属性名，那么表达式返回 true，例如：</p>

<pre><code class="javascript">var point = { x:1, y:1 }
"x" in point
"z" in point
"toString" in point
var data = [7,8,9]
"0" in data                 // =&gt; true      data["0"]
1 in data                   // =&gt; true      data[1]
3 in data                   // =&gt; false     data[3]
</code></pre>

<h3>instanceof 运算符</h3>

<p>instanceof 运算符希望左侧操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回 true，否则返回 false。</p>

<pre><code class="javascript">var d = new Date();
d instanceof Date;   // =&gt; true
d instanceof Object; // =&gt; true
d instanceof Number; // =&gt; false

var a = [1,2,3];
a instanceof Array   // =&gt; true
a instanceof Object  // =&gt; true
a instanceof RegExp  // =&gt; false
</code></pre>

<p>需要注意的是，<strong>所有的对象都是 Ojbect 的实例</strong>。当通过 instanceof 判断一个对象是否是一个类的实例的时候，<strong>这个判断也会包含对「父类」</strong>（superclass）的检测。如果左操作数不是对象的话，instanceof 返回 false。如果右操作数不是函数，则抛出一个类型错误异常</p>

<h2>逻辑表达式</h2>

<h3>逻辑与（&amp;&amp;）</h3>

<p>如果逻辑与运算符的左操作数转换成逻辑值为假的时候 &amp;&amp; 操作符不会去计算右操作数，比如：</p>

<pre><code class="javascript">var o = { x: 1 }
var p = null;
o &amp;&amp; o.x            // =&gt; 1
p &amp;&amp; p.x            // =&gt; null p 是伟假值，因此将其返回，并不计算 p.x
</code></pre>

<p>「&amp;&amp;」的行为有时候称做「短路」（short circuiting），我们经常看到很多代码利用这一我来有条件的执行代码，例如下面两条代码完全等价：</p>

<pre><code class="javascript">if (a == b) stop();
(a == b) &amp;&amp; stop;
</code></pre>

<h3>逻辑或（||）</h3>

<p>|| 会首先计算第一个操作数的值，也就是说会首先计算左侧的表达式。如果计算结果为真值，就返回这个真值。否则，再计算第二个操作数的值，即右侧的表达式，并返回计算结果</p>

<p>通常我们用「||」来从一组备选表达式中选出第一个真值：</p>

<pre><code class="javascript">var max = max_width || preferences.max_width || 500

function copy(o, p) {
    p = p || {}         // 用来给函数参数添加默认值
}
</code></pre>

<h3>逻辑非（!）</h3>

<pre><code class="javascript">// 对于 p 和 q 取任意值，这两个等式都永远成立
!(p &amp;&amp; q) === !p || !q
!(p || q) === !p &amp;&amp; !q
</code></pre>

<h2>赋值表达式</h2>

<pre><code class="javascript">i = 0
o.x = 1
(a = b) == 0              // b 的值赋给 a 再进行相等判断

i = j = k = 0;            // 把三个变量寝化为 0
total += sales_tax        // 带操作的赋值运算
total = total + sales_tax // 和上面等价
</code></pre>

<p><em>表4-2</em></p>

<table>
<thead>
<tr>
<th> 运算符   </th>
<th> 示例     </th>
<th> 等价于      </th>
</tr>
</thead>
<tbody>
<tr>
<td> +=       </td>
<td> a += b   </td>
<td> a = a + b   </td>
</tr>
<tr>
<td> -=       </td>
<td> a -= b   </td>
<td> a = a - b   </td>
</tr>
<tr>
<td> *=       </td>
<td> a *= b   </td>
<td> a = a * b   </td>
</tr>
<tr>
<td> /=       </td>
<td> a /= b   </td>
<td> a = a / b   </td>
</tr>
<tr>
<td> %=       </td>
<td> a %= b   </td>
<td> a = a % b   </td>
</tr>
<tr>
<td> &lt;&lt;=      </td>
<td> a &lt;&lt;= b  </td>
<td> a = a &lt;&lt; b  </td>
</tr>
<tr>
<td> >>=      </td>
<td> a >>= b  </td>
<td> a = a >> b  </td>
</tr>
<tr>
<td> >>>=     </td>
<td> a >>>= b </td>
<td> a = a >>> b </td>
</tr>
<tr>
<td> &amp;=       </td>
<td> a &amp;= b   </td>
<td> a = a &amp; b   </td>
</tr>
<tr>
<td> |=      </td>
<td> a |= b  </td>
<td> a = a | b  </td>
</tr>
<tr>
<td> ^=       </td>
<td> a ^= b   </td>
<td> a = a ^ b   </td>
</tr>
</tbody>
</table>


<h2>表达式计算</h2>

<h3>eval()</h3>

<p>eval() 是一个函数，但是它通常被当成运算符。如果一个池娄调用了 eval()，那么解释器将无法对这个函数做进一步的优化。而将 eval() 定义为函数的另一个问题是，它可以被赋予其他的名字：</p>

<pre><code class="javascript">var f = eval;
var g = f;
</code></pre>

<p>eval() 只有一个参数。如果传入的参数不是字符串，它直接返回这个参数。如果参数是字符串，它会把字符串当成 JavaScript 代码进行编译（parse），如果编译失败则抛出一个语法错误（SyntaxError）异常。如果编译成功，则开始执行这段代码，并返回字符串中的最后一个表达式或者语句的值，如果最后一个表达式或者语句没有值，则最终返回 undefined</p>

<p><strong>eval() 使用了调用它的变量作用域</strong> 环境。也就是说，它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样</p>

<h3>全局 eval()</h3>

<p>eval() 具有更改局部变量的能力。ECMAScript 3 标准规定了任何解释器都不允许对 eval() 赋予别名，通过别名调用会抛出一个 EvalError 异常</p>

<p>实际上，大多数的实现并不是这么做的。当通过别名调用时，eval()  会将其字符串当成顶层的全局代码来执行</p>

<p>ECMAScript 5 是返回使用 EvalError 的，并且规范了 eval() 的行为</p>

<pre><code class="javascript">var geval = eval;
var x = "global", y = "global";
function f() {
    var x = "local";
    eval("x += 'changed'");
    return x
}
function g(){
    var y = 'local';
    geval("y += 'changed'");
    return y
}

console.log(f(), x);
"changed global"
console.log(g(), y);
"globalchanged"
</code></pre>

<h3>严格 eval()</h3>

<p>ECMAScript 5 严格模式函数的行为施加了更多的限制，甚至对标识符 eval 的使用也施加了限制。当在严格模式下调用 eval() 时，或者 eval() 执行的代码段以「use strict」指令开始，这里的 eval() 是私有上下文环境中的局部 eval。也就是说，在严格模式下，eval 挂靠的代码段可以查询或者更改局部变量。但不能在局部作用域中定义新的变量或者函数，此外严格模式将「eval」列为保留字，这让 eval() 更像一个运算符。不能用一人上别名覆盖 eval() 函数。并且变量名、函数名、函数参数或者异常捕获的参数都不能取名为「eval」</p>

<h2>其它运算符</h2>

<h3>条件运算符（?:）</h3>

<p>条件运算符是 JavaScript 中唯一的个三元运算符（三个操作数）。</p>

<p>条件运算符的操作数可以是任意类型。第一个操作数当成布尔值，如果它是真值，那么将计算第二个操作数，并返回其计算结果。否则，如果第一个操作数是假值，那么将计算第三个操作数，并返回期计算结果。第二、三个操作数总是会计算其中一个，不可能同时执行</p>

<pre><code class="javascript">gretting = "hello " + (username ? username : "there");

// 等价于下面的条件语句
gretting = "hello ";
if (username)
    gretting += username;
else
    gretting += "there";
</code></pre>

<h3>typeof 运算符</h3>

<p>typeof 是一元运算符，放在其单个操作数前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串</p>

<p><em>表4-3</em></p>

<table>
<thead>
<tr>
<th> 值                     </th>
<th> typeof运算结果 </th>
</tr>
</thead>
<tbody>
<tr>
<td> undefined              </td>
<td> &ldquo;undefined&rdquo;    </td>
</tr>
<tr>
<td> null                   </td>
<td> &ldquo;object&rdquo;       </td>
</tr>
<tr>
<td> true/false             </td>
<td> &ldquo;boolean&rdquo;      </td>
</tr>
<tr>
<td> 任意数字或者NaN        </td>
<td> &ldquo;number&rdquo;       </td>
</tr>
<tr>
<td> 任意字符串             </td>
<td> &ldquo;string&rdquo;       </td>
</tr>
<tr>
<td> 任意函数               </td>
<td> &ldquo;function&rdquo;     </td>
</tr>
<tr>
<td> 任意内置对象（非函数） </td>
<td> &ldquo;object&rdquo;       </td>
</tr>
<tr>
<td> 任意宿主对象           </td>
<td> 由编译器各自实现的字符串，但不是<br> &ldquo;undefined&rdquo;, &ldquo;boolean&rdquo;, &ldquo;number&rdquo;, &ldquo;string&rdquo; </td>
</tr>
</tbody>
</table>


<h3>delete 运算符</h3>

<p>delete 是一元运算符，它用来删除对象属性或者数组元素。就像赋值、递增/减运算符一样，delete 也是有副作用的</p>

<pre><code class="javascript">var o = { x: 1, y: 2 }
delete o.x                  // =&gt; true 删除成功
"x" in o                    // =&gt; false 没有 "x" 元素
var a = [1,2,3]
delete a[2]                 // =&gt; true 删除最后一个元素成功
2 in a                      // =&gt; false 不存在 2 这个元素
a.length                    // =&gt; 3
</code></pre>

<p>需要注意的是，删除属性或者数组元素不难舍难分是设置了一个 undefined 值。当删除一个属性时，这个属性将不再存在。庋了一个不存在的属性将返回 undefined，但是可以通过 in 运算符来检测这个属性是否在对象中存在</p>

<p>delete 希望他的操作数是一个左传，如果它不是左传，那么 delete 将 <strong>不进行任何操作同时返回 true</strong>。否则，delete 将试图删除这个指定的左传。如果删除不成功，delete 将返回 true。然后并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，用户通过 var 语句声明的变量、function语句声明的函数 也不能删除</p>

<p>ECMAScript 5 严格模式中，如果 delete 的操作数是非法的，比如变量、函数或者函数参数，delete 操作将抛出一个语法错误（SyntaxError）异常，只有操作数是一个属性访问表达式的时候它才会正常工作。在严格模式下，delete 删除不可配置的属性时会抛出一个错误异常，非严格模式下，不会报错，只是简单地返回了 false</p>

<pre><code class="javascript">var o = { x:1, y: 2 }
delete o.x              // =&gt; true
typeof o.x              // =&gt; "undefined"
delete o.x              // =&gt; true 删除一个不存在的属性
delete o                // =&gt; false 不能删除通过 var 声明的变量

delete 1                // =&gt; true 参数不是一个左值
this.x = 1              // =&gt; 给全局对象一个属性 x，没使用 var
delete x                // =&gt; 试图删除它，在非严格模式下返回 true，严格模式下会抛出异常，这时只能使用 delete this.x
</code></pre>

<h3>void 运算符</h3>

<p>void 是一元运算符，它出现在操作数之前，操作数可以是任意类型。这个运算符不经常使用：操作数会照常计算，但忽略计算结果并返回 undefined。由于 void 会忽略操作数的值，因为在操作数具有副作用的时候使用 void 来让程序更具语义</p>

<p>这个运算符最学用丰客户端的 URL —— javascript: URL 中，在 URL 中写带有副作用的表达式，而 void 则让浏览器不必显示这个表达式的计算结果</p>

<pre><code class="html">&lt;a href="javascript: void window.open();"&gt;打开一个窗口&lt;/a&gt;
</code></pre>

<h3>逗号运算符</h3>

<p>逗号运算符是二元运算符，它的操作数是任意类型。它首先计算左操作数，然后计算右操作数，最后返回右操作数的值，看下面的示例代码</p>

<pre><code class="javascript">i = 0, j = 1, k = 2;
// 和下面的代码基本上是等价的
i = 0; j = 1; k = 2;
</code></pre>

<p>总会计算左侧的表达式，但计算结果魅力掉，也就是说只有左侧表达式具有副作用，最常用的场景是 for 循环</p>

<pre><code class="javascript">for (var i = 0, j = 10; i &lt; j; i++,j--)
    console.log(i+j);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 3 - 类型、值和变量]]></title>
    <link href="http://keelii.github.io/2016/06/16/javascript-definitive-guide-note-2/"/>
    <updated>2016-06-16T13:06:13+08:00</updated>
    <id>http://keelii.github.io/2016/06/16/javascript-definitive-guide-note-2</id>
    <content type="html"><![CDATA[<p>JavaScript 中的数据类型分为两类：原始类型（primitive type）和对象类型（object type）。原始类型包括数字、字符串和布尔值</p>

<p>JavaScript 中有两个特殊的原始值：null（空）和 undefined（未定义），它们不是数字、字符串或布尔值。它们通常代表了各自特殊类型的唯一的成员</p>

<p>除此之外的就是对象了。对象是属性（property）的集合，每个属性都由「名/值对」（值可以是原始值或者对象）构成。JavaScript 对象很多时候也是 JSON/map/hash/dict，只是在不同语言中叫法不一样</p>

<!--more-->


<p>普通对象是「命名值」的 <strong>无序</strong> 集合。数组则是一种有序集合对象</p>

<p>JavaScript 还定义了另一种特殊对象 —— 函数。如果用来初始化（使用 new 运算符）一个新建的对象，我们把这个函数称作 <strong>构造函数</strong>（constructor）。每个构造函数定义了一类（class）对象 —— 由构造函数初始化的对象组成的集合，常用的 JavaScript 核心类有 Array, Function, Date, RegExp, Error 等</p>

<p>JavaScript 解释器（interpreter）有自己的内存管理机制，可以自动对内存进行垃圾回收 GC（garbage collection）。当 <strong>不再有任何引用指向一个对象</strong>，解释器就会自动释放它占用的内存资源</p>

<p>JavaScript 是一种面向对象的语言，几乎一切皆对象。数据类型本身可以定义方法（method）来使用</p>

<p>从技术上讲，只有 JavaScript 对象才能拥有方法。然而数字、字符串和布尔值也可以拥有自己的方法。但是 null 和 undefined 是无法拥有方法的值</p>

<p>JavaScript 数据类型还可以分为：可以拥有方法和不可以拥有方法类型、<strong>可变</strong>（nutable）类型和 <strong>不可变</strong>（imutable）类型</p>

<blockquote><p>JavaScript 程序可以更改对象属性值和数组元素的值。数字、布尔值、null 和 undefined 属于不可变类型 —— 比如，修改一个数值的内容本身就说不通。字符串可以看成由字符组成的数组，你可能会认为它是可变的。然而在 JavaScript 中，字符串是不可变的。可以访问字符串任意位置的文本，但不能修改其内容</p></blockquote>

<p>JavaScript 可以自由地进行数据类型转换。比如程序期望使用字符串的地方使用了数字， JavaScript 会自动将数字转换为字符串。期望使用布尔值的地方使用了非布尔值也会自动进行相应转换</p>

<p>JavaScript 变量是无/弱类型的（untyped）,变量可以被赋予任何类型的值，也可以动态改变不同类型的值。JavaScript 采用 <strong>词法作用域</strong>（lexical scoping）。不在任何函数内声明的变量称做全局变量（global variable），函数内声明的变量具有函数作用域（function scope），且只在函数内可见</p>

<h2>数字</h2>

<p>JavaScript <strong>不区分</strong> 整数和浮点数。所有的数字均用浮点数值表示。JavaScript 采用 <a href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE 754</a> 标准定义的 64 位浮点格式表示数字</p>

<p>当一个数字直接出现在 JavaScript 程序中，我们称为数字直接量（numberic literal）。JavaScript 支持多种格式的籽安直接量。注意，在任何数字直接量前添加负号（-）可以得到它们的负值。但负号是 <strong>一元 <a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%93%8D%E4%BD%9C">求反</a></strong> 运算符，并不是数字直接量语法组成部分</p>

<h3>整型直接量</h3>

<p>十进制整数，例如：</p>

<pre><code class="javascript">0
3
1000000
</code></pre>

<p>十六进制值，指直接量以「」或为前缀，其后跟随十六进制数串的直接量。十六进制值是 0 ~ 9 之间的数字和 a(A) ~ f(F) 之前的字母构成，a ~ f 的字母对应的表示数字 10 ~ 15</p>

<pre><code class="javascript">0x2Af5         // 8192 + 2560 + 240 + 5 = 10996（十进制）
/*
+-------------------------------------------------+
|                                                 |
|       2          A          F          5        |
|                                                 |
|       3          2          1          0        |
|                                                 |
|    2*16^3      A*16^2     F*16^1     5*16^0     |
|                                                 |
|    2*4096      10*256     15*16       5*1       |
|                                                 |
|     8192   +    2560   +   240    +    5        |
|                                                 |
|       十六进制 2AF5 转换成十进制为10996         |
|                                                 |
+-------------------------------------------------+
*/
</code></pre>

<p>ECMAScript 标准 <strong>不支持</strong> 八进制直接量，ECMAScript 6 严格模式下不能使用八进制</p>

<h3>浮点型直接量</h3>

<p>浮点型直接量可以含有小数点，采用传统实数的写法。此外，还可以使用指数记数法表示浮点型直接量，即在实数后跟字母 e 或 E，后面再跟正负号，其后再加一个整形指数。这种记数方法表示的数值，是由前面的实数乘以 10 的指数次幂，例如：</p>

<pre><code class="javascript">3.14
2134.789
.33          // 0.33
6.02e23      // 6.02 乘以 10 的 23 次方
1.47e-32     // 1.47 乘以 10 的负 32 次方
</code></pre>

<h3>JavaScript 中的算术运算</h3>

<p>JavaScript 中的算术运算在 <strong>溢出</strong>（overflow）、<strong>下溢</strong>（underflow）或被零整除时不会报错，当数字运算结果超过了 JavaScript 所能表示的数字上限（溢出），结果为一个特殊的无穷大（infinity）值，相应的也有负无穷大（-infinity）值</p>

<p>下溢是当运算结果无限接近于零并比 JavaScript 能表示的最小值还小的时候发生的一种情况。这种情况下，JavaScript 将会返回 0。当一个负数发生下溢时，JavaScript 返回一个特殊的值「负零」，这个值几乎和正常的零完全一样</p>

<p>实零带除在 JavaScript 中并不报错：它会返回正或者负无穷大。但有一个例外，零除以零是没有意义的，这种整除运算结果也是一个非数字（not-a-number）值，用 NaN 表示</p>

<pre><code class="javascript">1/0                      // =&gt; Infinity
-1/0                     // =&gt; -Infinity
Number.NEGATIVE_INFINITY // =&gt; -Infinity
Number.MAX_VALUE         // =&gt; 1.7976931348623157e+308
Number.MAX_VALUE + 1     // =&gt; Infinity （经测试在 Chrome 里面并不是）
0/0                      // =&gt; NaN
Number.MIN_VALUE / 2     // =&gt; 0 发生下溢
-Number.MIN_VALUE / 2    // =&gt; -0 负零
-1/Infinity              // =&gt; -0
NaN == NaN               // =&gt; false
isNaN('hello')           // =&gt; false
isFinite(123)            // =&gt; true 参数不是 NaN, Infinity 或 -Infinity 时返回 true
isFinite(-1/0)           // =&gt; false
</code></pre>

<p>JavaScript 中的非数字值（NaN）和任何值都不相等，包括 NaN，<code>NaN == NaN</code> 返回 <code>false</code> 但是可以使用 isNaN 判断一个值是不是 NaN</p>

<h3>二进制浮点数和四舍五入错误</h3>

<p>IEEE-754 浮点表示法是一种二进制表示法，但是并不能精确表示十进制分数，在任何使用二进制浮点数的编程语言中都会有这个问题</p>

<p>下面的代码中 x 和 y 的值非常 <strong>接近</strong> 彼此和最终正确值。这种计算结果可以用途大多数的计算任务，<strong>这个问题也只有在比较两个值是否相等的时候才会出现</strong></p>

<pre><code class="javascript">0.3 - 0.2           // =&gt; 0.09999999999999998
0.2 - 0.1           // =&gt; 0.1
var x = 0.3 - 0.2;
var y = 0.2 - 0.1;
x == y              // =&gt; false
</code></pre>

<h3>日期和时间</h3>

<p>JavaScript 语言核心包括 Date() 构造函数，用来创建表示日期和时间对象，大致使用方法如下：</p>

<pre><code class="javascript">var then = new Date(2011, 0, 1);                // 2011 年 1 月 1 日
var later = new Date(2011, 0, 1, 17, 10, 30)    // 下午 5 点 10 分 30 秒
var elapsed = now - then;                       // 日期减法：计算时间间隔的毫秒数
later.getFullYear();                            // =&gt; 2011
later.getMonth();                               // =&gt; 0 月份从 0 开始
...
</code></pre>

<h2>文本</h2>

<p><strong>字符串</strong>（string）是一组 16 位值组成的不可变的有序序列，每个字符通常来自于 Unicode 字符集。字符串的长度（length）是其所含 16 位值的个数。字符串索引从零开始</p>

<pre><code class="javascript">""  // 空字符串
'testing'
"3.14"
"Wouldn't you prefer O'Reilly's book?"
"This string\nhas Two lines"  // 显示为两行
"one\
long\
line"   // 显示为单行，但是可以分行书写
</code></pre>

<h3>转义字符</h3>

<p>JavaScript 中转文字符用反斜线（\）加一个字符表示，比如 \n 就是一个转义字符，表示一个换行符</p>

<table>
<thead>
<tr>
<th> 转义字符 </th>
<th> 含义                               </th>
<th style="text-align:center;"> Unicode </th>
</tr>
</thead>
<tbody>
<tr>
<td> \o       </td>
<td> NUL 字符                           </td>
<td style="text-align:center;"> \u0000  </td>
</tr>
<tr>
<td> \b       </td>
<td> 退格符                             </td>
<td style="text-align:center;"> \u0008  </td>
</tr>
<tr>
<td> \t       </td>
<td> 水平制表符                         </td>
<td style="text-align:center;"> \u0009  </td>
</tr>
<tr>
<td> \n       </td>
<td> 换行符                             </td>
<td style="text-align:center;"> \u0009  </td>
</tr>
<tr>
<td> \v       </td>
<td> 垂直制表符                         </td>
<td style="text-align:center;"> \u0009  </td>
</tr>
<tr>
<td> \f       </td>
<td> 换页符                             </td>
<td style="text-align:center;"> \u0009  </td>
</tr>
<tr>
<td> \r       </td>
<td> 回车符                             </td>
<td style="text-align:center;"> \u0009  </td>
</tr>
<tr>
<td> \&ldquo;       </td>
<td> 双引号                             </td>
<td style="text-align:center;"> \u0009  </td>
</tr>
<tr>
<td> \&lsquo;       </td>
<td> 单引号                             </td>
<td style="text-align:center;"> \u0009  </td>
</tr>
<tr>
<td> \       </td>
<td> 反斜线                             </td>
<td style="text-align:center;"> \u0009  </td>
</tr>
<tr>
<td> \xXX     </td>
<td> 2位十六进制数XX指定的 Latin-1 字符 </td>
<td style="text-align:center;">         </td>
</tr>
<tr>
<td> \uXXXX   </td>
<td> 4位十六进制数XX指定的 Unicode 字符 </td>
<td style="text-align:center;">         </td>
</tr>
</tbody>
</table>


<h3>字符串的使用</h3>

<p>加号（+）运算符作用于字符串表示链接，字符串通过访问 length 属性得到长度</p>

<pre><code class="javascript">var s = "hello world"
s.charAt(0)                 // =&gt; "h" 下标为 0 的字符
s.substring(1, 4)           // =&gt; "ell" 下标从 1 ~ 4 的字符
s.slice(1, 4)               // =&gt; "ell" 同上
s.slice(-3)                 // =&gt; "rld" 最后三个字符
s.indexOf("l")              // =&gt; 2 字符 l 首次出现的下标
s.lastIndexOf("l")          // =&gt; 10 字符 l 最后一次出现的下标
s.split(", ")               // =&gt; ["hello", "world"] 分割字符串
s.replace("h", "H")         // =&gt; "Hello, world" 全文字替换
s.toUpperCase()             // =&gt; "HELLO, WORLD"
</code></pre>

<p>一定要记住，在 JavaScript 中字符串是固定不变的，类似 replace() 和 toUpperCase() 的方法都 <strong>返回新字符串</strong>，原字符串本身并没有发生改变。在 ECMAScript 5 中字符串可以当做只读数组，可以通过下标访问单位字符</p>

<h3>模式匹配</h3>

<p>JavaScript 定义了 RegExp() 构造函数，用来创建表示文本匹配模式的对象。这些模式称为「正则表达式」（regular expression）， JavaScript 采用 Perl 中的正则表达式语法。String 和 RegExp 对象均定义了正则模式匹配、查找和替换的函数</p>

<pre><code class="javascript">/^HTML/                       // 匹配以 HTML 开始的字符串
/[1-9][0-9]*/                 // 匹配一个非零数字，后面是任意个数字
/\bjavascript/i               // 匹配单词「javascript」，忽略大小写

var text = "testing: 1, 2, 3"
var pattern = /\d+/g          // 匹配所有包含一个或者多个数字的实例
pattern.test(text)            // =&gt; true 匹配成功
text.search(pattern)          // =&gt; 9 首次匹配成功的位置
text.match(pattern)           // =&gt; ["1", "2", "3"] 所有匹配组成的数组
text.replace(pattern, "#")    // =&gt; "testing: #, #, #"
text.split(/\D+/)             // =&gt; ["", "1", "2", "3"] 用非数字字符截取字符串
</code></pre>

<h2>布尔值</h2>

<p>JavaScript 中比较语句的结果通常都是布尔值，布尔值通常用于控制结构中。任意 JavaScript 的值都可以转换成布尔值。所有对象（数组）都会转换成 true, 面这些则都是 false</p>

<pre><code class="javascript">undefined
null
0
-0
NaN
""     // 空字符串
</code></pre>

<h2>null 和 undefined</h2>

<p>null 是 JavaScript 语言的关键字，执行 typeof 运算返回 「object」，也就是说，可以将 null 认为是一个特殊的对象值，含义是「非对象」。但实际上，通常认为 null 是它自有类型的唯一一个成员，它可以表示数字、字符串或对象是「无值」的</p>

<p>undefined 是一种取值，表明变量没有初始化，如果要查询对象属性或者数组元素的值时返回 undefined 则说明这个属性或者元素不存在。如果函数没有返回任何值，则返回 undefined引用没有提供实参的函数形参的值也只会得到 undefined。</p>

<p>undefined 不是关键字，是 JavaScript 预定义的全局变量，它的值就是「未定义」。ECMAScript 3 中，undefined 是 <strong>可读/写的变量</strong>，可以给它赋任意值。这个错误在 ECMAScript 5 中做了修正，变成了只读的。如果执行 typeof 运算得到 undefined 类型，则返回 &ldquo;undefied&rdquo;</p>

<p>null 和 undefined 都 <strong>不包含任何属性和方法</strong></p>

<h2>全局对象</h2>

<p>全局对象的属性是全局定义的符号，JavaScript 程序可以直接使用。当解释器启动时，它将创建一个新的全局对象，并给它一组初始属性：</p>

<p>全局属性，比如 undefined, Infinity 和 NaN
全局函数，比如 isNaN(), parseInt(), eval()
构造函数，比如 Date(), RegExp(), String(), Object() 和 Array()
全局对象，比如 Math 和 JSON</p>

<p>全局对象的 <strong>初始属性</strong> 并不是保留字（可以被污染/重写），但它们应该当做保留字来对待。对于客户端的 JavaScript 来讲，Window 对象定义了一些额外的全局属性</p>

<h2>包装对象</h2>

<pre><code class="javascript">var s = "test", n = 1, b = true;
var S = new String(s);
var N = new Number(N);
var B = new Boolean(b);

s == S                  // =&gt; true
s === S                 // =&gt; false
typeof s                // =&gt; "string"
typeof S                // =&gt; "object"
</code></pre>

<p>可以通过 Number() 或 Boolean() 构造函数来显式创建包装对象，JavaScript 会在必要的时候将包装对象转换成原始值。上段代码中的对象 S, N 和 B 常常但不总是表现的和值 s, n 和 b 一样。「==」运算符将原始值和其包装对象视为相等，但「===」全等运算符将它们视为不等，通过 typeof 运算符可以看到原始值和其包装对象的不同</p>

<h2>不可变的原始值和可变的对象引用</h2>

<p>JavaScript 中原始值（undefined, null, 布尔值，数字和字符串）和对象（包括数组和函数）有着根本的区别，<strong>原始值是不可更改的</strong>，比如字符串的所有方法都是新返回一个值</p>

<pre><code class="javascript">var s = "hello";
s.toUpperCase();    // =&gt; "HELLO"
s                   // =&gt; "hello"
</code></pre>

<p>对象和原始值不同，首先，它他是 <strong>可变的</strong> —— 值可以修改</p>

<pre><code class="javascript">var o = { x: 1};
o.x = 2;
oxy = 3;

var a = [1,2,3]
a[0] = 0;
a[3] = 4;
</code></pre>

<p><strong>对象的比较并非值的比较，即使两个对象包含同样的属性及相同的值</strong></p>

<pre><code class="javascript">var o = {x:1}, p = {x:1};
o === p                 // =&gt; false
var a = [], b = [];
a === b                 // =&gt; false
</code></pre>

<p>通常将对象𤠕引用类型（reference type）,以此来和 JavaScript 基本类型区分开。按术语的叫法，对象值都是引用（reference）,对象的比较均是引用的比较：<strong>当且仅当它们引用同一个基本对象时，它们才相等</strong></p>

<pre><code class="javascript">var a = [];
var b = a;
b[0] = 1;
a[0]        // =&gt; 1 变量 a 也会修改
a === b     // =&gt; true a 和 b 引用一个相同的数组，所以它们相等
</code></pre>

<h2>类型转换</h2>

<p>JavaScript 中的取值类型非常灵活，从布尔值可以看到这一点：当 JavaScript 期望使用一个布尔值的时候，你可以提供任意类型值， JavaScript 将根据需要自行转换类型。这在其它类型转换中同样适用</p>

<pre><code class="javascript">10 + " objects"         // =&gt; "10 objects" 数字 10 转换成字符串
"7" * "4"               // =&gt; 28 两个字符串均转换为数字
var n = 1 - "x"         // =&gt; NaN 字符串 "x" 无法转换为数字
n + " objects"          // =&gt; "NaN objects" NaN 转换为字符串 "NaN"
</code></pre>

<p><strong>常用值转换成对应的类型结果</strong></p>

<p><em>表3-1</em></p>

<table>
<thead>
<tr>
<th> 值                      </th>
<th> 字符串            </th>
<th> 数字        </th>
<th> 布尔值 </th>
<th> 对象                  </th>
</tr>
</thead>
<tbody>
<tr>
<td> undefined               </td>
<td> &ldquo;undefined&rdquo;       </td>
<td> NaN         </td>
<td> false  </td>
<td> throws TypeError      </td>
</tr>
<tr>
<td> null                    </td>
<td> &ldquo;null&rdquo;            </td>
<td> 0           </td>
<td> false  </td>
<td> throws TypeError      </td>
</tr>
<tr>
<td> true                    </td>
<td> &ldquo;true&rdquo;            </td>
<td> 1           </td>
<td>        </td>
<td> new Boolean(true)     </td>
</tr>
<tr>
<td> false                   </td>
<td> &ldquo;false&rdquo;           </td>
<td> 0           </td>
<td>        </td>
<td> new Boolean(false)    </td>
</tr>
<tr>
<td> &ldquo;&rdquo; (空字符串)           </td>
<td>                   </td>
<td> 0           </td>
<td> false  </td>
<td> new String(&ldquo;&rdquo;)        </td>
</tr>
<tr>
<td> &ldquo;1.2&rdquo; (非空数字)        </td>
<td>                   </td>
<td> 1.2         </td>
<td> true   </td>
<td> new String(&ldquo;1.2&rdquo;)     </td>
</tr>
<tr>
<td> &ldquo;one&rdquo; (非空，非数字)    </td>
<td>                   </td>
<td> NaN         </td>
<td> true   </td>
<td> new String(&ldquo;one&rdquo;)     </td>
</tr>
<tr>
<td> 0                       </td>
<td> &ldquo;0&rdquo;               </td>
<td>             </td>
<td> false  </td>
<td> new Number(0)         </td>
</tr>
<tr>
<td> -0                      </td>
<td> &ldquo;0&rdquo;               </td>
<td>             </td>
<td> false  </td>
<td> new Number(-0)        </td>
</tr>
<tr>
<td> NaN                     </td>
<td> &ldquo;NaN&rdquo;             </td>
<td>             </td>
<td> false  </td>
<td> new Number(NaN)       </td>
</tr>
<tr>
<td> Infinity                </td>
<td> &ldquo;Infinity&rdquo;        </td>
<td>             </td>
<td> true   </td>
<td> new Number(Infinity)  </td>
</tr>
<tr>
<td> -Infinity               </td>
<td> &ldquo;-Infinity&rdquo;       </td>
<td>             </td>
<td> true   </td>
<td> new Number(-Infinity) </td>
</tr>
<tr>
<td> 1 (无穷大，非零)        </td>
<td> &ldquo;1&rdquo;               </td>
<td>             </td>
<td> true   </td>
<td> new Number(1)         </td>
</tr>
<tr>
<td> {} (任意对象)           </td>
<td> 参考 §3.8.3       </td>
<td> 参考 §3.8.3 </td>
<td> true   </td>
<td>                       </td>
</tr>
<tr>
<td> [] (任意数组)           </td>
<td> &ldquo;&rdquo;                </td>
<td> 0           </td>
<td> true   </td>
<td>                       </td>
</tr>
<tr>
<td> [9] (1 个数字元素)      </td>
<td> &ldquo;9&rdquo;               </td>
<td> 9           </td>
<td> true   </td>
<td>                       </td>
</tr>
<tr>
<td> [&lsquo;a&rsquo;] (其它数组)        </td>
<td> use join() method </td>
<td> NaN         </td>
<td> true   </td>
<td>                       </td>
</tr>
<tr>
<td> function(){} (任意函数) </td>
<td> 参考 §3.8.3       </td>
<td> NaN         </td>
<td> true   </td>
<td>                       </td>
</tr>
</tbody>
</table>


<h3>转换和相等性</h3>

<p>以下结果均为 true</p>

<pre><code class="javascript">null == undefined
"0" == 0
0 == false
"0" == false
</code></pre>

<h3>显式类型转换</h3>

<p>显式类型转换最简单的方法就是使用 Boolean(), Number(), String() 或 Object() 函数。</p>

<pre><code class="javascript">Number("3")     // =&gt; 3
String(false)   // =&gt; "false"
Boolean([])     // =&gt; true
Object(3)       // =&gt; new Number(3)
</code></pre>

<p>除了 null 和 undefined 之外 <strong>任何值</strong> 都具有 toString() 方法</p>

<p>JavaScript 中的某些运算符会做隐式的类型转换。如果「+」运算符的一个操作数是字符串，它将会把另外一个操作数转换为字符串。一元「!」运算符将其操作数转换为布尔值并取反</p>

<pre><code class="javascript">x + ""      // 等价于 String(x)
+x          // 等价于 Number(x)
!!x         // 等价于 Boolean(x)
</code></pre>

<p>Number 类型定义的 toString() 方法可以接收表示转换基数的可选参数，默认是基于十进制的，toFixed(), toExponential(), toPrecision() 三个方法都会适当地进行四舍五入或填充 0</p>

<pre><code class="javascript">var n = 17
binary_sting = n.toString(2)        // 转换为 "10001"
octal_string = "0" + n.toString(8)  // 转换为 "021"
hex_string = "0x" + n.toString(16)  // 转换为 "0x11"
</code></pre>

<p>通过 Number() 转换函数传入一个字符串，它会试图将其转换为一个整数或浮点数直接量，这个方法只能基于十进制数进行转换，并且不能出现 <strong>非法的尾随字符</strong>。parseInt() 和 parseFloat() 函数（全局函数，不属于任何类的方法）更加灵活。如果字符前缀是「0x」或「0X」，parseInt() 将其解释为十六进制数，parseInt() 和 parseFloat() 都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略 <strong>后面的内容</strong></p>

<pre><code class="javascript">parseInt("3 blind mice")        // =&gt; 3
parseFloat(" 3.14 meters")      // =&gt; 3.14
parseInt(0xFF)                  // =&gt; 255
parseInt("0.1")                 // =&gt; 0
parseInt(".1")                  // =&gt; NaN
parseFloat("$72.47")            // =&gt; NaN
</code></pre>

<h3>对象转换为原始值</h3>

<p>所有对象继承了两个转换方法 toString(), valueOf()</p>

<p><strong>toString()</strong> 的作用是返回一个反映这个对象的字符串</p>

<pre><code class="javascript">({x:1, y:2}).toString()             // =&gt; "[object Object]"
[1,2,3].toString()                  // ==&gt; "1,2,3"
(function(x) { f(x); }).toString()  // =&gt; "function(x) {\n f(x);\n }"
/\d+/g.toString()                   // =&gt; "/\\d+/g"
new Date(2010,0,1).toString()       // =&gt; "Fri Jan 01 2010 00:00:00 GMT+0800 (中国标准时间)"
</code></pre>

<p><strong>valueOf()</strong> 这个方法的作答并未详细定义：如果存在任意原始值，它就默认将对象转换为表示它的原始值。复合值默认返回对象本身</p>

<p>JavaScript 中对象到字符串的转换经过了如下这些步骤：</p>

<ul>
<li>如果对象具有 toString() 方法，调用后，如果返回一个原始值，JavaScript 将这个值转换为字符串，并返回</li>
<li>如果没有 toString() 方法，或者这个方法并不返回一个原始值，那么 JavaScript 会调用 valueOf() 方法，如果存在这个方法，则调用它。如果返回值是原始值，就将这个值值的为字符串并返回</li>
<li>否则，无法从 toString() 和 valueOf() 获得一个原始值，这些将抛出一个类型错误异常</li>
</ul>


<pre><code class="javascript">var now = new Date();
typeof (now +1)             // =&gt; "string" 「+」将日期转换为字符串
typeof (now -1)             // =&gt; "number" 「-」使用对象到数字的转换
now == now.toString()       // =&gt; true
now &gt; (now - 1)             // =&gt; true
</code></pre>

<h2>变量声明</h2>

<pre><code class="javascript">var i;
var sum;
var i, sum;     // 单 var 声明多个变量
</code></pre>

<p>如果未在 var 声明语句中给变量指定初始值，那么虽然声明了这个变量，但在给它存入一个值之前，它的初始值就是 undefined</p>

<p>JavaScript 是弱类型语言，变量可以是任意数据类型，下面的写法是合法的：</p>

<pre><code class="javascript">var i = 10;
i = "ten";
</code></pre>

<h2>变量作用域</h2>

<p>变量作用域（scope）是程序源代码中定义它的区域。在函数体内，局部变量的优先级高于 <strong>同名</strong> 的全局变量，并且函数内部可以修改外部变量</p>

<pre><code class="javascript">var scope = "global";
function checkScope() {
  var scope = 'local';
  return scope
}
</code></pre>

<p>在声明全局变量时可以不使用 var 前缀，但在声明局部变量时 <strong>一定</strong> 要使用 var</p>

<pre><code class="javascript">scope = "global";       // 定义一个全局变量
function checkScope2() {
    scope = 'local';
    myscope = 'local';

    return [scope, myscope]
}

checkScope2()           // =&gt; ['local', 'local']
scope                   // =&gt; "local"
myscope                 // =&gt; "local"
</code></pre>

<h3>函数作用域和声明提前（Hoisting）</h3>

<p>像一些类 C 的编程语言中，花括号（{}）内的每一段代码都具有各自的作用域，变量在声明它们的代码段之外是不可见的，我们称为 <strong>块级作用域</strong>（block scope），而 JavaScript 中没有块级作用域。JavaScript 中使用了 <strong>函数作用域</strong>（function scope）：</p>

<blockquote><p>变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是可以被访问到的</p></blockquote>

<p>下面的代码中，在不同位置定义了变量 i,j 和 k，它们都在同一个作用域内。当调用 <code>test()</code> if 语句并没有执行，但是变量 j 已经定义却没被始化</p>

<pre><code class="javascript">function test(o) {
    var i = 0;
    if ( typeof o === 'object' ) {
        var j = 0;
        for (var k = 0; k &lt; 10; k++) {
            console.log(k);
        }
        console.log(k);
    }
    console.log(j);
}
</code></pre>

<blockquote><p>JavaScript 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。这就意味着变量在声明之前甚至已经可用。JavaScript 的这个被非正式地称为声明提前（hoisting），即 JavaScript 函数里声明的所有变量（不包括赋值）都被「提前」到函数体的顶部 <a href="http://www.slideshare.net/lijing00333/javascript-engine">参考</a></p></blockquote>

<pre><code class="javascript">var scope = "global";
function f() {
    console.log(scope);     // =&gt; undefined
    var scope = "local";
    console.log(scope);     // =&gt; "local"
}
f();

function b() {
    console.log(scope);     // =&gt; "global"
}
b();
</code></pre>

<p>上面的代码中函数 f 的局部变量 scope 由于 <strong>声明提前</strong>，代码刚执行进入 f 内部的时候 scope 就被赋值 undefined，这时局部变量优先级高于同名全局变量，所以就返回了 undefined，只有代码执行到 var 的时候 scope 才真正被赋值。所以函数 f 等价于：</p>

<pre><code class="javascript">function f() {
    var scope;
    console.log(scope);     // =&gt; undefined
    scope = "local";
    console.log(scope);     // =&gt; "local"
}
</code></pre>

<p>这也是为什么建议函数体内的变量尽量放在上面，避免造成混乱或者误解</p>

<h3>作为属性的变量</h3>

<p>当声明一个 JavaScript 全局变量时，实际上是定义了全局对象的一个属性。当使用 var 声明一个变量时，这个变量是无法通过 delete 运算符删除的。不使用 var 声明的全局变量却是可以被 delete 的</p>

<pre><code class="javascript">var truevar = 1;
fakevar = 2;                // 不用 var 创建一个全局变量
this.fakevar2 = 3;
delete truevar              // =&gt; false 不可删除
delete fakevar              // =&gt; true
delete this.fakevar2        // =&gt; true
</code></pre>

<h3>作用域链（scope chain）</h3>

<p>JavaScript 是基于 <strong>词法作用域</strong>（lexically scoped）的语言：通过阅读包含变量定义在内的源代码就能知道变量的作用域</p>

<p>每一段 JavaScript 代码（全局代码或函数）都有一个与之关联的作用域链。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码「作用域中」的变量。当 JavaScript 需要查找变量 x 值的时候（这个过程称做「变量解析」（valable resolution）），它会从链中的第一个对象开始查找，如果有则直接使用，如果没有 JavaScript 就会继续查找链上的下一个对象，以此类推。如果作用域名链上没有任何一个对象含有属性 x，那么就认为这段代码的作用域链接上不存在 x，并最终抛出一个引用错误（ReferenceError）异常</p>

<pre><code class="javascript">a();
function a() {
    alert('1');
}
a();
function a() {
    alert('2');
}
a();
var a = function() {
    alert('3');
};
a();
</code></pre>

<h3>引用</h3>

<ul>
<li>IEEE 754 <a href="https://zh.wikipedia.org/wiki/IEEE_754">https://zh.wikipedia.org/wiki/IEEE_754</a></li>
<li>位操作 <a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%93%8D%E4%BD%9C">https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%93%8D%E4%BD%9C</a></li>
<li>JavaScript Engine <a href="http://www.slideshare.net/lijing00333/javascript-engine">http://www.slideshare.net/lijing00333/javascript-engine</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
