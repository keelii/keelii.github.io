<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>javascript on 臨池不輟</title>
    <link>https://keelii.com/categories/javascript/</link>
    <description>Recent content in javascript on 臨池不輟</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 03 Jul 2019 18:33:57 +0800</lastBuildDate>
    
        <atom:link href="https://keelii.com/categories/javascript/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Nestjs 框架教程（第三篇：控制器）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-3/</link>
      <pubDate>Wed, 03 Jul 2019 18:33:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-3/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;控制器&lt;/strong&gt;（Controller）负责处理客户端请求并发送响应内容，在传统的 MVC 架构中控制器就是负责处理指定请求与应用程序的对应关系，路由则决定具体处理哪个请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/30/5d18c461b3cb641859.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;路由&#34;&gt;路由&lt;/h3&gt;

&lt;p&gt;得益于 TypeScript，在 Nest 中我们可以使用类来实现控制器的功能，使用装饰器来实现路由功能。它们分别需要配合 @Controller 和 @Get 饰器来使用，前者是控制器类的装饰，后者是具体方法的装饰器。&lt;/p&gt;

&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Controller, Get } from &#39;@nestjs/common&#39;;

@Controller(&#39;cats&#39;)
export class CatsController {
  @Get()
  findAll(): string {
    return &#39;This action returns all cats&#39;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码声明了一个猫咪控制器类，实现了 findAll 方法，当你在浏览器中发送请求到 /cates 时程序就返回给你 This action returns all cats&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;++小提示++：可以使用 Nest-cli 工具来自动生成上面的代码：$ nest g controller cats&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;@Get()&lt;/code&gt; 表示 HTTP 请求装饰器。控制器类的装饰器和 HTTP 方法的装饰器共同决定了一个路由规则。findAll 将返回一个状态码为 200 的响应，当然你有两种方法来指定返回的状态码：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;标准模式（建议的）&lt;/td&gt;
&lt;td&gt;使用内置方法时，如果返回一个 JavaScript 对象或者数据，将自动序列化成 JSON，如果是字符串将默认不会序列化，响应的返回状态码 &lt;strong&gt;默认&lt;/strong&gt; 总是 200，除非是 POST 请求会默认设置成 201。可以使用 @HttpCode() 装饰器来改变它&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;指定框架&lt;/td&gt;
&lt;td&gt;也可以使用指定框架的请求处理方法，比如 Express 的响应对象。可以使用 @Res() 装饰器来装饰响应对象使用，这样以来你就可以使用类 Express API 的方式处理响应了：&lt;code&gt;response.status(200).send()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;++警告++&lt;/strong&gt;：你可以同时使用上面两种方法，但是 Nest 会检测到，同时标准模式会在这个路由上被禁用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;请求对象&#34;&gt;请求对象&lt;/h3&gt;

&lt;p&gt;处理器一般需要访问到请求对象。一般配合 @Req() 装饰器来使用，请求对象包含查询字符串、参数、HTTP 头，请求体等。但是大多数情况只用到其中某个，我们可以单独使用指定的装饰器来装饰请求。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;装饰器&lt;/th&gt;
&lt;th&gt;参数值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Request()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;req&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Response()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;res&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Next()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;next&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Session()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;req.session&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Param(key?: string)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;req.params&lt;/code&gt; / &lt;code&gt;req.params[key]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Body(key?: string)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;req.body&lt;/code&gt; / &lt;code&gt;req.body[key]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Query(key?: string)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;req.query&lt;/code&gt; / &lt;code&gt;req.query[key]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Headers(name?: string)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;req.headers&lt;/code&gt; / &lt;code&gt;req.headers[name]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;举个例子：比如我们只需要处理请求的查询字符串（query string），就可以使用 @Query 来装饰入参，这样取到的值就自然是一个 query string 的字典了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get()
getHello(@Query() q: String): string {
    console.log(q)
    return this.appService.getHello();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们的请求是：&lt;a href=&#34;http://localhost:3000/?test=a&#34;&gt;http://localhost:3000/?test=a&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么控制台将打印一个 &lt;code&gt;{ test: &#39;a&#39; }&lt;/code&gt; 字典&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;++小提示++&lt;/strong&gt;：建议安装 @types/express 包来获取 Request 的相关类型提示&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;资源&#34;&gt;资源&lt;/h3&gt;

&lt;p&gt;除了使用 @Get 装饰器，我们还可以使用其它 HTTP 方法装饰器。比如：&lt;code&gt;@Put()&lt;/code&gt;, &lt;code&gt;@Delete()&lt;/code&gt;, &lt;code&gt;@Patch()&lt;/code&gt;, &lt;code&gt;@Options()&lt;/code&gt;, &lt;code&gt;@Head()&lt;/code&gt;, and &lt;code&gt;@All()&lt;/code&gt;，注意 All 并不是 HTTP 的方法，而是 Nest 提供的一个快捷方式，表示接收任何类型的 HTTP 请求。&lt;/p&gt;

&lt;h3 id=&#34;路由通配符&#34;&gt;路由通配符&lt;/h3&gt;

&lt;p&gt;Nest 支持基于模式的路由规则匹配，比如：星号（*）表示匹配任意的字母组合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get(&#39;ab*cd&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;&#39;ab*cd&#39;&lt;/code&gt; 路由将匹配 &lt;code&gt;abcd&lt;/code&gt;, &lt;code&gt;ab_cd&lt;/code&gt;, &lt;code&gt;abecd&lt;/code&gt; 等规则。同时：&lt;code&gt;?&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;()&lt;/code&gt; 通配符（wildcard）都可以使用&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;通配符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;匹配&lt;/th&gt;
&lt;th&gt;不匹配&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配任意数量的任意字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Law*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Law&lt;/code&gt;, &lt;code&gt;Laws&lt;/code&gt;, or &lt;code&gt;Lawyer&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;GrokLaw&lt;/code&gt;, &lt;code&gt;La&lt;/code&gt;, or &lt;code&gt;aw&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*Law*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Law&lt;/code&gt;, &lt;code&gt;GrokLaw&lt;/code&gt;, or &lt;code&gt;Lawyer&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;code&gt;La&lt;/code&gt;, or &lt;code&gt;aw&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配任意&lt;strong&gt;单个&lt;/strong&gt;字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;?at&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Cat&lt;/code&gt;, &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;Bat&lt;/code&gt; or &lt;code&gt;bat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;at&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[abc]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配方括号中的任意&lt;strong&gt;一个&lt;/strong&gt;字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[CB]at&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Cat&lt;/code&gt; or &lt;code&gt;Bat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;bat&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[a-z]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配字母、数字区间&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Letter[0-9]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Letter0&lt;/code&gt;, &lt;code&gt;Letter1&lt;/code&gt;, &lt;code&gt;Letter2&lt;/code&gt; up to &lt;code&gt;Letter9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Letters&lt;/code&gt;, &lt;code&gt;Letter&lt;/code&gt; or &lt;code&gt;Letter10&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;状态码&#34;&gt;状态码&lt;/h3&gt;

&lt;p&gt;响应的默认状态码是 200，POST 则是 201，我们可以使用装饰器 &lt;code&gt;@HttpCode(204)&lt;/code&gt; 来指定&lt;strong&gt;处理器&lt;/strong&gt;级别的 默认 HttpCode 为 204&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@HttpCode(204)
create() {
  return &#39;This action adds a new cat&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想动态指定状态码，就要使用 @Res() 装饰器来注入响应对象，同时调用响应的状态码设置方法。&lt;/p&gt;

&lt;h3 id=&#34;请求头&#34;&gt;请求头&lt;/h3&gt;

&lt;p&gt;同样的我们可以使用 &lt;code&gt;@Header()&lt;/code&gt; 来设置自定义的请求头，也可以使用 &lt;code&gt;response.header()&lt;/code&gt; 设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Post()
@Header(&#39;Cache-Control&#39;, &#39;none&#39;)
create() {
  return &#39;This action adds a new cat&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;路由参数&#34;&gt;路由参数&lt;/h3&gt;

&lt;p&gt;通常我们需要设置一些动态的路由来接收一些客户端的查询参数，通过指定路由参数可以很方便的捕获到 URL 上的动态参数到控制器中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get(&#39;:id&#39;)
findOne(@Param() params): string {
  console.log(params.id);
  return `This action returns a #${params.id} cat`;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过使用 @Param() 装饰器可以在方法中直接访问到路由装饰器 &lt;code&gt;@Get()&lt;/code&gt; 中的的参数字典，:id 就表示匹配到所有的字符串，可以通过引用 params.id 在方法中访问到。&lt;/p&gt;

&lt;p&gt;当然，就像前面学到的参数装饰器也可以指定到具体的某个参数值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Get(&#39;:id&#39;)
findOne(@Param(&#39;id&#39;) id): string {
  return `This action returns a #${id} cat`;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;路由顺序&#34;&gt;路由顺序&lt;/h3&gt;

&lt;p&gt;路由的注册顺序与控制器类中的&lt;strong&gt;方法&lt;/strong&gt;顺序相关，如果你先装饰了一个 cats/:id 的路由，后面又装饰了一个 cats 路由，那么当用户访问到 GET /cats 时，后面的路由将不会被捕获，因为参数才都是&lt;strong&gt;非必选&lt;/strong&gt;的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第二篇：入门）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-2/</link>
      <pubDate>Wed, 03 Jul 2019 18:32:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-2/</guid>
      <description>

&lt;p&gt;这篇教程起，你将会学习到 Nest 的几个核心点。为了更好的了解 Nest 应用中的模块，我们将开发一个有基本 CRUD&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Create-Read-Upda&#34;&gt;&lt;a href=&#34;#fn:Create-Read-Upda&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 功能的入门级应用。&lt;/p&gt;

&lt;h2 id=&#34;实现语言&#34;&gt;实现语言&lt;/h2&gt;

&lt;p&gt;Nest 是 TypeScript 写的，所以天生就很好的并且渐进地支持 JavaScript。&lt;/p&gt;

&lt;h2 id=&#34;依赖&#34;&gt;依赖&lt;/h2&gt;

&lt;p&gt;保证你的操作系统上安装的 Node.js 版本大于 8.9.0 即可。&lt;/p&gt;

&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;

&lt;p&gt;就像上节讲到的直接用 nest new project-name 就可以了。我们来回顾下目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;src
├── app.controller.spec.ts
├── app.controller.ts
├── app.module.ts
├── app.service.ts
└── main.ts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别对应的功能如下表：&lt;/p&gt;

&lt;p&gt;| app.controller.ts | 只有一个路由的控制器（controller）示例 |
| app.module.ts | 应用程序的根模块（root module） |
| main.ts | 应用程序的入口文件，使用 &lt;code&gt;NestFactory&lt;/code&gt; 方法创建应用实例 |
在 main.ts 中我们可以看到，默认使用了 NestFactory 的 create() 静态方法返回创建的应用对象，此对应会实现 INestApplication 接口。&lt;/p&gt;

&lt;h2 id=&#34;平台&#34;&gt;平台&lt;/h2&gt;

&lt;p&gt;Nest 的目标是一个平台无关的框架。这个意思就是说 Nest 本身并不造某个细分领域的轮子，他只构建一套构架体系，然后把一些好用的库或者平台融合进来。所以 Nest 可以衔接任何 HTTP 框架，默认支持 express 和 fastify 两个 web 框架。&lt;/p&gt;

&lt;p&gt;| &lt;code&gt;platform-express&lt;/code&gt; | &lt;strong&gt;&lt;a href=&#34;https://expressjs.com/&#34;&gt;Express&lt;/a&gt;&lt;/strong&gt; 是一个 Node web 框架，有很多社区成熟的资源。@nestjs/platform-express 默认会被引入，大家都很熟悉了，用起来会容易上手 |
| &lt;code&gt;platform-fastify&lt;/code&gt; | &lt;strong&gt;&lt;a href=&#34;https://www.fastify.io/&#34;&gt;Fastify&lt;/a&gt;&lt;/strong&gt; 是一个高能低耗的框架，致力于最大化效率与速度 |
无论使用哪个平台，都要暴露自己的应用接口。上面两个平台暴露了对应的两个变量 &lt;code&gt;NestExpressApplication&lt;/code&gt; and &lt;code&gt;NestFastifyApplication&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如下的代码会创建一个 app 对象，并且指定了使用 NestExpressApplication 平台：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const app = await NestFactory.create&amp;lt;NestExpressApplication&amp;gt;(ApplicationModule);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过一般情况下不需要指定这个类型。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:Create-Read-Upda&#34;&gt;Create, Read, Update, Delete 通常对应于数据的增删改查功能 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Create-Read-Upda&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Nestjs 框架教程（第一篇：简介）</title>
      <link>https://keelii.com/2019/07/03/nestjs-framework-tutorial-1/</link>
      <pubDate>Wed, 03 Jul 2019 18:31:57 +0800</pubDate>
      
      <guid>https://keelii.com/2019/07/03/nestjs-framework-tutorial-1/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/30/5d185dfb87f5e21948.png&#34; alt=&#34;Nestjs&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;教程目录&#34;&gt;教程目录&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;请注意：本教程结合官方文档内容并添加了许多我自己学习过种中的理解，存在许多个人观点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;Nestjs 框架教程（第一篇：&lt;a href=&#34;nestjs-framework-tutorial-1&#34;&gt;简介&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第二篇：入门）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第三篇：控制器）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第四篇：Providers）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第五篇：模块）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第三篇：中间件）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第三篇：异常过滤器）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第三篇：管道）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第三篇：守卫）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第三篇：拦截器）&lt;/li&gt;
&lt;li&gt;Nestjs 框架教程（第三篇：自定义装饰器）&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;Nest 是一个用于构建高效、可扩展的 Node.js 服务端应用框架，基于 TypeScript 编写并且结合了 OOP&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Object-Oriented&#34;&gt;&lt;a href=&#34;#fn:Object-Oriented&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;、FP&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Functional-Progr&#34;&gt;&lt;a href=&#34;#fn:Functional-Progr&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;、FRP&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Functional-React&#34;&gt;&lt;a href=&#34;#fn:Functional-React&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; 的相关理念。并且设计上很多灵感来自于 Angular。&lt;/p&gt;

&lt;p&gt;Angular 的很多模式又来自于 Java 中的 Spring 框架，依赖注入、面向切面编程等，所以你可以认为： &lt;strong&gt;Nest 是 Node.js 版的 Spring 框架&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;或许很多前端工程师看到这里就自动劝退了，事实上我以前也挺讨厌 Java 的（现在也不怎么喜欢），后来由于工作原因学习到了一些 Java 相关的知识后才发现自己的认识很片面。现在 WEB 后端主流的技术栈都基于 Spring 框架，框架必然是解决了很多实际问题，能学习到它的思想比它自己的出身、派系更重要。同时建议那些没有学习或者接触过 Java 的前端可以了解一些相关概念，不要拒绝，因为这可能会为你打开另一扇门。&lt;/p&gt;

&lt;p&gt;可能在很多伪 FP 爱好者来看 OOP 是臃肿无用的东西。但是从使用角度讲：&lt;strong&gt;FP 小而美，OOP 大而全&lt;/strong&gt;，如果不关注场景去讨论好坏没有任何意义。而且事实上这两者完全是不冲突的，可以结合得非常完美。不要被那些所谓的&lt;strong&gt;纯&lt;/strong&gt;函数、&lt;strong&gt;纯&lt;/strong&gt;页面对象的概念误导，能写出真正的好代码才是重要的。&lt;/p&gt;

&lt;p&gt;如果你以前在使用 Node.js 开发后端应用时常常不知道如何规划代码关系，搞不清楚控制器、服务、模型和数据的关系，或者是你打算使用 Node.js 构建大型应用，那就建议你了解一下 Nest。&lt;/p&gt;

&lt;h3 id=&#34;框架的哲学&#34;&gt;框架的哲学&lt;/h3&gt;

&lt;p&gt;在开始体验前，有必要简单介绍下 Nest 框架的的设计理念，我结合我自己的理解大概梳理下。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;近几年由于 Node.js 的出现，JavaScript 成为了前端和后端的「lingua franca&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:-&#34;&gt;&lt;a href=&#34;#fn:-&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;」，前端方面出现了 Angular, React, Vue 等众多的 UI 框架，后端方面也有像 Express, Koa 这样优秀的框架出现，但这些框架都没有高效地解决一个核心问题 — &lt;strong&gt;架构&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;官方的这段介绍和我看到的非常一致，注意作者说是&lt;strong&gt;高效地&lt;/strong&gt;解决，我的理解是现在 Node.js 或者说 JavaScript 框架都是各做各的，都是些点，可能确实有做的很不错的，但是整体而言并没有一个把各种好东西串链起来做成一种通用模式的框架，或者说是架构。&lt;/p&gt;

&lt;p&gt;这个问题主要有三方面原因：其一，现在大多前端工程师的工作范围还是局限于前端 UI 层，或者说视图层，后端一般都由更加成熟的一技术栈来实现；其二，Node.js 诞生于 2009 年，相比于 2002 就发第一版的 Spring 差的很远；其三，Node.js 实际上就是 JavaScript，这门语言本身也有很多缺陷，以至于无法胜任大型应用的架构场景。&lt;/p&gt;

&lt;p&gt;虽然有这些问题但是我始终认为 Nest 是个很好的开端，或者说对于所谓的「全栈」工程师来讲是个好事。因为我认为在大型项目中构架层面的复用比代码层面的复用更重要。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;安装 Nest 最方便的方法就是使用它额外提供的一个 CLI 工具（需要安装 Node.js &amp;gt; 8.9 版本），使用下面的命令它可以帮你自己生成项目的目录结构和预定义的最小模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm i -g @nestjs/cli
nest new project-name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后命令行可以看见它自动生成的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  github.com nest new project-name
⚡  We will scaffold your app in a few seconds..

CREATE /project-name/.prettierrc (51 bytes)
CREATE /project-name/README.md (3370 bytes)
CREATE /project-name/nest-cli.json (84 bytes)
CREATE /project-name/nodemon-debug.json (163 bytes)
CREATE /project-name/nodemon.json (67 bytes)
CREATE /project-name/package.json (1808 bytes)
CREATE /project-name/tsconfig.build.json (97 bytes)
CREATE /project-name/tsconfig.json (325 bytes)
CREATE /project-name/tslint.json (426 bytes)
CREATE /project-name/src/app.controller.spec.ts (617 bytes)
CREATE /project-name/src/app.controller.ts (274 bytes)
CREATE /project-name/src/app.module.ts (249 bytes)
CREATE /project-name/src/app.service.ts (142 bytes)
CREATE /project-name/src/main.ts (208 bytes)
CREATE /project-name/test/app.e2e-spec.ts (561 bytes)
CREATE /project-name/test/jest-e2e.json (183 bytes)

? Which package manager would you ❤️  to use? yarn
▹▸▹▹▹ Installation in progress... ☕
🚀  Successfully created project project-name
👉  Get started with the following commands:

$ cd project-name
$ yarn run start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时可以按提示，进入到 &lt;code&gt;project-name&lt;/code&gt; 运行项目。如果看到下面的输出就表示成功了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  github.com cd project-name
➜  project-name git:(master) ✗ yarn run start
yarn run v1.10.1
$ ts-node -r tsconfig-paths/register src/main.ts
[Nest] 26470   - 2019/06/30 下午8:58   [NestFactory] Starting Nest application...
[Nest] 26470   - 2019/06/30 下午8:58   [InstanceLoader] AppModule dependencies initialized +11ms
[Nest] 26470   - 2019/06/30 下午8:58   [RoutesResolver] AppController {/}: +5ms
[Nest] 26470   - 2019/06/30 下午8:58   [RouterExplorer] Mapped {/, GET} route +3ms
[Nest] 26470   - 2019/06/30 下午8:58   [NestApplication] Nest application successfully started +3ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们访问 &lt;code&gt;http://localhost:3000&lt;/code&gt; 就可以看到 &lt;code&gt;Hello World!&lt;/code&gt; 了。用编辑器打开目录结构如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/06/30/5d18b3033825c45837.png&#34; alt=&#34;nestjs init&#34; /&gt;&lt;/p&gt;

&lt;p&gt;自动生成的配置文件还是挺多的，我们现在暂不用关注这些，只需要知道大概是做什么的就行了。&lt;/p&gt;

&lt;p&gt;从上面的命令行中可以看出来整个项目是用 ts-node 跑起来的，这样的目的就是在开发环境节去了编译 .ts 的过程（实际上是 ts-node 在背后做了这个事情）。我们只需要关注 &lt;code&gt;src/main.ts&lt;/code&gt; 这个入口文件即可。&lt;/p&gt;

&lt;p&gt;整个 main.ts 文件就 8 行代码，使用 Nest 的工厂函数创建了一个应用实例，并且监听 3000 端口。注意，Nest 默认会使用 ES 的 async/await 语法，所以你再也不用怕嵌套回调函数了，以同步的编码方式获取异步的效率。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:Object-Oriented&#34;&gt;Object Oriented Programming &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Object-Oriented&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Functional-Progr&#34;&gt;Functional Programming &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Functional-Progr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Functional-React&#34;&gt;Functional Reactive Programming &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Functional-React&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:-&#34;&gt;一种术语，表示通用语言 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:-&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>ProseMirror 编辑器指南中文翻译版</title>
      <link>https://keelii.com/2018/12/09/prosemirror-guide-cn/</link>
      <pubDate>Sun, 09 Dec 2018 17:59:45 +0800</pubDate>
      
      <guid>https://keelii.com/2018/12/09/prosemirror-guide-cn/</guid>
      <description>

&lt;p&gt;这个指南介绍了很多编辑器的设计理念，以及他们之间的关系。想完整的了解整个系统，建议按顺序阅读，或者至少阅读视图组件部分&lt;/p&gt;

&lt;h2 id=&#34;简介-introduction&#34;&gt;简介 Introduction&lt;/h2&gt;

&lt;p&gt;ProseMirror 提供了一组工具和设计概念用来构建富文本编辑器，UI 的使用源于 WYSIWYG 的一些灵感，ProseMirror 试着屏蔽一些排版中的痛点&lt;/p&gt;

&lt;p&gt;ProseMirror 的主要原则是：*你的代码对于 &lt;strong&gt;文档&lt;/strong&gt; 及其事件变更有完整的控制权*。这个 &lt;strong&gt;文档&lt;/strong&gt; 并不是原生的 HTML 文档，而是一个自定义的数据结构，这个数据结构包含了通过你明确允许应该被包含的元素，它们的关系也由你指定。所有的更新都会在一个你可以查看并做出响应的地方进行&lt;/p&gt;

&lt;p&gt;核心的代码库并不是一个容易拿来就用的组合 — 我们会优先考虑 &lt;strong&gt;模块化&lt;/strong&gt; 和 &lt;strong&gt;可自定义&lt;/strong&gt; 化胜过简单化，希望将来有用户会基于 ProseMirror 分发一个拿来就用的版本。因此，ProseMirror 更像是乐高积木而不是火柴盒拼成的玩具车&lt;/p&gt;

&lt;p&gt;总共有四个核心模块，任何编辑行为都需要用到它们，还有很多核心团队维护的扩展模块，类似于三方模块 — 它们提供有用的功能，但是你可以删除或者替换成其它实现了相同功能的模块&lt;/p&gt;

&lt;p&gt;核心模块分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;prosemirror-model&lt;/code&gt; 定义了编辑器的文档模型，数据结构用来描述编辑器的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prosemirror-state&lt;/code&gt; 提供了整个编辑器状态的数据结构，包括选区和维护状态变化的事务系统&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prosemirror-view&lt;/code&gt; 实现一个用户界面组件，用来在浏览器中把编辑器的状态展示成可编辑元素，并且与其进行交互&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prosemirror-transform&lt;/code&gt; 包含了一种可以记录/重放文档修改历史的功能组件，这是 &lt;code&gt;state&lt;/code&gt; 模块中事务的基础，而且这还使得编辑器的恢复历史和协作编辑功能成为可能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，还有一些诸如 基础的编辑命令、快捷键绑定、恢复历史、输入宏、协作编辑，简单的文档骨架 的模块。&lt;a href=&#34;https://github.com/prosemirror/&#34; title=&#34;Prosemirror org&#34;&gt;Github prosemirror 组织&lt;/a&gt; 代码库中还有更多&lt;/p&gt;

&lt;p&gt;事实上 ProseMirror 并没有分发一个独立的浏览器可以加载的脚本，这表示你可能需要一些模块 bunder 来配合使用它。模块 Bunder 就是一个工具，用来自动化查找你的脚本依赖，然后合并到一个单独文件中，使你能很容易的在 web 面页中使用。你可以阅读更多关于 bundling 的东西，比如：&lt;a href=&#34;https://medium.freecodecamp.org/javascript-modules-part-2-module-bundling-5020383cf306&#34; title=&#34;JavaScript Modules Part 2: Module Bundling&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;我的第一个编辑器-my-first-editor&#34;&gt;我的第一个编辑器 My first editor&lt;/h3&gt;

&lt;p&gt;就像拼乐高积木一样，下面的代码可以创建一个最小化的编辑器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;
import {EditorState} from &amp;quot;prosemirror-state&amp;quot;
import {EditorView} from &amp;quot;prosemirror-view&amp;quot;

let state = EditorState.create({schema})
let view = new EditorView(document.body, {state})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ProseMirror 需要你为文档指定一个自己觉得合适的骨架（schema），所以上面的代码第一件事情就是引入一个基础骨架模块&lt;/p&gt;

&lt;p&gt;接着这个骨架被用来创建一个状态，它将按骨架的定义生成一个空的文档，光标会在文档最开始的地方。最后创建了一个与状态关联的视图，并且插入到 &lt;code&gt;document.body&lt;/code&gt;。这将会把状态的文档渲染成一个可编辑的 DOM 节点，并且一旦用户输入内容就会生成一个状态事务（transactions）&lt;/p&gt;

&lt;p&gt;现在这个编辑器还没什么用处。比如说当你按下回车键时没有任何反应，因为核心库并不关心回车键应该用来做什么。我们马上就会谈到这一点&lt;/p&gt;

&lt;h3 id=&#34;事务-transactions&#34;&gt;事务 Transactions&lt;/h3&gt;

&lt;p&gt;当用户输入或者与视图交互时，将会生成「状态事务」。这意味着它不仅仅是只修改文档并以这种方式隐式更新其状态。相反，每次更改都会触发一个事务的创建，该事务描述对状态所做的更改，而且它可以被应用于创建一个新状态，随后用这个新状态来更新视图&lt;/p&gt;

&lt;p&gt;这些过程都会默认地在后台处理，但是你可以写一个插件来挂载进去，或者通过配置视图的参数。例如，下面的代码添加了一个 &lt;code&gt;dispatchTransaction&lt;/code&gt; 属性（props），每当创建一个事务时都会调用它&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// (省略了导入代码库)

let state = EditorState.create({schema})
let view = new EditorView(document.body, {
  state,
  dispatchTransaction(transaction) {
    console.log(&amp;quot;Document size went from&amp;quot;, transaction.before.content.size,
                &amp;quot;to&amp;quot;, transaction.doc.content.size)
    let newState = view.state.apply(transaction)
    view.updateState(newState)
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次状态变化都会经过 &lt;code&gt;updateState&lt;/code&gt;，而且每个普通的编辑更新都将通过调度一个事务来触发&lt;/p&gt;

&lt;h3 id=&#34;插件-plugins&#34;&gt;插件 Plugins&lt;/h3&gt;

&lt;p&gt;插件用于以各种方式扩展编辑器和编辑器状态的状态，有的会非常简单，比如 快捷键 插件 — 为键盘输入绑定具体动作；有的会比较复杂，比如 编辑历史 插件 — 通过观察事务并逆序存储来实现撤销历史记录，以防用户想要撤消它们&lt;/p&gt;

&lt;p&gt;让我们为编辑器添加这两个插件来获取撤消（undo）/重做（redo）的功能：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// (Omitted repeated imports)
import {undo, redo, history} from &amp;quot;prosemirror-history&amp;quot;
import {keymap} from &amp;quot;prosemirror-keymap&amp;quot;

let state = EditorState.create({
  schema,
  plugins: [
    history(),
    keymap({&amp;quot;Mod-z&amp;quot;: undo, &amp;quot;Mod-y&amp;quot;: redo})
  ]
})
let view = new EditorView(document.body, {state})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当创建一个状态的时候插件就会被注册（因为插件需要访问状态事务），当这个开启了编辑历史状态的视图被创建时，你将可以通过按 &lt;code&gt;Ctrl-Z&lt;/code&gt; 或者 &lt;code&gt;Cmd-Z&lt;/code&gt; 来撤消最近的一次变更&lt;/p&gt;

&lt;h3 id=&#34;命令-commands&#34;&gt;命令 Commands&lt;/h3&gt;

&lt;p&gt;上面示例代码中的 &lt;code&gt;undo&lt;/code&gt; 和 &lt;code&gt;redo&lt;/code&gt; 变量值是绑定到指定键位的一种叫做 *命令* 的特殊值。大多数编辑动作都是作为可绑定到键的命令编写的，它可以用来挂载到菜单栏，或者直接暴露给用户&lt;/p&gt;

&lt;p&gt;&lt;code&gt;prosemirror-commands&lt;/code&gt; 包提供了许多基本的编辑命令，其中一些是你可以需要用到的基本的快捷键，比如 回车，删除编辑器中指定的内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// (Omitted repeated imports)
import {baseKeymap} from &amp;quot;prosemirror-commands&amp;quot;

let state = EditorState.create({
  schema,
  plugins: [
    history(),
    keymap({&amp;quot;Mod-z&amp;quot;: undo, &amp;quot;Mod-y&amp;quot;: redo}),
    keymap(baseKeymap)
  ]
})
let view = new EditorView(document.body, {state})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，你已经有了一个算得上可以使用的编辑器了&lt;/p&gt;

&lt;p&gt;添加菜单，额外的为特定骨架指定的快捷键绑定 等功能，可以通过查看 &lt;a href=&#34;https://github.com/prosemirror/prosemirror-example-setup&#34; title=&#34;prosemirror-example-setup&#34;&gt;prosemirror-example-setup&lt;/a&gt; 包了解更多。这个模块提供给你一组插件用来创建一个基础的编辑器，但是就像它的名字一样，只是个例子，并不是生产环境级别的代码库。真正的开发中，你可能会需要替换成自定义的代码来精确实现你想要的功能&lt;/p&gt;

&lt;h3 id=&#34;内容-content&#34;&gt;内容 Content&lt;/h3&gt;

&lt;p&gt;一个状态的文档被挂在它的 &lt;code&gt;doc&lt;/code&gt; 属性上。这是一个只读的数据结构，用各种级别的节点来表示文档，就像是浏览器的 DOM。一个简单的文档可能会由一个包含了两个「段落」节点，每个「段落」节点又包含一个「文本」节点的「文档」节点构成&lt;/p&gt;

&lt;p&gt;当初始化一个状态时，你可以给它一个初始文档。这种情况下，&lt;code&gt;schema&lt;/code&gt; 就变成非必传项了，因为 &lt;code&gt;schame&lt;/code&gt; 可以从文档中获取&lt;/p&gt;

&lt;p&gt;下面我们通过传入一个 DOM 元素 （ID 为 content）做为 DOM parser 的参数初始化一个状态，它将利用 &lt;code&gt;schema&lt;/code&gt; 中的信息来解析出对应的节点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {DOMParser} from &amp;quot;prosemirror-model&amp;quot;
import {EditorState} from &amp;quot;prosemirror-state&amp;quot;
import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;

let content = document.getElementById(&amp;quot;content&amp;quot;)
let state = EditorState.create({
  doc: DOMParser.fromSchema(schema).parse(content)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文档-documents&#34;&gt;文档 Documents&lt;/h3&gt;

&lt;p&gt;ProseMirror 定义了他自己的一种用来表示文档内容的数据结构。由于文档是构建所有编辑器的核心元素，了解它们的工作原理会对我们很有帮助&lt;/p&gt;

&lt;h3 id=&#34;结构-structure&#34;&gt;结构 Structure&lt;/h3&gt;

&lt;p&gt;一个 ProseMirror 文档就是一个节点，它包含一个片段，其中可以有一个或者多个子节点&lt;/p&gt;

&lt;p&gt;这个和浏览器 DOM 非常相似，浏览器 DOM 是一个递归的树型结构。但是 ProseMirror 的不同点在于它存储内联元素的方式&lt;/p&gt;

&lt;p&gt;在 HTML 中，一个段落的标记表示为一个树，就像这个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;This is &amp;lt;strong&amp;gt;strong text with &amp;lt;em&amp;gt;emphasis&amp;lt;/em&amp;gt;&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/14129/3/786/35284/5c0cc441E403d82b0/ef0b3f850962b393.png&#34; alt=&#34;prosemirror-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而在 ProseMirror 中，内联内容被建模为 &lt;strong&gt;扁平&lt;/strong&gt; 的序列，标记作为元数据附加到节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/15813/40/792/39752/5c0cc4e0Ee27f5876/150f7e117aa64233.png&#34; alt=&#34;prosemirror-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这更符合我们思考和使用此类文本的方式，这允许我们使用字符来表示位置而不是树的路径，这使得一些操作如分割、更改内容样式变得比维护树简单&lt;/p&gt;

&lt;p&gt;这也意味着每个文档都只有一种合法的表现层。具有相同标记集的相邻文本节点总是组合在一起，并且不允许有空文本节点，标记出现的顺序由骨架指定&lt;/p&gt;

&lt;p&gt;所以说一个 ProseMirror 文档就是一颗块级节点树，其中大多数叶子节点都是文本块，块级节点可以包含这些文本块儿。你也可以有一些空的叶子节点，比如水平分隔线或者视频元素&lt;/p&gt;

&lt;p&gt;节点对象有很多属性，它们代表所处文档中的角色：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isBlock&lt;/code&gt; 和 isInline 告诉你给定的节点是一个块级节点还是内联节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inlineContent&lt;/code&gt; 表示一个节点希望它的内容是是内联元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isTextblock&lt;/code&gt; 表示一个块级节点包含内联内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isLeaf&lt;/code&gt; 告诉你节点不允许有任何内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;典型的「段落」节点是一个文本节点，而「引用块」可能是一个包含其它块级元素的元素。文本、硬换行（&lt;br&gt;）以及内联图片都是内联叶子节点，水平分隔线节点则是一种块级叶子节点&lt;/p&gt;

&lt;p&gt;骨架允许你更准确地指定什么东西应该出现在什么位置，例如。即使一个节点允许块级内容，这并不表示他会允许所有的节点做为它的内容&lt;/p&gt;

&lt;h3 id=&#34;标识与存储-identity-and-persistence&#34;&gt;标识与存储 Identity and persistence&lt;/h3&gt;

&lt;p&gt;另外一个 DOM 树和 ProseMirror 文档不同的地方是，对象表示节点的行为。在 DOM 中，节点是具有标识的可变的对象，这表示一个节点只能出现在一个父节点中，当节点更新的时候对象也会被修改&lt;/p&gt;

&lt;p&gt;另外一方面，在 ProseMirror 中，节点仅仅是一些 *值*，和你想表示数字 3 一样，3 可以同时出现在很多数据结构中，它自己所处的部分与父元素没有连系，如果你给它加 1，你会得到一个新值 4，并且不用改变和原来 3 相关的任何东西&lt;/p&gt;

&lt;p&gt;所以它是 ProseMirror 文档的一部分，它们不会更改，但是可以用作计算修改后的文档的起始值。它们也不知道自己处在什么数据结构当中，但可以是多个结构的一部分，甚至多次出现在一个结构中。它们是值，不是状态化的对象&lt;/p&gt;

&lt;p&gt;这表示每当你更新文档，你将会获得一个新的文档值。文档值将共享所有子节点，并且不会修改原来的文档值，这使得它创建起来相对廉价&lt;/p&gt;

&lt;p&gt;这有很多优点。它可以使两次更新之间的过程无效（严格控制更新的内容和过程），因为具有新文档的新状态可以瞬间转换。它还使得文档以某种数学方式推理变得更容易，相反的如果你的值不断的在后台发生变化这将会很难做到。这也使得协作编辑成为可能，并允许 ProseMirror 通过将最后一个绘制到屏幕的文档与当前文档进行比较来运行非常高效的 DOM 更新算法&lt;/p&gt;

&lt;p&gt;由于此类节点使用了常规的 JavaScript 对象来表示，如果并且明确地冻结（&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&#34; title=&#34;freeze&#34;&gt;freezing&lt;/a&gt;）其属性可能会影响到性能，实际上属性是 *可以* 改变的，但是并不建议你这么做，这将会导致程序中断，因为它们几乎总是在多个数据结构之间共享。所以要小心！请注意，这也适用于作为节点对象一部分的数组和普通对象，例如用于存储节点属性的对象或片段中子节点的数组（译注：意思是你最好不要更改类似的内部对象，给对象添加或者删除属性）&lt;/p&gt;

&lt;h3 id=&#34;数据结构-data-structures&#34;&gt;数据结构 Data structures&lt;/h3&gt;

&lt;p&gt;一个文档的对象看起来像这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/9284/27/8310/83213/5c0cc4f2E3dca8ae6/dcc5b46f77995593.png&#34; alt=&#34;prosemirror-3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每个节点都是一个 Node 类的实例。都有一个 type 做为标签，通过 type 可以知道节点的名字，节点的属性字段也是有效的等等。节点的类型（和标识类型）每骨架会创建一次，他们知道自己属于骨架的哪个部分&lt;/p&gt;

&lt;p&gt;节点的内容存储在 Fragment 的一个实例中，它掌握着节点序列。即使节点没有或者不允许有内容，这个字段也会有值（共享的空 fragment）&lt;/p&gt;

&lt;p&gt;一些节点类型允许添加属性，它些值被存储到每个节点上。比如，图片节点一般会使用属性来存储 alt 文本和图片的 URL&lt;/p&gt;

&lt;p&gt;此外，内联节点包含一组活动标记 — 例如强调（emphasis）或链接（link）— 活动标记就是一组 Mark 实例&lt;/p&gt;

&lt;p&gt;整个文档就是一个节点。文档内容表现为一个顶级节点的子节点。通常，它将包含一系列块节点，其中一些块节点可能是包含内联内容的文本块。但顶级节点本身也可以是文本块，这样的话文档就只包含内联内容&lt;/p&gt;

&lt;p&gt;什么样的节点可以被允许，是由文档的骨架决定的。用代码的方式创建节点（而不是直接用基础骨架库），你必须通过骨架来实现，比如使用 &lt;code&gt;node&lt;/code&gt; 和 &lt;code&gt;text&lt;/code&gt; 方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;

// 如果需要的话可以把 null 参数替换成你想给节点添加的属性
let doc = schema.node(&amp;quot;doc&amp;quot;, null, [
  schema.node(&amp;quot;paragraph&amp;quot;, null, [schema.text(&amp;quot;One.&amp;quot;)]),
  schema.node(&amp;quot;horizontal_rule&amp;quot;),
  schema.node(&amp;quot;paragraph&amp;quot;, null, [schema.text(&amp;quot;Two!&amp;quot;)])
])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;索引-indexing&#34;&gt;索引 Indexing&lt;/h3&gt;

&lt;p&gt;ProseMirror 节点支持两种索引 — 它们可以看做是树，使用单个节点的偏移量，或者它们可以被视为一个扁平的标识（tokens）序列&lt;/p&gt;

&lt;p&gt;&lt;em&gt;第一种&lt;/em&gt; 允许你执行类似于对 DOM 与单个节点进行操作的交互，使用 &lt;code&gt;child&lt;/code&gt; 方法和 &lt;code&gt;childCount&lt;/code&gt; 直接访问子节点，编写扫描文档的递归函数（如果你只想查看所有节点，请使用 &lt;code&gt;descendants&lt;/code&gt; 或 &lt;code&gt;nodesBetween&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;&lt;em&gt;第二种&lt;/em&gt; 当访问一个文档中指定的位置时更好用。它允许把文档任意位置表示为一个整数 — 即标记序列中的索引。这些标识并不做为对象在内存中 — 它们仅仅是用来计数的惯例 — 但是文档的树形状以及每个节点都知道它的大小，这使得按位置访问变的廉价（译注：类似于用下标访问扁平数组，而不是递归遍历嵌套结构的树）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在第一个内容之前，文档的开头是位置 0&lt;/li&gt;
&lt;li&gt;进入或离开不是叶子节点的节点（即支持内容）计为一个&lt;strong&gt;标识索引位&lt;/strong&gt;。因此，如果文档以段落开头，则该段落的开头计为位置 1&lt;/li&gt;
&lt;li&gt;文本节点中的每个字符都算作一个标识索引位。因此，如果文档开头的段落包含单词「hi」，则位置 2 位于「h」之后，位置 3 位于「i」之后，位置 4 位于整个段落之后&lt;/li&gt;
&lt;li&gt;不允许有内容（例如图像）的叶子节点也算作 &lt;strong&gt;单个&lt;/strong&gt; 标识索引位&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，如果你有一个文档，当表示为 HTML 时，将如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;One&amp;lt;/p&amp;gt;
&amp;lt;blockquote&amp;gt;&amp;lt;p&amp;gt;Two&amp;lt;img src=&amp;quot;...&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标识序列以及位置下标，将会是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0   1 2 3 4    5
 &amp;lt;p&amp;gt; O n e &amp;lt;/p&amp;gt;

5            6   7 8 9 10    11   12            13
 &amp;lt;blockquote&amp;gt; &amp;lt;p&amp;gt; T w o &amp;lt;img&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个节点都有一个 &lt;code&gt;nodeSize&lt;/code&gt; 属性，可以为告诉你整个节点的大小，你可以访问 &lt;code&gt;.content.size&lt;/code&gt; 来获取节点 *内容* 的大小。注意，对于外部文档节点，打开和关闭标记不被视为文档的一部分（因为你无法将光标放在文档外面），因此文档的大小为 &lt;code&gt;doc.content.size&lt;/code&gt;，而不是 &lt;code&gt;doc.nodeSize&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;手动解释这样的位置会涉及相当多的计数操作。你可以调用 &lt;code&gt;Node.resolve&lt;/code&gt; 来获取关于节点位置的更具有描述性的数据结构。这个数据结构将告诉你该位置的父节点是什么，它与父节点的偏移量是什么，父节点的祖先是什么，以及其他一些东西&lt;/p&gt;

&lt;p&gt;注意区分子索引（每个 childCount），文档范围的位置和 &lt;code&gt;node-local&lt;/code&gt; 偏移（有时在递归函数中用于表示当前正在处理的节点中的位置）&lt;/p&gt;

&lt;h3 id=&#34;切片-slices&#34;&gt;切片 Slices&lt;/h3&gt;

&lt;p&gt;为了处理一些诸如复制/粘贴和拖拽之类的操作，通过切片与文档进行通信是非常必要的，比如，两个位置之间的内容。这样的切片不同于整个节点或者片段，一些节点可能位于切片开始或者结束（译注：切片的开始位置可能在某个节点的中间）&lt;/p&gt;

&lt;p&gt;例如，从一个段落的中间选择到下一个段落的中间，你所选择的切片中会有两个段落，那么切片的开始位置在第一个段落打开的地方，结束位置就在第二个段落打开的地方。然而如果你 node-select 一个段落，你就选择了一整个有关闭的节点。可能的情况是，如果将此类开放节点中的内容视为节点的完整内容，则会违反骨架约束（标签可能没关闭），因为某些所需节点落在切片之外&lt;/p&gt;

&lt;p&gt;Slice 数据结构用于表示这样的切片。它存储一个 fragment 以及两侧的 节点打开深度（open depth）。你可以在节点上使用切片方法从文档外剪切切片&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/*
0   1 2 3   4
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
4   5 6 7   8 
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
*/
// doc holds two paragraphs, containing text &amp;quot;a&amp;quot; and &amp;quot;b&amp;quot;
let slice1 = doc.slice(0, 3) // The first paragraph
/*
0|   1 2 3   |4
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
*/
console.log(slice1.openStart, slice1.openEnd) // → 0 0
let slice2 = doc.slice(1, 5) // From start of first paragraph
                             // to end of second
/*
0  1| 2 3   4
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
4    5|6 7   8 
 &amp;lt;p&amp;gt; a b &amp;lt;/p&amp;gt;
*/
console.log(slice2.openStart, slice2.openEnd) // → 1 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;更改-changing&#34;&gt;更改 Changing&lt;/h3&gt;

&lt;p&gt;由于节点和片段是持久存储的，因此 &lt;strong&gt;永远&lt;/strong&gt; 不要修改它们。如果你有文档（或节点或片段）的句柄，那这个句柄引用的对象将保持不变（译注：这意味着并不能通过拿到的引用直接修改节点，因为这个节点的引用是不可变的值，当你想改变的时候节点可能已经成为历史）&lt;/p&gt;

&lt;p&gt;大多数情况下，你将使用转换（transformations）来更新文档，而不必直接接触节点。这些也会留下更改记录，当文档是编辑器状态的一部分时，这是必要的&lt;/p&gt;

&lt;p&gt;如果你确实想要「手动」派发更新的文档，那么 &lt;code&gt;Node&lt;/code&gt; 和 &lt;code&gt;Fragment&lt;/code&gt; 类型上有一些辅助方法可用。要创建整个文档的更新版本，通常需要使用&lt;code&gt;Node.replace&lt;/code&gt;，它用一个新的内容切片替换文档的给定范围。要少量地更新节点，可以使用 copy 方法，该方法使用新内容创建类似的节点。Fragments 还有各种更新方法，例如 &lt;code&gt;replaceChild&lt;/code&gt; 或 &lt;code&gt;append&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;骨架-schemas&#34;&gt;骨架 Schemas&lt;/h2&gt;

&lt;p&gt;每个 ProseMirror 文档都有一个与之关联的骨架，骨架描述了文档中可能出现的节点类型以及它们嵌套的方式。例如，它可能会指定顶级节点可以包含一个或多个块，并且段落节点可以包含任意数量的内联节点，内联节点可以使用任何标记&lt;/p&gt;

&lt;p&gt;有一个包含基础骨架的包，但 ProseMirror 的优点在于它允许你定义自己的骨架&lt;/p&gt;

&lt;h3 id=&#34;节点类型-node-types&#34;&gt;节点类型 Node Types&lt;/h3&gt;

&lt;p&gt;文档中的每个节点都有一个类型，表示其语义和属性，正如其在编辑器中呈现的方式&lt;/p&gt;

&lt;p&gt;定义骨架时，可以枚举其中可能出现的节点类型，并使用 &lt;code&gt;spec&lt;/code&gt; 对象描述：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const trivialSchema = new Schema({
  nodes: {
    doc: {content: &amp;quot;paragraph+&amp;quot;},
    paragraph: {content: &amp;quot;text*&amp;quot;},
    text: {inline: true},
    /* ... and so on */
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码定义了一个骨架，其中文档可能包含一个或多个段落，每个段落可以包含任意数量的文本&lt;/p&gt;

&lt;p&gt;每个骨架必须至少定义顶级节点类型（默认为名称「doc」，但你可以设置），以及文本内容的（text）类型&lt;/p&gt;

&lt;p&gt;注意内联的节点必须使用 inline 属性声明（但对于文本类型，根据定义是内联的，可以省略它）&lt;/p&gt;

&lt;h3 id=&#34;内容表达式-content-expressions&#34;&gt;内容表达式 Content Expressions&lt;/h3&gt;

&lt;p&gt;上面示例模式中的内容字段（paragraph+, text*）中的字符串称为内容表达式。它们控制子节点的哪些序列对此节点类型有效&lt;/p&gt;

&lt;p&gt;例如 &lt;code&gt;paragraph&lt;/code&gt; 表示「一个段落」, &lt;code&gt;paragraph+&lt;/code&gt; 表示「一个或者多个段落」。相似地，&lt;code&gt;paragraph*&lt;/code&gt; 表示「零个或者更多个段落」, &lt;code&gt;caption?&lt;/code&gt; 表示「零个或者一个说明文字」。你可以使用类正则的范围区间，比如 &lt;code&gt;{2}&lt;/code&gt; 表示精确的两次，&lt;code&gt;{1, 5}&lt;/code&gt; 表示 1~5 次，&lt;code&gt;{2,}&lt;/code&gt; 表示 2~更多多次&lt;/p&gt;

&lt;p&gt;可以组合这些表达式来创建序列，比如 &lt;code&gt;heading paragraph+&lt;/code&gt; 表示「首先是标题，然后是一个或多个段落」。你也可以使用管道运算符 &lt;code&gt;|&lt;/code&gt; 表示两个表达式之间的选择，如 &lt;code&gt;(paragraph|blockquote)+&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;某些元素类型组将在你的模式中出现多种类型 — 例如，你可能有一个「块」节点的概念，它可能出现在顶层但也嵌套在块引用内。你可以通过为节点规范提供 group 属性来创建节点组，然后在表达式中按名称引用该组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const groupSchema = new Schema({
  nodes: {
    doc: {content: &amp;quot;block+&amp;quot;},
    paragraph: {group: &amp;quot;block&amp;quot;, content: &amp;quot;text*&amp;quot;},
    blockquote: {group: &amp;quot;block&amp;quot;, content: &amp;quot;block+&amp;quot;},
    text: {}
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 &lt;code&gt;block+&lt;/code&gt; 相当于 &lt;code&gt;(paragraph | blockquote)+&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;建议在具有块内容的节点中始终需要至少一个子节点（例如上面示例中的 &lt;code&gt;doc&lt;/code&gt; 和 &lt;code&gt;blockquote&lt;/code&gt;），因为当节点为空时，浏览器将完全折叠节点，不方便编辑&lt;/p&gt;

&lt;p&gt;节点在 or-表达式中的显示顺序非常重要。为非可选节点创建默认实例时，例如，为了确保在替换步骤后文档仍符合模式，将使用表达式中的第一个类型。如果这是一个组，则使用组中的第一个类型（由组成员在节点映射中显示的顺序确定）。如果我在示例骨架中切换 &lt;code&gt;paragraph&lt;/code&gt; 和 &lt;code&gt;blockquote&lt;/code&gt; 的位置，编辑器尝试创建一个块节点时，你会得到堆栈溢出 - 它会创建一个 &lt;code&gt;blockquote&lt;/code&gt; 节点，其内容至少需要一个块，因此它会尝试创建另一个 &lt;code&gt;blockquote&lt;/code&gt; 作为内容， 等等&lt;/p&gt;

&lt;p&gt;库中的节点操作函数并非每个都会检查它是否正在处理有效的内容 - 高层次的概念，例如 转换（transforms）会，但原始节点创建方法通常不会，而是负责为其调用者提供合理的输入。完全可以使用例如 NodeType.create 来创建具有无效内容的节点。对于在切片边缘 &lt;code&gt;打开&lt;/code&gt; 的节点，这甚至是合理的事情。有一个单独的 createChecked 方法，以及一个事后 check 方法，可用于断言给定节点的内容是有效的。&lt;/p&gt;

&lt;h3 id=&#34;标记-marks&#34;&gt;标记 Marks&lt;/h3&gt;

&lt;p&gt;标记用于向内联内容添加额外样式或其他信息。骨架必须声明允许的所有标记类型。&lt;strong&gt;标记类型&lt;/strong&gt; 是与 &lt;strong&gt;节点类型&lt;/strong&gt; 非常相似的对象，用于标记标记对象并提供其他信息&lt;/p&gt;

&lt;p&gt;默认情况下，具有内联内容的节点允许将骨架中定义的所有标记应用于其子项。你可以使用节点规范上的 marks 属性对其进行配置&lt;/p&gt;

&lt;p&gt;这有一个简单的骨架，支持段落中文本的 strong 和 emphasis 标记，但不支持标题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const markSchema = new Schema({
  nodes: {
    doc: {content: &amp;quot;block+&amp;quot;},
    paragraph: {group: &amp;quot;block&amp;quot;, content: &amp;quot;text*&amp;quot;, marks: &amp;quot;_&amp;quot;},
    heading: {group: &amp;quot;block&amp;quot;, content: &amp;quot;text*&amp;quot;, marks: &amp;quot;&amp;quot;},
    text: {inline: true}
  },
  marks: {
    strong: {},
    em: {}
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标记集被解释为以空格分隔的标记名称或标记组字符串 — &lt;code&gt;_&lt;/code&gt; 充当通配符，空字符串对应于空集&lt;/p&gt;

&lt;h3 id=&#34;属性-attributes&#34;&gt;属性 Attributes&lt;/h3&gt;

&lt;p&gt;文档骨架还定义了每个节点或标记具有的属性。如果你的节点类型需要存储额外的信息，例如标题节点的级别，那就最好使用属性&lt;/p&gt;

&lt;p&gt;属性集可以认为就是普通对象，具有预定义（每个节点或标记）属性集，包含任何 JSON 可序列化值。要指定它允许的属性，请使用节点中的可选 attrs 字段或标记规范&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;heading: {
  content: &amp;quot;text*&amp;quot;,
  attrs: {level: {default: 1}}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的骨架中，标题节点的每个实例都将具有 level 属性。如果不指定，则默认为 1&lt;/p&gt;

&lt;p&gt;如果不指定属性默认值，在尝试创建此类节点又不传属性时将引发错误。在满足模式约束条件下进行转换或调用 createAndFill 时，也无法使用库生成此类节点并填充&lt;/p&gt;

&lt;h3 id=&#34;序列化与解析-serialization-and-parsing&#34;&gt;序列化与解析 Serialization and Parsing&lt;/h3&gt;

&lt;p&gt;为了能够在浏览器中编辑它们，必须能够在浏览器 DOM 中表示文档节点。最简单的方法是使用 node spec 中的 &lt;code&gt;toDOM&lt;/code&gt; 字段包含有关骨架中每个节点的 DOM 表示的信息&lt;/p&gt;

&lt;p&gt;该字段应包含一个函数，当以节点作为参数调用时，该函数返回该节点的DOM 结构的描述。这可以是直接 DOM 节点或描述它的数组，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const schema = new Schema({
  nodes: {
    doc: {content: &amp;quot;paragraph+&amp;quot;},
    paragraph: {
      content: &amp;quot;text*&amp;quot;,
      toDOM(node) { return [&amp;quot;p&amp;quot;, 0] }
    },
    text: {}
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表达式 &lt;code&gt;[“p”, 0]&lt;/code&gt; 声明了一个段落会被渲染成 HTML &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 标签。零是一个「孔」用来表示内容被渲染的地方，你还可以在标记名称后面包含具有 HTML 属性的对象，例如：&lt;code&gt;[&amp;quot;div&amp;quot;, {class: &amp;quot;c&amp;quot;}, 0]&lt;/code&gt;。叶节点在其 DOM 表示中不需要「洞」，因为它们没有内容&lt;/p&gt;

&lt;p&gt;Mark specs 允许类似于 toDOM 方法，但它们需要渲染成直接包装内容的单个标记，因此内容始终直接在返回的节点中，并且不需要指定「孔」&lt;/p&gt;

&lt;p&gt;你可能经常需要从 DOM 数据中 *解析* 文档，例如，当用户将某些内容粘贴或拖动到编辑器中时。模型（Model） 模块具有相应的功能，建议你使用 &lt;code&gt;parseDOM&lt;/code&gt; 属性直接在骨架中包含解析信息&lt;/p&gt;

&lt;p&gt;这可以列出一个解析规则数组，它描述映射到给定节点或标记的 DOM 结构。例如，基础骨架具有以下表示 emphasis 标记：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;parseDOM: [
  {tag: &amp;quot;em&amp;quot;},                 // Match &amp;lt;em&amp;gt; nodes
  {tag: &amp;quot;i&amp;quot;},                  // and &amp;lt;i&amp;gt; nodes
  {style: &amp;quot;font-style=italic&amp;quot;} // and inline &#39;font-style: italic&#39;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析规则中标记的值可以是 CSS 选择器，因此你也可以使用 &lt;code&gt;div.myclass&lt;/code&gt; 之类的操作。同样，style 属性匹配内联 CSS 样式&lt;/p&gt;

&lt;p&gt;当骨架包含 parseDOM 注解时，你可以使用 DOMParser.fromSchema 为其创建DOMParser 对象。这是由编辑器完成的，用于创建默认剪贴板解析器，但你也可以覆写它&lt;/p&gt;

&lt;p&gt;文档还带有内置的 JSON 序列化格式。你可以在文档上调用 toJSON 以获取可以安全地传递给 JSON.stringify 的对象，并且骨架对象具有将此表示形式解析回文档的 nodeFromJSON 方法&lt;/p&gt;

&lt;h3 id=&#34;扩展一个骨架-extending-a-schema&#34;&gt;扩展一个骨架 Extending a schema&lt;/h3&gt;

&lt;p&gt;传递给 Schema 构造函数的 nodes 和 marks 选项采用了 OrderedMap 对象以及纯 JavaScript 对象。骨架的 spec.nodes 和 spec.marks 属性始终是一组 OrderedMap，可以用作其它骨架的基础&lt;/p&gt;

&lt;p&gt;此类映射支持许多方法以方便地创建更新版本。例如，你可以调用 &lt;code&gt;schema.markSpec.remove(“blockquote”)&lt;/code&gt; 来派生一组没有 blockquote 节点的节点，然后可以将其作为新骨架的节点字段传入&lt;/p&gt;

&lt;p&gt;schema-list 模块导出一个便捷方法，将这些模块导出的节点添加到节点集中&lt;/p&gt;

&lt;h2 id=&#34;文档转换-document-transformations&#34;&gt;文档转换 Document transformations&lt;/h2&gt;

&lt;p&gt;转换是 ProseMirror 工作方式的核心。它们构成了事务的基础，转换使得历史追踪和协作编辑成为可能&lt;/p&gt;

&lt;h3 id=&#34;为什么-why&#34;&gt;为什么 Why?&lt;/h3&gt;

&lt;p&gt;为什么我们不能直接改变文档？或者至少创建一个新版本的文档，然后将其放入编辑器中？&lt;/p&gt;

&lt;p&gt;有几个原因。一个是代码清晰度。不可变数据结构确实使得代码更简单。但是，转换系统的主要工作是留下更新的痕迹，以值的形式表示旧版本的文档到新版本所采取的各个步骤&lt;/p&gt;

&lt;p&gt;撤消历史记录可以保存这些步骤并反转应用它们以便及时返回（ProseMirror 实现选择性撤消，这比仅回滚到先前状态更复杂）&lt;/p&gt;

&lt;p&gt;协作编辑系统将这些步骤发送给其他编辑器，并在必要时重新排序，以便每个人最终都使用相同的文档&lt;/p&gt;

&lt;p&gt;更一般地说，编辑器插件能够检查每个更改并对其进行响应是非常有用的，为了保持其自身状态与编辑器的其余状态保持一致&lt;/p&gt;

&lt;h3 id=&#34;步骤-steps&#34;&gt;步骤 Steps&lt;/h3&gt;

&lt;p&gt;对文档的更新会分解为步骤（step）来描述一次更新。通常不需要你直接使用这些，但了解它们的工作方式很有用&lt;/p&gt;

&lt;p&gt;例如使用 &lt;code&gt;ReplaceStep&lt;/code&gt; 来替换一份文档，或者使用 &lt;code&gt;AddMarkStep&lt;/code&gt; 来给指定的范围（Range）添加标记&lt;/p&gt;

&lt;p&gt;可以将步骤应用于文档来成新文档&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(myDoc.toString()) // → p(&amp;quot;hello&amp;quot;)
// A step that deletes the content between positions 3 and 5
let step = new ReplaceStep(3, 5, Slice.empty)
let result = step.apply(myDoc)
console.log(result.doc.toString()) // → p(&amp;quot;heo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用一个步骤是一件相对奇怪的过程 — 它没有做任何巧妙的事情，比如插入节点以保留骨架的约束，或者转换切片以使其适应约束。这意味着应用步骤可能会失败，例如，如果你尝试仅删除节点的打开标记，这会使标记失衡，这对你来说是毫无意义的。这就是为什么 apply 返回一个 result 对象的原因，result 对象包含一个新文档或者一个错误消息&lt;/p&gt;

&lt;p&gt;你通常会使用工具函数来生成步骤，这样就不必担心细节&lt;/p&gt;

&lt;h3 id=&#34;转换-transforms&#34;&gt;转换 Transforms&lt;/h3&gt;

&lt;p&gt;一个编辑动作可以产生一个或多个步骤（step）。处理一系列步骤最方便的方法是创建一个 &lt;code&gt;Transform&lt;/code&gt; 对象（或者，如果你正在使用整个编辑器状态，则可以使用 &lt;code&gt;Transaction&lt;/code&gt;，它是 &lt;code&gt;Transform&lt;/code&gt; 的子类）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let tr = new Transform(myDoc)
tr.delete(5, 7) // Delete between position 5 and 7
tr.split(5)     // Split the parent node at position 5
console.log(tr.doc.toString()) // The modified document
console.log(tr.steps.length)   // → 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大多数转换方法都返回转换本身，方便链式调用 &lt;code&gt;tr.delete(5,7).split(5)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;会有很多关于转换的方法可以使用，删除、替换、添加、删除标记，以及维护树型结构的方法如 分割、合并、包裹等&lt;/p&gt;

&lt;h3 id=&#34;映射-mapping&#34;&gt;映射 Mapping&lt;/h3&gt;

&lt;p&gt;当你对文档进行更改时，指向该文档的指针可能会变成无效或并不是你想要的样子了。例如，如果插入一个字符，那么该字符后面的所有位置都会指向一个旧位置之前的标记。同样，如果删除文档中的所有内容，则指向该内容的所有位置现在都会失效&lt;/p&gt;

&lt;p&gt;我们经常需要保留文档更改的位置，例如选区边界。为了解决这个问题，步骤可以为你提供一个字典映射，可以在应用该步骤之前和之后进行转换并且应用应该步骤&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let step = new ReplaceStep(4, 6, Slice.empty) // Delete 4-5
let map = step.getMap()
console.log(map.map(8)) // → 6
console.log(map.map(2)) // → 2 (nothing changes before the change)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转换对象会自动对其中的步骤（step）累加一系列的字典，使用一种叫做 &lt;strong&gt;映射&lt;/strong&gt; 的抽象，它收集了一系列的步骤字典来帮助你一次性映射它们&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let tr = new Transaction(myDoc)
tr.split(10)    // split a node, +2 tokens at 10
tr.delete(2, 5) // -3 tokens at 2
console.log(tr.mapping.map(15)) // → 14
console.log(tr.mapping.map(6))  // → 3
console.log(tr.mapping.map(10)) // → 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在某些情况下，并不是完全清楚应该将给定位置映射到什么位置。考虑上面示例的最后一行代码。位置 10 恰好指向我们分割节点的地方，插入两个标识。它应该被映射到插入内容后面还是前面？例子中明显是映射到插入内容后面&lt;/p&gt;

&lt;p&gt;但是有时候你需要一些其它的行为，这是为什么 map 方法有第二个参数 &lt;code&gt;bias&lt;/code&gt; 的原因，你可以设置成 -1 当内容被插入到前面时保持你的位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(tr.mapping.map(10, -1)) // → 7
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;rebasing&#34;&gt;Rebasing&lt;/h3&gt;

&lt;p&gt;当使用步骤和位置映射时，比如实现一个变更追踪的功能，或者给协作编辑符加一些功能，你可能就会遇到使用 rebase 步骤的场景&lt;/p&gt;

&lt;p&gt;…（本小节译者并没有完全理解，暂不翻译，有兴趣可以参考&lt;a href=&#34;http://prosemirror.net/docs/guide/#transform.rebasing&#34; title=&#34;prosemirror - transform.rebasing&#34;&gt;原文&lt;/a&gt;）&lt;/p&gt;

&lt;h2 id=&#34;编辑器状态-the-editor-state&#34;&gt;编辑器状态 The editor state&lt;/h2&gt;

&lt;p&gt;编辑的状态由什么构成？当然，你有自己的文档。还有当前的选区。例如当你需要禁用或启用一个标记但还没在该标记上输入内容时，需要有一种方法来存储当前标记集已更改的情况&lt;/p&gt;

&lt;p&gt;一个 ProseMirror 的状态由三个主要的组件构成：&lt;code&gt;doc&lt;/code&gt;, &lt;code&gt;selection&lt;/code&gt; 和 &lt;code&gt;storedMarks&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;
import {EditorState} from &amp;quot;prosemirror-state&amp;quot;

let state = EditorState.create({schema})
console.log(state.doc.toString()) // An empty paragraph
console.log(state.selection.from) // 1, the start of the paragraph
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是插件可能也有存储状态的需求 — 例如，撤消历史记录必须保留其变更记录。这就是为什么所有激活的插件也被存放在状态中的原因，并且这些插件可以用于存储自身状态的槽（slots）&lt;/p&gt;

&lt;h3 id=&#34;选区-selection&#34;&gt;选区 Selection&lt;/h3&gt;

&lt;p&gt;ProseMirror 支持几种选区类型（并允许三方代码定义新的选区类型）。选区就是 &lt;code&gt;Selection&lt;/code&gt; 类的一个实例。就像文档和其它状态相关的值一样，它们是不可变的 — 想改变选区，就得创建一个新的选区对象让新的状态关联它&lt;/p&gt;

&lt;p&gt;选区至少包含一个开始（&lt;code&gt;.from&lt;/code&gt;）和一个结束（&lt;code&gt;.to&lt;/code&gt;）做为当前文档的位置指针。许多选区还区分选区的 &lt;code&gt;anchor&lt;/code&gt;（不可移动的）和 &lt;code&gt;head&lt;/code&gt;（可移动的），因此这两个属性在每个选区对象上都存在&lt;/p&gt;

&lt;p&gt;最常见的选区类型是文本选区（text selection），它用于常规的光标（当 &lt;code&gt;anchor&lt;/code&gt; 和 &lt;code&gt;head&lt;/code&gt; 一样时）或者选择的文本。文本选区两端必须是内联位置，比如 指向内联内容的节点&lt;/p&gt;

&lt;p&gt;核心库同样也支持节点选区（node selections），当一个文档节点被选择，你就能得到它，比如，当你按下 ctrl 或者 cmd 键的同时再用鼠标点击一个节点。这样就会产生一个节点开始到结束的选区&lt;/p&gt;

&lt;h3 id=&#34;事务-transactions-1&#34;&gt;事务 Transactions&lt;/h3&gt;

&lt;p&gt;在正常的编辑过程中，新状态将从它们之前的状态派生而来。但是某些情况例外，例如 你想要创建一个全新的状态来初化化一个新文档&lt;/p&gt;

&lt;p&gt;通过将一个事务应用于现有状态，来生成新状然后进行状态更新。从概念上讲，它们只发生一次：给定旧状态和事务，为状态中的每个组件计算一个新值，并将它们放在一个新的状态值中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let tr = state.tr
console.log(tr.doc.content.size) // 25
tr.insertText(&amp;quot;hello&amp;quot;) // Replaces selection with &#39;hello&#39;
let newState = state.apply(tr)
console.log(tr.doc.content.size) // 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Transaction&lt;/code&gt; 是 &lt;code&gt;Transform&lt;/code&gt; 的子类，它继承了构建一个文档的方法，即 应用步骤到初始文档中。另外一点，事务会追踪选区和其它状态相关的组件，它提供了一些和选区相关的便捷方法，例如 &lt;code&gt;replaceSelection&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建事务的最简单方法是使用编辑器状态对象上的 &lt;code&gt;tr getter&lt;/code&gt;。这将基于当前状态创建一个空事务，然后你可以向其添加步骤和其他更新&lt;/p&gt;

&lt;p&gt;默认情况下，旧选区通过每个步骤映射以生成新选区，但可以使用 &lt;code&gt;setSelection&lt;/code&gt; 显式设置新选区&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let tr = state.tr
console.log(tr.selection.from) // → 10
tr.delete(6, 8)
console.log(tr.selection.from) // → 8 (moved back)
tr.setSelection(TextSelection.create(tr.doc, 3))
console.log(tr.selection.from) // → 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样地，在文档或选区更改后会自动清除激活的标记集，并可使用 &lt;code&gt;setStoredMarks&lt;/code&gt; 或 &lt;code&gt;ensureMarks&lt;/code&gt; 方法设置&lt;/p&gt;

&lt;p&gt;最后，&lt;code&gt;scrollIntoView&lt;/code&gt; 方法可用于确保在下次绘制状态时，选区内容将滚动到视图中。大多情况下都需要执行此操作&lt;/p&gt;

&lt;p&gt;与 &lt;code&gt;Transform&lt;/code&gt; 方法一样，许多 &lt;code&gt;Transaction&lt;/code&gt; 方法都会返回事务本身，以方便链式调用&lt;/p&gt;

&lt;h3 id=&#34;插件-plugins-1&#34;&gt;插件 Plugins&lt;/h3&gt;

&lt;p&gt;当创建一个新状态时，你可以指定一个插件数组挂载到上面。这些插件将被应用在这个新状态以及它的派生状态上，这会影响到事务的应用以及基于这个状态的编辑器行为&lt;/p&gt;

&lt;p&gt;插件是 &lt;code&gt;Plugin&lt;/code&gt; 类的实例，可以用来实现很多功能，最简单的一个例子就是给编辑器视图添加一些属性，例如 处理某些事件。复杂一点的就如添加一个新的状态到编辑器并基于事务更新它&lt;/p&gt;

&lt;p&gt;创建一个插件，你可以传入一个对象来指定它的行为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let myPlugin = new Plugin({
  props: {
    handleKeyDown(view, event) {
      console.log(&amp;quot;A key was pressed!&amp;quot;)
      return false // We did not handle this
    }
  }
})

let state = EditorState.create({schema, plugins: [myPlugin]})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个插件需要他自己的状态槽时，可以定义一个 &lt;code&gt;state&lt;/code&gt; 属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let transactionCounter = new Plugin({
  state: {
    init() { return 0 },
    apply(tr, value) { return value + 1 }
  }
})

function getTransactionCount(state) {
  return transactionCounter.getState(state)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例中的插件定义了一个非常简单的状态，它只计算已经应用于某个状态的事务数。辅助函数使用插件的 &lt;code&gt;getState&lt;/code&gt; 方法，该方法可用于从编辑器的状态对象中（插件作用域外）获取插件状态&lt;/p&gt;

&lt;p&gt;因为编辑器状态是持久化（不可变）的对象，并且插件状态是该对象的一部分，所以插件状态值必须是不可变的。即需要更改，他们的 &lt;code&gt;apply&lt;/code&gt; 方法必须返回一个新值，而不是更改旧值，并且其他代码是不可以更改它们的&lt;/p&gt;

&lt;p&gt;可对于插件而言向事务添加一些额外信息是非常有用的。例如，撤销历史记录在执行实际撤消时会标记生成的事务，以便在插件可以识别到，而不仅仅是生成一个新事务，将它们添加到撤消堆栈，我们需要单独处理它，从撤消（undo）堆栈中删除顶部项，然后同时将此事务添加到重做（redo）堆栈&lt;/p&gt;

&lt;p&gt;为此，事务允许附加元数据（metadata）。我们可以更新我们的事务计数器插件，过滤那些被标记过的事务，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let transactionCounter = new Plugin({
  state: {
    init() { return 0 },
    apply(tr, value) {
      if (tr.getMeta(transactionCounter)) return value
      else return value + 1
    }
  }
})

function markAsUncounted(tr) {
  tr.setMeta(transactionCounter, true)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;metadata 的属性键可以是字符串，但是要避免命名冲突，建议使用插件对象。有一些属性名库中已经定义过了，比如：&lt;code&gt;addToHistory&lt;/code&gt; 可以设置成 &lt;code&gt;false&lt;/code&gt; 表示事务不可以被撤消，当处理一个粘贴动作时，编辑器将在事务上设置 &lt;code&gt;paste&lt;/code&gt; 属性为 &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;视图组件-the-view-component&#34;&gt;视图组件 The view component&lt;/h2&gt;

&lt;p&gt;ProseMirror 编辑器视图是一个 UI 组件，它向用户显示编辑器状态，并允许它们进&lt;/p&gt;

&lt;p&gt;核心视图组件使用的 &lt;em&gt;编辑操作&lt;/em&gt; 的定义相当狭义 — 它用来直接处理与编辑器界面的交互，比如 输入、点击、复制、粘贴、拖拽，除此之外就没了。这表示核心视图组件并不支持一些高级一点的功能，像 菜单、快捷键绑定 等。想实现这类功能必须使用插件&lt;/p&gt;

&lt;h3 id=&#34;可编辑的-dom-editable-dom&#34;&gt;可编辑的 DOM Editable DOM&lt;/h3&gt;

&lt;p&gt;浏览器允许我们指定 DOM 的某些部分是可编辑的，这具有允许我们可以在上面聚焦或者创建选区，并且可以输入内容。视图创建其文档的 DOM 展示（默认情况下使用模式的 &lt;code&gt;toDOM&lt;/code&gt; 方法），并使其可编辑。当聚焦到可编辑的元素时，ProseMirror 确保 DOM 选区对应于编辑器状态中的选区&lt;/p&gt;

&lt;p&gt;它还会注册很多我DOM在事件处理程序，并将事件转换为适当的事务。例如，粘贴时，粘贴的内容将被解析为 ProseMirror 文档切片，然后插入到文档中&lt;/p&gt;

&lt;p&gt;很多事件也会按原生方式触发，然后才会由 ProseMirror 的数据模型重新解释。浏览器很擅长处理光标和选区等问题（当需要两向操作时则变得困难无比），所以大多数与光标相关的键和鼠标操作都由浏览器处理，之后 ProseMirror 会检查当前 DOM 选区对应着什么样的文本选区类型。如果该选区与当前选区不同，则通过调度一次事务来更新选区&lt;/p&gt;

&lt;p&gt;甚至像输入这种动作通常都留给浏览器处理，因为干扰它往往会破坏诸如 拼写检查，某些手机上单词自动首字母大写，以及其它一些设配原生的功能。当浏览器更新 DOM 时，编辑器会注意到，并重新解析文档的更改的部分，并将差异转换为一次事务&lt;/p&gt;

&lt;h3 id=&#34;数据流-data-flow&#34;&gt;数据流 Data flow&lt;/h3&gt;

&lt;p&gt;编辑器视图展示给定的编辑器状态，当发生某些事件时，它会创建一个事务并广播它。然后，这个事务通常用于创建新状态，该状态调用它的 &lt;code&gt;updateState&lt;/code&gt; 方法将状态返回给视图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/28003/16/976/56676/5c0e39efEba5293ce/3ad15f7825aa70c8.png&#34; alt=&#34;prosemirror-4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样就创建了一个简单的循环数据流，在 JavaScript 的世界，通常会立即处理事件处理器（可以理解成命令式的触发事件后直接操作 DOM），后者往往会创建更复杂的数据流网络（数据流可能是双向的，不容易理解与维护）&lt;/p&gt;

&lt;p&gt;由于事务是通过 &lt;code&gt;dispatchTransaction&lt;/code&gt; 属性来调度的，所以拦载事务是可以的做到的，为了将这个循环数据流连接到一个更大的周期 — 如果你的整个应用程序使用这样的数据流模型，就像类似 Redux 的体系结构一样，你可以使 ProseMirror 的事务与主动作调度（main action-dispatching）周期集成起来，将 ProseMirror 的状态保留在你应用程序的 &lt;code&gt;store&lt;/code&gt; 中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// The app&#39;s state
let appState = {
  editor: EditorState.create({schema}),
  score: 0
}

let view = new EditorView(document.body, {
  state: appState.editor,
  dispatchTransaction(transaction) {
    update({type: &amp;quot;EDITOR_TRANSACTION&amp;quot;, transaction})
  }
})

// A crude app state update function, which takes an update object,
// updates the `appState`, and then refreshes the UI.
function update(event) {
  if (event.type == &amp;quot;EDITOR_TRANSACTION&amp;quot;)
    appState.editor = appState.editor.apply(event.transaction)
  else if (event.type == &amp;quot;SCORE_POINT&amp;quot;)
    appState.score++
  draw()
}

// An even cruder drawing function
function draw() {
  document.querySelector(&amp;quot;#score&amp;quot;).textContent = appState.score
  view.updateState(appState.editor)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;高效更新-efficient-updating&#34;&gt;高效更新 Efficient updating&lt;/h3&gt;

&lt;p&gt;一种简单的实现 &lt;code&gt;updateState&lt;/code&gt; 的方法是在每次调用文档时重绘文档。但对于大型文档而言，这会变得很慢&lt;/p&gt;

&lt;p&gt;由于在更新期间，视图可以访问到旧文档和新文档，可以用它们来做对比，单独保留没发生变化的节点对应的 DOM 部分。 ProseMirror 就是这么做的，这将使得常规的更新动作只需要做很少的工作&lt;/p&gt;

&lt;p&gt;在某些情况下，例如 通过浏览器的编辑操作添加到 DOM 的更新文本。确保DOM 和状态一致，根本不需要任何 DOM 更改（当以一个事务被取消，修改时，视图将撤消 DOM 更改以确保 DOM 和状态保持同步）&lt;/p&gt;

&lt;p&gt;类似地，DOM 选区仅在实际与状态中的选区不同步时才会更新，这是为了避免破坏浏览器在选区中的各种「隐藏 hidden」状态（例如，当你使用向下或向上箭头空过短行时，你的水平位置会回到你进入下一条长行的位置）&lt;/p&gt;

&lt;h3 id=&#34;属性-props&#34;&gt;属性 Props&lt;/h3&gt;

&lt;p&gt;大体上讲 Props 很有用，这是从 React 学过来的。属性就像是 UI 组件中的参数。理想情况下，组件的属性完全定义其行为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let view = new EditorView({
  state: myState,
  editable() { return false }, // Enables read-only behavior
  handleDoubleClick() { console.log(&amp;quot;Double click!&amp;quot;) }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，当前的状态就是一个属性。即使一段代码控制了组件并更新某属性，它也不是真正意义上的状态，因为组件 &lt;strong&gt;自己&lt;/strong&gt; 并没有改变它们，&lt;code&gt;updateState&lt;/code&gt; 方法也只是更新状态中某个属性的一种简写&lt;/p&gt;

&lt;p&gt;插件可以声明除了 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;dispatchTransaction&lt;/code&gt; 以外的任意属性，它们可以直接传给视图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function maxSizePlugin(max) {
  return new Plugin({
    props: {
      editable(state) { return state.doc.content.size &amp;lt; max }
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个给定的属性被多次声明时，它的处理方式取决于属性类型。直接传入的的属性优先，然后每个插件按顺序执行。对于一些属性而言，比如 &lt;code&gt;domParser&lt;/code&gt;，只会使用第一次声明的值。如果是事件处理函数，可以返回一个布尔值来告诉底层事件系统是否要执行自己的逻辑（比如 事件处理函数反回 false，这表示底层事件上绑定的相同事件处理函数将不会被处理），有的属性，像 attributes 则会做合并然后使用&lt;/p&gt;

&lt;h3 id=&#34;装饰器-decorations&#34;&gt;装饰器 Decorations&lt;/h3&gt;

&lt;p&gt;装饰使你可以控制视图绘制文档的方式。它们是通过从 装饰器 属性返回值创建的，有三种类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点装饰器&lt;/strong&gt; Node decorations - 将样式或其他 DOM 属性添加到单个节点的 DOM 展示中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;挂件装饰器&lt;/strong&gt; Widget decorations - 在指定位置插入一个 DOM 节点，该节点不是实际文档的一部分&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内联装饰器&lt;/strong&gt; Inline decorations - 添加样式或属性，就像节点装饰器一样，但是会添加到给定范围内的所有内联节点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了能够有效地绘制和比较装饰器，它们需要作为装饰数组提供（这是一种模仿实际文档的树形数据结构）。你可以使用静态 &lt;code&gt;create&lt;/code&gt; 方法创建，提供文档和装饰对象数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let purplePlugin = new Plugin({
  props: {
    decorations(state) {
      return DecorationSet.create(state.doc, [
        Decoration.inline(0, state.doc.content.size, {style: &amp;quot;color: purple&amp;quot;})
      ])
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你有很多装饰器，那么每次重新绘制时都要重新创建这些装置成本会很高。这种情况下，维护装饰器的推荐方法是将数组放在插件的状态中，通过更改将其映射到之前的状态，并且只在需要时进行更改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let specklePlugin = new Plugin({
  state: {
    init(_, {doc}) {
      let speckles = []
      for (let pos = 1; pos &amp;lt; doc.content.size; pos += 4)
        speckles.push(Decoration.inline(pos - 1, pos, {style: &amp;quot;background: yellow&amp;quot;}))
      return DecorationSet.create(doc, speckles)
    },
    apply(tr, set) { return set.map(tr.mapping, tr.doc) }
  },
  props: {
    decorations(state) { return specklePlugin.getState(state) }
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的插件将其状态初始化为装饰器数组，该装饰器数组将会执行每 4 个位置添加黄色背景。这个例子可能并不是非常有用，但有点类似于突出显示搜索匹配或注释区域的场景&lt;/p&gt;

&lt;p&gt;当事务应用于状态时，插件状态的 apply 方法将装饰器数组向前映射，使装饰器保持原位并「适应」新文档形状。通过利用装饰器数组的树形结构使得映射方法（典型的局部变化）变得高效 - 树形结构中只有变化的部分才会被处理或者重建&lt;/p&gt;

&lt;p&gt;在插件的实际使用过程中，apply 方法也可以根据你基于新事件添加或删除装饰的位置而定，或者是通过检测事务中的更新，或基于特定的附加到事务的插件元数据&lt;/p&gt;

&lt;p&gt;最后，装饰属性只是返回插件状态，这就导致装饰器会展示在视图中&lt;/p&gt;

&lt;h3 id=&#34;节点视图-node-views&#34;&gt;节点视图 Node views&lt;/h3&gt;

&lt;p&gt;还有一种方法可以影响编辑器视图绘制文档的方式。节点视图可以为文档中的各个节点定义一种微型的 UI 组件。它们允许你展示 DOM，定义更新方式，并编写自定义代码以及响应事件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let view = new EditorView({
  state,
  nodeViews: {
    image(node) { return new ImageView(node) }
  }
})

class ImageView {
  constructor(node) {
    // The editor will use this as the node&#39;s DOM representation
    this.dom = document.createElement(&amp;quot;img&amp;quot;)
    this.dom.src = node.attrs.src
    this.dom.addEventListener(&amp;quot;click&amp;quot;, e =&amp;gt; {
      console.log(&amp;quot;You clicked me!&amp;quot;)
      e.preventDefault()
    })
  }

  stopEvent() { return true }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的示例为图片节点定义了视图对象，为图像创建了自定义的 DOM 节点，添加了事件处理程序，并使用 stopEvent 方法声明 ProseMirror 应忽略来自该DOM 节点的事件&lt;/p&gt;

&lt;p&gt;通常你可能会有与节点交互以影响文档中的实际节点的需求。但是要创建更改节点的事务，首先需要知道该节点的位置。为此，节点视图将传递一个 getter 函数，该函数可用于查询文档中当前节点的位置。让我们修改示例，实现单击节点查询你输入图像的 alt 文本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let view = new EditorView({
  state,
  nodeViews: {
    image(node, view, getPos) { return new ImageView(node, view, getPos) }
  }
})

class ImageView {
  constructor(node, view, getPos) {
    this.dom = document.createElement(&amp;quot;img&amp;quot;)
    this.dom.src = node.attrs.src
    this.dom.alt = node.attrs.alt
    this.dom.addEventListener(&amp;quot;click&amp;quot;, e =&amp;gt; {
      e.preventDefault()
      let alt = prompt(&amp;quot;New alt text:&amp;quot;, &amp;quot;&amp;quot;)
      if (alt) view.dispatch(view.state.tr.setNodeMarkup(getPos(), null, {
        src: node.attrs.src,
        alt
      }))
    })
  }

  stopEvent() { return true }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;setNodeMarkup&lt;/code&gt; 是一个方法，可用于更改给定位置的节点的类型或属性集。在示例中，我们使用 getPos 查找图像的当前位置，并使用新的 alt 文本为其提供新的属性对象&lt;/p&gt;

&lt;p&gt;节点更新后，默认行为是保持节点外部 DOM 结构不变，并将其子项与新的子元素集进行比较，根据需要更新或替换它们。节点视图可以使用自定义行为覆盖它，这允许我们执行类似于根据内容更改段落类（css class）属性的操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let view = new EditorView({
  state,
  nodeViews: {
    paragraph(node) { return new ParagraphView(node) }
  }
})

class ParagraphView {
  constructor(node) {
    this.dom = this.contentDOM = document.createElement(&amp;quot;p&amp;quot;)
    if (node.content.size == 0) this.dom.classList.add(&amp;quot;empty&amp;quot;)
  }

  update(node) {
    if (node.type.name != &amp;quot;paragraph&amp;quot;) return false
    if (node.content.size &amp;gt; 0) this.dom.classList.remove(&amp;quot;empty&amp;quot;)
    else this.dom.classList.add(&amp;quot;empty&amp;quot;)
    return true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图片标签不会有子内容，所以在我们之前的例子里，我们并不需要关心它是如何渲染的，但是段落有子内容。Node view 支持两种处理内容的方式：要么你让 ProseMirror 库来管理它，要么完全由你自己来管理。如果你提供一个 &lt;code&gt;contentDOM&lt;/code&gt; 属性，ProseMirror 将把节点渲染到这里并处理内容更新。如果你不提供这个属性，内容对于编辑器将变成一个黑盒，内容如何展示如何交互都将取决于你&lt;/p&gt;

&lt;p&gt;在这种情况下，我们希望段落内容的行为类似于常规可编辑文本，因此contentDOM 属性被定义为与 dom 属性相同，因为内容需要直接渲染到外部节点中&lt;/p&gt;

&lt;p&gt;魔术发生在 &lt;code&gt;update&lt;/code&gt; 方法中。首先，该方法负责决定是否可以更新节点视图以显示新节点。此新节点可能是编辑器更新算法尝试绘制的任何内容，因此你必须验证此节点有对应的节点视图来处理它&lt;/p&gt;

&lt;p&gt;示例中的 &lt;code&gt;update&lt;/code&gt; 方法首先检查新节点是否为段落，如果不是，就退出。然后它确保 &lt;code&gt;empty&lt;/code&gt; 类存在或不存在，具体取决于新节点的内容，返回true，则表示更新成功（此时节点的内容将被更新）&lt;/p&gt;

&lt;h2 id=&#34;命令-commands-1&#34;&gt;命令 Commands&lt;/h2&gt;

&lt;p&gt;在 ProseMirror 的术语中，命令是实现编辑操作的功能，用户可以通过按某些组合键或与菜单交互来执行命令&lt;/p&gt;

&lt;p&gt;出于实际原因考虑，命令的接口稍微有点复杂。一个接收 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;dispatch&lt;/code&gt; 参数的函数，该函数返回一个布尔值。下面是一个非常简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false
  dispatch(state.tr.deleteSelection())
  return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个命令非正常执行时应该返回 false，表示什么都不会发生。相反如果返正常执行，则应该调度一个事务并且返回 true。确实是这样的，当一个命令被绑定到一个健位并执行时，keymap 插件中对应于这个健位的事件将会被阻止&lt;/p&gt;

&lt;p&gt;为了能够查询一个命令对于一个状态下是否具有&lt;strong&gt;可执行性&lt;/strong&gt;（可执行但又不通过执行来验证），&lt;code&gt;dispatch&lt;/code&gt; 参数是可选的 — 当命令被调用并且没传入 dispatch 参数时，如果命令具有可执行性，那就应该什么也不做并返回 true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false
  if (dispatch) dispatch(state.tr.deleteSelection())
  return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了能够知道一个选区否可以被删除，你可以调用 &lt;code&gt;deleteSelection(view.state, null)&lt;/code&gt;，然而如果你想真正执行这个命令就应该这样调 &lt;code&gt;deleteSelection(view.state, view.dispatch)&lt;/code&gt;。菜单栏就是用这个来决定菜单按钮的可用性的&lt;/p&gt;

&lt;p&gt;这种行式下，命令并不需要访问实际的编辑器视图 — 大多数命令都不需要，这样的话命令就可以在设置中应用和测试而不必关心视图是否可用。但是有的命令则偏偏需要与 DOM 交互 — 可能需要查询指定的位置是否在文本块儿后面，或者打开一个相对于视图定位的对话框。为了解决这种需求，命令还提供了第三个（整个编辑器视图）参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function blinkView(_state, dispatch, view) {
  if (dispatch) {
    view.dom.style.background = &amp;quot;yellow&amp;quot;
    setTimeout(() =&amp;gt; view.dom.style.background = &amp;quot;&amp;quot;, 1000)
  }
  return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子可能并不是合适，因为命令并没有调度一次事务 — 调用他们可能会产生副作用，所以 *通常* 需要调度一次事务，但是也可能不需要，比如弹出一个层（因为这个层不在编辑器视图里面，并不属于编辑器的状态，所以调度事务就显得多余了）&lt;/p&gt;

&lt;p&gt;prosemirror-commands 模块提供了很多编辑器命令，从简单如 &lt;code&gt;deleteSelection&lt;/code&gt; 命令到复杂如 &lt;code&gt;joinBackward&lt;/code&gt; 命令，后者实现了块级节点的拼合，当你在文本块开始的地方触发 backspace 键的时候就会发生。它也会附加一些基本的快捷键绑定&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chainCommands&lt;/code&gt; 函数可以合并一系列的命令并执行直到某个命令返回 true&lt;/p&gt;

&lt;p&gt;举个例子，基础的快捷键绑定模块中，backspace 会被绑定到一个&lt;code&gt;命令链&lt;/code&gt;上：1. &lt;code&gt;deleteSelection&lt;/code&gt; 当选区不为空时删除选区；2. joinBackward 当光标在文本块开始的地方时；3. selectNodeBackward 选择选区前的节点，以防骨架中不允许有常规的拼合操作。当这些都不适用时，允许浏览器运行自己的 backspace 行为，这对于清除文本块内容是合理的&lt;/p&gt;

&lt;p&gt;命令模块还导出许多命令构造器，例如 &lt;code&gt;toggleMark&lt;/code&gt;，它采用标记类型和可选的一组属性，并返回一个命令函数，用于切换当前选区上的标记&lt;/p&gt;

&lt;p&gt;其他一些模块也会导出命令函数 — 例如，从 history 模块中 &lt;code&gt;undo&lt;/code&gt; 和 &lt;code&gt;redo&lt;/code&gt;。要自定义编辑器，或允许用户与自定义文档节点进行交互，你可能还需要编写自定义命令&lt;/p&gt;

&lt;h2 id=&#34;协作编辑-collaborative-editing&#34;&gt;协作编辑 Collaborative editing&lt;/h2&gt;

&lt;p&gt;实时协作编辑允许多人同时编辑同一文档。它们所做的更改会立即应用到本地文档，然后发送给对等（pears）方，这些对等方会自动合并这些更改（无需手动解决冲突），以便编辑动作可以不间断地进行，文档也会不断地被合并&lt;/p&gt;

&lt;p&gt;这一节将介绍如何给 ProseMirror 嫁接上协作编辑的功能&lt;/p&gt;

&lt;h3 id=&#34;算法-algorithm&#34;&gt;算法 Algorithm&lt;/h3&gt;

&lt;p&gt;ProseMirror 的协作编辑使用了一种中央集权式的系统，它会决定哪个变更会被应用。如果两个编辑器同时发生变更，他们两都将带着自己的变更进入系统，系统会接受其中之一，并且广播到其它编辑器中，另外一方的变更将不会被应用，当这个编辑器接收到新的变更时，它将被基于其它编辑器之上执行本地变更的 rebase 操作，然后再次提交更新&lt;/p&gt;

&lt;h3 id=&#34;权鉴-the-authority&#34;&gt;权鉴 The Authority&lt;/h3&gt;

&lt;p&gt;集权式的系统的角色其实是相对简单的，它只须做到以下几点…&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;跟踪当前文档的版本&lt;/li&gt;
&lt;li&gt;接受编辑器的变更，当变更被应用时，添加到变更列表中&lt;/li&gt;
&lt;li&gt;当给定一个版本时，提供一种编辑器接受变更的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;让我们实现一个简单的集权式的系统，它在与编辑器相同的 JavaScript 环境中运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Authority {
  constructor(doc) {
    this.doc = doc
    this.steps = []
    this.stepClientIDs = []
    this.onNewSteps = []
  }

  receiveSteps(version, steps, clientID) {
    if (version != this.steps.length) return

    // Apply and accumulate new steps
    steps.forEach(step =&amp;gt; {
      this.doc = step.apply(this.doc).doc
      this.steps.push(step)
      this.stepClientIDs.push(clientID)
    })
    // Signal listeners
    this.onNewSteps.forEach(function(f) { f() })
  }

  stepsSince(version) {
    return {
      steps: this.steps.slice(version),
      clientIDs: this.stepClientIDs.slice(version)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当编辑器试着提交他们的变更到系统时，可以调用 &lt;code&gt;receiveSteps&lt;/code&gt; 方法，传递他们接收到的最新版本号，同时携带着新的变更及他们自己的 client ID（用来识别变更来自哪里）&lt;/p&gt;

&lt;p&gt;当这步骤被接收，客户端就会知道被接收了。因为系统会通知他们新的可用步骤，然后发送给他们自己的步骤。真正的实现中，做为优化项，你也可以调用 &lt;code&gt;receiveSteps&lt;/code&gt; 返回一个状态码，然后立即确认发送的步骤，但是这里用到的东西必须要在不可靠的网络环境下保证同步&lt;/p&gt;

&lt;p&gt;这种权限的实现保持了一系列不断增长的步骤，其长度表示当前版本&lt;/p&gt;

&lt;h3 id=&#34;协作模块-the-collab-module&#34;&gt;协作模块 The &lt;code&gt;collab&lt;/code&gt; Module&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;collab&lt;/code&gt; 模块导出一个 &lt;code&gt;collab&lt;/code&gt; 函数，该函数返回一个插件，负责跟踪本地变更，接收远程变更，并对于何时必须将某些内容发送到中央机构做出指示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {EditorState} from &amp;quot;prosemirror-state&amp;quot;
import {EditorView} from &amp;quot;prosemirror-view&amp;quot;
import {schema} from &amp;quot;prosemirror-schema-basic&amp;quot;
import collab from &amp;quot;prosemirror-collab&amp;quot;

function collabEditor(authority, place) {
  let view = new EditorView(place, {
    state: EditorState.create({schema, plugins: [collab.collab()]}),
    dispatchTransaction(transaction) {
      let newState = view.state.apply(transaction)
      view.updateState(newState)
      let sendable = collab.sendableSteps(newState)
      if (sendable)
        authority.receiveSteps(sendable.version, sendable.steps,
                               sendable.clientID)
    }
  })

  authority.onNewSteps.push(function() {
    let newData = authority.stepsSince(collab.getVersion(view.state))
    view.dispatch(
      collab.receiveTransaction(view.state, newData.steps, newData.clientIDs))
  })

  return view
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;collabEditor&lt;/code&gt; 函数创建一个加载了&lt;code&gt;collab&lt;/code&gt; 插件的编辑器视图。每当状态更新时，它都会检查是否有任何内容要发送给系统。如果有，就发送&lt;/p&gt;

&lt;p&gt;它还注册了一个当新的步骤可用时系统应该调用的函数，并创建一个事务来更新我们的本地编辑器反映这些步骤的状态&lt;/p&gt;

&lt;p&gt;当一组步骤被系统拒绝时，它们将一直保持未确认状态，这个时间段应该会比较短，持续到我们从系统收到新的步骤之后。接着，因为 &lt;code&gt;onNewSteps&lt;/code&gt; 回调调用 &lt;code&gt;dispatch&lt;/code&gt;，&lt;code&gt;dispatch&lt;/code&gt; 再调用我们的 &lt;code&gt;dispatchTransaction&lt;/code&gt; 函数，代码才会将尝试再次提交其更改&lt;/p&gt;

&lt;p&gt;这基本上就是的所有协作模块的功能了。当然，对于异步数据通道（例如上面的演示代码中的长轮询或 Web套接字），你需要更复杂的通信和同步代码，而且你也可能需要集权系统在某些情况下开始抛出步骤，而不至于内存被消耗完。但是这个小例子大概也描述清楚了实现过程&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jQuery ajax 方法 data 参数默认 encode 失败的 bug</title>
      <link>https://keelii.com/2018/05/25/jquery-ajax-data-param-auto-encode-bug/</link>
      <pubDate>Fri, 25 May 2018 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2018/05/25/jquery-ajax-data-param-auto-encode-bug/</guid>
      <description>&lt;p&gt;使用 jQuery ajax 方法调用异步接口时 data 参数默认会被添加转码 &lt;code&gt;encodeURIComponent&lt;/code&gt;，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$.ajax({
    url: &#39;http://your.domain.com/action&#39;,
    dataType: &#39;jsonp&#39;,
    data: {
        spaces: &#39;a b&#39;,
        other: &#39;&amp;amp;&#39;
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码会向 &lt;code&gt;http://your.domain.com/action?spaces=a+b&amp;amp;other=%26&lt;/code&gt; 发送 get 请求，奇怪的是参数中的 &lt;code&gt;&amp;amp;&lt;/code&gt; 被正确转码成 &lt;code&gt;%26&lt;/code&gt;，但是  被转成了 &lt;code&gt;+&lt;/code&gt; 而不是 &lt;code&gt;%20&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;看看正确的转码结果长啥样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;encodeURIComponent(&#39;&amp;amp;&#39;) // =&amp;gt; &amp;quot;%26&amp;quot;
encodeURIComponent(&#39; &#39;) // =&amp;gt; &amp;quot;%20&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然 data 参数里面的 key,value 都要被 encodeURIComponent，那么出现这种情况只能去查 jQuery 源代码了。jQuery 会调用 $.param 方法来编码 data 参数，大概在 &lt;strong&gt;jQuery-1.7.2&lt;/strong&gt; 的 &lt;em&gt;(7736)&lt;/em&gt; 行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;param: function( a, traditional ) {
    // ...
    } else {
        // If traditional, encode the &amp;quot;old&amp;quot; way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for ( var prefix in a ) {
            buildParams( prefix, a[ prefix ], traditional, add );
        }
    }

    // Return the resulting serialization
    return s.join( &amp;quot;&amp;amp;&amp;quot; ).replace( r20, &amp;quot;+&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;param 方法内部会再调用 &lt;code&gt;buildParams&lt;/code&gt; 来把 data 对象键值对添加编码，一切都很正常&lt;/p&gt;

&lt;p&gt;然饿最后一行 &lt;code&gt;replace( r20, &amp;quot;+&amp;quot; )&lt;/code&gt; 是什么鬼！&lt;code&gt;r20&lt;/code&gt; 变量是内部的一个空白转义符的正则 &lt;code&gt;/%20/g&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这就有点意思了，为啥把正确的空格编码再转回 &lt;code&gt;+&lt;/code&gt; 呢？&lt;/p&gt;

&lt;p&gt;外事不决问 Google，搜索 &lt;code&gt;why jquery ajax convert %20 to +&lt;/code&gt; 结果发现有一条 jQuery 官方的 github issue: &lt;a href=&#34;https://github.com/jquery/jquery/issues/2658&#34;&gt;Only change %20 to + for application/x-www-form-urlencoded&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img11.360buyimg.com/devfe/jfs/t20344/242/259059096/183424/9e8e0f30/5b078bbdN06c75a01.png&#34; alt=&#34;google-why-jquery-convert-space-to-plus&#34; /&gt;&lt;/p&gt;

&lt;p&gt;根据 issue 的描述大意是说 &lt;code&gt;convert %20 to +&lt;/code&gt; 这个逻辑只应该在 POST 请求的时候做转换，而不是所有请求。我们的示例中的 jsonp 刚好是 get 请求&lt;/p&gt;

&lt;p&gt;继续往下看找到了一个 &lt;a href=&#34;https://github.com/dmethvin/jquery/commit/60453ce299a0c84550e70010ceea12d538226bf5&#34;&gt;commit(60453ce)&lt;/a&gt; 修复了这个问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img14.360buyimg.com/devfe/jfs/t20692/166/263146843/79735/7f45adb2/5b078b49N8f97629d.png&#34; alt=&#34;jquery-param-encode-bug&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意一点，我们并不能简单的在 data 对象传入的时候手动添加 &lt;code&gt;encodeURIComponent&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$.ajax({
    url: &#39;http://your.domain.com/action&#39;,
    dataType: &#39;jsonp&#39;,
    data: {
        // 错误的做法
        spaces: encodeURIComponent(&#39;a b&#39;),
        other: &#39;&amp;amp;&#39;
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 spaces 参数有别的应该被正常编码的字符串，这样会导致正常的被编码的字符被 &lt;strong&gt;两次&lt;/strong&gt; encodeURIComponent。所以要正确解决这个问题需要修改 jQuery 源代码，这个可以参考上面的那个 fix commit&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解决 seajs parseDependencies 方法引起的依赖解析错误问题</title>
      <link>https://keelii.com/2017/11/03/fix-seajs-parse-dep-bug/</link>
      <pubDate>Fri, 03 Nov 2017 15:51:27 +0000</pubDate>
      
      <guid>https://keelii.com/2017/11/03/fix-seajs-parse-dep-bug/</guid>
      <description>&lt;p&gt;使用 seajs 的过程中偶尔会发现 require 进来的模块甚至都没有加载。查看源代码之后发现 seajs 是通过正则表达式匹配出了模块 factory 中的 require 路径&lt;/p&gt;

&lt;p&gt;正常情况下，下面这个模块里面 require 的外部模块会解析出依赖 &lt;code&gt;GLOBAL_ROOT/base/cookie&lt;/code&gt; 和 &lt;code&gt;GLOBAL_ROOT/base/utils&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;define(&#39;moduleName&#39;, function() {
    var a = require(&#39;GLOBAL_ROOT/base/cookie&#39;)
    var b = require(&#39;GLOBAL_ROOT/base/utils&#39;)
    // 正常情况 a 应该是个对象，
    console.log(a)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果 cookie 模块加载失败，a 就会返回 null 这时候再调 a 上面的方法就会报错。当 seajs 内部解析依赖时发生了错误时就会出现这种情况，由于我们使用的是比较老的 seajs 版本（2.2.0），去查看源代码发现 parseDependencies 方法使用了一个正则表达式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var REQUIRE_RE = /&amp;quot;(?:\\&amp;quot;|[^&amp;quot;])*&amp;quot;|&#39;(?:\\&#39;|[^&#39;])*&#39;|\/\*[\S\s]*?\*\/|\/(?:\\\/|[^\/\r\n])+\/(?=[^\/])|\/\/.*|\.\s*require|(?:^|[^$])\brequire\s*\(\s*([&amp;quot;&#39;])(.+?)\1\s*\)/g
var SLASH_RE = /\\\\/g

function parseDependencies(code) {
  var ret = []

  code.replace(SLASH_RE, &amp;quot;&amp;quot;)
      .replace(REQUIRE_RE, function(m, m1, m2) {
        if (m2) {
          ret.push(m2)
        }
      })

  return ret
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在控制台里面跑一下看看结果，上面的模块解析正确：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//img30.360buyimg.com/devfe/jfs/t11401/113/1005903134/64122/b08677b9/59fc23d6N998f2848.png&#34; alt=&#34;seajs-works-well&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是我自己的场景并没有这么简单，我贴上自己的代码时就异常了，由于源码比较多我就放到 jsbin 上了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jsbin.com/bowazakosu/edit?html,js,console,output&#34;&gt;压缩成一行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jsbin.com/likonikoye/edit?html,js,console,output&#34;&gt;格式化压缩代码后&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有意思的地方就在于 压缩成一行 的代码中是异常的，但是当我把代码格式化后就正常了？！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;seajs 3.x 版本以后 &lt;a href=&#34;https://github.com/seajs/seajs/blob/3.0.0/src/util-deps.js&#34;&gt;util-deps.js&lt;/a&gt; 引入了一个依赖解析器方法，直接用这个替代原来的即可。至于为什么那个正则对于压缩后的代码没起作用我暂还没详细研究，不过感觉像获取模块依赖关系这种静态分析任务还是用解析器靠谱点，正则有太多的不确定性，虽然它能节省很多代码&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jQuery data 方法的一个小特技</title>
      <link>https://keelii.com/2017/05/03/a-trick-from-jquery-data-method/</link>
      <pubDate>Wed, 03 May 2017 17:59:45 +0800</pubDate>
      
      <guid>https://keelii.com/2017/05/03/a-trick-from-jquery-data-method/</guid>
      <description>&lt;p&gt;通常我们在用 JavaScript 操作 DOM 元素的时候会往 DOM 上临时添加一些参数，用来记住一些状态，或者从后端取参数值等&lt;/p&gt;

&lt;p&gt;一般通过在 HTML 标签上添加自定义属性来实现，但是这样会不可避免的访问 DOM，性能上并不好。如果你使用 jQuery 的话建议使用 &lt;code&gt;$el.data()&lt;/code&gt; 方法来取元素上 &lt;code&gt;data-*&lt;/code&gt; 的值，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;demo&amp;quot; data-key=&amp;quot;value&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    $(&#39;#demo&#39;).attr(&#39;data-key&#39;)
    $(&#39;#demo&#39;).data(&#39;key&#39;)  // 第一次访问 DOM，以后从缓存取
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个方法的区别在于 attr 每次都会直接访问 DOM 元素，而 data 方法会缓存第一次的查找，后续调用不需要访问 DOM&lt;/p&gt;

&lt;p&gt;很明显建议使用后者，但是在 &lt;strong&gt;低版本的 jQuery&lt;/strong&gt; 中默认会对 data 方法取到的值进行粗暴的强制数据类型转换「parseFloat」。看下面代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;demo0&amp;quot; data-key=&amp;quot;abc&amp;quot;&amp;gt;字符串&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo1&amp;quot; data-key=&amp;quot;123&amp;quot;&amp;gt;数字&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo2&amp;quot; data-key=&amp;quot;123e456&amp;quot;&amp;gt;科学计数法&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo3&amp;quot; data-key=&amp;quot;0000123&amp;quot;&amp;gt;八进制数字&amp;lt;/div&amp;gt;
&amp;lt;script src=&amp;quot;jquery-1.6.4&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    $(&#39;#demo0&#39;).data(&#39;key&#39;)  // &amp;quot;abc&amp;quot;
    $(&#39;#demo1&#39;).data(&#39;key&#39;)  // 123
    $(&#39;#demo2&#39;).data(&#39;key&#39;)  // Infinity
    $(&#39;#demo3&#39;).data(&#39;key&#39;)  // 83
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面两种显然出错了，就是因为 jQuery 对属性值进行了强制 parseFloat 操作。这种转换是方便了使用者，如果是数字的话我们取到这个值进行计算什么的就不用再转数据类型了，但是一不小心就会出 bug&lt;/p&gt;

&lt;p&gt;发现这个 bug 的时候第一感觉是 jQuery 不应该没考虑到这一点呀。后来果断去查了下最新版的 jQuery 源代码，发现已经修复了。核心代码在 &lt;a href=&#34;https://github.com/jquery/jquery/blob/master/src/data.js#L36&#34;&gt;data.js 35 行&lt;/a&gt;，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getData( data ) {
    if ( data === &amp;quot;true&amp;quot; ) {
        return true;
    }

    if ( data === &amp;quot;false&amp;quot; ) {
        return false;
    }

    if ( data === &amp;quot;null&amp;quot; ) {
        return null;
    }

    // Only convert to a number if it doesn&#39;t change the string
    // 重点就在这里 →_→
    if ( data === +data + &amp;quot;&amp;quot; ) {
        return +data;
    }

    if ( rbrace.test( data ) ) {
        return JSON.parse( data );
    }

    return data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getData 方法就返回了节点属性的值，只不过加了一些特殊处理使得我们取到了没有 bug 的值，关键地方就在这里： &lt;code&gt;data === +data + &amp;quot;&amp;quot;&lt;/code&gt; 。这行代码做了些什么神奇的事情&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;将节点的属性值强制转换成数字「+data」后再转成字符串「+ &amp;ldquo;&amp;ldquo;」，如果转换后的值与原来相等就取转换后的值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以简单的这么理解：jQuery 会尝试转换数据类型，如果转换后和转换前的 &lt;strong&gt;长得一样&lt;/strong&gt; 那么 jQuery 就认为它是需要被转换成数字的。这样就可以完美规避上面例子中的两种问题，我们来测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var data = &#39;abc&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值

var data = &#39;123&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // true 转换，使用转换后的数字类型值

var data = &#39;123e456&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值

var data = &#39;0000123&#39;
console.log(data === +data + &amp;quot;&amp;quot;)        // false 不转换，直接返回字符串原值
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>TrimPath 模板引擎使用指南</title>
      <link>https://keelii.com/2016/11/21/trimpath-template-engine/</link>
      <pubDate>Mon, 21 Nov 2016 12:39:49 +0800</pubDate>
      
      <guid>https://keelii.com/2016/11/21/trimpath-template-engine/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.summitdowntown.org/site_media/media/javascript/private/trimpath-template-docs/JavaScriptTemplates.html&#34;&gt;TrimPath&lt;/a&gt; 是一款轻量级的前端 JavaScript 模板引擎，语法类似 &lt;a href=&#34;http://freemarker.org/&#34;&gt;FreeMarker&lt;/a&gt;, &lt;a href=&#34;https://velocity.apache.org/&#34;&gt;Velocity&lt;/a&gt;，主要用于方便地渲染 json 数据&lt;/p&gt;

&lt;h2 id=&#34;语法-syntax&#34;&gt;语法 Syntax&lt;/h2&gt;

&lt;h3 id=&#34;表达式-expressions&#34;&gt;表达式 Expressions&lt;/h3&gt;

&lt;p&gt;表达式和修饰符（其它模板语言中叫做过滤器 filter）中间用 &lt;code&gt;|&lt;/code&gt; 分割且 &lt;strong&gt;不能有空格&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${expr}
${expr|modifier}
${expr|modifier1:arg1,arg2|modifier2:arg1,arg2|...|modifierN:arg1,arg2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;语句-statements&#34;&gt;语句 Statements&lt;/h3&gt;

&lt;h4 id=&#34;控制流-control-flow&#34;&gt;控制流 Control Flow&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{if testExpr}
    {elseif testExpr}
    {else}
{/if}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;循环-loops&#34;&gt;循环 Loops&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{for varName in listExpr}
{/for}

{for varName in listExpr}
    ...循环主体...
{forelse}
    ...当 listExpr 是 null 或者 length 为 0 ...
{/for}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;变量声明-variable-declarations&#34;&gt;变量声明 Variable Declarations&lt;/h4&gt;

&lt;p&gt;变量声明语句用花括号 &lt;code&gt;{}&lt;/code&gt; 括起来，不需要关闭。类似 JavaScript 中的赋值语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{var varName}
{var varName = varInitExpr}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;宏声明-macro-declarations&#34;&gt;宏声明 Macro Declarations&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{macro macroName(arg1, arg2, ...argN)}
    ...macro 主体...
{/macro}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;cdata-部分-cdata-text-sections&#34;&gt;CDATA 部分 CDATA Text Sections&lt;/h4&gt;

&lt;p&gt;CDATA 部分用来告诉模板引擎不用做任何解析渲染，直接输出。比如展示一个模板字符串本身&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{cdata}
    ${customer.firstName} ${customer.lastName}
{/cdata}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;in-line-javascript&#34;&gt;In-line JavaScript&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;eval blocks&lt;/strong&gt; 用来执行 JavaScript 代码片段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{eval}
    ...模板渲染的时候执行的 JavaScript 代码...
{/eval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;minify blocks&lt;/strong&gt; 用来压缩内容中的换行符，比如压缩 HTML 属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;commentPanel&amp;quot; style=&amp;quot;{minify}
      display:none;
      margin: 1em;
      border: 1px solid #333;
      background: #eee;
      padding: 1em;
    {/minify}&amp;quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;修饰符-modifier&#34;&gt;修饰符 Modifier&lt;/h2&gt;

&lt;p&gt;修饰符用来处理上一个表达式的结果，并输出内容。类似于 Linux shell 中的管道操作符，使用「|」分割不同修饰符，可以串联使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${name|capitalize}
${name|default:&amp;quot;noname&amp;quot;|capitalize}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;内置修饰符&#34;&gt;内置修饰符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;capitalize&lt;/strong&gt; 返回大写内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;default:valueWhenNull&lt;/strong&gt; 如果内容为 null，返回 valueWhenNull&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;eat&lt;/strong&gt; 返回空内容，一般用于表达式求值后又不想展示输出的内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;escape&lt;/strong&gt; 转换 HTML 字符实体，比如： &amp;amp; 转换成 &amp;amp;amp;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;h&lt;/strong&gt; 和 escape 效果一样&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;自定义修饰符&#34;&gt;自定义修饰符&lt;/h3&gt;

&lt;p&gt;自定义修饰符可以挂载到 contextObject 上的 &lt;code&gt;_MODIFIERS&lt;/code&gt; 属性上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Modifiers = {
  toFixed: function(value, num) {
    return value.toFixed(num)
  }
}
var out = &#39;${num|toFixed:2}&#39;.process({
  _MODIFIERS: Modifiers,
  num: 1024
})
// =&amp;gt; &amp;quot;1024.00&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;宏-macro&#34;&gt;宏 Macro&lt;/h2&gt;

&lt;p&gt;macro 一般用来封装可复用 HTML 模板，类似函数的功能。对于每个模板来说 macro 是私用的。如果想公用 macro，可以保存 macro 引用到 contextObject 上（下次调用 process() 方法的时候再手动挂载上!? ）。需要在调用 process() 方法之前给 contextObject 设置一个空的 exported 属性：&lt;code&gt;contextObject[&#39;exported&#39;] = {}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个公用的 macro 设计的有点奇葩，可以参考这个 &lt;a href=&#34;http://codepen.io/keelii/pen/dOvgOJ&#34;&gt;示例&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{macro link(href, name)}
    &amp;lt;a href=&amp;quot;${href}&amp;quot;&amp;gt;${name}&amp;lt;/a&amp;gt;
{/macro}

${link(&#39;http://google.com&#39;, &#39;google&#39;)}      =&amp;gt; &amp;lt;a href=&amp;quot;http://google.com&amp;quot;&amp;gt;google&amp;lt;/a&amp;gt;
${link(&#39;http://facebook.com&#39;, &#39;facebook&#39;)}  =&amp;gt; &amp;lt;a href=&amp;quot;http://facebook.com&amp;quot;&amp;gt;facebook&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var data = {
    name: &#39;iPhone 6 Plus&#39;,
    weight: 480,
    ram: &#39;16gb&#39;,
    networks: [
        &#39;移动（TD-LTE)&#39;,
        &#39;联通(TD-LTE)&#39;,
        &#39;电信(FDD-LTE)&#39;
    ]
}

data._MODIFIERS = {
    toFixed: function(n, num) {
        return n.toFixed(num)
    }
}

var template = &#39;\
名称: ${name}&amp;lt;br&amp;gt;\
重量：${weight|toFixed:2}&amp;lt;br&amp;gt;\
内存：${ram|capitalize}&amp;lt;br&amp;gt;\
网络：\
{for item in networks}\
  {if item_index!=0}|{/if}\
  ${item}\
{/for}&#39;;

template.process(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;名称: iPhone 6 Plus&amp;lt;br&amp;gt;
重量：480.00&amp;lt;br&amp;gt;
内存：16GB&amp;lt;br&amp;gt;
网络：
  移动（TD-LTE)
 | 联通(TD-LTE)
 | 电信(FDD-LTE)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践</title>
      <link>https://keelii.com/2016/11/17/best-practice-for-phantomjs-and-nodejs-at-jd-s-webdev-front-end-monitor-platform/</link>
      <pubDate>Thu, 17 Nov 2016 09:55:41 +0800</pubDate>
      
      <guid>https://keelii.com/2016/11/17/best-practice-for-phantomjs-and-nodejs-at-jd-s-webdev-front-end-monitor-platform/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文首发于 &lt;a href=&#34;http://www.infoq.com/cn/articles/practise-of-phantomjs-and-nodejs-in-jingdong&#34;&gt;infoQ&lt;/a&gt; 及「前端之巅」微信公众号（&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;amp;mid=2247484138&amp;amp;idx=1&amp;amp;sn=431702ee926dd3a92403bb58417d88d4&amp;amp;scene=2&amp;amp;srcid=0831H070dVHqyZ5Gg62tZRsl&amp;amp;from=timeline&amp;amp;isappinstalled=0&amp;amp;pass_ticket=UAxLVHRLr%2B46hzwgDjfAanLKPSIcnzOQLPJZtqRkoQeHy03khyC2aD7Lat9WgyiL&#34;&gt;微信群直播记录&lt;/a&gt;），感谢 infoQ 前端之巅尾尾同学对文章的整理和校对、微信群直播的组织策划。「前端之巅」是个非常棒的前端知识分享平台，想了解最前沿的前端知识资讯果断关注吧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;为什么需要一个前端监控系统&#34;&gt;为什么需要一个前端监控系统&lt;/h2&gt;

&lt;p&gt;通常在一个大型的 Web 项目中有很多监控，比如后端的服务 API 监控，接口存活、调用、延迟等监控，这些一般都用来监控后台接口数据层面的信息。而且对于大型网站系统来说，从后端服务到前台展示会有很多层：内网 VIP、CDN 等。但是这些监控并不能准确地反应用户看到的前端页面状态，比如：页面第三方系统数据调用失败，模块加载异常，数据不正确，空白开天窗等。这时候就需要从前端 DOM 展示的角度去分析和收集用户真正看到的东西，从而检测出页面是否出现异常问题&lt;/p&gt;

&lt;h2 id=&#34;需要监控系统解决的问题&#34;&gt;需要监控系统解决的问题&lt;/h2&gt;

&lt;p&gt;页面通常出现以下问题时需要使用邮件、短信通知相关人员修复问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;状态码返回错误（50x, 40x）无法打开&lt;/li&gt;
&lt;li&gt;模块加载失败&lt;/li&gt;
&lt;li&gt;页面乱码&lt;/li&gt;
&lt;li&gt;数据正确性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;触发报警时要有现场快照，以便复现问题&lt;/p&gt;

&lt;h2 id=&#34;技术选型&#34;&gt;技术选型&lt;/h2&gt;

&lt;p&gt;监控的意义和回归测试的在本质上是一致的，都是对已上线功能进行回归测试，但不同的是监控需要做长期的可持续可循环的回归测试，而测试仅仅需要在上线之后做一次回归&lt;/p&gt;

&lt;p&gt;既然监控和测试的本质一致，那我们完全可以采用测试的方式来做监控系统。在自动化测试技术遍地开花的时代，不乏很多好用的自动化工具，我们只需要把这些自动化工具进行整合为我们所用即可&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NodeJS - 特别适用于网络密集型任务&lt;/li&gt;
&lt;li&gt;PhantomJS - 模拟无界面的浏览器，提供丰富的内核交互 API&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;nodejs&#34;&gt;NodeJS&lt;/h3&gt;

&lt;p&gt;NodeJS 是一个 JavaScript 运行环境，非阻塞 I/O 和异步、事件驱动，这几点对于我们构建基于 DOM 元素的监控是非常重要的&lt;/p&gt;

&lt;h3 id=&#34;phantomjs&#34;&gt;PhantomJS&lt;/h3&gt;

&lt;p&gt;PhantomJS 是一个基于 webkit 的浏览器引擎，可以使用 JavaScript API 来模拟浏览器的操作。它使用 QtWebKit 作为它的浏览器核心，使用 webkit 来编译解释执行 JavaScript 代码。也就是说任何你可以在 webkit 浏览器里做的事情，它都能做到&lt;/p&gt;

&lt;p&gt;它不仅是个隐形的浏览器，提供了诸如 CSS 选择器、支持 Web 标准、DOM 操作、JSON、HTML5、Canvas、SVG 等，同时也提供了处理文件 I/O 的操作等。PhantomJS 的用处可谓非常广泛，诸如网络监测、网页截屏、无浏览器的 Web 测试、页面访问自动化等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么不是 Selenium&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;做自动化测试的同学肯定都知道 Selenium。可以使用 Selenium 将测试用例在浏览器中执行，而且 Selenium 对各种平台和常见浏览器支持比较好，但是 Selenium 上手难度系数略高，而且使用Selenium 需要在服务器端安装浏览器&lt;/p&gt;

&lt;p&gt;考虑到监控主要任务在监控不在测试。系统并不需要太多考虑兼容性，而且监控功能相对单一，主要对页面进行功能上的回归测试，所以选择了 PhantomJS&lt;/p&gt;

&lt;h2 id=&#34;架构设计&#34;&gt;架构设计&lt;/h2&gt;

&lt;h3 id=&#34;架构概览&#34;&gt;架构概览&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17013271/ec2bc29e-4f4f-11e6-9591-0838a0243206.png&#34; alt=&#34;4&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;架构简述&#34;&gt;架构简述&lt;/h3&gt;

&lt;p&gt;对于 DOM 监控服务，在应用层面上进行了垂直划分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;规则管理系统&lt;/li&gt;
&lt;li&gt;规则队列生成器&lt;/li&gt;
&lt;li&gt;长时持续处理器&lt;/li&gt;
&lt;li&gt;PhantomJS 服务&lt;/li&gt;
&lt;li&gt;服务化 API&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在应用层面上进行的垂直划分可以对应用做分布式部署，提高处理能力。后期也方便做性能优化、系统改造扩展等&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;h3 id=&#34;前台规则录入&#34;&gt;前台规则录入&lt;/h3&gt;

&lt;p&gt;这是一个独立的 Web 系统，系统主要用来收集用户录入的页面信息、页面对应的规则、展示错误信息。通过调用后端页面抓取服务来完成页面检测的任务，系统可以创建三种类型的检测页面：常规监控、高级监控、可用性监控&lt;/p&gt;

&lt;h4 id=&#34;常规监控&#34;&gt;常规监控&lt;/h4&gt;

&lt;p&gt;录入一个页面地址，和若干检测规则。注意这里的检测规则，我们把常用的一些检测点抽象成了一条类似测试用例的语句。每条规则用来匹配页面上的一个 DOM 元素，用 DOM 元素的属性来和预期做匹配，如果匹配失败系统就会产生一条错误信息，后续交由报警系统处理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;匹配类型&lt;/strong&gt; 一般有这么几种：&lt;code&gt;长度、文本、HTML、属性&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;处理器&lt;/strong&gt; 类似编程语言中的操作符：&lt;code&gt;大于、大于等于、小于、小于等于、等于、正则&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样做的处就是，录入规则的人只要了解一点 DOM 选择器的知识就可以上手操作了，在我们内部通常是交由测试工程师统一完成规则的录入&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17012424/2963f11e-4f4a-11e6-96f1-a962c767e651.png&#34; alt=&#34;1&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;高级监控&#34;&gt;高级监控&lt;/h4&gt;

&lt;p&gt;主要用来提供高级页面测试的功能，一般由有经验的工程师来撰写测试用例。这个测试用例写起来会有一些学习成本，但是可以模拟 Web 页面操作，如：点击、鼠标移动等事件从而做到精确捕捉页面信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17012590/324509de-4f4b-11e6-9ddc-63e5a140b208.png&#34; alt=&#34;2&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;可用性监控&#34;&gt;可用性监控&lt;/h4&gt;

&lt;p&gt;可用性监控侧重于对页面的可访问性、内容正确性等比较 &lt;strong&gt;严重的问题&lt;/strong&gt; 做即时监控。通常这类页面我们只需要在程序里面启一个 Worker 不断的去获取页面 HTML 就可以对结果进行检测匹配了，所以我们选择了 NodeJS 来做异步的页面抓取队列，高效快速的完成这种网络密集型任务&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17012775/7ccfad00-4f4c-11e6-80b6-60186069bdac.png&#34; alt=&#34;3&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;主动错误上报&#34;&gt;主动错误上报&lt;/h3&gt;

&lt;h4 id=&#34;页面脚本执行错误监控&#34;&gt;页面脚本执行错误监控&lt;/h4&gt;

&lt;p&gt;页面引入一段监控脚本来收集页面产成 error 事件返回的错误信息，自动上报给后端服务，在系统里面可以汇总所有报错信息，以及对应的客户端浏览器版本、操作系统、IP 地址等&lt;/p&gt;

&lt;h4 id=&#34;页面主动上报&#34;&gt;页面主动上报&lt;/h4&gt;

&lt;p&gt;这个功能需要对应的前端工程师在代码中调用错误上报 API，来主动提交错误信息。主要使用的场景有，页面异步服务延时无响应、模块降级兜底主动通知等。监控脚本提供几个简单的 API 来完成这项任务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// error 方法调用后立即上报错误信息并发出邮件、短信通知
errorTracker.error(&#39;错误描述&#39;)
// info 方法调用后立即上报信息，并在单位时间内仅产生一条邮件、短信通知
errorTracker.info(&#39;信息描述&#39;)
// log 方法调用后由报错检测是否达到设置阀值，最终确认是否报错
errorTracker.log(&#39;日志信息&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;后端页面抓取服务&#34;&gt;后端页面抓取服务&lt;/h3&gt;

&lt;p&gt;由于京东很多页面内容是异步加载的，像首页、单品等系统有许多第三方异步接口调用，使用后端程序抓取到的页面数据是同步的，并不能取到动态的 JavaScript 渲染的内容，所以就必须使用像 PhantomJS 这种能模拟浏览器的工具&lt;/p&gt;

&lt;p&gt;常规监控我们使用 PhantomJS 模拟浏览器打开页面进行抓取，然后将监控规则解析成 JavaScript 代码片段执行并收集结果&lt;/p&gt;

&lt;p&gt;高级监控我们使用 PhantomJS 打开页面后向页面注入像 jasmine, mocha 等类似的前端 JavaScript 测试框架，然后在页面执行对应的录入测试用例并返回结果&lt;/p&gt;

&lt;h4 id=&#34;规则队列生成器&#34;&gt;规则队列生成器&lt;/h4&gt;

&lt;p&gt;规则队列生成器会将采集的规则转化类成消息队列，然后交由长时持续处理器一次处理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么采用类消息队列的处理方式？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这和 PhantomJS 的性能是密不可分的，由多次实践发现，PhantomJS 并不能很好地进行并发处理，当并发过多，会导致 CPU 过载，从而导致机器宕机&lt;/p&gt;

&lt;p&gt;在本机环境下的虚拟机中进行并发测试，数据并不理想，极限基本在 ab -n 100 -c 50 左右。 所以为了防止并发导致的问题，就选择了使用类消息队列来避免因为并发过高导致的服务不可用&lt;/p&gt;

&lt;h4 id=&#34;类消息队列的实现&#34;&gt;类消息队列的实现&lt;/h4&gt;

&lt;p&gt;我们这里通过调用内部的分布式缓存系统生成类消息队列，队列的生成其实可以参考数据结构&amp;ndash;队列。最基本的模型就是在缓存中创建一个 KEY ，然后根据队列数据结构的模式进行数据的插入和读取&lt;/p&gt;

&lt;p&gt;当然，类消息队列的中间介质可根据你实际的条件来选择，你也可以使用本机内存实现。这可能会导致应用和类消息队列竞争内存&lt;/p&gt;

&lt;h4 id=&#34;长时持续处理器&#34;&gt;长时持续处理器&lt;/h4&gt;

&lt;p&gt;长时持续处理器是要功能就是消费规则队列生成器生成的类消息队列&lt;/p&gt;

&lt;h4 id=&#34;长时持续处理实现&#34;&gt;长时持续处理实现&lt;/h4&gt;

&lt;p&gt;在长时持续处理器的具体实现中，我们利用了 JavaScript 的 setInterval 方法来持续获取累消息队列的内容下发给规则转化器，然后转发给负载均衡调度器。之后再对返回的结果进行统一处理，比如邮件或者短信报警&lt;/p&gt;

&lt;h4 id=&#34;api&#34;&gt;API&lt;/h4&gt;

&lt;p&gt;PhantomJS 服务可以做为公共 API 提供给客户端进行测试需求的处理， API 通过 HTTP 方式调用。在 API 的处理上需要提供 HTTP 数据到规则和 PhantomJS 的转换。从而又演化出了 HTTP 数据到规则转换器&lt;/p&gt;

&lt;h4 id=&#34;phantomjs-服务&#34;&gt;PhantomJS 服务&lt;/h4&gt;

&lt;p&gt;PhantomJS 服务是指将 PhantomJS 结合 HTTP 服务和子进程进行服务化的处理&lt;/p&gt;

&lt;p&gt;首先、启动 HTTP 服务，然后将长时处理器下发的规则进行进一步转化，转化后启动子进程，HTTP 服务会监听子进程的处理结果，并在处理完毕之后返回&lt;/p&gt;

&lt;h3 id=&#34;报警系统&#34;&gt;报警系统&lt;/h3&gt;

&lt;p&gt;报警系统我们目前使用的是京东内部自己的统一监控平台 UMP，通过调用平台提供的一些 API 来实现报警邮件与短信通知&lt;/p&gt;

&lt;h4 id=&#34;如何根据报警定位到具体页面&#34;&gt;如何根据报警定位到具体页面？&lt;/h4&gt;

&lt;p&gt;用户通过监控管理系统录入规则后，监控系统会根据 UMP 规则针对用户录入的页面生成 UMP 使用的 key。当长时持续处理器发现 PhantomJS 服务返回的结果标示为异常后，就会使用 key 来进行日志记录&lt;/p&gt;

&lt;h4 id=&#34;何时出发报警&#34;&gt;何时出发报警？&lt;/h4&gt;

&lt;p&gt;报警主要分为了短信和邮件报警。邮件报警是在每条异常之后就会发给指定系统用户。短信则是根据异常次数来进行处理的，当异常次数过大，就会下发短信通知&lt;/p&gt;

&lt;h3 id=&#34;部署&#34;&gt;部署&lt;/h3&gt;

&lt;p&gt;对于系统部署可以分为两大块进行。因为机器资源数量有限，没有将所有部分都单独部署&lt;/p&gt;

&lt;p&gt;规则管理系统以及规则队列生成器和持续处理器整合部署在一台机器上，PhantomJS 服务部署在了其他的机器上。进程管理使用了著名的 NPM 模块 —— PM2&lt;/p&gt;

&lt;p&gt;PM2 是一个带有负载均衡功能的 NodeJS 应用的进程管理器。可充分利用 CPU，并保证进程稳定存活&lt;/p&gt;

&lt;p&gt;PM2 特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内建负载均衡（使用 Node cluster 集群模块）&lt;/li&gt;
&lt;li&gt;无缝重启类似 nginx reload&lt;/li&gt;
&lt;li&gt;具有 Ubuntu 和 CentOS 的开机启动脚本&lt;/li&gt;
&lt;li&gt;控制台检测&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过在目前部署任务中，并没有使用内建负载均衡的特性，没用通过集群的方式部署代理。仅使用了后台运行和无缝重启的特性&lt;/p&gt;

&lt;h2 id=&#34;总结与展望&#34;&gt;总结与展望&lt;/h2&gt;

&lt;p&gt;其实我们现在开发的这套监控系统并不复杂，只是合理的运用了一些现有的技术框架。抽象出来我们自己需要的一些功能。但却有效的达到了我们的预期功能，并且节省了很多之前需要人肉测试的时间成本。系统本身还有很多问题在待解决状态，比如报警系统的规则处理与阀值设定，JavaScript 报错的准确过滤机制等，这些问题我们都会逐个解决，并且未来的前端监控系统会成为一个平台，核心服务在后端爬取页面服务，应用端可以有多种形式，比如监控、测试工具等&lt;/p&gt;

&lt;p&gt;一些可以持续优化点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;监控系统虽然在应用层面进行了垂直划分，但是由于机器资源等限制，并没有进行单独功能的部署。这点可能会在后期的使用中进行优化&lt;/li&gt;
&lt;li&gt;PhantomJS 服务还需要进一步优化，以承载大并发，大处理量。提供稳定的服务&lt;/li&gt;
&lt;li&gt;报警由于依赖于公司内部的 UMP 系统，所以并不是特别灵活，后期可以考虑自己实现一套报警机制&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>JavaScript 浏览器事件</title>
      <link>https://keelii.com/2016/09/29/javascript-browser-event/</link>
      <pubDate>Thu, 29 Sep 2016 17:22:29 +0800</pubDate>
      
      <guid>https://keelii.com/2016/09/29/javascript-browser-event/</guid>
      <description>&lt;h2 id=&#34;javascript-浏览器-事件之间的关系&#34;&gt;JavaScript、浏览器、事件之间的关系&lt;/h2&gt;

&lt;p&gt;JavaScript 程序采用了异步事件驱动编程（Event-driven programming）模型，维基百科对它的解释是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;事件驱动程序设计（英语：Event-driven programming）是一种电脑程序设计模型。这种模型的程序运行流程是由用户的动作（如鼠标的按键，键盘的按键动作）或者是由其他程序的消息来决定的。相对于批处理程序设计（batch programming）而言，程序运行的流程是由程序员来决定。批量的程序设计在初级程序设计教学课程上是一种方式。然而，事件驱动程序设计这种设计模型是在交互程序（Interactive program）的情况下孕育而生的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简页言之，在 web 前端编程里面 JavaScript 通过浏览器提供的事件模型 API 和用户交互，接收用户的输入&lt;/p&gt;

&lt;p&gt;由于用户的行为是不确定的，也就是说不知道用户什么时候发生点击、滚动这些动作。这种场景是传统的同步编程模型没法解决的，因为你不可能等用户操作完了才执行后面的代码&lt;/p&gt;

&lt;p&gt;比如我们在 Python 里面调用接收用户输入的方法 &lt;code&gt;raw_input()&lt;/code&gt; 后终端就会一直等待用户的输入，直到输入完成才会执行后面的代码逻辑。但是在下面这段 NodeJS 代码中，接收用户输入的方法 &lt;code&gt;process.stdin.read&lt;/code&gt; 是在一个事件中调用的。后面的代码不会被阻塞（blocked）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#39;use strict&#39;;

process.stdin.on(&#39;readable&#39;, () =&amp;gt; {
    var chunk = process.stdin.read();
    if (chunk !== null) {
        process.stdout.write(`Async output data: ${chunk}`);
    }
});

process.stdin.on(&#39;end&#39;, () =&amp;gt; {
    process.stdout.write(&#39;end&#39;);
});

console.log(&#39;Will not be blocked&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事件驱动程序模型基本的实现原理基本上都是使用 &lt;a href=&#34;https://www.youtube.com/watch?v=8aGhZQkoFbQ&#34;&gt;事件循环（Event Loop）&lt;/a&gt;，这部分内容涉及浏览器事件模型、回调原理，有兴趣的去看链接里面的视频学习下&lt;/p&gt;

&lt;p&gt;需要说明的是在客户端 JavaScript 中像 setTimeout, XMLHTTPRequest 这类 API &lt;strong&gt;并不是&lt;/strong&gt; JavaScript 语言本身就有的。而是 JavaScript 的宿主环境（在客户端 JavaScript 中就是浏览器），同样像 DOM、BOM、Event API 都是浏览器提供的&lt;/p&gt;

&lt;h2 id=&#34;事件绑定的方法&#34;&gt;事件绑定的方法&lt;/h2&gt;

&lt;h3 id=&#34;dom-元素行内绑定&#34;&gt;DOM 元素行内绑定&lt;/h3&gt;

&lt;p&gt;直接在 DOM 元素上通过设置 &lt;code&gt;on + eventType&lt;/code&gt; 来绑定事件处理程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;#none&amp;quot; onclick=&amp;quot;alert(&#39;clicked.&#39;)&amp;quot;&amp;gt;点击我&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种绑定方法是最原始的，有两个缺点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 事件处理程序和 HTML 结构混杂在一起&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;早期在结构、样式、表现分离的时代很忌讳这一点。现在看来在很多 MVX 框架中将事件绑定和 DOM 结构放在一起处理，这样似乎更方便维护（不用来回切换 HTML,JavaScript 文件），而且也符合可预见（predictable）性的规则&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 命名空间冲突&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为 &lt;code&gt;onclick&lt;/code&gt; 中的 JavaScript 代码片段执行环境是全局作用域。然而在 JavaScript 语言中并没有相关的命名空间特性。所以就很容易造成命名空间的冲突，非要用这种方法绑定事件的话只能用对象来做一些封装&lt;/p&gt;

&lt;h3 id=&#34;古老的绑定方法&#34;&gt;古老的绑定方法&lt;/h3&gt;

&lt;p&gt;使用 DOM Element 上面的 &lt;code&gt;on + eventType&lt;/code&gt; 属性 API&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;#none&amp;quot; id=&amp;quot;button&amp;quot;&amp;gt;click me&amp;lt;/a&amp;gt;
&amp;lt;script&amp;gt;
    var el = getElementById(&#39;button&#39;);
    el.onclick = function() { alert(&#39;button clicked.&#39;) };
    el.onclick = function() { alert(&#39;button clicked (Rewrite event handler before).&#39;) };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法也有一个缺点，因为属性赋值会覆盖原值的。所以无法绑定 &lt;strong&gt;多个&lt;/strong&gt; 事件处理函数，如果我们要注册多个 onload 事件处理程序的话就得自己封装一个方法来防止这种事情发生，下面这个例子可以解决这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function addLoadEvent(fn) {
    var oldonLoad = window.onload;
    if (typeof oldonLoad !== &#39;function&#39;) {
        window.onload = fn;
    } else {
        window.onload = function() {
            oldonLoad();
            fn();
        }
    }
}

addLoadEvent(function() { alert(&#39;onload 1&#39;) });
addLoadEvent(function() { alert(&#39;onload 2&#39;) });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这只是个示例，生产环境很少会用到。一般用 DOM Ready 就可以了，因为 JavaScript 的执行通常不用等到页面资源全部加载完，DOM 加载完就可以了&lt;/p&gt;

&lt;h3 id=&#34;现代-标准的绑定方法&#34;&gt;现代/标准的绑定方法&lt;/h3&gt;

&lt;p&gt;标准的绑定方法有两种，&lt;code&gt;addEventListener&lt;/code&gt; 和 &lt;code&gt;attachEvent&lt;/code&gt; 前者是标准浏览器支持的 API，后者是 IE 8 以下浏览器支持的 API。通常需要我们做个兼容封装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function addEvent(target, type, handler) {
    if (target.addEventListener) {
        target.addEventListener(type, handler, false);
    } else {
        target.attachEvent(&#39;on&#39; + type, handler)
    }
}

addEvent(document, &#39;click&#39;, function() { alert(this === document) });
addEvent(document, &#39;click&#39;, function() { alert(this === document) });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子在 IE 8 以下和标准浏览器的效果是不一样的，问题就在于 &lt;code&gt;addEventListener&lt;/code&gt; 中的事件回调函数中的 this 指向元素（target）本身，而 &lt;code&gt;attachEvent&lt;/code&gt; 则指向 &lt;code&gt;window&lt;/code&gt; 为了修复这个问题上面的 attachEvent 可以做一点小调整让其保持和 &lt;code&gt;addEventListener&lt;/code&gt; 的效果一样，不过这样的话注册的 handler 就是个匿名函数，&lt;strong&gt;无法移除&lt;/strong&gt;！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function addEvent(target, type, handler) {
    if (target.addEventListener) {
        target.addEventListener(type, handler, false);
    } else {
        target.attachEvent(&#39;on&#39; + type, function() {
            return handler.call(target)
        });
    }
}

addEvent(document, &#39;click&#39;, function() { alert(this === document) });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当上面这几种情况同时出现的时候就比较有意思了，可以试试下面这段代码的你输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;javascript:alert(1)&amp;quot; onclick=&amp;quot;alert(2)&amp;quot; id=&amp;quot;link&amp;quot;&amp;gt;click me&amp;lt;/a&amp;gt;
&amp;lt;script&amp;gt;
    var link = document.getElementById(&#39;link&#39;);
    link.onclick = function() { alert(3); }

    $(&#39;#link&#39;).bind(&#39;click&#39;, function() { alert(4); });
    $(&#39;#link&#39;).bind(&#39;click&#39;, function() { alert(5); });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正确的结果应该是 &lt;code&gt;3,4,5,1&lt;/code&gt;，根据结果我们可以得出以下结论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;链接上的 href 伪 javascript 协议相当于在浏览器地址栏执行了一段 JavaScript 代码，链接如果是这种格式，点击的时候相当于执行了这段 JavaScript 脚本&lt;/li&gt;
&lt;li&gt;行内的事件绑定和元素调用 onclick 绑定事件会覆盖&lt;/li&gt;
&lt;li&gt;使用 jQuery（内部使用标准事件注册 API）可以绑定多个事件处理程序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;事件冒泡&#34;&gt;事件冒泡&lt;/h2&gt;

&lt;p&gt;大部分事件会沿着事件触发的目标元素往上传播。比如：&lt;code&gt;body&amp;gt;div&amp;gt;p&amp;gt;span&lt;/code&gt; 如果他们都注册了点击事件，那么在 span 元素上触发点击事件后 p,div,body 各自的点击事件也会按顺序触发&lt;/p&gt;

&lt;p&gt;事件冒泡是可以被停止的，下面这个函数封闭了停止事件冒泡的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function stopPropagation(event) {
    event = event || window.event;
    if (event.stopPropagation) {
        event.stopPropagation()
    } else {// IE
        event.cancelBubble = true
    }
}

addEvent(&#39;ele&#39;, &#39;click&#39;, function(e) {
    // click handler
    stopPropagation(e);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;事件对象&#34;&gt;事件对象&lt;/h2&gt;

&lt;p&gt;标准浏览器中在事件处理程序被调用时 &lt;strong&gt;事件对象&lt;/strong&gt; 会通过参数传递给处理程序，IE 8 及以下浏览器中事件对象可以通过全局的 &lt;code&gt;window.event&lt;/code&gt; 来访问。比如我们要获取当前点击的 DOM Element&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;addEvent(document, &#39;click&#39;, function(event) {
    // IE 8 以下 =&amp;gt; undefined
    console.log(event);
});
addEvent(document, &#39;click&#39;, function(event) {
    event = event || window.event;
    // 标准浏览器 =&amp;gt; [object HTMLHtmlElement]
    // IE 8 以下 =&amp;gt; undefined
    console.log(event.target);
    var target = event.target || event.srcElement;

    console.log(target.tagName);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;事件代理&#34;&gt;事件代理&lt;/h2&gt;

&lt;p&gt;有时候我们需要给 &lt;strong&gt;不存在的&lt;/strong&gt;（可能将来会有）的一段 DOM 元素绑定事件，比如给一段 Ajax 请求完成后渲染的 DOM 节点绑定事件。一般绑定的逻辑会在渲染前执行，绑定的时候找不到元素所以并不能成功，当然你也可以把绑定事件的代码放在 Ajax 请求之后。这样做在一些事件逻辑简单的应用里面没问题，但是会加重数据渲染逻辑和事件处理的逻辑耦合。一但事件处理程序特别多的时候，我们通常建议把事件的逻辑和其它代码逻辑分离，这样方便维护。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们通常使用事件代理/委托（Event Delegation ）。而且通常来说使用 &lt;strong&gt;事件代理的性能会比单独绑定事件高&lt;/strong&gt; 很多，我们来看个例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;
    &amp;lt;li id=&amp;quot;item-1&amp;quot;&amp;gt;item1&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;item-2&amp;quot;&amp;gt;item2&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;item-3&amp;quot;&amp;gt;item3&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;item-4&amp;quot;&amp;gt;item4&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;item-5&amp;quot;&amp;gt;item5&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如 &lt;code&gt;ul&lt;/code&gt; 中的 HTML 是 Ajax 异步插入的，通常我们的做法是 插入完成后遍历每个 li 绑定事件处理程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;script&amp;gt;
    function bindEvent(el, n) {
        addEvent(lis[i], &#39;click&#39;, function() { console.log(i); });
    }
    // 用 setTimeout 模拟 Ajax 伪代码
    setTimeout(function() {
        var ajaxData = &#39;&amp;lt;li id=&amp;quot;item-1&amp;quot;&amp;gt;item1&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-2&amp;quot;&amp;gt;item2&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-3&amp;quot;&amp;gt;item3&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-4&amp;quot;&amp;gt;item4&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-5&amp;quot;&amp;gt;item5&amp;lt;/li&amp;gt;&#39;;
        var ul = document.getElementById(&#39;list&#39;)
        ul.innerHTML(ajaxData);
        var lis = ul.getElementsByTagName(&#39;li&#39;);

        for (var i = 0; i &amp;lt; lis.length; i++) {
            bindEvent(lis[i], i);
        }
    }, 1000);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再使用事件代理把事件绑定到 &lt;code&gt;ul&lt;/code&gt; 元素上，我们知道很多事件可以冒并沿着 DOM 树传播到所有的父元素上，我们只需要判断目标元素是不是我们想绑定的真正元素即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;script&amp;gt;
function delegateEvent(el, eventType, fn) {
    addEvent(el, eventType, function(event) {
        event = event || window.event;
        var target = event.target || event.srcElement;
        fn(target);
    });
}

var el = document.getElementById(&#39;list&#39;);
// 用 setTimeout 模拟 Ajax 伪代码
setTimeout(function() {
    var ajaxData = &#39;&amp;lt;li id=&amp;quot;item-1&amp;quot;&amp;gt;item1&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-2&amp;quot;&amp;gt;item2&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-3&amp;quot;&amp;gt;item3&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-4&amp;quot;&amp;gt;item4&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-5&amp;quot;&amp;gt;item5&amp;lt;/li&amp;gt;&#39;;
    el.innerHTML(ajaxData)
}, 1000);

delegateEvent(el, &#39;click&#39;, function(target) {
    console.log(target.id);
});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然使用了事件代理之后，代码变少了。逻辑也很清晰，关键是以前需要 N 次的绑定操作现在只需要一次&lt;/p&gt;

&lt;h2 id=&#34;jquery-中的事件绑定&#34;&gt;jQuery 中的事件绑定&lt;/h2&gt;

&lt;p&gt;以 jQuery1.6.4 为例，jQuery 提供了很多事件绑定的 API。例如： &lt;code&gt;delegate()&lt;/code&gt;, &lt;code&gt;bind()&lt;/code&gt;, &lt;code&gt;click()&lt;/code&gt;, &lt;code&gt;hover()&lt;/code&gt;, &lt;code&gt;one()&lt;/code&gt;, &lt;code&gt;live()&lt;/code&gt;，这些方法其实都是一些别名，核心是调用了 jQuery 底层事件的 &lt;code&gt;jQuery.event.add&lt;/code&gt; 方法。其实现也是上文提到的 &lt;code&gt;addEventListener&lt;/code&gt; 和 &lt;code&gt;attachEvent&lt;/code&gt; 两个 API&lt;/p&gt;

&lt;p&gt;这些 API 主要是为了方便绑定事件的各种场景，并且内部处理好了兼容性问题。还有一个比较好用的地方就是 &lt;code&gt;事件命名空间&lt;/code&gt;。比如：两个弹出层都向 document 绑定了点击关闭事件，但是如果只想解绑其中一个。这时候使用命名空间再合适不过了。可以试试这个小例子 &lt;a href=&#34;http://jsbin.com/sacinereju/edit?html,output&#34;&gt;Event Binding&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document).bind(&#39;click.handler1&#39;, function() { console.log(1);})
$(document).bind(&#39;click.handler2&#39;, function() { console.log(2);})

$(document).unbind(&#39;click.handler2&#39;);   // 解除指定的
$(document).unbind(&#39;click&#39;);            // 解除所有点击事件
$(document).unbind()                    // 解除所有事件
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自定义事件与发布-订阅者设计模式&#34;&gt;自定义事件与发布/订阅者设计模式&lt;/h2&gt;

&lt;p&gt;自定义事件是设计模式中的 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85&#34;&gt;发布/订阅者&lt;/a&gt; 的一种实现。发布者与订阅者松散地耦合，而且不需要关心对方的存在。&lt;a href=&#34;https://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/&#34;&gt;这里&lt;/a&gt;有 NC 大师的一种实现。实际使用过程中，主要被运用在异步操作比较多的场景和不同系统之间消息通信，之前的&lt;a href=&#34;https://keelii.com/2016/07/31/something-have-to-say-with-JD-item/#TOC-25&#34;&gt;文章&lt;/a&gt;中有过一些实例&lt;/p&gt;

&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88&#34;&gt;事件驱动程序设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.quirksmode.org/js/introevents.html&#34;&gt;Introduction to Events&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/&#34;&gt;Custom events in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>