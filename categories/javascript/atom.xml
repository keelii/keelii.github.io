<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Something</title>
    <link>https://keelii.github.io/categories/javascript/atom/index.xml</link>
    <description>Recent content on Something</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <atom:link href="https://keelii.github.io/categories/javascript/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JavaScript 浏览器事件</title>
      <link>https://keelii.github.io/2016/09/29/javascript-browser-event/</link>
      <pubDate>Thu, 29 Sep 2016 17:22:29 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/09/29/javascript-browser-event/</guid>
      <description>&lt;h2 id=&#34;javascript-浏览器-事件之间的关系&#34;&gt;JavaScript、浏览器、事件之间的关系&lt;/h2&gt;

&lt;p&gt;JavaScript 程序采用了异步事件驱动编程（Event-driven programming）模型，维基百科对它的解释是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;事件驱动程序设计（英语：Event-driven programming）是一种电脑程序设计模型。这种模型的程序运行流程是由用户的动作（如鼠标的按键，键盘的按键动作）或者是由其他程序的消息来决定的。相对于批处理程序设计（batch programming）而言，程序运行的流程是由程序员来决定。批量的程序设计在初级程序设计教学课程上是一种方式。然而，事件驱动程序设计这种设计模型是在交互程序（Interactive program）的情况下孕育而生的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
简页言之，在 web 前端编程里面 JavaScript 通过浏览器提供的事件模型 API 和用户交互，接收用户的输入&lt;/p&gt;

&lt;p&gt;由于用户的行为是不确定的，也就是说不知道用户什么时候发生点击、滚动这些动作。这种场景是传统的同步编程模型没法解决的，因为你不可能等用户操作完了才执行后面的代码&lt;/p&gt;

&lt;p&gt;比如我们在 Python 里面调用接收用户输入的方法 &lt;code&gt;raw_input()&lt;/code&gt; 后终端就会一直等待用户的输入，直到输入完成才会执行后面的代码逻辑。但是在下面这段 NodeJS 代码中，接收用户输入的方法 &lt;code&gt;process.stdin.read&lt;/code&gt; 是在一个事件中调用的。后面的代码不会被阻塞（blocked）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#39;use strict&#39;;

process.stdin.on(&#39;readable&#39;, () =&amp;gt; {
    var chunk = process.stdin.read();
    if (chunk !== null) {
        process.stdout.write(`Async output data: ${chunk}`);
    }
});

process.stdin.on(&#39;end&#39;, () =&amp;gt; {
    process.stdout.write(&#39;end&#39;);
});

console.log(&#39;Will not be blocked&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事件驱动程序模型基本的实现原理基本上都是使用 &lt;a href=&#34;https://www.youtube.com/watch?v=8aGhZQkoFbQ&#34;&gt;事件循环（Event Loop）&lt;/a&gt;，这部分内容涉及浏览器事件模型、回调原理，有兴趣的去看链接里面的视频学习下&lt;/p&gt;

&lt;p&gt;需要说明的是在客户端 JavaScript 中像 setTimeout, XMLHTTPRequest 这类 API &lt;strong&gt;并不是&lt;/strong&gt; JavaScript 语言本身就有的。而是 JavaScript 的宿主环境（在客户端 JavaScript 中就是浏览器），同样像 DOM、BOM、Event API 都是浏览器提供的&lt;/p&gt;

&lt;h2 id=&#34;事件绑定的方法&#34;&gt;事件绑定的方法&lt;/h2&gt;

&lt;h3 id=&#34;dom-元素行内绑定&#34;&gt;DOM 元素行内绑定&lt;/h3&gt;

&lt;p&gt;直接在 DOM 元素上通过设置 &lt;code&gt;on + eventType&lt;/code&gt; 来绑定事件处理程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;#none&amp;quot; onclick=&amp;quot;alert(&#39;clicked.&#39;)&amp;quot;&amp;gt;点击我&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种绑定方法是最原始的，有两个缺点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 事件处理程序和 HTML 结构混杂在一起&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;早期在结构、样式、表现分离的时代很忌讳这一点。现在看来在很多 MVX 框架中将事件绑定和 DOM 结构放在一起处理，这样似乎更方便维护（不用来回切换 HTML,JavaScript 文件），而且也符合可预见（predictable）性的规则&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 命名空间冲突&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为 &lt;code&gt;onclick&lt;/code&gt; 中的 JavaScript 代码片段执行环境是全局作用域。然而在 JavaScript 语言中并没有相关的命名空间特性。所以就很容易造成命名空间的冲突，非要用这种方法绑定事件的话只能用对象来做一些封装&lt;/p&gt;

&lt;h3 id=&#34;古老的绑定方法&#34;&gt;古老的绑定方法&lt;/h3&gt;

&lt;p&gt;使用 DOM Element 上面的 &lt;code&gt;on + eventType&lt;/code&gt; 属性 API&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;#none&amp;quot; id=&amp;quot;button&amp;quot;&amp;gt;click me&amp;lt;/a&amp;gt;
&amp;lt;script&amp;gt;
    var el = getElementById(&#39;button&#39;);
    el.onclick = function() { alert(&#39;button clicked.&#39;) };
    el.onclick = function() { alert(&#39;button clicked (Rewrite event handler before).&#39;) };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法也有一个缺点，因为属性赋值会覆盖原值的。所以无法绑定 &lt;strong&gt;多个&lt;/strong&gt; 事件处理函数，如果我们要注册多个 onload 事件处理程序的话就得自己封装一个方法来防止这种事情发生，下面这个例子可以解决这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function addLoadEvent(fn) {
    var oldonLoad = window.onload;
    if (typeof oldonLoad !== &#39;function&#39;) {
        window.onload = fn;
    } else {
        window.onload = function() {
            oldonLoad();
            fn();
        }
    }
}

addLoadEvent(function() { alert(&#39;onload 1&#39;) });
addLoadEvent(function() { alert(&#39;onload 2&#39;) });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这只是个示例，生产环境很少会用到。一般用 DOM Ready 就可以了，因为 JavaScript 的执行通常不用等到页面资源全部加载完，DOM 加载完就可以了&lt;/p&gt;

&lt;h3 id=&#34;现代-标准的绑定方法&#34;&gt;现代/标准的绑定方法&lt;/h3&gt;

&lt;p&gt;标准的绑定方法有两种，&lt;code&gt;addEventListener&lt;/code&gt; 和 &lt;code&gt;attachEvent&lt;/code&gt; 前者是标准浏览器支持的 API，后者是 IE 8 以下浏览器支持的 API。通常需要我们做个兼容封装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function addEvent(target, type, handler) {
    if (target.addEventListener) {
        target.addEventListener(type, handler, false);
    } else {
        target.attachEvent(&#39;on&#39; + type, handler)
    }
}

addEvent(document, &#39;click&#39;, function() { alert(this === document) });
addEvent(document, &#39;click&#39;, function() { alert(this === document) });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子在 IE 8 以下和标准浏览器的效果是不一样的，问题就在于 &lt;code&gt;addEventListener&lt;/code&gt; 中的事件回调函数中的 this 指向元素（target）本身，而 &lt;code&gt;attachEvent&lt;/code&gt; 则指向 &lt;code&gt;window&lt;/code&gt; 为了修复这个问题上面的 attachEvent 可以做一点小调整让其保持和 &lt;code&gt;addEventListener&lt;/code&gt; 的效果一样，不过这样的话注册的 handler 就是个匿名函数，&lt;strong&gt;无法移除&lt;/strong&gt;！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function addEvent(target, type, handler) {
    if (target.addEventListener) {
        target.addEventListener(type, handler, false);
    } else {
        target.attachEvent(&#39;on&#39; + type, function() {
            return handler.call(target)
        });
    }
}

addEvent(document, &#39;click&#39;, function() { alert(this === document) });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当上面这几种情况同时出现的时候就比较有意思了，可以试试下面这段代码的你输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;javascript:alert(1)&amp;quot; onclick=&amp;quot;alert(2)&amp;quot; id=&amp;quot;link&amp;quot;&amp;gt;click me&amp;lt;/a&amp;gt;
&amp;lt;script&amp;gt;
    var link = document.getElementById(&#39;link&#39;);
    link.onclick = function() { alert(3); }

    $(&#39;#link&#39;).bind(&#39;click&#39;, function() { alert(4); });
    $(&#39;#link&#39;).bind(&#39;click&#39;, function() { alert(5); });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正确的结果应该是 &lt;code&gt;3,4,5,1&lt;/code&gt;，根据结果我们可以得出以下结论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;链接上的 href 伪 javascript 协议相当于在浏览器地址栏执行了一段 JavaScript 代码，链接如果是这种格式，点击的时候相当于执行了这段 JavaScript 脚本&lt;/li&gt;
&lt;li&gt;行内的事件绑定和元素调用 onclick 绑定事件会覆盖&lt;/li&gt;
&lt;li&gt;使用 jQuery（内部使用标准事件注册 API）可以绑定多个事件处理程序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;事件冒泡&#34;&gt;事件冒泡&lt;/h2&gt;

&lt;p&gt;大部分事件会沿着事件触发的目标元素往上传播。比如：&lt;code&gt;body&amp;gt;div&amp;gt;p&amp;gt;span&lt;/code&gt; 如果他们都注册了点击事件，那么在 span 元素上触发点击事件后 p,div,body 各自的点击事件也会按顺序触发&lt;/p&gt;

&lt;p&gt;事件冒泡是可以被停止的，下面这个函数封闭了停止事件冒泡的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function stopPropagation(event) {
    event = event || window.event;
    if (event.stopPropagation) {
        event.stopPropagation()
    } else {// IE
        event.cancelBubble = true
    }
}

addEvent(&#39;ele&#39;, &#39;click&#39;, function(e) {
    // click handler
    stopPropagation(e);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;事件对象&#34;&gt;事件对象&lt;/h2&gt;

&lt;p&gt;标准浏览器中在事件处理程序被调用时 &lt;strong&gt;事件对象&lt;/strong&gt; 会通过参数传递给处理程序，IE 8 及以下浏览器中事件对象可以通过全局的 &lt;code&gt;window.event&lt;/code&gt; 来访问。比如我们要获取当前点击的 DOM Element&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;addEvent(document, &#39;click&#39;, function(event) {
    // IE 8 以下 =&amp;gt; undefined
    console.log(event);
});
addEvent(document, &#39;click&#39;, function(event) {
    event = event || window.event;
    // 标准浏览器 =&amp;gt; [object HTMLHtmlElement]
    // IE 8 以下 =&amp;gt; undefined
    console.log(event.target);
    var target = event.target || event.srcElement;

    console.log(target.tagName);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;事件代理&#34;&gt;事件代理&lt;/h2&gt;

&lt;p&gt;有时候我们需要给 &lt;strong&gt;不存在的&lt;/strong&gt;（可能将来会有）的一段 DOM 元素绑定事件，比如给一段 Ajax 请求完成后渲染的 DOM 节点绑定事件。一般绑定的逻辑会在渲染前执行，绑定的时候找不到元素所以并不能成功，当然你也可以把绑定事件的代码放在 Ajax 请求之后。这样做在一些事件逻辑简单的应用里面没问题，但是会加重数据渲染逻辑和事件处理的逻辑耦合。一但事件处理程序特别多的时候，我们通常建议把事件的逻辑和其它代码逻辑分离，这样方便维护。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们通常使用事件代理/委托（Event Delegation ）。而且通常来说使用 &lt;strong&gt;事件代理的性能会比单独绑定事件高&lt;/strong&gt; 很多，我们来看个例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;
    &amp;lt;li id=&amp;quot;item-1&amp;quot;&amp;gt;item1&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;item-2&amp;quot;&amp;gt;item2&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;item-3&amp;quot;&amp;gt;item3&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;item-4&amp;quot;&amp;gt;item4&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;item-5&amp;quot;&amp;gt;item5&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如 &lt;code&gt;ul&lt;/code&gt; 中的 HTML 是 Ajax 异步插入的，通常我们的做法是 插入完成后遍历每个 li 绑定事件处理程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;script&amp;gt;
    function bindEvent(el, n) {
        addEvent(lis[i], &#39;click&#39;, function() { console.log(i); });
    }
    // 用 setTimeout 模拟 Ajax 伪代码
    setTimeout(function() {
        var ajaxData = &#39;&amp;lt;li id=&amp;quot;item-1&amp;quot;&amp;gt;item1&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-2&amp;quot;&amp;gt;item2&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-3&amp;quot;&amp;gt;item3&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-4&amp;quot;&amp;gt;item4&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-5&amp;quot;&amp;gt;item5&amp;lt;/li&amp;gt;&#39;;
        var ul = document.getElementById(&#39;list&#39;)
        ul.innerHTML(ajaxData);
        var lis = ul.getElementsByTagName(&#39;li&#39;);

        for (var i = 0; i &amp;lt; lis.length; i++) {
            bindEvent(lis[i], i);
        }
    }, 1000);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再使用事件代理把事件绑定到 &lt;code&gt;ul&lt;/code&gt; 元素上，我们知道很多事件可以冒并沿着 DOM 树传播到所有的父元素上，我们只需要判断目标元素是不是我们想绑定的真正元素即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;script&amp;gt;
function delegateEvent(el, eventType, fn) {
    addEvent(el, eventType, function(event) {
        event = event || window.event;
        var target = event.target || event.srcElement;
        fn(target);
    });
}

var el = document.getElementById(&#39;list&#39;);
// 用 setTimeout 模拟 Ajax 伪代码
setTimeout(function() {
    var ajaxData = &#39;&amp;lt;li id=&amp;quot;item-1&amp;quot;&amp;gt;item1&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-2&amp;quot;&amp;gt;item2&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-3&amp;quot;&amp;gt;item3&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-4&amp;quot;&amp;gt;item4&amp;lt;/li&amp;gt; &amp;lt;li id=&amp;quot;item-5&amp;quot;&amp;gt;item5&amp;lt;/li&amp;gt;&#39;;
    el.innerHTML(ajaxData)
}, 1000);

delegateEvent(el, &#39;click&#39;, function(target) {
    console.log(target.id);
});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然使用了事件代理之后，代码变少了。逻辑也很清晰，关键是以前需要 N 次的绑定操作现在只需要一次&lt;/p&gt;

&lt;h2 id=&#34;jquery-中的事件绑定&#34;&gt;jQuery 中的事件绑定&lt;/h2&gt;

&lt;p&gt;以 jQuery1.6.4 为例，jQuery 提供了很多事件绑定的 API。例如： &lt;code&gt;delegate()&lt;/code&gt;, &lt;code&gt;bind()&lt;/code&gt;, &lt;code&gt;click()&lt;/code&gt;, &lt;code&gt;hover()&lt;/code&gt;, &lt;code&gt;one()&lt;/code&gt;, &lt;code&gt;live()&lt;/code&gt;，这些方法其实都是一些别名，核心是调用了 jQuery 底层事件的 &lt;code&gt;jQuery.event.add&lt;/code&gt; 方法。其实现也是上文提到的 &lt;code&gt;addEventListener&lt;/code&gt; 和 &lt;code&gt;attachEvent&lt;/code&gt; 两个 API&lt;/p&gt;

&lt;p&gt;这些 API 主要是为了方便绑定事件的各种场景，并且内部处理好了兼容性问题。还有一个比较好用的地方就是 &lt;code&gt;事件命名空间&lt;/code&gt;。比如：两个弹出层都向 document 绑定了点击关闭事件，但是如果只想解绑其中一个。这时候使用命名空间再合适不过了。可以试试这个小例子 &lt;a href=&#34;http://jsbin.com/sacinereju/edit?html,output&#34;&gt;Event Binding&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document).bind(&#39;click.handler1&#39;, function() { console.log(1);})
$(document).bind(&#39;click.handler2&#39;, function() { console.log(2);})

$(document).unbind(&#39;click.handler2&#39;);   // 解除指定的
$(document).unbind(&#39;click&#39;);            // 解除所有点击事件
$(document).unbind()                    // 解除所有事件
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自定义事件与发布-订阅者设计模式&#34;&gt;自定义事件与发布/订阅者设计模式&lt;/h2&gt;

&lt;p&gt;自定义事件是设计模式中的 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85&#34;&gt;发布/订阅者&lt;/a&gt; 的一种实现。发布者与订阅者松散地耦合，而且不需要关心对方的存在。&lt;a href=&#34;https://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/&#34;&gt;这里&lt;/a&gt;有 NC 大师的一种实现。实际使用过程中，主要被运用在异步操作比较多的场景和不同系统之间消息通信，之前的&lt;a href=&#34;https://keelii.github.io/2016/07/31/something-have-to-say-with-JD-item/#TOC-25&#34;&gt;文章&lt;/a&gt;中有过一些实例&lt;/p&gt;

&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88&#34;&gt;事件驱动程序设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.quirksmode.org/js/introevents.html&#34;&gt;Introduction to Events&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/&#34;&gt;Custom events in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 15 - 脚本化文档</title>
      <link>https://keelii.github.io/2016/08/12/javascript-definitive-guide-note-13/</link>
      <pubDate>Fri, 12 Aug 2016 15:36:59 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/08/12/javascript-definitive-guide-note-13/</guid>
      <description>&lt;p&gt;每个 Window 对象有一个 document 属性引用了 Document 对象。Document 对象表示窗口的内容，它是一个巨大的 API 中的核心对象，叫做文档对象模型（Document Obejct Model, DOM），用来展示和操作文档内容&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;dom-概览&#34;&gt;DOM 概览&lt;/h2&gt;

&lt;p&gt;HTML 或 XML 文档的嵌套元素在 DOM 中以「树」的形式展示。HTML 文档的树装结构包含表示 HTML 标签或元素（如 body, p）和表示文本字符串的节点，也可能包含表示 HTML 注释的节点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Simple Document&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Heading&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;This is a &amp;lt;i&amp;gt;paragraph&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;置换成 DOM 树表示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
                    +------------+
                    |  Document  |
                    +-----+------+
                          |
                    +-----+------+
                    |   &amp;lt;html&amp;gt;   |
                    +-----+------+
                          |
     +--------------------+--------------------+
     |                                         |
+----+------+                             +----+-----+
|  &amp;lt;head&amp;gt;   |                             |  &amp;lt;body&amp;gt;  |
+----+------+                             +----+-----+
     |                                         |
+----+------+                     +------------+------------+
|  &amp;lt;title&amp;gt;  |                     |                         |
+-----------+                 +----+---+               +---------+
                              |  &amp;lt;h1&amp;gt;  |               |   &amp;lt;p&amp;gt;   |
+------------------+          +--------+               +---------+
| &amp;quot;Simple Document&amp;quot;|                                        |
+------------------+                            +-----------+-----------+
                                                |                       |
                                         +------+--------+         +----+-----+
                                         | &amp;quot;This is a&amp;quot;   |         |   &amp;lt;i&amp;gt;    |
                                         +---------------+         +----+-----+
                                                                        |
                                                                   +----+------+
                                                                   |&amp;quot;paragraph&amp;quot;|
                                                                   +-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上图中每个方框是文档的一个节点（node），它表示一个 Node 对象。注意树形的根部是 Document 节点，它代表整个文档。代表 HTML 元素的节点是 Element 节点。代表文本的节点是 Text 节点。Document、Element 和 Text 是 Node 的子类&lt;/p&gt;

&lt;h2 id=&#34;选取文档元素&#34;&gt;选取文档元素&lt;/h2&gt;

&lt;h3 id=&#34;通过-id-选择元素&#34;&gt;通过 ID 选择元素&lt;/h3&gt;

&lt;p&gt;HTML 元素可以有一个 id 属性，在文档中该值必须 &lt;strong&gt;唯一&lt;/strong&gt;，可以使用 getElementById() 方法选取一个基于唯一 ID 的元素&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var section1 = document.getElementById(&#39;selection1&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在低于 IE 8 版本的浏览器中，&lt;strong&gt;getElementById() 对匹配元素的 ID 不区分大小写，而且也返回匹配 name 属性的元素&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;通过名字选取元素&#34;&gt;通过名字选取元素&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var radiobuttons = document.getElementsByName(&#39;favorite_color&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getElementsByName() 定义在 HTMLDocument 类中，而不在 Document 类中，所以它 &lt;strong&gt;只针对 HTML 文档可用&lt;/strong&gt;，XML 中不可用。它返回一个 NodeList 对象，后者的行为类似一个包含若干 Element 对象的只读数组。在 IE 中，也会返回 id 属性匹配指定的元素&lt;/p&gt;

&lt;h3 id=&#34;通过标签名选取元素&#34;&gt;通过标签名选取元素&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 返回所有的 span 标签元素
var spans = document.getElementsByTagName(&#39;span&#39;);
// 返回所有元素
var allTags = document.getElementsByTagName(&#39;*&#39;);
// 选取第一个 span 里面的所有 a 标签
// Element 类也定义 getElementsByTagName() 方法，
// 它只取调用该方法的元素（spans）的后代元素
var links = spans[0].getElementsByTagName(&#39;a&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTMLDocument 对象还定义了两个属性，它们指代特殊的单个元素而不是集合：&lt;code&gt;document.body&lt;/code&gt; 是一个 HTML 文档的 &lt;body&gt; 元素；&lt;code&gt;document.head&lt;/code&gt; 是 &lt;head&gt; 元素。这些属性总是会定义的。&lt;strong&gt;即使文档中没有 head 或 body 元素，浏览器也将隐式地创建他们&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;getElementsByName() 和 getElementsByTagName() 都返回 NodeList 对象，而类似 document.images 和 document.forms 的属性为 HTMLCollection 对象。
这些对象都是只读类数组对象。有 length 属性，也可以被索引到，也可以进行循环迭代&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;通过-css-类选取元素&#34;&gt;通过 CSS 类选取元素&lt;/h3&gt;

&lt;p&gt;HTML 元素的 class 属性值是一个以空格隔开的列表，可以为空或者包含多个标识符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 查找 class 属性追念 warning 的所有元素
var warnings = document.getElementsByClassName(&#39;warning&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意除了 IE8 及以下低版本浏览器，getElementsByClassName() 在所有的浏览器中都实现了&lt;/p&gt;

&lt;h3 id=&#34;通过-css-选择器选取元素&#34;&gt;通过 CSS 选择器选取元素&lt;/h3&gt;

&lt;p&gt;CSS 样式表有一种非常强大的语法，那就是选择器，用来描述文档中的若干元素&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;#nav          // id=&amp;quot;nav&amp;quot; 的元素
div           // 所有 &amp;lt;div&amp;gt; 元素
.warning      // 所有 class 属性值包含 &amp;quot;warning&amp;quot; 的元素
p[lang=&amp;quot;fr&amp;quot;]  // 所有属性 lang 为 fr 的 &amp;lt;p&amp;gt; 元素
*[lang=&amp;quot;fr&amp;quot;]  // 所有属性 lang 为 fr 的元素
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;文档结构和遍历&#34;&gt;文档结构和遍历&lt;/h2&gt;

&lt;h3 id=&#34;作为节点树的文档&#34;&gt;作为节点树的文档&lt;/h3&gt;

&lt;p&gt;Document 对象、它的 Element 对象和文档中表示文本的 Text 对象都是 Node 对象。Node 对象有以下属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;parentNode&lt;/strong&gt; 该节点的父节点，Document 对象没有父节点，它的 parentNode 返回 null&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;childNodes&lt;/strong&gt; 只读的类数组对象（NodeList 对象），表示该节点的所有子节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;firstChild、lastChild&lt;/strong&gt; 该节点的子节点中的第一个或最后一个&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nextSibling、previoursSibling&lt;/strong&gt; 该节点的兄弟节点中的前一个或下一个&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nodeType&lt;/strong&gt; 该节点的类型

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;11&lt;/strong&gt; - DocumentFragment 节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;9&lt;/strong&gt; - Document 节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;8&lt;/strong&gt; - Comment 节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3&lt;/strong&gt; - Text 节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt; - Element 节点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nodeVlaue&lt;/strong&gt; Text 节点或 Comment 节点的文本内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nodeName&lt;/strong&gt; 元素标签名，以大写形式表示&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 注意删除了空格和换行
// &amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;Hello World!&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
document.childNodes[0].childNodes[1]      // =&amp;gt; body 节点
document.firstChild.firstChild.nextSibling // =&amp;gt; null title 节点的下个兄弟节点为 null
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;属性&#34;&gt;属性&lt;/h2&gt;

&lt;p&gt;HTML 元素由一个标签和一组称为属性（attribute）的名/值对组成&lt;/p&gt;

&lt;h3 id=&#34;html-属性作为-element-的属性&#34;&gt;HTML 属性作为 Element 的属性&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var image = document.getElementById(&#39;myimage&#39;);
var imgurl = image.src;

var f = document.forms[0];
f.action = &#39;http://www.example.com/submit.php&#39;;
f.method = &#39;POST&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTML 属性名不区分大小写，但是 JavaScript 则区分。用 JavaScript 取元素属性名的时候一般用小写，如果属性名是多个单词用驼峰式的规则，例如：defaultChecked、tabIndex。如果属性是 JavaScript 中的保留字，一般用 html 前缀，比如 for 属性，使用 htmlFor 来访问。class 则不同，使用 className 来访问&lt;/p&gt;

&lt;h3 id=&#34;获取和设置非标准-html-属性&#34;&gt;获取和设置非标准 HTML 属性&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var image = document.images[0];
// getAttribute 始终返回字符串
var width = parseInt(image.getAttribute(&#39;width&#39;))
image.setAttribute(&#39;class&#39;, &#39;thumbnail)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数据集属性&#34;&gt;数据集属性&lt;/h3&gt;

&lt;p&gt;有时候在 HTML 元素上绑定一些额外的信息会很有帮助（通常给 JavaScript 来读取），一般可以把信息存储在 HTML 属性上&lt;/p&gt;

&lt;p&gt;HTML 5 提供了一个解决文案。在 HTML 5 文档中，任意以「data-」为前缀的小写的属性名称都是合法的。这些「数据集属性」将不会对元素表示产生影响&lt;/p&gt;

&lt;p&gt;HTML 5 还在 Element 对象上定义了 dataset 属性。该属性指代一个对象，它的各个属性对应于去掉前缀的 data- 属性。因此 dataset.x 应该保存 data-x 属性的值。带连字符的属性对应于驼峰命名法属性名：data-jquery-test 属性就变成 dataset.jqueryTest 属性&lt;/p&gt;

&lt;h3 id=&#34;作为-html-的元素内容&#34;&gt;作为 HTML 的元素内容&lt;/h3&gt;

&lt;p&gt;读取 Element 的 innerHTML 属性作为字符串标记返回那个元素的内容。设置元素的 innerHTML 属性则调用 Web 浏览器的解析器，用新的字符串内容解析替换当前内容&lt;/p&gt;

&lt;p&gt;通常来说设置 innerHTML 效率很高，但是对 innerHTML 属性使用「+=」操作符时效率比较低下，因为它既要序列化又要解析&lt;/p&gt;

&lt;p&gt;HTML 5 还标准化了 outerHTML 属性，表示返回包含标签本身的 HTML 内容&lt;/p&gt;

&lt;p&gt;另外 IE 引入了一个 insertAdjacentHTML() 方法，它将任意的 HTML 标记字符串插入到指定的元素「相邻」的位置。标记是该方法的第二个参数。并且「相邻」的精确含义依赖于第一个参数的值。第一个参数为具有以下值之一的字符串：「beforebegin」、「afterbegin」、「beforeend」、「afterend」&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    |&amp;lt;div id=&amp;quot;target&amp;quot;&amp;gt;|This is the element content|&amp;lt;/div&amp;gt;|
    |                 |                           |      |
 beforebegin     afterbegin                  beforeend afterend
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;作为纯文本的元素内容&#34;&gt;作为纯文本的元素内容&lt;/h3&gt;

&lt;p&gt;查询线文本形式的元素内容，
标准的方法是 Node 的 textContent 属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var para = document.getElementsByTagName(&#39;p&#39;)[0]
var text = para.textContent;
para.textContent = &#39;Hello World!&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;textContent 属性除 IE 其它浏览器都支持，不支持的可以用 innerText 属性来代替。textContent 属性就是将指定元素所有的后代 Text 节点简单地串联在一起。但是和 textContent 不同。innerText 不返回 script 元素的内容，它会忽略多余空白，并试图保留表格格式。同时 innerText 针对某些表格元素（如 table、tbody、tr）是只读的属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function textContente(e) {
    var child, type, s = &#39;&#39;;
    for (child = e.firstChild; child != null; child = child.nextSibling ) {
        type = child.nodeType;
        if ( type === 3 || type === 4 )
            s += child.nodeValue;
        else if ( type === 1 )
            s += textContent(child);
    }
    return s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建-插入和删除节点&#34;&gt;创建、插入和删除节点&lt;/h2&gt;

&lt;p&gt;一个简单的动态插入脚本的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function loadasyn(url) {
    var head = document.getElementsByTagName(&#39;head&#39;)[0];
    var s = document.createElement(&#39;script&#39;);
    s.src = url;
    head.appendChild(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建节点&#34;&gt;创建节点&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.createElement(&#39;script&#39;)
document.createTextNode(&#39;text node content&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种创建新文档节点的方法是复制已存在的节点。第个节点有一个 cloneNode() 方法来返回该节点的一个全新副本。给方法传递参数 true 也能够递归地复制所有后代节点，或传递参数 false 只执行一个浅复制&lt;/p&gt;

&lt;h3 id=&#34;插入节点&#34;&gt;插入节点&lt;/h3&gt;

&lt;p&gt;下面代码展示了 insertBefore() 和 appendChild() 方法使用场景&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function insertAt(parent, child, n) {
    if ( n &amp;lt; 0 || n &amp;gt; parent.childNodes.length ) throw new Error(&#39;invalid index&#39;);
    else if ( n == parent.childNodes.length ) parent.appendChild(child);
    else parent.insertBefore(child, parent.childNodes[n]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;删除和替换节点&#34;&gt;删除和替换节点&lt;/h3&gt;

&lt;p&gt;removeChild() 方法删除一个子节点并用一个新的节点取而代之&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;n.parentNode.removeChild(n);
n.parentNode.replaceChild(document.createTextNode(&#39;[ REDACTED ]&#39;), n)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-documentfragment&#34;&gt;使用 DocumentFragment&lt;/h3&gt;

&lt;p&gt;DocumentFragment 是一种特殊的 Node，它作为其他节点的一个临时窗口。像这样创建一个 DocumentFragment：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var frag = document.createDocumentFragment();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像 Document 节点一样，DocumentFragment 是独立的，而不是任何其他文档的一部分。它的 parentNode 总是 null。但类似 Element，它可以有任意多的子节点，可以用 appendChild()、insertBefore() 等方法来操作它们&lt;/p&gt;

&lt;h2 id=&#34;文档和元素的几何开头和滚动&#34;&gt;文档和元素的几何开头和滚动&lt;/h2&gt;

&lt;h3 id=&#34;文档坐标和视口坐标&#34;&gt;文档坐标和视口坐标&lt;/h3&gt;

&lt;p&gt;元素的位置是以像素来表示的，向右代表 X 坐标增加，向下代表 Y 坐标增加。但是，有两个不同的点作为坐标系原点：元素的 X 和 Y 坐标可以相对于文档的左上角或者相对于在其中显示文档的视口左上角。在顶级窗口和标签页中，「视口」只是实际显示文档内容的浏览器的一部分：它 &lt;strong&gt;不包括&lt;/strong&gt; 浏览器「外壳」（如菜单、工具条和标签页）。针对框架页中显示的文档，视口是定义了框架页的 iframe 元素。无论在何种情况下，当讨论元素的位置时，必须弄清楚所使用的坐标是文档坐标还是视口（窗口）坐标&lt;/p&gt;

&lt;p&gt;如果文档比视口要小，或者说它还未出现滚动，则文档的左上角就是视口的左上角，文档和视口坐标系统是同一个。但是，一般来说，要在两种坐标系之间互相转换，必须加上或者减去滚动的偏移量（scroll offset）&lt;/p&gt;

&lt;p&gt;为了在坐标系之间互相转换，我们需要判定浏览器窗口的流动条的位置。Window 对象的 pageXOffset 和 pageYOffset 属性在所有浏览器中提供这些值。除了 IE 8 以及更早的版本以外。也可以使用 scrollLeft 和 scrollTop 属性来获得滚动条的位置。令人迷惑的是，正常情况下通过查询文档的根节点（document.documentElement）来获取这些属性值，但在怪异模式下，必须在文档的 body 元素上查询它们，下面这个是一种兼容方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getScrollOffsets(w) {
    w = w || window;
    if ( w.pageXOffset != null ) return { x: w.pageXOffset, y: pageYOffset };

    var d = w.document;
    if ( document.compatMode == &#39;CSS1Compat&#39; )
        return { x: d.documentElement.scrollLeft, y: d.documentElement.scrollTop };

    return { x: d.body.scrollLeft, y: d.body.scrollTop };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查询元素的尺寸&#34;&gt;查询元素的尺寸&lt;/h3&gt;

&lt;p&gt;判定一个元素的尺寸和位置最简单的方法是调用它的 getBoundingClientRect() 方法。该方法是在 IE 5 中引入的，而珔当前的所有浏览器都实现了（然而并非如此）。它不需要参数，返回一个有 left, right, top 和 bottom 属性的对象&lt;/p&gt;

&lt;h3 id=&#34;滚动&#34;&gt;滚动&lt;/h3&gt;

&lt;p&gt;window 对象的 scrollTop() 方法接受一个点的 X 和 Y 坐标，并作为滚动条的偏移量设置它们。也就是窗口滚动到指定的点出现在视口的左上角&lt;/p&gt;

&lt;h3 id=&#34;关于元素尺寸-位置和溢出更多的信息&#34;&gt;关于元素尺寸、位置和溢出更多的信息&lt;/h3&gt;

&lt;p&gt;getBoundingClientRect() 方法在所有当前的浏览器上都有定义，但如果需要支持老式浏览器就不行了。元素的尺寸比较简单：任何 HTML 元素的只读属性 offsetWidth 和 offsetHeight 以 CSS 像素返回它的屏幕尺寸。返回尺寸 &lt;strong&gt;包含&lt;/strong&gt; 元素的边框和内边距，除去了外边距&lt;/p&gt;

&lt;p&gt;所有 HTML 元素拥有 offsetLeft 和 offsetTop 属性来返回元素的 X 和 Y 坐标。对于很多元素，这些值是文档坐标，并直接指定元素的位置。&lt;strong&gt;但对于已定位的元素的后代元素和一些其他元素（如表格），这些属性返回的坐标是相对于祖先元素的而非文档。&lt;/strong&gt; offsetParent 属性指定这些属性所相对的父元素。如果 offsetParent 为 null，这些属性都是文档坐标，因此，一般来说用 offsetLeft 和 offsetTop 来计算元素 e 的位置需要一个循环：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getElementPosition(e) {
    var x = 0, y = 0;
    while (e != null) {
        x += e.offsetLeft;
        y += e.offsetTop;
        e = e.offsetParent;
    }
    return { x: x, y: y };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了这些名字以 offset 开头的属性外，所有的文档元素定义了其它的两组属性，基名称一组以 client 开头，另一组以 scroll 开头。即，每个 HTML 元素都有以下这些属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;offsetWidth         clientWidth          scrollWidth
offsetHeight        clientHeight         scrollHeight
offsetLeft          clientLeft           scrollLeft
offsetTop           clientTop            scrollTop
offsetParent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clientWidth 和 clientHeight 类似 offsetWidth 和 offsetHeight，不同的是它们 &lt;strong&gt;不包含边框大小&lt;/strong&gt;，只包含内容和它的内边距。同时，如果浏览器在内边距和边框之间添加了滚动条，clientWidth 和 clientHeight 在其返回值中也不包含滚动条。内联元素，clientWidth 和 clientHeight 总是返回 0&lt;/p&gt;

&lt;h2 id=&#34;html-表单&#34;&gt;HTML 表单&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;表 15-1 HTML 表单元素&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;HTML 元素&lt;/th&gt;
&lt;th&gt;类型属性&lt;/th&gt;
&lt;th&gt;事件处理程序&lt;/th&gt;
&lt;th&gt;描述和事件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;button&amp;rdquo;&amp;gt; or&lt;br&gt; &amp;lt;button type=&amp;ldquo;button&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“button”&lt;/td&gt;
&lt;td&gt;onclick&lt;/td&gt;
&lt;td&gt;按钮&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;checkbox&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“checkbox”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;复选按钮&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;file&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“file”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;文件域，value 属性只读&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;hidden&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“hidden”&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;数据由表单提交，但对用户不可见&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;option&amp;gt;&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;Select 对象的单个选项，事件对象 &lt;br&gt; 在 Select 对象上，而不是 option&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;password&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“password”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;密码输出框，输入的字符不可见&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;radio&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“radio”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;单选按钮&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;reset&amp;rdquo;&amp;gt; or&lt;br&gt; &amp;lt;button type=&amp;ldquo;reset&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“reset”&lt;/td&gt;
&lt;td&gt;onclick&lt;/td&gt;
&lt;td&gt;重置表单按钮&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;select&amp;gt;&lt;/td&gt;
&lt;td&gt;“select-one”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;单选下拉框&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;select multiple&amp;gt;&lt;/td&gt;
&lt;td&gt;“select-multiple”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;多选列表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;submit&amp;rdquo;&amp;gt; or&lt;br&gt; &amp;lt;button type=&amp;ldquo;submit&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“submit”&lt;/td&gt;
&lt;td&gt;onclick&lt;/td&gt;
&lt;td&gt;表单提交按钮&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;input type=&amp;ldquo;text&amp;rdquo;&amp;gt;&lt;/td&gt;
&lt;td&gt;“text”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;单行文本输出域；type 默认 text&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;textarea&amp;gt;&lt;/td&gt;
&lt;td&gt;“textarea”&lt;/td&gt;
&lt;td&gt;onchange&lt;/td&gt;
&lt;td&gt;多行文本输入域&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;选择框和选项元素&#34;&gt;选择框和选项元素&lt;/h3&gt;

&lt;p&gt;Select 元素表示用户可以做出选择的一组选项（用 Option 元素表示）。浏览器通常将其渲染为下拉菜单的形式，但当指定其 size 属性值大于 1 时，它将显示为列表中的选项（可能有滚动条）。Select 元素的 multiple 属性决定了 Select 是不是可以多选&lt;/p&gt;

&lt;p&gt;当用户选取或取消一个选项时， Select 元素触发 onchange 事件。针对「select-one」属性的 Select 元素，它的可读/写属性 selectedIndex 指定了哪个选项当前被选中。针对「select-multiple」元素，单个 selectedIndex 属性不足以表示被选中的一组选项。这种情况下需要遍历 options[] 数组的元素，检测每个 Option 对象的 selected 属性。注意 Option 并没有相关事件处理程序，一般只能给 Select 元素绑定事件&lt;/p&gt;

&lt;h2 id=&#34;其他文档特性&#34;&gt;其他文档特性&lt;/h2&gt;

&lt;h3 id=&#34;document-的属性&#34;&gt;Document 的属性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cookie&lt;/strong&gt; 允许 JavaScript 读、写 HTTP cookie 的属性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;domain&lt;/strong&gt; 允许当 Web 页面交互时，相同域名下互相信任的 Web 服务器之间协作放宽同源策略安全限制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lastModified&lt;/strong&gt; 包含文档修改时间的字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;location&lt;/strong&gt; 与 Window 对象的 location 属性引用同一个 Location 对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;referrer&lt;/strong&gt; 如果有，它表示浏览器来到当前页面的上一个页面。与 HTTP 的 Referer 头信息内容相同&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;title&lt;/strong&gt; 文档中 title 标签的内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;URL&lt;/strong&gt; 文档的 URL，只读字符串而不是 Location 对象。该属性值与 location.href 的 &lt;strong&gt;初始值&lt;/strong&gt;相同，不会发生变化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;document-write-方法&#34;&gt;document.write() 方法&lt;/h3&gt;

&lt;p&gt;document.write() 会将其字符串参数连接起来，然后将结果字符串插入到文档中调用它的脚本元素的位置。当脚本执行结束，浏览器解析生成输出并显示它。例如，下面代码把信息输出到一个静态的 HTML 文档中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
    document.write(&#39;Document title: &#39; + document.title);
    document.write(&#39;URL: &#39; + document.URL);
    document.write(&#39;Referred by: &#39; + document.referrer);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;只有在解析文档时才能使用 write() 方法输出 HTML 到当前文档中&lt;/strong&gt;。也就是说能够在 script 元素的顶层代码中调用 document.write()，就是因为这些脚本的执行是文档解析流程的一部分。如果将 docuemnt.write() 放在一个函数的定义中，而该函数的调用是从一个事件处理程序中发起的，产生的结果未必是你想要的——事实上，它会擦除当前文档和它包含的脚本。同理，在设置了 defer 或 async 属性的脚本中不要使用 document.write()&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 14 - Window 对象</title>
      <link>https://keelii.github.io/2016/07/26/javascript-definitive-guide-note-12/</link>
      <pubDate>Tue, 26 Jul 2016 11:35:42 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/07/26/javascript-definitive-guide-note-12/</guid>
      <description>&lt;p&gt;本章介绍 Window 对象的属性和方法&lt;/p&gt;

&lt;h2 id=&#34;计时器&#34;&gt;计时器&lt;/h2&gt;

&lt;p&gt;setTimeout() 和 setInterval() 可以用来注册指定时间之后调用的函数，不同的是 setInterval 会在指定毫秒数的间隔里重复调用。它们都返回一个值，这个值可以传递给 clearInterval/clearTimeout，用于取消后续函数的调用

由于历史原因（通常不建议这么做），setTimeout 和 setInterval 的第一个参数可以作为字符串传入。如果是字符串，当到达指定时间时相当于执行 eval 字符串内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 4 秒后显示 log
var t1 = setTimeout(function () {
    console.log(&#39;show after 4s&#39;);
}, 4000);

function fn() { console.log(&#39;show every 1s&#39;); }
setTimeout(&#39;fn()&#39;, 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;浏览器定位和导航&#34;&gt;浏览器定位和导航&lt;/h2&gt;

&lt;p&gt;Window 对象的 location 属性引用的是 Location 对象，它表示窗口中当前显示的文档 URL。并且定义了方法来使窗口载入新的文档&lt;/p&gt;

&lt;p&gt;Document 对象上的 location 属性也引用到 Location 对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.location = document.location
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Document 对象也有一个 URL 属性，是文档首次载入后保存的该文档的 URL 静态字符串。如果定位到文档中的片段标识符（如#table-of-content，其实就是锚点），Location 对象会做相应的更新，&lt;strong&gt;而 document.URL 属性不会&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;解析-url&#34;&gt;解析 URL&lt;/h2&gt;

&lt;p&gt;Location 对象的 href 属性是一个字符串，后者包含 URL 的完整文本。Location 对象的 toString() 方法返回 href 属性的值，因此会隐式调用 toString() 的情况下，可以使用 location 代替 location.href&lt;/p&gt;

&lt;p&gt;这个对象的其它属性——protocol, host, hostname, port, pathname 和 search 分别表示 URL 的各个部分。它们称为「URL 分解」属性，同时被 link 对象（通过 HTML 文档中的 a 和 area 元素创建）支持&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17127989/2285a748-533c-11e6-946d-a1d129e845c7.gif&#34; alt=&#34;url&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;载入新的文档&#34;&gt;载入新的文档&lt;/h3&gt;

&lt;p&gt;Location 对象的 assign() 方法可以使用窗口载入并显示你指定的 URL 中的文档。replace() 方法也类似，但它在 &lt;strong&gt;载入新文档之前会从浏览器历史中把当前文档删除&lt;/strong&gt;，assign 会产生一个新的历史记录，也就是说可以使用浏览器的返回按钮到上一页，replace 则不行&lt;/p&gt;

&lt;h2 id=&#34;浏览历史&#34;&gt;浏览历史&lt;/h2&gt;

&lt;p&gt;Window 对象的 history 属性用来把窗口的浏览历史用文档和文档状态列表的形式表示。history 对象的 length 属性表示浏览历史列表中的元素数量，但是脚本并不能访问已保存的 URL&lt;/p&gt;

&lt;p&gt;history 对象的 bace() 和 forward() 方法与浏览器的「后退」和「前端」按钮一样。go() 方法接收一个整数参数，可以在历史列表中向前（正数）或向后（负数）跳过任意多个页&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;history.go(-2);     // 后退两个历史记录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果窗口包含多个子窗口（比如 iframe 元素），子窗口的浏览历史也会被记录，这音中着在主窗口调用 history.back() 可能会使子窗口跳转而主窗口不变&lt;/p&gt;

&lt;h2 id=&#34;浏览器和屏幕信息&#34;&gt;浏览器和屏幕信息&lt;/h2&gt;

&lt;h3 id=&#34;navigator-对象&#34;&gt;navigator 对象&lt;/h3&gt;

&lt;p&gt;Window 对象的 navigator 属性引用的是包含浏览器厂商和版本信息的 navigator 对象。navigator 有四个属性用于提供关于运行中的浏览器版本信息，并且可以用来做浏览器嗅探&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;appName&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Web 浏览器的全称。在 IE 中，就是「Microsoft Internet Explorer」，在 Firefox 中就是「Netscape」&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;appVersion&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此属性通常以数字开始，并跟着包含浏览器厂商和版本信息的详细字符串。字符串前面的数字通常是 4.5 或 5.0，表示它是第 4 或 5 代兼容的浏览器&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;userAgent&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;浏览器在它的 USER-AGENT HTTP 头部中发送的字符串。这个属性通常包含 appVersion 中的所有信息，以及其它细节&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;platform&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在其上运行浏览器的操作系统字符串&lt;/p&gt;

&lt;h3 id=&#34;screen-对象&#34;&gt;screen 对象&lt;/h3&gt;

&lt;p&gt;screen 对象提供有关窗口显示的大小和可用的颜色数量信息，属性 width 和 height 指定的是以像素为单位的窗口大小。属性 avilWidth 和 avilHeight 指定的是实际可用的显示大小，它们排除了像浏览器任务栏这样的特性所占用的屏幕空间&lt;/p&gt;

&lt;h2 id=&#34;对话框&#34;&gt;对话框&lt;/h2&gt;

&lt;p&gt;Window 对象提供了 3 个方法来向用户显示简单的对话框。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;alert()&lt;/strong&gt; 向用户显示一条消息并等待用户关闭
&lt;strong&gt;confirm()&lt;/strong&gt; 也显示一条消息并要求用户单击「确定」或「取消」，并返回一个布尔值
&lt;strong&gt;prompt()&lt;/strong&gt; 也显示一条消息并等待用户输入字符串，并返回那个字符串&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;do {
    var name = prompt(&#39;What is your name?&#39;);
    var correct = confirm(&#39;You entered: &#39; + name + &#39;\n\
                            Click OK to processed or Cancel to re-enter&#39;)
} while(!correct)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三个方法都会产生阻塞，也就是说，在用户关掉它们所显示的对话框之前，它们不会返回，这就意味着在弹出一个对话框前，代码就会停止运行。如果当前正在载入文档，也会停止载入。直到用户用要求的输入进行响应为止&lt;/p&gt;

&lt;h2 id=&#34;错误处理&#34;&gt;错误处理&lt;/h2&gt;

&lt;p&gt;Window 对象的 onerror 属性是一个事件处理程序，当未捕获的异常传播到调用栈上的时候就会触发它，并把错误消息输出到浏览器的 JavaScript 控制台上，onerror 事件处理函数调用通过三个字符串参数，而不是事件对象。分别是&lt;code&gt;错误信息&lt;/code&gt;、&lt;code&gt;产生错误的页面地址&lt;/code&gt;、&lt;code&gt;错误源代码的行号&lt;/code&gt;，onerror 的返回值也很重要，如果 onerror 处理程序返回 false，表示它通知浏览器事件处理程序已经处理错误了，不需要其它操作。Firefox 则刚好相反&lt;/p&gt;

&lt;h2 id=&#34;作为-window-对象属性的文档元素&#34;&gt;作为 Window 对象属性的文档元素&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如果 HTML 文档中用 id 属性来为元素命名，并且如果 Window 对象没有此名字的属性（并且这个id是个合法的标识符），Window 对象会赋予一个属性，它的名字就是 id 属性的值&lt;/strong&gt;，而它的值指向表示文档元素的 HTMLElement 对象&lt;/p&gt;

&lt;p&gt;元素 ID 作为全局变量的隐式应用是 Web 浏览器进化过程中遗留的问题，主要是出于兼容性的考虑。&lt;strong&gt;但并不推荐使用这种做法&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;多窗口和窗体&#34;&gt;多窗口和窗体&lt;/h2&gt;

&lt;p&gt;Web 浏览器的窗口中每一个标签页都是独立的「浏览上下文」（browsing context），每一个上下文都有独立的 Window 对象，而且相互之间不干扰，也不知道其他标签页的存在&lt;/p&gt;

&lt;p&gt;但是窗口并不总是和其它窗口完全没关系，因为可以通过脚本打开新的窗口或标签页。如果这么做就可以通过脚本跨窗口进行操作（参照之前的 &lt;a href=&#34;https://keelii.github.io/2016/07/14/javascript-definitive-guide-note-11/#TOC-16&#34;&gt;同源策略&lt;/a&gt;）&lt;/p&gt;

&lt;h3 id=&#34;打开和关闭窗口&#34;&gt;打开和关闭窗口&lt;/h3&gt;

&lt;p&gt;使用 Window 对象的 open() 方法可以打开一个新的浏览器窗口&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;var windowObjectReference = window.open(url, name, [features]);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第一个参数 &lt;code&gt;url&lt;/code&gt; 是要在新窗口中显示文档的 URL，如果参数省略，默认会使用空页面的 URL about:blank&lt;/p&gt;

&lt;p&gt;第二个参数 &lt;code&gt;name&lt;/code&gt; 表示打开窗口的名字，如果指定的是一个已经存在的窗口名字（并且脚本允许跳转到那个窗口），会直接用已存在的窗口。否则，会打开新的窗口，并将这个指定的名字赋值给它。如果省略此参数，会使用指定的名字「_blank」打开一个新的未命名窗口&lt;/p&gt;

&lt;p&gt;第三个参数 &lt;code&gt;features&lt;/code&gt;（非标准）是一个以逗号分隔的列表，包含表示打开窗口的大小和各种属性&lt;/p&gt;

&lt;p&gt;open() 也可以有第四个参数，且只在第二个参数命名的是一个存在的窗口时才有用。它是一个布尔值，𡔬了由第一个参数指定的 URL 是应用替换掉窗口浏览器历史的当前条目（true），还是应该在窗口浏览历史中创建一个新的条目（false），后者是默认设置&lt;/p&gt;

&lt;p&gt;open() 的返回值是代表命名或新创建的窗口的 Window 对象。可以在自己的 JavaScript 代码中使用这个 windows 对象来引用新创建的窗口，就像用隐式的 Window 对象 window 来引用运行代码的窗口一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var w = window.open();
w.alert(&#39;About to visit http://jd.com&#39;);
w.location = &#39;http://jd.com&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由 window.open() 方法创建的窗口中，opener 属性引用的是打开它的脚本的 Window 对象，在其它窗口中，opener 为 null&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;w.opener !== null;      // =&amp;gt; true
w.open().opener === w   // =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;关闭窗口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;像 open() 方法一样，close() 用来关闭一个（脚本打开的）窗口，注意，&lt;strong&gt;大多数浏览器只允许自己关闭自己的 JavaScript 代码创建的窗口&lt;/strong&gt;，要关闭其它窗口，可以用一个对话框提示用户，要求他关闭窗口的请求进行确认。在表示窗体而不是顶级窗口或者标签页上的 Window 对象上执行 close() 方法不会有任何效果，它不能关闭一个窗体&lt;/p&gt;

&lt;p&gt;即使一个窗口关闭了，代表它的 Window 对象 &lt;strong&gt;仍然存在&lt;/strong&gt;。已关闭的窗口会有一个值为 true 的 closed 属性，它的 document 会是 null， 它的方法通常也不会再工作&lt;/p&gt;

&lt;h3 id=&#34;窗体之间的关系&#34;&gt;窗体之间的关系&lt;/h3&gt;

&lt;p&gt;任何窗口中的 JavaScript 代码都可以将自己的窗口引用为 window 或 self。窗体可以用 parent 属性引用包含它的窗口的 Window 对象。如果一个窗口是顶级窗口或标签，那么其 parent 属性引用的就是这个窗口本身：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;parent.history.back();
parent == self;            // 只有顶级窗口才会返回 true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个窗体包含在另一个窗体中，而后者又包含在顶级窗口中，那么该窗体就可以使用 parent.parent 来引用顶级窗口。top 属性是一个通用的快捷方式，无论一个窗体被嵌套几层，它的 top 属性引用的都是指向包含它的顶级窗口。如果一个 Window 对象代表的是一个顶级窗口，那么它的 top 属性就是窗口本身。对于那些顶级窗口的直接子窗体，top 属性就等价于 parent 属性&lt;/p&gt;

&lt;p&gt;parent 和 top 属性允许脚本引用它的窗体的祖先。有不止一种方法可以引用窗口的子孙窗体。窗口是通过 iframe 元素创建的，可以获取其他元素的方法来获取一个表示 iframe 的元素对象，iframe 元素有 contentWindow 属性，引用该窗体的 Window 对象。也可以反向操作，使用 Window 对象的 frameElement 属性来引用被包含的 iframe 元素，对于顶级窗口来说 Window 对象的 frameElement 属性为 null&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 假设页面有一个 id=&amp;quot;f1&amp;quot; 的 iframe 元素
var iframeElement = document.getElementById(&#39;f1&#39;);
var iframeWindowObject = iframeElement.contentWindow;
// 对于 iframe 来说永远是 true
iframeWindowObject.frameElement === iframeElement
// 对于顶级窗口来说 frameElement 永远是 null
window.frameElement === null;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个 window 上都会有一个 frames 属性，表示当前窗口里面引用的窗口。frames 是个类数组对象，并可以通过数字或者窗体名称（如 iframe name 属性）进行索引。注意 frames 元素引用的是窗口的 Window 对象，而不是 iframe 元素&lt;/p&gt;

&lt;h3 id=&#34;交互窗口中的-javascript&#34;&gt;交互窗口中的 JavaScript&lt;/h3&gt;

&lt;p&gt;每个窗口都是它自身的 JavaScript 执行上下文，以 window 做为全局对象&lt;/p&gt;

&lt;p&gt;设想一个 Web 页面里面有两个 iframe 元素，分别叫「A」和「B」，并假设这些窗体所包含的文档来自于相同的一个服务器，并且包含交互脚本。我们在窗体 A 里的脚本定义了一个变量 i：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个变量只是全局对象的一个属性，也是 Window 对象的一个属性。窗体 A 中的代码可以用标识符 i 来引用变量，或者用 Window 对象显示地引用这个变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;i           // =&amp;gt; 3
window.i    // =&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于窗体 B 中的脚本可以引用窗体 A 的 Window 对象，因此它也可以引用那个 Window 对象的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;parent.A.i = 4;             // 修改窗体 A 中的变量
parent.A.fun();             // 调用 A 窗体中的全局函数
var s = new parent.Set();   // 甚至可以构造父窗口中的对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和用户定义的类不同，内置类（比如 String, Date 和 RegExp）都会在所有的窗口中自动预定义。但是要注意，&lt;strong&gt;每个窗口都有构造函数的一个独立副本和构造函数对应的原型对象的一个独立副本&lt;/strong&gt;。例如，每个窗口都有自己的 String() 构造函数和 String.prototype 对象副本。因此，如果编写一个操作 JavaScript 字符串的新方法，并且通过把它赋值给当前窗口中的 String.prototype 对象而使它成为 String 类的一个方法，那么该窗口中的所有字符串就可以使用这个新方法。但是，&lt;strong&gt;别的窗口中定义的字符串不能使用这个新方法&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 13 - Web 浏览器中的 JavaScript</title>
      <link>https://keelii.github.io/2016/07/14/javascript-definitive-guide-note-11/</link>
      <pubDate>Thu, 14 Jul 2016 14:11:08 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/07/14/javascript-definitive-guide-note-11/</guid>
      <description>&lt;h2 id=&#34;客户端的-javascript&#34;&gt;客户端的 JavaScript&lt;/h2&gt;

&lt;p&gt;Window 对象是所有客户端 JavaScript 特性和 API 的主要接入点。它表示 Web 浏览器的一个窗口或者窗体，并且可以用标识符 window 来引用它。Window 对象定义了一些属性，比如:
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 页面跳转
window.location = &#39;http://www.oreilly.com/&#39;;
// 页面圣诞框
alert(&#39;Hello World&#39;)
setTimeout(function () { alert(&#39;Hello later World&#39;) }, 1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;window 对象也是全局对象。可以省略「window.」来调用上面的方法。这意味着 windows 对象牌作用域链的顶部，它的属性和方法实际上是全局变量和全局函数。window 对象有一个引用自己的属性，叫做 window。如果需要引用窗口对象本身可以用这个属性，但是如果只想要引用全局窗口对象的属性，通常并不需要用 window&lt;/p&gt;

&lt;p&gt;windows 对象还定义了很多其他重要的属性、方法和构造函数。其中最重要的一个属性是 document，它引用 Document 对象，后者表示显示在窗口中的文档。document 对象有一些重要方法，比如 getElementById() 获取一个 DOM 元素，它返回一个 Element 对象也有其他重要属性和方法，比如，给元素绑定点击事件 onclick&lt;/p&gt;

&lt;h2 id=&#34;在-html-里嵌入-javascript&#34;&gt;在 HTML 里嵌入 JavaScript&lt;/h2&gt;

&lt;p&gt;在 HTML 里嵌入 客户端 JavaScript 有 4 种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内联，放置在 &amp;lt;script&amp;gt; 和 &amp;lt;/script&amp;gt; 标签之间&lt;/li&gt;
&lt;li&gt;外链，放置在由 script 标签的 src 属性指定的外部文件中&lt;/li&gt;
&lt;li&gt;放置在 HTML 事件处理程序中，该事件处理程序由 onclick 或 on[eventType] 这样的 HTML 属性指定&lt;/li&gt;
&lt;li&gt;放在一个 URL 里，这个 URL 使用特殊的「javascript:」协议&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!--html 中的事件处理程序--&amp;gt;
&amp;lt;input type=&amp;quot;checkbox&amp;quot; onchange=&amp;quot;any_javascript_statement&amp;quot; /&amp;gt;
&amp;lt;!--url 中的javascript--&amp;gt;
&amp;lt;a href=&amp;quot;javascript: new Date().toLocaleTimeString();&amp;quot;&amp;gt;What time is it?&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用外链 src 文件方式有一些优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以把 JavaScript 代码从 HTML 文件中删除，这有助于保持内容和行为的分离，从而简化 HTML 文件&lt;/li&gt;
&lt;li&gt;如果多个 Web 页面共用相同的 JavaScript 代码，用 src 属性可以让你只管理一份代码，而不用在代码变更时每个页面都更新&lt;/li&gt;
&lt;li&gt;如果一个 JavaScript 文件由多个页面共享，就只需要下载一次，以后的页面只要引用过就可以使用缓存检索它&lt;/li&gt;
&lt;li&gt;src 属性值可以是任意的 URL，因此来自一个 Web 服务器的 JavaScript 程序或 Web 页面可以使用由 &lt;strong&gt;另外一个&lt;/strong&gt; Web 服务器输出的代码，很多广告依赖与些&lt;/li&gt;
&lt;li&gt;从其它网站载入脚本的能力，可以让我们更好地利用缓存，使用 CDN&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;脚本的类型&#34;&gt;脚本的类型&lt;/h3&gt;

&lt;p&gt;script 标签默认的类型「type」是「text/javascript」，如果要使用不标准的脚本语言，如 Microsoft 的 VBScript（只有 IE 支持），就必须用 type 属性指定脚本的 MIME 类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/vbscript&amp;quot;&amp;gt;
// 这里是 VBScript 代码
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外很多老的浏览器还支持 language 属性，作用和 type 一样，不过已经废弃了，不应该再使用了&lt;/p&gt;

&lt;p&gt;当 Web 浏览器遇到 &amp;lt;script&amp;gt; 元素，并且这个元素包含其值不之前能点浏览器识别的 type 属性时，它会解析这个元素但不会尝试显示或执行它的内容。这意味着可以使用 &amp;lt;script&amp;gt; 来嵌入任意的文件数据到文档里，比如 &lt;a href=&#34;http://handlebarsjs.com/&#34;&gt;handlebars&lt;/a&gt; 模板引擎，通常把模板放在自定义 type 的 script 标签中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script id=&amp;quot;entry-template&amp;quot; type=&amp;quot;text/x-handlebars-template&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;entry&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;{{title}}&amp;lt;/h1&amp;gt;
        &amp;lt;div class=&amp;quot;body&amp;quot;&amp;gt;
            {{body}}
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;同步-异步和延迟的脚本&#34;&gt;同步、异步和延迟的脚本&lt;/h3&gt;

&lt;p&gt;JavaScript 第一次添加到 Web 浏览器时，还没有 API 可以用来遍历和操作文档的结构和内容。当文档还在载入时，JavaScript 影响文档内容的唯一方法是使用 document.write() 方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h1&amp;gt;Table of Factorials&amp;lt;/h1&amp;gt;
&amp;lt;script&amp;gt;
function factorial(n) {
    if ( n &amp;lt;= 1 ) return n;
    else return n * factorial(n - 1);
}
document.write(&#39;&amp;lt;table&amp;gt;&#39;);
document.write(&#39;&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;n&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;n!&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&#39;);
for (var i = 1; i &amp;lt;= 10; i++) {
    document.write(&#39;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&#39;+ i +&#39;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&#39;+ factorial(i) +&#39;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&#39;)
}
document.write(&#39;&amp;lt;/table&amp;gt;&#39;);
document.write(&#39;Generated ad &#39; + new Date());
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当脚本把文本传递给 document.write() 时，这个文本被添加到文档输入流中，HTML 解析器会在当前位置创建一个文本节点，将文本插入这个文本节点后面。我们并不推荐使用 document.write()，但在某些场景下它有很重要的用途。当 HTML 解析器遇到 script 元素时，它默认 &lt;strong&gt;必须先执行脚本&lt;/strong&gt;，然后恢复文档的解析和渲染。这对于内联脚本没什么问题，但如果脚本源代码是一个由 src 属性指定的外部文件，这意味着脚本后面的文档部分在下载和执行脚本之间，都不会出现在浏览器中&lt;/p&gt;

&lt;p&gt;脚本的执行只在默认情况下是同步和阻塞的。script 标签可以有 defer 和 async 属性，这可以改变脚本的执行方式。HTML 5 说这些属性只在和 src 属性联合使用时才有效，但有些浏览器还支持延迟的内联脚本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;a.js&amp;quot; defer&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;b.js&amp;quot; async&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;defer 和 async 属性都在告诉浏览器链接进来的脚本不会使用 document.write()，也不会生成文档内容，因此不蜂鸣器可以在下载脚本时继续解析和渲染文档，defer 属性使得浏览器延迟脚本的执行，直到文档的载入和解析完成，并可以操作。async 属性使得浏览器可以尽快地挂靠脚本，而不用在下载脚本时阻塞文档解析。如果 script 标签同时有两个属性，同时支持两者的浏览器会 &lt;strong&gt;遵从 async 属性并忽略 defer 属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意，延迟的脚本会按它们在文档里的 &lt;strong&gt;出现顺序执行&lt;/strong&gt;。而异步脚本在它们载入后执行，这意味着它们可能会 &lt;strong&gt;无序执行&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;事件驱动的-javascript&#34;&gt;事件驱动的 JavaScript&lt;/h3&gt;

&lt;p&gt;上面的打印斐波那契数列程序在页面载入时开始挂靠，生成一些输出，这种程序今天已经不沉凶了。通常我们使用注册事件处理程序函数来写程序。之后在注册的事件发生时 &lt;strong&gt;异步&lt;/strong&gt; 调用这些函数。&lt;/p&gt;

&lt;p&gt;事件都有名字，比如 click, change, load, mouseover, keypress, readystatechange 等，如果想要程序响应一个事件，就需要注册一个事件处理函数&lt;/p&gt;

&lt;p&gt;事件处理程序的属性名字一般都以「on」开始，后面跟着事件的名字。大部分浏览器中的事件会把一个对象传递给事件处理程序作为参数，那个对象的属性提供了事件的详细信息。比如，传递给点击事件的对象，会有一个属性说明鼠标的哪个按钮被点击了。（在 IE 里，这些事件信息被存储在全局 event 对象里，而不是传给处理程序的函数）&lt;/p&gt;

&lt;p&gt;有些事件的目标是文档元素，它们会经常往上传递事件给文档树。这个过程叫做「&lt;strong&gt;冒泡&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;关于事件传播顺序可以参考 ppk 的 &lt;a href=&#34;http://www.quirksmode.org/js/events_order.html&#34;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;客户端-javascript-线程模型&#34;&gt;客户端 JavaScript 线程模型&lt;/h3&gt;

&lt;p&gt;JavaScript 语言核心并不包含任何线程机制，并且客户端 JavaScript 传统上也没有定义任何线程机制。HTML 5 定义了一种作为后台线程的「WebWorker」，但是客户端 JavaScript 还像严格的单线程一样工作。甚至当可能并发执行的时候，客户端 JavaScript 也不会知道是否真的的有并行逻辑执行&lt;/p&gt;

&lt;p&gt;单线程执行是𧫂让编程更加简单。编写代码时可以确保两个事件处理程序不会同一时刻运行，操作文档的内容时也不必操心会有其它线程试图同时修改应该没配，并且永远不需要在写 JavaScript 代码的时候操心锁、死锁和竟态条件（race condition）&lt;/p&gt;

&lt;p&gt;单线程执行意味着浏览器 &lt;strong&gt;必须在脚本和事件处理程序运行的时候停止响应用户输入&lt;/strong&gt;。这为 JavaScript 程序员带来了负担，它意味着 JavaScript 脚本和事件处理程序不能运行太长时间。如果一个脚本执行 &lt;strong&gt;计算密集&lt;/strong&gt; 的任务，它将会使文档载入带来延迟，用户无法在脚本执行完成前看到内容。浏览器可能变得无法响应甚至崩溃&lt;/p&gt;

&lt;h3 id=&#34;客户端-javascript-时间线&#34;&gt;客户端 JavaScript 时间线&lt;/h3&gt;

&lt;p&gt;JavaScript 程序执行的时间线&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Web 浏览器创建 Document 对象，并且开始解析 Web 页面，解析 HTML 元素和它们的文本内容后添加 Element 对象和 Text 节点到文档中。在这个阶段 document.readystate 属性的值是「loading」&lt;/li&gt;
&lt;li&gt;当 HTML 解析器遇到没有 async 和 defer 属性的 script 元素时，它把这些元素添加到文档中，然后执行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样脚本就可以用 document.write() 来把文本插入到输入流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为在它们执行时已经存在了。这样，同步脚本可以看到它自己的 script 元素和它们之前的文档内容&lt;/li&gt;
&lt;li&gt;当解析器遇到设置了 async 属性的 script 元素时，它开始下载脚本文本，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下载。异步脚本禁止使用 document.write() 方法。它们可以看到自己的 script 元素和它之前的所有文档元素，并且可能或干脆不可能访问其它的文档内容&lt;/li&gt;
&lt;li&gt;当文档完成解析，document.readyState 属性变成「interactive」&lt;/li&gt;
&lt;li&gt;所有有 defer 属性的脚本，会按它们在文档里出现的顺序执行。异步脚本可能也会在这个时间执行。延迟脚本能访问完整的文档树，禁止使用 document.write() 方法&lt;/li&gt;
&lt;li&gt;浏览器在 Document 对象上触发 DOMContentLoaded 事件。这标志着程序执行 &lt;strong&gt;从同步脚本执行阶段转换到了异步事件驱动阶段&lt;/strong&gt;。但要注意，这时可能还胡异步脚本没有执行完成&lt;/li&gt;
&lt;li&gt;这时，文档已经完全解析完成，但是浏览器可能还在等待其它内容载入，如图片。当所有这些内容完成时，并且所有异步脚本完成载入和执行，document.readyState 属性改变为「complete」，Web 浏览器触发 window 对象上的 load 事件&lt;/li&gt;
&lt;li&gt;从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是一条理想的时间线，但是所有浏览器都没支持它的全部细节，所有浏览器普遍都支持 load 事件，都会触发它，它是决定文档完全载入并可以操作最通用的技术，除了 IE 之外，document.readyState 属性已被大部分浏览器实现，但是属性的值在浏览器之间有细微的差别&lt;/p&gt;

&lt;h2 id=&#34;兼容性和互用性&#34;&gt;兼容性和互用性&lt;/h2&gt;

&lt;p&gt;客户端 JavaScript 兼容性和互用性的问题可以归纳为以下三类：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;演化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Web 平台一直在演变和发展当中。一个标准规范会倡导一个新的特性或 API。如果特性看起来有用，浏览器开发商实现它。如果足够多的开发商实现，开发者开始试用这个特性。有时新浏览器支持一些特性老的却不支持&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比如，IE 8 不支持 convas 元素，虽然其它浏览器已经实现了它。IE 也没有对 DOM Level 2 Event 规范实现，即使这个规范在十年前就是标准化了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;bug&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每个浏览器都有 bug，并且没有按照规范准确地实现所有客户端 JavaScript API。有时候编写能兼容各个浏览器的 JavaScript 程序是个很麻烦的工作，必须要研究各种浏览器的兼容性问题&lt;/p&gt;

&lt;h3 id=&#34;处理兼容性问题的类库&#34;&gt;处理兼容性问题的类库&lt;/h3&gt;

&lt;p&gt;比如有的浏览器客户端不支持 canvas 元素，可以使用开源的「explorer canvas」项目，引用 excanvas.js 即可模拟 canvas 元素的功能&lt;/p&gt;

&lt;h3 id=&#34;分级浏览器支持&#34;&gt;分级浏览器支持&lt;/h3&gt;

&lt;p&gt;分级浏览器支持（graded browser support）是由 Yahoo! 率先提出的一种测试技术。从某种维度对浏览器厂商/版本/操作系统进行分级。根据分级来确定哪些特性在哪些浏览器需要支持的程度&lt;/p&gt;

&lt;h3 id=&#34;功能测试&#34;&gt;功能测试&lt;/h3&gt;

&lt;p&gt;功能测试（capability testing）是解决不兼容性问题的一种技术。比如添加事件 API，在标准浏览器里面是 addEventListener 而低版浏览器里面是 attachEvent，我们就可以通过特性检测来给一个添加事件的公共方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
if (element.addEventListener) {
    element.addEventListener(&amp;quot;keydown&amp;quot;, handler, false);
} else if (element.attachEvent) {
    element.attachEvent(&amp;quot;keydown&amp;quot;, handler);
} else {
    element.onkeydown = handler
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;怪异模式和标准模式&#34;&gt;怪异模式和标准模式&lt;/h3&gt;

&lt;p&gt;doctype 可以触发浏览器的渲染模式，IE 浏览器有怪异模式，可以通过 document.compatMode 属性判断是否是标准模式。如果返回值为「CSS1Compat」则说明浏览器工作在标准模式；如果值是「BackCompat」或者 「undefined」则说明工作在怪异模式&lt;/p&gt;

&lt;h3 id=&#34;浏览器测试&#34;&gt;浏览器测试&lt;/h3&gt;

&lt;p&gt;通常我们用功能测试来处理兼容性问题，但有时候可能需要在某种浏览器中解决个别的 bug，同时又没有可用的特性 API，这里只能通过判断浏览器来做兼容性处理，通常可以使用浏览器 UA（user agent）来解析浏览器版本、类型等&lt;/p&gt;

&lt;h3 id=&#34;ie-里的条件注释&#34;&gt;IE 里的条件注释&lt;/h3&gt;

&lt;p&gt;IE 浏览器中可以通过在 HTML 中添加特殊的注释来告诉浏览器代码在哪个浏览器中作用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!--[if IE 6]&amp;gt;
这里面的内容只会显示在 IE 6 浏览器中
&amp;lt;![endif]--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IE 的 JavaScript 解释器也支持条件注释，以文本 &lt;code&gt;/*@cc_on&lt;/code&gt; 开头，以文本 &lt;code&gt;@*/&lt;/code&gt;结束。下面的条件注释包含了只在 IE 中执行的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;script&amp;gt;&amp;lt;!--忽略 script 标签系统解析有问题--&amp;gt;
/*@cc_on
 @if (@_jscript)
    alert(&amp;quot;in IE&amp;quot;)
 @end
 @*/
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安全性&#34;&gt;安全性&lt;/h2&gt;

&lt;h3 id=&#34;javascript-不能做什么&#34;&gt;JavaScript 不能做什么&lt;/h3&gt;

&lt;p&gt;Web 浏览器针对恶意代码的第一条防线就是它们不支持某些功能。例如，客户端的 JavaScript 没有权限来写入或删除计算机上的文件/目录，这意味着 JavaScript 不能删除数据或者植入病毒&lt;/p&gt;

&lt;p&gt;类似地，客户端 JavaScript 没有任何通用的网络能力。HTML 5 有一个附属标准叫 WebSockets 定义了一个类套接字的 API，用于和指定的服务器通信。但是这些 API 都不允许对于范围更广的网络进行直接访问&lt;/p&gt;

&lt;p&gt;浏览器针对恶意代码的第二条防线是在自己支持的某些功能上施加限制。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript 程序可以打开一个新的浏览器窗口，但是为了防止广告商滥用弹出窗口，很多浏览器限制了这一功能，使得只有为了响应鼠标单击这样的用户触发事件的时候，才能用它&lt;/li&gt;
&lt;li&gt;JavaScript 程序可以关闭 &lt;strong&gt;自己打开的&lt;/strong&gt; 浏览器窗口，但是不允许不经过用户确认就关闭其它窗口&lt;/li&gt;
&lt;li&gt;HTML FileUpload 元素的 value 属性是只读的。如果可以设置这个属性，脚本就能设置它为任意期望的文件名，从而导致表单上传指定的文件（比如密码文件）内容到服务器&lt;/li&gt;
&lt;li&gt;脚本不能读取从不同服务器载入的文档内容，除非这个就是包含该脚本的文档。类似地，一个脚本不能在来自不同服务器的文档上注册事件监听器。这就防止脚本窃取其他页面的用户输入&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;同源策略&#34;&gt;同源策略&lt;/h3&gt;

&lt;p&gt;同源策略是对 JavaScript 代码能够操作哪些 Web 内容的一条完整的安全限制。当 Web 页面使用多个 iframe 元素或者打开其它浏览器窗口的时候，这一策略通常就会发挥作用。在这情况下，同源策略负责管理窗口或窗体中的 JavaScript 代码以及和其它窗口或帧的交互&lt;/p&gt;

&lt;p&gt;文档的来源包含协议、主机、以及载入文档的 URL 商品。从不同 Web 服务器载入的文档具有不同的来源。通过同一主机不同商品载入的文档具有不同来源。使用 &lt;code&gt;http:&lt;/code&gt; 协议载入的文档和使用 &lt;code&gt;https:&lt;/code&gt; 协议载入的文档具有不同的来源，&lt;strong&gt;即使它们来自同一个服务器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;脚本本身的来源和同源策略并不相关&lt;/strong&gt;，相关的是脚本所嵌入文档的来源。例如，来自主机 A 的脚本被包含到宿主 B 的一个 Web 页面中。这个脚本的 &lt;strong&gt;来源（origin）&lt;/strong&gt; 是主机 B，并且可以完整地访问包含它的文档的内容。如果脚本打开一个新的窗口并载入来自主机 B 的另一个文档，脚本对这个文档的内容也具有完全的访问权限。但是如果脚本打开第三个窗口并载入一个来自主机 C 的文档（或者来自主机 A），同源策略就会发挥作用，阻止脚本访问这个文档&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A 页面包含一个 B 脚本，B 脚本对 A 页面有完全的访问权限，如果 B 脚本控制打开一个 A 服务器上另外一个页面 C，那么脚本也可以访问这个 C 页面，如果 B 脚本控制打开了一个 D 页面，这时就会触发同源策略，即 B 脚本不可以访问 D 页面，&lt;strong&gt;因为 A 和 C 同源，A 和 D 不同源&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;不严格的同源策略&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在某些情况下，同源策略就显得太过严格了，常常表现在多个子域名站点的场景中。比如：来自 A.yourdomain.com 的文档里脚本无法直接读取 B.yourdomain.com 页面的文档，不过可以通过设置 document.domain 为同一个主域来获取访问权限，即给两个域名下的页面都设置 &lt;code&gt;document.domain=&amp;quot;yourdomain.com&amp;quot;&lt;/code&gt;，这样以来两个文档就有了同源性可以相互访问&lt;/p&gt;

&lt;p&gt;还有一项已经标准化的技术：&lt;strong&gt;跨域资源共享&lt;/strong&gt;（Cross-Origin Resource Sharing）这个标准草案用新的「Origin:」请求头和新的 Access-Control-Allow-Origin 响应头来扩展 HTTP，它允许服务器用头信息显式地列出源，或使用能本符来匹配所有的源并允许由任何地址请求文件，这样就可以实现跨域的 HTTP 请求， XMLHttpRequest 也不会被同源策略所限制了&lt;/p&gt;

&lt;p&gt;还有一种新技术，叫做跨文档消息（cross-document messaging），允许来自一个文档的脚本可以传递文本消息到另一个文档的脚本，而不管脚本的来源是否不同。调用 window 对象上的 postMessage() 方法，可以异步传递消息事件&lt;/p&gt;

&lt;h3 id=&#34;跨站脚本&#34;&gt;跨站脚本&lt;/h3&gt;

&lt;p&gt;跨站脚本（Cross-site scripting），或者叫 XXS，这个术语表示一类安全问题。攻击者向目标 Web 站点注入 HTML 标签或者脚本&lt;/p&gt;

&lt;p&gt;如果 Web 页面动态地产生文档内容，并且这些文档内容是用户提交的，如果没有过滤用户提交内容的话，这个页面很容易遭到跨站脚本攻击，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
var name = decodeURIComponent(window.location.search.substring(1) || &amp;quot;&amp;quot;);
document.write(&amp;quot;hello &amp;quot; + name)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当页面的 url 被手动拼成恶意参数提交时就会产生 XXS 攻击，比如：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://example.com/greet.html?%3Cscript%3Ealert(%22XXS%20attack%22)%3C%2Fscript%3E&#34;&gt;http://example.com/greet.html?%3Cscript%3Ealert(%22XXS%20attack%22)%3C%2Fscript%3E&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;打开这个 url 就会弹出「XXS attack」，解决办法通过是对接收参数进行标签屏蔽&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
name = name.replace(/&amp;lt;/g, &amp;quot;&amp;amp;lt;&amp;quot;).replace(/&amp;gt;/g, &amp;quot;&amp;amp;gt;&amp;quot;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;客户端框架&#34;&gt;客户端框架&lt;/h2&gt;

&lt;p&gt;从某种意义上讲类库也是框架，它们对 Web 浏览器提供的标准和专用 API 进行封闭，向上提供更高级别的 API，用以更高效地进行客户端编程开发。一但使用就要用框架定义的 API 来写代码，后面有专门的章节讲 jQuery，除了这个常用的类库还有一些其它广泛使用的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://prototypejs.org/&#34;&gt;Prototype&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dojotoolkit.org/&#34;&gt;Dojo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yuilibrary.com/&#34;&gt;YUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/closure/&#34;&gt;Closure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.gwtproject.org/&#34;&gt;GWT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 11 - 服务器端的 JavaScript</title>
      <link>https://keelii.github.io/2016/07/10/javascript-definitive-guide-note-10/</link>
      <pubDate>Sun, 10 Jul 2016 19:47:18 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/07/10/javascript-definitive-guide-note-10/</guid>
      <description>&lt;h2 id=&#34;用-node-实现异步-i-o&#34;&gt;用 Node 实现异步 I/O&lt;/h2&gt;

&lt;p&gt;Node 是基于 C++ 的调整 JavaScript 解释器，绑定了用于进程、文件和网络套接字等底层 Unix API，还绑定了 HTTP 客户端和服务器 API。除了一些专门命名的同步方法外，Node 的绑定是异步的，且 Node 程序默认绝不阻塞，这意味着它们通过具备强大的可伸缩能力并能有效地处理高负荷。由于 API 是异步的，因此 Node 依赖事件处理程序，其通常使用嵌套函数和闭包来实现&lt;/p&gt;

&lt;p&gt;
Node 在其全局对象中实现了所有标准的 ECMAScript 5 构造函数、属性和函数。除此之外，它也支持客户端講器函数集 setTimeout(), setInterval()&lt;/p&gt;

&lt;p&gt;Node 在 process 名字空间中定义了其它重要的 &lt;strong&gt;全局&lt;/strong&gt; 属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;process.version         // Node 的版本字符串信息
process.argv            // &#39;node&#39; 命令行数组参数，argv[0] 是 &amp;quot;node&amp;quot;
process.pid             // 进程 id
process.getuid()        // 返回用户 id
process.cwd()           // 返回当前的工作目录
process.chdir()         // 改变当目录
process.exit()          // 退出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在有的情况下，可以使用 Node 的事件机制。Node 对象产生事件（称为事件触发器(event emitter)），定义 on() 方法来注册处理程序。当传入参数时，将事件类型（一个字符串）作为第一参数，处理程序函数作为第二参数。不同的事件类型传递给处理程序函数的参数不同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;emitter.on(name, f)
emitter.addListener(name, f)
emitter.once(name, f)
emitter.removeListener(name, f)
emitter.removeListeners(name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 process 全局对象也是一个事件触发器，它继承了 EventEmitter 类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;process.on(&#39;exit&#39;, function () { console.log(&#39;Goodbye&#39;); });
process.on(&#39;uncaughException&#39;, function (e) { console.log(Exception, e); });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node 的文件和文件系统 API 位于「fs」模块中，这个模块提供了大部分方法的「同步版本」。任何名字以「Sync」结尾的方法都是一个 &lt;strong&gt;阻塞方法&lt;/strong&gt;，它返回一个值或抛出一个异常，不以「Sync」结尾的文件系统方法都是非阻塞的，它们会把结果或者错误传给指定的回调函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 同步读取文件，指定编码获取文本而不是字节
var text = fs.readFileSync(&#39;config.json&#39;, &#39;utf8&#39;);
// 异步读取二进制文件，通过传递函数获得数据
fs.readFile(&#39;image.png&#39;, function (err, buffer) {
    if (err) throw err;
    process(buffer);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似地，存在用来写文件的 writeFile() 和 writeFileSync() 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fs.writeFile(&#39;config.json&#39;, JSON.stringify(json))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「net」模块是用于基于 TCP 网络的 API，下面是 Node 中一个非常简单的 TCP 服务器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var net = require(&#39;net&#39;);
var server = net.createServer();
server.listen(2000, function() { console.log(&#39;Listening on port 2000&#39;); });
server.on(&#39;connection&#39;, function (stream) {
    console.log(&#39;Accepting connection from&#39;, stream.remoteAddress);
    stream.on(&#39;data&#39;, function (data) {
        stream.write(data)
    });
    stream.on(&#39;end&#39;, function(data) {
        console.log(&#39;Connection closed&#39;);
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;node-示例-http-服务器&#34;&gt;Node 示例：HTTP 服务器&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var http = require(&#39;http&#39;);

var hostname = &#39;127.0.0.1&#39;;
var port = 3000;

var server = http.createServer(function(req, res) {
    res.statusCode = 200;
    res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);
    res.end(&#39;Hello World\n&#39;);
});

server.listen(port, hostname, function() {
    console.log(&#39;Server running at http://$s:%s/&#39;, hostname, port);
});
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 10 - 正则表达式的模式匹配</title>
      <link>https://keelii.github.io/2016/07/06/javascript-definitive-guide-note-9/</link>
      <pubDate>Wed, 06 Jul 2016 12:43:30 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/07/06/javascript-definitive-guide-note-9/</guid>
      <description>&lt;p&gt;正则表达式（regular expression）是一个描述字符模式的对象。在 JavaScript 中 String 和 RegExp 都定义了相关方法对文本进行模式匹配、检索和替换&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;正则表达式的定义&#34;&gt;正则表达式的定义&lt;/h2&gt;

&lt;p&gt;JavaScript 中的正则表达式用 RegExp 对象表示，可以使用 RegExp() 构造函数来创建 RegExp 对象，不过也可以通过两个双斜杠「/reg/」以正则直接量的形式创建&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var pattern = /s$/;             // 通过直接量创建
var pattern = new RegExp(&#39;s$&#39;); // 通过构造函数创建
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;直接量字符&#34;&gt;直接量字符&lt;/h3&gt;

&lt;p&gt;JavaScript 正则表达式语法也支持非字母的字符匹配，这些字符需要通过反斜线（\）作为前缀进行转义&lt;/p&gt;

&lt;p&gt;&lt;em&gt;表10-1&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;匹配&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;字母和数字&lt;/td&gt;
&lt;td&gt;自身&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\0&lt;/td&gt;
&lt;td&gt;NUL 字符（\u0000）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;制表符（\u0009）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;换行符（\u000A）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;垂直制表符（\u000B）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;换页符（\u000C）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;回车符（\u000D）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\xnn&lt;/td&gt;
&lt;td&gt;由十六进制数 nn 指定的拉丁字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\uxxxx&lt;/td&gt;
&lt;td&gt;由十六进制数 xxxx 指定的 unicode 字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\cX&lt;/td&gt;
&lt;td&gt;控制字符 ^x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;正则表达式中，许多标点符号也具有特殊含义，它们是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;^ $ . * + ? = ! : | \ / ( ) { }&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;字符类&#34;&gt;字符类&lt;/h3&gt;

&lt;p&gt;将直接量字符单独放进方括号内组成了字符类（charactor class）&lt;/p&gt;

&lt;p&gt;&lt;em&gt;表10-2&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;匹配&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;[&amp;hellip;]&lt;/td&gt;
&lt;td&gt;方括号内的任意字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[^&amp;hellip;]&lt;/td&gt;
&lt;td&gt;不在方括号内的任意字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;除换行符和其它 Unicode 行终止符之外的任意字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;任何 ASCII 字符组成的单词，等价于 [a-zA-Z0-9]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;任何不是 ASCII 字符组成的单词，等价于 [^a-zA-Z0-9]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;任何 Unicode 空白符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;任何非 Unicode 空白符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;任何 ASCII 数字，等价于 [0-9]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;任何非 ASCII 数字，等价于 [^0-9]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[\b]&lt;/td&gt;
&lt;td&gt;退格直接量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;重复&#34;&gt;重复&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;表10-3&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;{n, m}&lt;/td&gt;
&lt;td&gt;匹配前一项至少 n 次，但不能超过 m 次&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;{n,}&lt;/td&gt;
&lt;td&gt;匹配前一项 n 次或者更多次&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;{n}&lt;/td&gt;
&lt;td&gt;匹配前一项 n 次&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;匹配前一项 0 次或者 1 次，也就是说前一项是可选的，等价于 {0,1}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;匹配前一项 1 次或者多次，等价于 {1,}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;匹配前一项 0 次或者多次，等价于{0,}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;举例说明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/\d{2,4}/           // 匹配 2 ~ 4 个数字
/\w{3}\d?/          // 匹配三个单词和一个可选的数字
/\s+java\s+/        // 匹配前后带有一个或者多个空白字符串 &amp;quot;java&amp;quot;
/[^(]*/             // 匹配一个或多个非左括号字符
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;非贪婪的重复&#34;&gt;非贪婪的重复&lt;/h4&gt;

&lt;p&gt;表10-3 中列出一匹配重复字符是尽可能多地匹配，而且允许后续的正则表达式继续匹配。因此，我们称之为「&lt;strong&gt;贪婪的&lt;/strong&gt;」匹配。我们同样可以使用正则表达式进行非贪婪匹配。只需在特匹配的字符后跟随一个问题即可：「??」、「+?」、「*?」或「{1,5}?」&lt;/p&gt;

&lt;h3 id=&#34;选择-分级和引用&#34;&gt;选择、分级和引用&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;表10-4&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;选择，匹配的是该符号左边的子表达式或者右边的子表达式&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(&amp;hellip;)&lt;/td&gt;
&lt;td&gt;组合，将几个项组合为一个单元，这个单元可通过「*」、「+」、「?」和「|」等符号&lt;br&gt;加以修饰，而且可以记住和这个组合相匹配的字符串&lt;br&gt;以供此后的引用使用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(?:&amp;hellip;)&lt;/td&gt;
&lt;td&gt;只组合，把项组合到一个单元，但不记忆与该组想匹配的字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;和第 n 个分级第一次匹配的字符相匹配，组是圆括号中的子表达式&lt;br&gt;（也有可能是嵌套的），组索引是从左到右的左括号数，&lt;br&gt;「(?:」形式的分组不编码&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;指定匹配位置&#34;&gt;指定匹配位置&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;表10-5&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;匹配字符串的开头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;匹配字符串的结尾&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;匹配一个单词的边界&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\B&lt;/td&gt;
&lt;td&gt;匹配非单词边界的位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(?=p)&lt;/td&gt;
&lt;td&gt;零宽正向先行断言，要求接下来的字符都与 p 匹配，但不能包括匹配 p 的那些字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(?!p)&lt;/td&gt;
&lt;td&gt;零宽负向先行断言，要求接下来的字符都不与 p 匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;标识&#34;&gt;标识&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;/reg/flag&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;标识是放在斜扛右边的，通常有 i, g, m 三种&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;i 执行不区分大小写的匹配&lt;/li&gt;
&lt;li&gt;g 执行一个全局匹配，即 找到所有的匹配，而不是找到第一个就停止&lt;/li&gt;
&lt;li&gt;m 多行匹配模式&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;用于模式匹配的-string-方法&#34;&gt;用于模式匹配的 string 方法&lt;/h2&gt;

&lt;p&gt;String 支持 4 种使用正则表达式的方法&lt;/p&gt;

&lt;h3 id=&#34;string-prototype-search&#34;&gt;String.prototype.search()&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search&#34;&gt;search()&lt;/a&gt; 方法返回第一个与之匹配的子串起始位置，如果找不到匹配的子串，它将返回 -1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;quot;JavaScript&amp;quot;.search(/script/i);         // =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 search() 参数不是正则表达式，则首先会 &lt;strong&gt;通过 RegExp 构造函数将它转换成正则表达式&lt;/strong&gt;，search() 方法不支持全局检索，因为它 &lt;strong&gt;忽略&lt;/strong&gt; 正则表达式参数中的标识 g&lt;/p&gt;

&lt;h3 id=&#34;string-prototype-replace&#34;&gt;String.prototype.replace()&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;str.replace(regexp|substr, newSubStr|function)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace&#34;&gt;replace()&lt;/a&gt; 方法用以执行检索与替换操作，正则表达式如果带标识 g，则会替换所有匹配子串&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 将所有不区分大小写的 javascript 都替换成 JavaScript
text.replace(/javascript/gi);

// 用中文引号替换英文应该引号，同时要保持引号之间的内容（存储在 $1 中）没有被修改
var quote = /&amp;quot;([^&amp;quot;]*)&amp;quot;/g;
text.replace(quote, &#39;“$1”&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;string-prototype-match&#34;&gt;String.prototype.match()&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match&#34;&gt;match()&lt;/a&gt; 方法返回一个由匹配结果组成的数组，如果没有标识全局搜索，match() 只检索第一个匹配&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;quot;1 plus 2 equals 3&amp;quot;.match(/\d+/g);  // =&amp;gt; [&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;regexp-对象&#34;&gt;RegExp 对象&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;RegExp(pattern [, flags])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RegExp 构造函数一般用在动态创建正则表达式的时候，这种情况往往没办法通过写死在代码中的正则直接量来实现，比如检索字符串是用户输出的&lt;/p&gt;

&lt;h3 id=&#34;regexp-的属性&#34;&gt;RegExp 的属性&lt;/h3&gt;

&lt;p&gt;每个 RegExp 对象都包含 5 个属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;source 只读字符串，包含正则表达式的文本&lt;/li&gt;
&lt;li&gt;global 只读布尔值，说明正则表达式是否带全局标识 g&lt;/li&gt;
&lt;li&gt;ignoreCase 也是一个只读布尔值，说明正则表达式是否带标识 i&lt;/li&gt;
&lt;li&gt;multiline 也是一个只读布尔值，说明正则表达式是否带标识 m&lt;/li&gt;
&lt;li&gt;lastIndex 它是一个可读/写的整数。如果匹配模式带有 g 标识，这个属性存储在整个字符串中下一次检索的开始位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;regexp-的方法&#34;&gt;RegExp 的方法&lt;/h3&gt;

&lt;h4 id=&#34;exec&#34;&gt;exec()&lt;/h4&gt;

&lt;p&gt;exec() 对一个指定的字符串执行一个正则表达式，如果没有找到任何匹配，它就返回 null，但如果它找到一个匹配，将返回一个数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var pattern = /Java/g;
var text = &amp;quot;JavaScript is more fun than Java!&amp;quot;;
var result;
while((result = pattern.exec(text)) != null) {
    console.log(&amp;quot;Matched &#39;%s&#39; at position &#39;%s&#39;; next search begins at %s&amp;quot;,
        result[0],
        result.index,
        pattern.lastIndex);
}
// Matched &#39;Java&#39; at position &#39;0&#39;; next search begins at 4
// Matched &#39;Java&#39; at position &#39;28&#39;; next search begins at 32
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;test&#34;&gt;test()&lt;/h4&gt;

&lt;p&gt;test() 对方法转入字符串进行检测，匹配到结果返回 true，否则返回 false&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var pattern = /java/i;
pattern.test(&#39;JavaScript&#39;);     // =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 9 - 类和模块</title>
      <link>https://keelii.github.io/2016/07/02/javascript-definitive-guide-note-8/</link>
      <pubDate>Sat, 02 Jul 2016 13:58:30 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/07/02/javascript-definitive-guide-note-8/</guid>
      <description>&lt;p&gt;每个 JavaScript 对象都是一个属性集合，相互之间没有任何联系。在 JavaScript 中也可以定义对象的类，让每个对象都共享某些属性，这种「共享」的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或者定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。这些行为通常是由类定义的，而且为所有实例所共享。例如，假设有一个 Complex 的类用来表示复数， 同时还定义了一些复数运算，一个 Complex 实例应当包含实数的实部和虚部（状态），同样 Complex 类还会定义复数的加法和乘法操作（行为）&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;JavaScript 中类的一个重要特性是「&lt;strong&gt;动态可继承&lt;/strong&gt;」（dynamically extendable），我们可以将类看做是类型，本章会介绍一种编程哲学 —— 「&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B&#34;&gt;&lt;strong&gt;鸭子类型&lt;/strong&gt;&lt;/a&gt;」（duck-typing），它弱化了对象的类型，强化了对象的功能&lt;/p&gt;

&lt;h2 id=&#34;类和原型&#34;&gt;类和原型&lt;/h2&gt;

&lt;p&gt;在 JavaScript 中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。在之前的 &lt;a href=&#34;https://keelii.github.io/2016/06/23/javascript-definitive-guide-note-5/#TOC-4&#34;&gt;章节&lt;/a&gt; 里定义了 inherit() 函数，这个函数返回一个新创建的对象，后者继承自某个原型对象。如果定义一个原型对象，然后通过 inherit() 函数创建一个继承自它的对象，这样就定义了一个 JavaScript 类。通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 一个简单的实现表示值的范围的类
function range(from, to) {
    var r = inherit(range.methods);

    r.from = from;
    r.to = to;
    return r;
}
range.methods = {
    includes: function(x) {
        return this.from &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt;= this.to;
    },
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &amp;lt;= this.to; x++) f(x);
    }
    toString: function() {
        return &amp;quot;(&amp;quot; + this.from + &amp;quot;...&amp;quot; + this.to + &amp;quot;)&amp;quot;;
    }
}
var r = range(1, 3);
r.includes(2)           // =&amp;gt; true
r.foreach(console.log)
// =&amp;gt; 1
// =&amp;gt; 2
// =&amp;gt; 3
console.log(r);         // =&amp;gt; (1...3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码定义了一个工厂方法 range()，用来创建新的范围对象。range.methods 属性用来快捷地存放定义类的原型对象。range() 函数给每个范围对象都定义了 from 和 to 属性，用以定义范围的起始和结束位置，这两个属性是 &lt;strong&gt;非共享&lt;/strong&gt; 的，当然也是不可继承的。&lt;/p&gt;

&lt;h2 id=&#34;类和构造函数&#34;&gt;类和构造函数&lt;/h2&gt;

&lt;p&gt;上节中展示了定义类的一种方法，但是这种方法并不常用，它没定义构造函数。构造函数是用来初始化新创建的对象的。调用构造函数的一个重要特征是，构造函数的 prototype 属性被用做新对象的原型。这意味着 &lt;strong&gt;通过同一个构造函数创建的所有对象都继承自一个相同的对象&lt;/strong&gt;，因此它们都是同一个类的成员&lt;/p&gt;

&lt;p&gt;&lt;em&gt;例9-2&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Range(from, to) {
    this.from = from;
    this.to = to;
}
Range.prototype = {
    includes: function(x) {
        return this.from &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt;= this.to;
    },
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &amp;lt;= this.to; x++) f(x);
    }
    toString: function() {
        return &amp;quot;(&amp;quot; + this.from + &amp;quot;...&amp;quot; + this.to + &amp;quot;)&amp;quot;;
    }
};
var r = new Range(1, 3)
r.includes(2)       // =&amp;gt; true
r.foreach(console.log)
// =&amp;gt; 1
// =&amp;gt; 2
// =&amp;gt; 3
console.log(r);    // =&amp;gt; &amp;quot;(1...3)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从某种意义上讲，定义构造函数既是定义类，并且 &lt;strong&gt;类名首字母要大写&lt;/strong&gt;，而普通普通的函数和方法都是首字母小写，Range() 构造函数是通过 new 关键字调用的，而在上一节的工厂函数则不必使用 new。通过 new 调用不必再用  inherit 来创建对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个对象&lt;/p&gt;

&lt;h3 id=&#34;构造函数的类的标识&#34;&gt;构造函数的类的标识&lt;/h3&gt;

&lt;p&gt;上文提到，原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。而初始化对象的状态的构造函数则不能作为类的标识，两个构造函数的 prototype 属性可能指责同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的&lt;/p&gt;

&lt;p&gt;构造函数的名字通常用做类名，比如我们说 Range() 构造函数创建 Range 对象。然而，更根本地讲，当使用 instancdof 运算符来检测对象是否属于某个类时会用到构造函数。假设有一个对象 r，我们想知道它是否是 Range 对象，可以这样判断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;r instanceof Range  // 如果 r 继承自 Range.prototype，则返回 true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上 instanceof 运算符并不会检查 r 是否是由 Range() 构造函数初始化而来，而是 &lt;strong&gt;检查 r 是否继承自 Range.prototype&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;constructor-属性&#34;&gt;constructor 属性&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;每个 JavaScript 函数（bind除外）都自动拥有一个 prototype 属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性 constructor。constructor 属性的值是一个函数对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var F = function() {};
var p = F.prototype;
var c = p.constructor;
c === F                 // =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图 9-1 展示了构造函数和原型对象之间的关系，包括原型到构造函数的反向引用以及构造函数创建的实例&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图9-1&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;   构 造 函 数                      原 型                        实 例
+------------------+       +------------------+          +---------------+
|                  |       |                  | inherits |               |
|  Range()         &amp;lt;---------- contructor     &amp;lt;----------+ new Range(2)  |
|                  |       |                  |          |               |
|                  |       |                  |          +---------------+
|                  |       |   includes       |
|   prototype  ------------&amp;gt;                  |
|                  |       |   foreach        |          +---------------+
|                  |       |                  | inherits |               |
|                  |       |   toString       &amp;lt;----------+ new Range(3,4)|
|                  |       |                  |          |               |
|                  |       |                  |          +---------------+
+------------------+       +------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例9-2中定义的 Range 类使用它自身的一个新对象重写预定义的 Range.prototype 对象。这个新定义的原型对象不含有 constructor 属性。因此 Range 类的实例也不含有 constructor 属性。我匀可以通过补救措施来修正这个问题，显式给原型添加一个构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Range.prototype = {
    constructor: Range,
    incluces: function() {/*code*/}
};
// 当然也可以使用给 prototype 指定方法赋值的方式，避免重写整个 prototype
Range.prototype.includes = function() {/*code*/}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;javascript-中-java-式的类继承&#34;&gt;JavaScript 中 Java 式的类继承&lt;/h2&gt;

&lt;p&gt;在 Java 或者其它类似强类型面向对象语言中，类成员可能是这样的：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例字段&lt;/strong&gt; 它们是基于实例的属性或变量，用以保存独立对象的状态&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例方法&lt;/strong&gt; 它们是类的所有实例共享方法，由每个独立的实例调用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类字段&lt;/strong&gt; 这些属性或变量是属于类的，而不属于类的某个实例&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类方法&lt;/strong&gt; 这些方法是属于类的，而不属于类的某个实例&lt;/p&gt;

&lt;p&gt;JavaScript 和 Java 的一个不同之处在于，JavaScript 中的函数都是以值的形式出现的，方法和字段之间并没有太大的区别。如果属性是函数，那么这个属性就定义一个方法，否则，它只是一个普通的属性或「字段」&lt;/p&gt;

&lt;h2 id=&#34;类和类型&#34;&gt;类和类型&lt;/h2&gt;

&lt;h3 id=&#34;instanceof-运算符&#34;&gt;instanceof 运算符&lt;/h3&gt;

&lt;p&gt;之前我们已经了解过 instanceof 运算符。左操作数是待检测其类的对象，右操作数是定义类的构造函数。如果 o 继承自 c.prototype，则表达式 o instanceof c 值返回 true。这里的继承可以不是直接继承，如果 o 所继承的对象继承自另一个对象，后一个对象继承自 c.prototype，这个表达式的运算结果也是 true&lt;/p&gt;

&lt;p&gt;构造函数是类的公共标识，但原型是唯一的标识。尽管 instanceof 运算符的右操作数是构造函数，但计算过程实际上是检测了对象的继承关系，而不是检测创建对象的构造函数&lt;/p&gt;

&lt;h3 id=&#34;constructor-属性-1&#34;&gt;constructor 属性&lt;/h3&gt;

&lt;p&gt;另一种识别对象是否属于某个类的方法是使用 constructor 属性，因为构造函数是类的公共标识，所以最直接的方法就是使用 constructor 属性，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function typeAndValue(x) {
    if (x == null) return &amp;quot;&amp;quot;;
    switch(x.constructor) {
        case: Number:
            return &amp;quot;Number: &amp;quot; + x;
        case: String:
            return &amp;quot;String: &amp;quot; + x;
        case: Date:
            return &amp;quot;Date: &amp;quot; + x;
        case: RegExp:
            return &amp;quot;RegExp: &amp;quot; + x;
        case: Complex:
            return &amp;quot;Complex: &amp;quot; + x;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 constructor 属性检测对象属于某个类的技术不足之处和 instanceof 一样。在 &lt;strong&gt;多个执行上下文&lt;/strong&gt; 场景中它是无法正常工作的（比如在浏览器窗口的多个框架子页面中）。在这种情况下每个框架页面各自拥有独立的构造函数集合。比如一个框架页面中的 Array 构造函数和另一个构架页面的 Array 构造函数不是同一个&lt;/p&gt;

&lt;h3 id=&#34;鸭子类型&#34;&gt;鸭子类型&lt;/h3&gt;

&lt;p&gt;上面描述的检测对象的类的各种技术多少都会有些问题，至少在客户端 JavaScript 中是如此。解决办法就是规避掉这些问题：&lt;strong&gt;不要关注「对象是什么」，而是关注「对象能做什么」&lt;/strong&gt;。这种思考问题的方式在 Python 和 Ruby 中右学普遍，称为「鸭子类型」&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;像鸭子一样走路、游泳并且嘎嘎叫的鸟就是鸭子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这又让我想起了《蝙蝠侠》里面的那句话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It’s not who you are underneath, it’s what you do that defines you&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;javascript-中的面向对象技术&#34;&gt;JavaScript 中的面向对象技术&lt;/h2&gt;

&lt;h3 id=&#34;一个例子-集合类&#34;&gt;一个例子：集合类&lt;/h3&gt;

&lt;p&gt;集合（set）是一种数据结构，用来表示非重复值的无序集合。集合有添加值、检测值是否存在等方法，下面的例子实现了一个更加通用的 Set 类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Set() {
    this.values = {};
    this.n = 0;
    this.add.apply(this, arguments)
}
Set.prototype.add = function () {
    for (var i = 0; i &amp;lt; arguments.length; i++) {
        var val = arguments[i];
        var str = Set._v2s(val);
        if (!this.values.hasOwnProperty(str)) {
            this.values[str] = val;
            this.n++;
        }
    }

    return this;
}
Set.prototype.remove = function () {
    for (var i = 0; i &amp;lt; arguments.length; i++) {
        var str = Set._v2s(arguments[i]);
        if (this.values.hasOwnProperty(str)) {
            delete this.values[str];
            this.n--;
        }
    }
}
Set.prototype.contains = function (value) {
    return this.values.hasOwnProperty(Set._v2s(value))
}
Set.prototype.size = function () {
    return this.n;
}
Set.prototype.foreach = function(f, context) {
    for (var s in this.values) {
        if (this.values.hasOwnProperty(s)) {
            f.call(context, this.values[s]);
        }
    }
}
Set._v2s = function (val) {
    switch (val) {
        case undefined:     return &#39;u&#39;;
        case null:          return &#39;n&#39;;
        case true:          return &#39;t&#39;;
        case false:         return &#39;f&#39;;
        default:
            switch (typeof val) {
                case &#39;number&#39;: return &#39;#&#39; + val;
                case &#39;string&#39;: return &#39;&amp;quot;&#39; + val;
                default: return &#39;@&#39; + objectId(val)
            }
    }
    function objectId(o) {
        var prop = &amp;quot;|**objectid**|&amp;quot;;
        if (!o.hasOwnProperty(prop)) {
            o[prop] = Set._v2s.nex++;
        }
        return o[prop];
    }
}
Set._v2s.next = 100;

var s = new Set(1,2,3);
s.values;       // =&amp;gt; Object {#1: 1, #2: 2, #3: 3}
var s1 = new Set(1,2,3,3,2,1, null, undefined)
s1.values;      // =&amp;gt; Object {#1: 1, #2: 2, #3: 3, n: null, u: undefined}
s1.remove(null, undefined);
s1.values;      // =&amp;gt; Object {#1: 1, #2: 2, #3: 3}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;构造函数的重载和工厂方法&#34;&gt;构造函数的重载和工厂方法&lt;/h3&gt;

&lt;p&gt;有时候，我们希望对象的初始化有多种方式，比如 Set 对象，我们想专入一个数组或者类数组，而不是多个参数来初始化它，我们可以加一些判断来实现重载（overload）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 重载
function Set() {
    this.values = {};
    this.n = 0;

    if (arguments.length == 1 &amp;amp;&amp;amp; isArrayLike(arguments[0])) {
        this.add.apply(this, arguments[0])
    } else {
        this.add.apply(this, arguments)
    }
}

// 工厂方法: 可以从数组创建一个集合对象
Set.fromArray = function(a) {
    var s = new Set();
    s.add.apply(s, a)
    return s;
}
// Set 类的一个辅助构造函数
function SetFromArray(a) {
    Set.apply(this, a);
}
SetFromArray.prototype = Set.prototype;
var s = new SetFromArray([1,2,3]);
s instanceof Set        // =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;子类&#34;&gt;子类&lt;/h2&gt;

&lt;p&gt;在面向对象编程中，类 B 可以继承自另外一个类 A。我们将 A 称为父类（superclass），将 B 称为子类（subclass）。B 的实例从 A继承了所有的实例方法。类 B 可以定义自己的实例类方法，有些方法可以重载类 A 中的同名方法，如果 B 的方法重载了 A 中的方法，B 中的重载方法可能会调用 A 中的重载类 A 方法，这种做法称为「方法链」（method chaining）。同样子类的构造函数 B() 有时需要调用父类的构造函数 A()，这种做法称为「构造函数链」（constructor chaining）。子类还可以有子类，当涉及类的层次结构时，往往需要定义抽象类（abstract class）。抽象类中定义的方法没有实现。抽象类中的抽象方法是在抽象类的具体子类中实现的&lt;/p&gt;

&lt;h3 id=&#34;定义子类&#34;&gt;定义子类&lt;/h3&gt;

&lt;p&gt;JavaScript 的对象可以从类的原型对象中继承属性。如果 O 是类 B 的实例，B 是 A 的子类，那么 O 也一定从 A 中继承了属性。为此，首先要确保 B 的原型对象继承自 A 的原型对象，通过 inherit() 函数可以实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;B.prototype = inherit(A.prototype);
B.prototype.constructor = B;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;构造函数和方法链&#34;&gt;构造函数和方法链&lt;/h3&gt;

&lt;p&gt;我们定义一个 Set 的子类 NonNullSet，它不允许 null 和 undefined 作为集合成员，这就需要在子类的 add() 方法中对 null 和 undefined 值做检测。它需要完全重新实现一个 add() 方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function NonNullSet() {
    Set.apply(this, arguments);
}
NonNullSet.prototype = inherit(Set.prototype);
NonNullSet.prototype.constructor = NonNullSet;
NonNullSet.prototype.add = function() {
    for (var i = 0; i &amp;lt; arguments.length; i++) {
        if (arguments[i] == null) {
            throw new Error(&amp;quot;Cant&#39;t add null or undefined to a NonNullSet&amp;quot;);
        }
    }
    return Set.prototype.add.apply(this, arguments);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;组合-vs-子类&#34;&gt;组合 vs 子类&lt;/h3&gt;

&lt;p&gt;上节中定义的集合可以根据特定的标准对集合成员做限制，而且使用了子类的技术来实现这种功能&lt;/p&gt;

&lt;p&gt;然后还有一种更好的方法来完成这种需求，既面向对象编程中一条广为人知的设计原则：「组合优于继承」。这样，可以利用组合的原理定义一个新的集合实现，它「包装」了另外一个集合对象，在将受限制的成员过滤掉之后会用到这个集合对象&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 8 - 函数</title>
      <link>https://keelii.github.io/2016/06/29/javascript-definitive-guide-note-7/</link>
      <pubDate>Wed, 29 Jun 2016 20:22:22 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/06/29/javascript-definitive-guide-note-7/</guid>
      <description>&lt;p&gt;函数是一段 JavaScript 代码，定义一次，可以被执行多次。JavaScript 函数是参数化的：函数定义会包括一个形参（parameter）的标识符列表，这些参数在函数体中像 &lt;strong&gt;局部变量&lt;/strong&gt; 一样工作，函数被调用的时候会为形参提供实参（argument）的值。使用实参的值计算返回值，成为该函数的 &lt;strong&gt;&lt;a href=&#34;https://keelii.github.io/2016/06/20/javascript-definitive-guide-note-3/#TOC-4&#34;&gt;调用表达式&lt;/a&gt;&lt;/strong&gt;值，调用上下文（invocation context）可以用 this 引用，嵌套函数可以构成闭包（closure）&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;函数定义&#34;&gt;函数定义&lt;/h2&gt;

&lt;p&gt;使用 function 关键字来定义一个函数，可以用在函数定义表达式或者函数声明语句里&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 打印对象名称和值
function printprops(o) {
    for(var p in o)
        console.log(p + &amp;quot;: &amp;quot; + o[p] + &amp;quot;\n&amp;quot;);
}
// 递归调用计算阶乘
function factorial(x) {
    if (x &amp;lt;= 1) return 1;
    return x * factorial(x - 1);
}
// 函数定义表大式，函数名称可以省略
var square = function(x) { return x * x; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return 语句导致函数停止执行，并返回它的表达式给调用都。如果 return 语句没有一个与之相关的表达式，则它返回 undefined 值，没有 return 语句也会默认返回 undefined 值给调用者&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;嵌套函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function hypotenuse(a, b) {
    function square(x) { return x*x; }
    return Math.sqrt(square(a) + square(b));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嵌套函数的作用域规则：它们可以访问嵌套它们的函数的参数和变量。上面的代码里，内部函数 square() 可以读写外部函数 hypotenuse() 定义的参数 a 和 b&lt;/p&gt;

&lt;h2 id=&#34;函数调用&#34;&gt;函数调用&lt;/h2&gt;

&lt;p&gt;有 4 种方式来调用 JavaScript 函数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;作为函数&lt;/li&gt;
&lt;li&gt;作为（对象）方法&lt;/li&gt;
&lt;li&gt;作为构造函数&lt;/li&gt;
&lt;li&gt;通过它们的 call() 和 apply() 方法间接调用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;函数调用-1&#34;&gt;函数调用&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;function_name(param1, param2);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;方法调用&#34;&gt;方法调用&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;object.method(param1, param2);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 对象直接量
var calculator = {
    operand1: 1,
    operand2: 1,
    add: function() {
        this.result = this.operand1 + this.operand2;
    },
    add1: function(a) {
        this.operand1 + a;
        return this;
    },
    add2: function(b) {
        this.operand2 + a;
        return this;
    }
};
calculator.add();
calculator.result       // =&amp;gt; 2
// 使用对象属性访问表达式调用方法
calculator[&#39;result&#39;]    // =&amp;gt; 2
// 链式调用
calculator.add1(1).add2(2)
calculator.operand1         // =&amp;gt; 2
calculator.operand2         // =&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;构造函数调用&#34;&gt;构造函数调用&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;new Object(param1, param2);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果没有参数可以省略括号 &lt;code&gt;new Object&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;间接调用&#34;&gt;间接调用&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;function_name.call()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JavaScript 中的 &lt;strong&gt;函数也是对象&lt;/strong&gt;，和其它 JavaScript 对象没什么区别，函数对象也可以包含方法。其中两个 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call&#34;&gt;call()&lt;/a&gt; 和 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&#34;&gt;apply()&lt;/a&gt; 可以用来间接地调用函数。两个方法都允许显式地指定调用所需的 this 值&lt;/p&gt;

&lt;h2 id=&#34;函数的实参和形参&#34;&gt;函数的实参和形参&lt;/h2&gt;

&lt;p&gt;JavaScript 的函数定义不用指定形参的类型，调用传入的实参也可以是任意类型，JavaScript &lt;strong&gt;甚至&lt;/strong&gt; 不检查传入实参的个数&lt;/p&gt;

&lt;h3 id=&#34;可选形参&#34;&gt;可选形参&lt;/h3&gt;

&lt;p&gt;如果调用函数的时候传入的实参比指定的形参少，剩下的形参都将设置为 undefined 值，通常使用逻辑与运算符给形参指定默认值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getName(name) {
    // 如果 name 传入值则使用传入值，否则使用默认值 &amp;quot;no name&amp;quot;
    // 通常建议可选参数放在参数列表最后
    name = name || &amp;quot;no name&amp;quot;;

    // code

    return name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;可变长的实参列表-实参对象&#34;&gt;可变长的实参列表：实参对象&lt;/h3&gt;

&lt;p&gt;当调用函数的时候传入实参人个数超过形参个数时（和上面相反），没有办法直接获得未命名值的引用。参数对象解决了这个问题，在函数体内，标识符 arguments 是指向实参对象的引用，参数对象是一个 &lt;a href=&#34;https://keelii.github.io/2016/06/23/javascript-definitive-guide-note-6/#TOC-23&#34;&gt;类数组对象&lt;/a&gt;，这样可以通过索引来访问实参了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function fn(x, y, z) {
    console.log(arguments);
}
fn(1,2,3)           // =&amp;gt; [1,2,3]
fn(1,2,3,4,5)       // =&amp;gt; [1,2,3,4,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实参对象的重要用处就是让函数可以操作任意数量的实参，比如我们自己实现一个数组的 push 方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function push(arr /* optional items [, item ... [, item]] */) {
    var items = Array.prototype.slice.call(arguments, 1)
    for (var i = 0; i &amp;lt; items.length; i++) {
        arr[arr.length] = items[i];
    }
}
var arr1 = [1,2,3];
push(arr1, 4,5,6);
arr1                // =&amp;gt; [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在非严格模式下，修改 arguments 元素的值，实参的值也会变。不过在 ECMAScript 5 中这个特性被移除了。在非严格模式中，函数里的 arguments 仅仅是个标识符。在严格模式中，它变成了一个保留字，严格模式中函数无法使用 arguments 作为 &lt;strong&gt;形参名&lt;/strong&gt; 或者 &lt;strong&gt;局部变量名&lt;/strong&gt;，也不能给它（arguments）赋值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function f(x) {
    console.log(x);         // =&amp;gt; 实参的初始值
    arguments[0] = null;
    console.log(x);         // =&amp;gt; 非严格返回 null， 非严格返回 1
}
f(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;callee-和-caller-属性&#34;&gt;callee 和 caller 属性&lt;/h4&gt;

&lt;p&gt;除了数组元素，实参对象还定义了 callee 和 caller 属性。严格模式中对这两个属性读写操作会产生一个类型错误，非严格模式下，ECMAScript 标准规范规定 callee 属性指代当前正在执行的函数。caller 是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数。通过 caller 属性可以访问调用栈，callee 属性在某些时候非常有用，比如在匿名函数中通过 callee 来递归调用自身&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var factorial = function(x) {
    if (x &amp;lt;= 1) return 1;
    return x * arguments.callee(x-1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;将对象属性用做实参&#34;&gt;将对象属性用做实参&lt;/h3&gt;

&lt;p&gt;当一个函数包含超过三个形参时，很难记住参数顺序。这时我们可以用名/值对的形式来传入参数，这样参数的顺序就无关紧要了（然后名/值对里面的键名还是得记住）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function arraycopy(from, from_start, to, to_start, length) {
}
function easycopycopy(args) {
    arraycopy(args.from,
              args.from_start || 0,
              args.to,
              args.to_start || 0,
              args.length);
}
var a = [1,2,3,4], b = [];
easycopy({ from: a, to: b, length:4 })
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;实参类型&#34;&gt;实参类型&lt;/h3&gt;

&lt;p&gt;JavaScript 函数中形参并未声明类型，在形参数传入之前也未做任何类型检查，JavaScript 会在必要的时候进行类型转换，因此如果函数期望接收一个出神入化串实参，而调用函数时传入其它类型的值，所传入的值会在函数体内将其转换为字符串&lt;/p&gt;

&lt;h2 id=&#34;作为值的函数&#34;&gt;作为值的函数&lt;/h2&gt;

&lt;p&gt;函数的定义和调用是 JavaScript 的词法特性，其它语言也一样。然而在 JavaScript 中，函数不仅仅是一种语法，也可以是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组元素中，作为参数传入另外一个函数等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function square(x) { return x*x; }
var s = square;
square(4) == s(4)       // =&amp;gt; true

var a = [ function square(x) { return x*x; }, 20 ];
a[0](a[1]);             // =&amp;gt; 400

// 将函数用做值
function add(x, y) { return x + y; }
function subtract(x, y) { return x - y; }
function multiply(x, y) { return x * y; }
function divide(x, y) { return x / y; }

function operate(operator, operand1, operand2) {
    return operator(operand1, operand2)
}
// =&amp;gt; 25 (2 + 3) + (4 * 5)
var i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;自定义函数属性&#34;&gt;自定义函数属性&lt;/h4&gt;

&lt;p&gt;JavaScript 中函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有 &lt;strong&gt;属性&lt;/strong&gt;。当函数需要一个 &lt;strong&gt;静态变量&lt;/strong&gt; 来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 注意静态变量不必在函数后面声明
uniqueInteger.counter = 0;

function uniqueInteger() {
    // 注意 ++counter 和 count++ 不一样
    return ++uniqueInteger.counter;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面这个函数 factirial() 使用了自身的属性（将自身当做数组来对待）来缓存上一次的计算结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 计算阶乘
function factorial(n) {
    if (isFinite(n) &amp;amp;&amp;amp; n &amp;gt; 0 &amp;amp;&amp;amp; n == Math.round(n)) {
        if (!(n in factorial)) {
            factorial[n] = n * factorial(n-1)
        }
        return factorial[n]
    } else {
        return NaN;
    }
}
// 初始化缓存以保存这种基本情况
factorial[1] = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;作为命名空间的函数&#34;&gt;作为命名空间的函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(/*paramater*/) {
    // 模块代码
    // 这个模块使用的所有变量（通过 var 声明）都是局部变量
    // 不会污染全局命名空间
})(/*arguments*/);

(function(win, doc) {
    var obj = {
        privateMethod: function() {},
        publicMethod: function() {}
    };

    win.yourPublicAPIMethodName = obj.publicMethod
})(window, document);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&#34;&gt;立即执行函数表达式（IIFE）&lt;/a&gt;&lt;/strong&gt; 可以隔离代码块的命名空间，在匿名函数中声明的变量只在内部有效，不会对全局产生影响，同时可以有选择地向全局输出变量用来给外部代码访问&lt;/p&gt;

&lt;h2 id=&#34;闭包&#34;&gt;闭包&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;词法作用域（lexical scoping）的执行依赖于变量作用域，这个作用域是在函数 &lt;strong&gt;定义时&lt;/strong&gt; 决定的，而不是函数调用时，为了实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为「闭包」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从技术角度讲，所有的 JavaScript 函数都是闭包：它们都是对象，它们都关联到作用域链。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事情就变得非常我刚好和。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象 &lt;strong&gt;作为返回值返回&lt;/strong&gt; 的时候，这种事情就发生了&lt;/p&gt;

&lt;p&gt;先看一下嵌套函数的词法作用域规则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 例 1
var scope = &amp;quot;global scope&amp;quot;;
function checkscope() {
    var scope = &amp;quot;local scope&amp;quot;;
    function f() { return scope;}
    return f();
}
checkscope();       // =&amp;gt; &amp;quot;local scope&amp;quot;
// 例 2
var scope = &amp;quot;global scope&amp;quot;;
function checkscope() {
    var scope = &amp;quot;local scope&amp;quot;;
    function f() { return scope;}
    return f;
}
checkscope()()      // =&amp;gt; &amp;quot;local scope&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在例 2 中我们将 checkscope 返回值 f 调用的括号移动到了 checkscope 调用后面。复习一下作用域的基本规则：JavaScript 函数的执行用到了作用域链，这个作用域链是函数 &lt;strong&gt;定义的时候&lt;/strong&gt; 创建的，嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管在何时执行函数当 f()，这种绑定在执行 f() 时依然有效。因此最后一行代码返回「local scope」而不是「global scope」。简而言之，闭包的这个特性强大到让人吃惊：它们可以捕捉到局部变量（和参数），&lt;strong&gt;并一直保存下来&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多程序员觉得闭包非常难理解，他们觉得在外部函数中定义的局部变量在函数返回后就不存在了，那么嵌套的函数如何能调用不存在的作用域链呢？如果你想搞清楚这个问题，还得更深入地了解类似 C 语言这种更底层的编程语言，并了解基于栈的 CPU 架构 &lt;strong&gt;如果一个函数的尾部变量定义在 CPU 的栈中，那么当函数返回时它们的确就不存在了&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#TOC-13&#34;&gt;上节&lt;/a&gt;中的 uniqueInteger() 函数，这个函数有一个问题，函数本身是全局可访问的，这个 counter 很可能被外部修改。如果使用闭包就没有这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var uniqueInteger = (function() {
    var counter = 0;
    return function() {
        return ++counter;
    }
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将匿名立即执行函数赋值给 uniqueInteger 变量，所以函数的返回值赋值给变量 uniqueInteger，内部变量 counter 只在函数体内部可以访问，外部无法操作&lt;/p&gt;

&lt;p&gt;私有变量也可以被多个闭包访问到，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function counter() {
    var n = 0;
    return {
        count: function() { return n++ },
        reset: function() { n = 0 }
    }
}
// 创建两个计数器
var c = counter(), d = counter();
c.count()       // =&amp;gt; 0 互
c.count()       // =&amp;gt; 1 不
d.count()       // =&amp;gt; 0 干
d.count()       // =&amp;gt; 1 扰
c.reset()       // =&amp;gt; 0 重置 c
d.count()       // =&amp;gt; 2 不影响 d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在同一个作用域链中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是一种非常重要的技术，但是要特别小心那些不希望共享的变量往往不经意间共享给了其它的闭包，了解这一点也很重要&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function constfunc(v) { return function() { return v; } }

var funcs = [];
for(var i = 0; i &amp;lt; 10; i++) {
    funcs[i] = constfunc(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果这样写就完全不一样了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function constfuncs() {
    var funcs = [];
    for (var i = 0; i &amp;lt; 10; i++) {
        funcs[i] = function() {
            return i;
        };
    }
    return funcs;
}
var funcs = constfuncs();
funcs[5]()                  // =&amp;gt; 10 !!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这段代码循环创建了 10 个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量 i。当 constfuncs() 返回时，变量的 i 值是 10，所有的闭包都共享这一个值，因此，数组中的函数的返回值是同一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域链都是「活动的（live）」，记住这一点非常重要。嵌套的当函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照（static snapshot）&lt;/p&gt;

&lt;p&gt;书写闭包的时候还需注意一件事情，this 是 JavaScript 的关键字，不是变量。正如之前讨论的，每个函数调用都包含一个 this 值，如果闭包在外部函数里是无法访问 this 的，除非外部函数将 this 默契为一个变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function outerFn() {
    var self = this;

    function innerFn() {
        // self.xxxx
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数属性-方法和构造函数&#34;&gt;函数属性、方法和构造函数&lt;/h2&gt;

&lt;p&gt;在 JavaScript 中，函数是值，对函数执行 typeof 运算会返回字符串 &amp;ldquo;function&amp;rdquo;，但是函数是 JavaScript 中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，像普通对象一样。甚至可以用 Function() 构造函数来创建新的函数对象&lt;/p&gt;

&lt;h3 id=&#34;prototype-属性&#34;&gt;prototype 属性&lt;/h3&gt;

&lt;p&gt;每一个当函数都包含一个 prototype 属性，这个属性是指向一个对象的引用，这个对象称做「原型对象」（prototype object）。每一个函数都包含不同的原型对象。当将函数胜仗构造函数的时候，新创建的对象会从原型对象上继承属性&lt;/p&gt;

&lt;h3 id=&#34;call-和-apply-方法&#34;&gt;call() 和 apply() 方法&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;fun.call(thisArg[, arg1[, arg2[, &amp;hellip;]]])&lt;/p&gt;

&lt;p&gt;fun.apply(thisArg[, argsArray])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以将 call 和 apply 看做是某个对象的方法，通过调用方法的形式来间接调用函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 将对象 o 中名为 m 的方法替换为另外一个方法
function trace(o, m) {
    var original = o[m];
    o[m] = function() {
        console.log(new Date, &amp;quot;Entering: &amp;quot;, m);
        var result = original.apply(this, arguments)
        console.log(new Date, &amp;quot;Exiting: &amp;quot;, m);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;trace() 函数接收两个参数，一个对象和一个方法名，它将指定的方法替换为一个新方法，这个新方法就是「包裹」原始方法的另一个泛函数。这种动态修改已有方法的做法有时称做「猴子补丁 monkey-patching」&lt;/p&gt;

&lt;h3 id=&#34;bind-方法&#34;&gt;bind() 方法&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;fun.bind(thisArg[, arg1[, arg2[, &amp;hellip;]]])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;bind 方法是 ECMAScript 5 中新增的方法，但在 ECMAScript 3 中可以模拟出来。主要用于将函数绑定到某个对象。当在函数 f 上调用 bind 方法并传入一个对象 o 做参数，这个方法将返回一个新的函数。调用新的函数将会把原始的函数 f &lt;strong&gt;当做 o 的方法来调用&lt;/strong&gt;。传入新函数的任何实参都将传入原始函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function f(y) { return this.x + y; }
var o = { x: 1};
var g = f.bind(o);
g(2)                // =&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过下面代码实现 bind 方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function bind(f, o) {
    if (f.bind) {
        return f.bind(o);
    } else {
        return f.apply(ok arguments)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bind 方法还有一些其他应用：除了第一个实参之外，传入 bind 的实参也会绑定至 this，这个附带的应用是一种常见的函数式编程技术，有时也被称为「&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96&#34;&gt;柯里化&lt;/a&gt;」（currying）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var sum = function(x, y) { return x + y }

var succ = sum.bind(null, 1)
succ(2)     // =&amp;gt; 3

function f(y, z) { return this.x + y + z }
var g = f.bind({x:1}, 2)
g(3)        // =&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 bind 方法有些特性是模拟不出来的&lt;/p&gt;

&lt;h3 id=&#34;tostring-方法&#34;&gt;toString() 方法&lt;/h3&gt;

&lt;p&gt;和所有的 JavaScript 对象一样，函数也有 toString 方法，ECMAScript 规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数的 toString 方法的实现都返回函数的完成源码。内置函数往往返回一个类似 &amp;ldquo;[native code]&amp;rdquo; 的字符串作为函数体&lt;/p&gt;

&lt;h3 id=&#34;function-构造函数&#34;&gt;Function() 构造函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;new Function ([arg1[, arg2[, &amp;hellip;argN]],] functionBody)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;关于 Function() 构造函数有几点需要特别注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Function() 构造函数允许 JavaScript 在运行时动态地创建并编译函数&lt;/li&gt;
&lt;li&gt;每次调用 Function() 构造函数都会解析函数体，执行效率会受影响。&lt;/li&gt;
&lt;li&gt;Function() 构造函数创建的函数 &lt;strong&gt;并不是使用词法作用域&lt;/strong&gt;，相反，函数体代码的编译总是会在顶层函数执行，效果类似在全局作用域中执行 eval()&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var scope = &amp;quot;global&amp;quot;;
function constructFunction() {
    var scope = &amp;quot;local&amp;quot;;
    return new Function(&amp;quot;return scope&amp;quot;);
}
constructFunction()();  // =&amp;gt; &amp;quot;global&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;可调用的对象&#34;&gt;可调用的对象&lt;/h3&gt;

&lt;p&gt;「类数组对象」类似数组但并不是真正的数组，「可调用对象（callable object）」类似于函数但并不是真正的函数。可调用对象在两个 JavaScript 实现中不能算作函数。首先，IE Web 浏览器（IE 6 及之前的版本）实现了客户端方法（如 Window.alert() 和 Document.getElementById()），使用了可调用的宿主对象，而不是内置函数对象，IE 中的这些方法在其它浏览器中都存在，但它们本质上不是 Function 对象。IE 9 将它们实现为真正的函数，因此这类可调用的对象将越来越罕见&lt;/p&gt;

&lt;p&gt;另外一个常见的可调用对象是 RegExp 对象，对 RegExp 执行 typeof 运算的结果并不统一，有些返回 &amp;ldquo;function&amp;rdquo; 有些返回 &amp;ldquo;object&amp;rdquo;。可以使用下面的方法判断是不是真正的函数对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function isFunction(o) {
    return Object.prototype.toString.call(x) === &amp;quot;[object Function]&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数式编程&#34;&gt;函数式编程&lt;/h2&gt;

&lt;p&gt;JavaScript 并不是一种像 List 或 Haskell 的函数式编程语言，但在 JavaScript 中可以像操控对象一样操控函数，也就是说可以在 JavaScript 中应用函数式编程技术&lt;/p&gt;

&lt;h3 id=&#34;使用函数处理数组&#34;&gt;使用函数处理数组&lt;/h3&gt;

&lt;p&gt;假设有一个数组，元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话代码一般会是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var data = [1,1,3,5,5]
var total = 0;
for (var i = 0; i &amp;lt; data.length; i++) {
    total += data[i];
}
var mean = total / data.length;                 // =&amp;gt; 3

total = 0;
for (var i = 0; i &amp;lt; data.length; i++) {
    var deviation = data[i] - mean;
    total += deviation * deviation;
}
var stddev = Math.sqrt(total/(data.length-1))   // =&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用数组方法 map() 和 reduce() 来实现同样的计算，这种实现极其乘法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var sum = function(x, y) { return x + y; }
var square = function(x) { return x*x; }

var data = [1,1,3,5,5]
var mean = data.reduce(sum)/data.length;
var deviations = data.map(function(x) { return x-mean; })
var stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length-1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然 ECMAScript 3 并没有 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map&#34;&gt;map&lt;/a&gt;， &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&#34;&gt;reduce&lt;/a&gt; 这两个方法，不过我们也可以自己实现一个 Polyfill，可以参考链接里面的内容&lt;/p&gt;

&lt;h3 id=&#34;高阶函数&#34;&gt;高阶函数&lt;/h3&gt;

&lt;p&gt;所谓高阶函数（higher-order function）就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function not(f) {
    return function() {
        var result = f.apply(this, arguments);
        return !result;
    }
}
var even = function(x) {
    return x % 2 == 0;
}
var odd = not(even);
[1,1,3,5,5].every(odd)          // =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mapper() 函数也是一个高阶函数，它接收一个函数作为参数，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上，这个函数使用了之前定义的 map() 函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function mapper(f) {
    return function(a) { return map(a, f); }
}
var increment = function(x) { return x + 1; }
var incrementer = mapper(increment);
incrementer([1,2,3])  // =&amp;gt; [2,3,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个更常见的例子，它接收两个函数 f() 和 g()，并返回一个新的函数用以计算 f(g())&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function compose(f, g) {
    return function() {
        return f.call(this, g.apply(this, arguments))
    }
}
var square = function(x) { return x * x; }
var sum = function(x, y) { return x + y; }
var squareofsum = compose(square, sum)
squareofsum(2, 3)           // =&amp;gt; 25
/* - 伪代码执行过程大致如下 -
    arguments: 2, 3
    return square.call(this, sum.apply(this, arguments))
    return square.call(this, sum(2, 3))
    return square.call(this, 5)
    arguments: 5
    return square(5)
    return 25
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;不完全函数&#34;&gt;不完全函数&lt;/h3&gt;

&lt;p&gt;函数 &lt;a href=&#34;https://keelii.github.io/2016/06/29/javascript-definitive-guide-note-7/#TOC-19&#34;&gt;f()&lt;/a&gt; 的 bind() 方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用函数 f()。我们说它把函数「绑定至」对象并传入一部分参数。bind() 方法只是将实参放在左侧，也就是说传入 bind() 的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入 bind() 的实参放在右侧&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 将类数组对象转换为真正的数组
function array(arr, n) { return Array.prototype.slice.call(arr, n || 0); }

// 这个函数的实参传递到左侧
function partialLeft(f) {
    var args = arguments;

    return function() {
        var a = array(args, 1);
        a = a.concat(array(arguments))
        return f.apply(this, a)
    }
}
function partialRight(f) {
    var args = arguments;

    return function() {
        var a = array(arguments)
        a = a.concat(array(args, 1))
        return f.apply(this, a)
    }
}

function partial(f) {
    var args = arguments;

    return function() {
        var a = array(args, 1)
        var i = 0, j = 0;
        for (; i &amp;lt; a.length; i++) {
            if ( a[i] === undefined ) a[i] = arguments[j++];
        }
        a = a.concat(array(arguments, j))
        return f.apply(this, a);
    }
}

var f = function(x, y, z) { return x * (y - z) }
partialLeft(f, 2)(3, 4)             // =&amp;gt; -2 2 * (3-4)
partialRight(f, 2)(3, 4)            // =&amp;gt; 6 3 * (4-2)
partial(f, undefined, 2)(3, 4)      // =&amp;gt; -6 3 * (2-4)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;记忆&#34;&gt;记忆&lt;/h3&gt;

&lt;p&gt;上面的 &lt;a href=&#34;https://keelii.github.io/2016/06/29/javascript-definitive-guide-note-7/#TOC-13&#34;&gt;章节&lt;/a&gt; 中定义了一个阶乘函数，它可以将上次的计算结果缓存起来。在函数式程序当中，这种缓存技巧叫做「记忆」（memorization）。下面的代码展示了一个高阶函数，memorize() 接收一个函数作为实参，并返回带有记忆能力的函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function memorize(f) {
    var cache = {};

    return function() {
        // 将实参转换为字符串形式，并胜仗缓存的键名
        var key = arguments.length + Array.prototype.join.call(arguments, &amp;quot;,&amp;quot;)
        if ( key in cache ) {
            return cache[key];
        } else {
            return cache[key] = f.apply(this, arguments)
        }
    }
}
function factorial (num) {
    console.log(&#39;Actually invoked.&#39;);
    if (num &amp;lt; 0) {
        return -1;
    } else if (num === 0 || num === 1) {
        return 1;
    } else {
        return (num * factorial(num - 1));
    }
}

var cached_factorial = memorize(factorial);

cached_factorial(3)
// =&amp;gt; &#39;Actually invoked.&#39;
// =&amp;gt; &#39;Actually invoked.&#39;
// =&amp;gt; &#39;Actually invoked.&#39;
// =&amp;gt; 6
cached_factorial(3)
// =&amp;gt; 6

/**
 * 注意下面的调用方式将不会缓存
 * 因为新建了多个闭包，闭包在每
 * 调用一次 memorize 就返回一
 * 份新的 cache 变量
 */
memorize(factorial)(3)
// =&amp;gt; &#39;Actually invoked.&#39;
// =&amp;gt; &#39;Actually invoked.&#39;
// =&amp;gt; &#39;Actually invoked.&#39;
// =&amp;gt; 6
memorize(factorial)(3)
// =&amp;gt; &#39;Actually invoked.&#39;
// =&amp;gt; &#39;Actually invoked.&#39;
// =&amp;gt; &#39;Actually invoked.&#39;
// =&amp;gt; 6

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 5 - 语句</title>
      <link>https://keelii.github.io/2016/06/23/javascript-definitive-guide-note-4/</link>
      <pubDate>Thu, 23 Jun 2016 19:10:28 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/06/23/javascript-definitive-guide-note-4/</guid>
      <description>&lt;p&gt;表达式在 JavaScript 中是短语（phrases），那么语句（statements）就是 JavaScript 整句或命令，语句以分号结束。表达式计算出一个值，语句用来执行以使某件事情发生&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;表达式语句&#34;&gt;表达式语句&lt;/h2&gt;

&lt;p&gt;赋值语句、递增/减运算、delete 运算符删除对象属性、函数调用都是表达式语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;gretting = &amp;quot;Hello &amp;quot; + name;
i *= 3;
count++;
delete o.x;
alert(greeting)
window.close();
Math.cos(x)
cs = Math.cos(x);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复合语句和空语句&#34;&gt;复合语句和空语句&lt;/h2&gt;

&lt;p&gt;逗号运算符将几个表达式连接在一起形成一个表达式，同样，JavaScript 中还可以将多条语句联合在一起，形成一条复合语句（compound statement）。只须用花括号括起来即可，下面几行代码就可以当成一条单独语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
    x = Math.PI;
    cx = Math.cos(x);
    console.log(&amp;quot;cos(x) = &amp;quot; cx);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的两点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;语句块的结尾不需要分号。块中的原始语句 &lt;strong&gt;必须&lt;/strong&gt; 以分号结束&lt;/li&gt;
&lt;li&gt;语句块中的行缩进不是必须的，但是合理的缩进更容易理解&lt;/li&gt;
&lt;li&gt;语句块并没有块级作用域名，语句块中声明的变量不是语句块私有的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;空语句（empty statement）允许包含 0 条语句，空语句在初化一个数组时偶尔会用到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = Array(50);
a                                           // =&amp;gt; [undefined,,,,undefined]
for (i = 0; i &amp;lt; a.length; a[i++] = 0) ;     // 初始化一个数组，注意末尾的分号不能少
a                                           // =&amp;gt; [0,,,0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个循环中，所有操作都在表达式 a[i++]=0 中完成，这里并不需要任何循环体。然而 JavaScript 需要循环体中 &lt;strong&gt;至少包含一条语句&lt;/strong&gt;，因此，这里只使用了一个单独的分号来表示一条空语句&lt;/p&gt;

&lt;h2 id=&#34;声明语句&#34;&gt;声明语句&lt;/h2&gt;

&lt;p&gt;var 和 function 都是声明语句，声明语句本身什么也不做，只用来更好地组织代码的语义&lt;/p&gt;

&lt;h3 id=&#34;var&#34;&gt;var&lt;/h3&gt;

&lt;p&gt;var 语句用来声明一个或者多个变量，用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var name_1 [= value_1] [,..., name_n [= value_n]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 var 语句出现在函数体内，那么它定义的是一个 &lt;strong&gt;局部变量&lt;/strong&gt;，其作用域就是这个函数，如果在顶层代码中使用 var 语句，它声明的是 &lt;strong&gt;全局变量&lt;/strong&gt;，整个程序中都是可用的&lt;/p&gt;

&lt;p&gt;全局变量是全局对象的属性。然而通过 var 声明的全局变量 &lt;strong&gt;无法&lt;/strong&gt; 通过 delete 删除&lt;/p&gt;

&lt;p&gt;如果 var 语句中的变量没有指定初始化表达式，那么这个变量的值初始为 undefined&lt;/p&gt;

&lt;h3 id=&#34;function&#34;&gt;function&lt;/h3&gt;

&lt;p&gt;函数声明的语句的语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function fun_name([arg1 [, arg2 [..., argn]]]) {
    statements
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var f = function(x) { return x+1; };        // 通过 var 声明函数
function f(x) { return x+1; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;条件语句&#34;&gt;条件语句&lt;/h2&gt;

&lt;h3 id=&#34;if&#34;&gt;if&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (expression) {
    statement
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种形式中，需要计算 expression 的值，如果结果是真值，那么就执行 statement&lt;/p&gt;

&lt;p&gt;为了避免歧义，建议 &lt;strong&gt;总是&lt;/strong&gt; 给 if 语句添加花括号&lt;/p&gt;

&lt;h3 id=&#34;else-if&#34;&gt;else if&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (expression) {
    statement
} else if (expression) {
    statement
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;switch&#34;&gt;switch&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;switch(expression) {
    statement
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;循环&#34;&gt;循环&lt;/h2&gt;

&lt;h3 id=&#34;while&#34;&gt;while&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var count = 0;
while (count &amp;lt; 10) {
    console.log(count);
    count++
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;do-while&#34;&gt;do/while&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function printArray(a) {
    var len = a.length, i = 0;
    if (len == 0) {
        console.log(&#39;Empty Array);
    } else {
        do {
            console.log(a[i]);
        } while(++i &amp;lt; len);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;for&#34;&gt;for&lt;/h3&gt;

&lt;p&gt;for 循环的 &lt;strong&gt;执行顺序&lt;/strong&gt; 是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;initialize&lt;/li&gt;
&lt;li&gt;test 条件为真&lt;/li&gt;
&lt;li&gt;statement&lt;/li&gt;
&lt;li&gt;increment&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (initialize; test; increment) {
    statement
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多数情况下与之等价的 while 循环写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;initialize;
while(test) {
    statement
    increment;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;for-in&#34;&gt;for/in&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (variable in object) {
    statement
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;variable 通常是一个变量名（也可以是个表达式），也可以是一个可以产生左值的表达式或者一个通过 var 语句声明的变量，总之必须是一个适用于赋值表达式左侧的值。object 是一个 &lt;strong&gt;表达式&lt;/strong&gt;，这个表达式计算结果是一个对象&lt;/p&gt;

&lt;p&gt;在执行 for/in 语句的过程中，JavaScript 解释器首先计算 object 表达式。如果表达式为 null 或者 undefined，解释器将会跳过循环并执行后续代码（ECMAScript 3 可能会抛出一个类型错误异常）。如果表达式等于一个原始值，这个原始值将会转换为与之对应的 &lt;a href=&#34;https://keelii.github.io/2016/06/16/javascript-definitive-guide-note-2/&#34;&gt;包装对象&lt;/a&gt;（wrapper object）否则，expression 本身已经是对象了。JavaScript 会依次遍历 &lt;strong&gt;可枚举&lt;/strong&gt; 的对象属性来执行循环体语句&lt;/p&gt;

&lt;p&gt;for/in 循环并不会遍历对象的所有属性，只有「可枚举」（emumerable）的属性才会遍历到。JavaScript 语言核心所定义的内置方法就 &lt;strong&gt;不是&lt;/strong&gt;「可枚举的」，比如，所有对象都有方法 toString()，但 for/in 循环并不枚举 toString 这个属性，还有很多内置属性也是不可枚举的（nonenumerable）。而代码中定义的所有属性和方法都是可枚举的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;属性枚举的顺序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ECMAScript 规范并没有指定 for/in 循环按照何种顺序来枚举对象属性。但实际上，主流浏览器厂商的 JavaScript 实现是按照 &lt;strong&gt;属性定义的先后顺序&lt;/strong&gt; 来枚举简单对象的属性&lt;/p&gt;

&lt;h2 id=&#34;跳转&#34;&gt;跳转&lt;/h2&gt;

&lt;p&gt;JavaScript 中另一类语句是跳转语句（jump statement）。通常有 break, continue, return, throw&lt;/p&gt;

&lt;h3 id=&#34;标签语句&#34;&gt;标签语句&lt;/h3&gt;

&lt;p&gt;语句是可以添加标签的，标签由语句前的标识符和冒号组成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;indetifier: statement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标识符必须是一个合法的 JavaScript 标识符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;mainloop: while(token != null) {
    // statement
    continue mainloop;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;break-语句&#34;&gt;break 语句&lt;/h3&gt;

&lt;p&gt;单独使用 break 语句的作用是立即退出最内层的 &lt;strong&gt;循环&lt;/strong&gt; 或者 &lt;strong&gt;switch 语句&lt;/strong&gt;，break 关键字后面也可以跟一个语句标签，当 break 和标签一块使用时，程序将跳转到这个标签所标识的语句块的结束&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不管 break 语句带不带标签，它的控制权都无法超过函数的边界&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;continue-语句&#34;&gt;continue 语句&lt;/h3&gt;

&lt;p&gt;类似于 break，但是它不退出循环，而是转而执行下一次循环。continue 语句只能在循环体内使用，其它地方使用会报错&lt;/p&gt;

&lt;p&gt;在不同类型的循环中，continue 的行为也是有所区别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 while 循环中，在循环开始处指定的 expression 会重复检测，如果检测结果为 true，循环休会从头开始执行&lt;/li&gt;
&lt;li&gt;在 do/while 循环中，程序的执行直接跳到循环结尾处，这里会重新判断循环条件，之后才会继续下一次循环&lt;/li&gt;
&lt;li&gt;在 for 循环中，首先计算自增表达式，然后再次检测 test 表达式，用以判断是否执行循环体&lt;/li&gt;
&lt;li&gt;在 for/in 循环中，循环开始遍历下一个属性名，这个属性名赋给了指定的变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是 continue 语句在 while 和 for 循环中的区别，while 循环直接进入一下轮的循环条件判断，但 for 循环首先计算其 increment 表达式，然后判断循环条件，所以 for 循环并不能完全等价模拟出 while 循环&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// while 语句中的写法会造成死循环，for 语句则不会
// for 语句中的 increment 表达式总是会执行到
var i = 0;
while (i &amp;lt; 10) {
    if (i &amp;lt; 5 ) {
        continue;
    }
    console.log(i);
    i++;
}

for (var k = 1; k &amp;lt; 10; k++) {
    if (k &amp;lt; 5) {
        continue;
    }
    console.log(k);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;return-语句&#34;&gt;return 语句&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;return expression;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return 语句 &lt;strong&gt;只能&lt;/strong&gt; 出现在函数体内，如果不是的话会报语法错误。当执行到 return 语句的时候，函数终止执行，并返回 expression 的值给调用程序，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function square(x) { return x*x; }
square(2)   // =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return 可以单独使用而不必带有 expression，这样的话函数会向调用程序返回 undefined&lt;/p&gt;

&lt;h3 id=&#34;throw-语句&#34;&gt;throw 语句&lt;/h3&gt;

&lt;p&gt;所谓异常（exception）是当发生了落地生根异常情况或错误时产生的一个信号。抛出异常（throw exception），就是用信号通知发生错误或者异常头部。捕获（catch）异常是指处理这个信号，即采取必要的手段从异常中恢复&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;throw expression;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;expression 的值可以是任意类型的。当 JavaScript 解释器抛出异常的时候通常采用 Error 类型和其子类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function factorial(x) {
    // 如果输出参数是非法的，则抛出一个异常
    if (x &amp;lt; 0) throw new Error(&#39;x 不能是负数&#39;);
    for (var f = 1; x &amp;gt; 1; f*= x, x--) ;
    return f;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当异常招聘时，JavaScript 解释器会 &lt;strong&gt;立即停止&lt;/strong&gt; 当前正在执行的逻辑，并跳转到 &lt;strong&gt;就近的&lt;/strong&gt; 异常处理程序。异常钼是程序是用 try/catch/finally 语句的 catch 从句编写的，JavaScript 会沿着方法的词法结构和调用栈向上传播&lt;/p&gt;

&lt;h3 id=&#34;try-catch-finally-语句&#34;&gt;try/catch/finally 语句&lt;/h3&gt;

&lt;p&gt;try 从句定义了需要处理的异常所有代码块。catch 从句跟在其后，当 try 块内某处发生了异常时，调用 catch 内的代码逻辑。catch 从句后跟随 finally 块，后者中放置清理代码，不管 try 块中是否产生异常，finally 块内的逻辑总是会执行。尽管 catch 和 finally 都是可先的，但 try 从句需要至少二者之一（catch/finally）与之组成完整的语句。&lt;/p&gt;

&lt;p&gt;try, catch 和 finally 语句块都 &lt;strong&gt;必须&lt;/strong&gt; 使用花括号括起来，即使只有一条语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;try {
    // 通常来讲，这里的代码会从头执行到尾而不会产生任何问题，
    // 但有时会招聘一个异常，要么是由 throw 语句直接抛出，要
    // 么是通过调用一个方法间接抛出异常
} catch (e) {
    // 当且仅当 try 语句块抛出了异常，才会执行这里的代码
    // 这里可以通过局部变量 e 来警告对 Error 对象或者抛出的其他值的引用
    // 还可以通过 throw 语句重新抛出异常
} finally {
    // 不管 try 语句是否抛出了异常，这里的逻辑总是会执行，终止 try 语句块的方式有：
    // 1. 正常终止，执行完语句块的最后一条语句
    // 2. 通过 break, continue 或 return 语句终止
    // 3. 抛出一个异常，异常被 catch 从句捕获
    // 4. 抛出一个异常，异常未被捕获，继续向上传播
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来说 JavaScript 使用 try/catch 语句的时候很少使用 finally。通常在一些后端语言 IO 操作中使用 finally 的比较多，比如打开一个文件，出现异常或者正常执行完 try 从句都需要关闭文件句柄&lt;/p&gt;

&lt;h2 id=&#34;其它语句类型&#34;&gt;其它语句类型&lt;/h2&gt;

&lt;p&gt;with, debugger 和 use strict&lt;/p&gt;

&lt;h3 id=&#34;with-语句&#34;&gt;with 语句&lt;/h3&gt;

&lt;p&gt;with 语句用于临时扩展作用域链，语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;with (object) {
    statement
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这条语句将 object 添加到 &lt;strong&gt;作用域链的头部&lt;/strong&gt;，然后执行 statement，最后把作用域链恢复到原始状态&lt;/p&gt;

&lt;p&gt;严格模式中是禁止使用 with 语句的，并且在非严格模式里也是 &lt;strong&gt;不推荐&lt;/strong&gt; 使用 with 语句的。使用 with 语句的 JavaScript 代码非常难于优化，并且和没有使用 width 语句的代码相比，运行更慢&lt;/p&gt;

&lt;p&gt;在对象嵌套层次很深的时候通常会使用 with 语句来简化代码编写。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.forms[0].address.value = &#39;a&#39;
document.forms[0].name.value = &#39;b&#39;
document.forms[0].job.value = &#39;c&#39;

// 等价于
with (document.forms[0]) {
    address.value = &#39;a&#39;
    name.value = &#39;b&#39;
    job.value = &#39;c&#39;
}
// 使用 with 语句减少了对象访问前缀，但是仍然可以不使用 with 解决这个问题
// 使用变量 f 缓存对象引用
var f = document.forms[0];
f.address.value = &#39;a&#39;
f.name.value = &#39;b&#39;
f.job.value = &#39;c&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有在查找标识符的时候才会用到作用域链，创建新的变量的时候不使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var d = 0;
var o = { a: 1, b: 2, c: 3};

with(o) {
   a = 2;
   d = 1
}
d           // =&amp;gt; 1
o           // =&amp;gt; {a: 2, b: 2, c: 3}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;debugger-语句&#34;&gt;debugger 语句&lt;/h3&gt;

&lt;p&gt;debugger 语句通常什么也不做。当调试程序可用并运行的时候，JavaScript 解释器将会（非必需）以调试模式运行。这条语句用来产生一个断点（breakpoint），JavaScript 代码的挂靠会停止在断点的位置，这时可以使用调试器转出当前的变量、调用栈等&lt;/p&gt;

&lt;p&gt;ECMAScript 5 中，debugger 语句正式加入到了语言规范里，在此之前注流浏览器厂商基本都已经实惠过了&lt;/p&gt;

&lt;h3 id=&#34;use-strict&#34;&gt;&amp;lsquo;use strict&amp;rsquo;&lt;/h3&gt;

&lt;p&gt;&amp;lsquo;use strict&amp;rsquo; 是 ECMAScript 5 引入的一条指定。非常类似语句但不是，区别在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;它 &lt;strong&gt;不包含&lt;/strong&gt;任何语言的关键字，指令仅仅是一个包含一个特殊字符串直接量的表达式，它是一条没有副作用的表达式语句，什么也没做&lt;/li&gt;
&lt;li&gt;它只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。但不必一定出现在脚本或者函数休内的首行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用 &amp;lsquo;use strict&amp;rsquo; 指令的目的是说明（脚本或函数中）后续的代码将会解析为严格代码&lt;/p&gt;

&lt;p&gt;严格代码以 &lt;strong&gt;严格模式&lt;/strong&gt; 执行，严格模式悠了语言的重要缺陷，并提供健壮的查氏功能和增强的安全机制，和非严格模式的区别如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;严格模式中 &lt;strong&gt;禁止&lt;/strong&gt; 使用 width 语句&lt;/li&gt;
&lt;li&gt;严格模式中，所有的变量都要先声明，如果给一个未声明的变量、函数、函数参数、catch 从句参数或全局对象的属性赋值，将会抛出一个引用错误异常&lt;/li&gt;
&lt;li&gt;严格模式中，调用的函数（不是方法）中的一个 this 值是 undefined（非严格模式下 this 值总是全局对象），可以利用这个特性来判断当前的 JavaScript 是否支持严格模式 &lt;code&gt;var hasStrictMode = (function() { &amp;quot;use strict&amp;quot;; return this === undefined }())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;严格模式中，给只读属性赋值和给不可扩展的对象创建新成员都将抛出一个类型错误异常（非严格模式中不会报错）&lt;/li&gt;
&lt;li&gt;严格模式中，传入 eval() 的代码不能在调用程序所在的上下文中声明变量或定义函数，非严格模式中可以&lt;/li&gt;
&lt;li&gt;严格模式中，函数里的 arguments 对象拥有传入函数值的 &lt;strong&gt;静态副本&lt;/strong&gt;。非严格模式下，arguments 里的数组元素和函数参数都指向同一个值的引用&lt;/li&gt;
&lt;li&gt;严格模式中，当 delete 运算符后跟随非法的标识符（变量、函数、当函数参数）时，将会抛出一个语法错误异常&lt;/li&gt;
&lt;li&gt;严格模式中试图删除一个 &lt;strong&gt;不可配置&lt;/strong&gt; 的属性将抛出一个类型错误异常（非严格模式中，返回 false）&lt;/li&gt;
&lt;li&gt;严格模式中，一个对象直接量中定义两个或多个 &lt;strong&gt;同名属性&lt;/strong&gt; 将产生一个语法错误&lt;/li&gt;
&lt;li&gt;严格模式中，函数声明中存在两个或多个同名参数将产生一个语法错误&lt;/li&gt;
&lt;li&gt;严格模式中，&lt;strong&gt;不允许使用八进制&lt;/strong&gt; 整数直接量（以 0 为前缀）&lt;/li&gt;
&lt;li&gt;严格模式中，标识符 eval 和 arguments 当做关键字，它们的值是不能更改的，不能给它们赋值，也不能把它们声明为变量、函数名&lt;/li&gt;
&lt;li&gt;严格模式中，限制了对调用栈的检测能力，在严格模式的函数中，arguments.caller 和 arguments.callee 都会抛出一个类型错误异常&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 6 - 对象</title>
      <link>https://keelii.github.io/2016/06/23/javascript-definitive-guide-note-5/</link>
      <pubDate>Thu, 23 Jun 2016 19:10:28 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/06/23/javascript-definitive-guide-note-5/</guid>
      <description>&lt;p&gt;对象是 JavaScript 的基本数据类型。是一种复合值：将很多值聚合在一起。对象可以看做是无序集合，每个属性都是一个名/值对。这种基本数据结构还有很多叫法，比如「散列」（hash）、「散列表」（hashtable）、「字典」（dictionary）、「关联数组」（associative array）。JavaScript 还可以从一个称为 &lt;strong&gt;原型&lt;/strong&gt; 的对象继承属性&lt;/p&gt;

&lt;p&gt;JavaScript 对象是动态的 —— 可以新增属性也可以删除属性，除了字符串、数字、布尔值、null 和 undefined 之外，JavaScript 中的值都是对象&lt;/p&gt;

&lt;p&gt;对象是可变的，通过引用操作对象原对象也会受到影响
&lt;/p&gt;

&lt;p&gt;属性包括名字和值。名字是可以包含空字符串在内的 &lt;strong&gt;任意字符串&lt;/strong&gt;，值可以是任意 JavaScript 值，或者（在 ECMAScript 5中）可以是一个 getter 或者 setter （或都有），每个属性还有一些与之相关的值称为「属性特性」（property attribute）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可写（writable）&lt;/li&gt;
&lt;li&gt;可枚举（enumerable）&lt;/li&gt;
&lt;li&gt;可配置（configurable），表明是否可以删除或者修改&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ECMAScript 5 之前，&lt;strong&gt;通过代码给对象创建的所有属性都是可写、可枚举和可配置的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;除了包含属性之外，每个对象还拥有三个相关的对象特性（object attribute）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对象的原型（prototype）指向另外一个对象，本对象的属性继承自它的原型对象&lt;/li&gt;
&lt;li&gt;对象的类（class）是一个标识对象类型的字符串&lt;/li&gt;
&lt;li&gt;对象的扩展标记（extensible flag）指明了（在 ECMAScript 5 中）是否可以向该对象添加新属性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这些术语用来区分三类 JavaScript 对象和两类属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内置对象（native object），由 ECMAScript 规范定义的对象或类。例如 数组、日期&lt;/li&gt;
&lt;li&gt;宿主对象（host object），由 JavaScript 解释器所嵌入的宿主环境（比如浏览器）定义的。比如浏览器中的 HTMLElement，document&lt;/li&gt;
&lt;li&gt;自定义对象（user-defined object），由运行中的 JavaScript 代码创建的对象&lt;/li&gt;
&lt;li&gt;自有属性（own property），直接在对象中定义的属性&lt;/li&gt;
&lt;li&gt;继承属性（inherited property）是在对象的原型对象中定义的属性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;创建对象&#34;&gt;创建对象&lt;/h2&gt;

&lt;h3 id=&#34;对象直接量&#34;&gt;对象直接量&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var empty = {}
var point = { x:0, y:0 }
var point2 = { x:point.x, y:point.y + 1 }
var book = {
    &amp;quot;main title&amp;quot;: &amp;quot;JavaScript&amp;quot;,
    &amp;quot;for&amp;quot;: &amp;quot;all audiences&amp;quot;,
    author: {
        firstname: &amp;quot;David&amp;quot;,
        surname: &amp;quot;Flanagan&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 ECMAScript 5 中，保留字可以用做不带引号的属性名。然后对于 ECMAScript 3 来说，使用保留字作为属性名必须使用引号引起来。ECMAScript 5 中属性最后一个逗号会被忽略，但在 IE 中则报错&lt;/p&gt;

&lt;h3 id=&#34;通过-new-创建对象&#34;&gt;通过 new 创建对象&lt;/h3&gt;

&lt;p&gt;new 运算符创建并初始化一个新对象。new 后跟随一个函数调用。这里的函数称做构造函数（constructor），用来初始化一个新创建的对象。JavaScript 语言核心的原始类型都包含内置构造函数（另一方面也证实了 JavaScript 中一切皆对象）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = new Object();
var a = new Array();
var d = new Date();
var r = new RegExp(&#39;js&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;原型&#34;&gt;原型&lt;/h3&gt;

&lt;p&gt;每一个 JavaScript 对象（null 除外）都和另一个对象相关联，这个对象就是「原型」，每一个对象都从原型继承属性&lt;/p&gt;

&lt;p&gt;通过 new 创建的对象原型就是构造函数的 prototype 属性值，通过 new Object() 创建的对象也继承自 Obejct.property&lt;/p&gt;

&lt;p&gt;没有原型对象的为数不多，Obejct.prototype 就是其中之一。它不继承任何属性，普通对象都具有原型。所有的内置构造函数都具有一个继承自 Object.prototype 的原型。例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性现时继承自 Date.prototype 和 Object.prototype，这一系列链接的原型对象就是所谓的「原型链」（prototype chain）&lt;/p&gt;

&lt;h3 id=&#34;object-create&#34;&gt;Object.create()&lt;/h3&gt;

&lt;p&gt;ECMAScript 5 定义了一个名为 Obejct.create() 的方法，用来创建一个新对象，其中第一个参数是这个对象的原型，第二个可选参数用来对对象的属性进行进一步描述，Object.create() 是一个 &lt;strong&gt;静态函数&lt;/strong&gt;，不是提供给对象调用的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o1 = Object.create({ x:1, y:2 });       // o1 继承了属性 x 和 y
var o2 = Obejct.create(null);               // o2 不继承任何属性和方法
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 ECMAScript 3 中可以用类似代码来模拟原型继承：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function inherit(p) {
    if (p == null) throw TypeError();
    if (Object.create) return Object.create(p);

    var t = typeof p;
    if (t !== &amp;quot;object&amp;quot; &amp;amp;&amp;amp; t !== &amp;quot;undefined&amp;quot;) throw TypeError();

    function f() {}
    f.prototype = p;

    return new f();
}

var o = { x: &amp;quot;test o&amp;quot; }

var c = inherit(o);

c.x = &amp;quot;test c&amp;quot;;

console.log(c.x);       // =&amp;gt; &amp;quot;test c&amp;quot;
console.log(o.x);       // =&amp;gt; &amp;quot;test o&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;属性的查询和设置&#34;&gt;属性的查询和设置&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var author = book.author;           // 取得 book 的 author 属性
var title = book[&amp;quot;main title&amp;quot;];     // 使用 [] 访问属性时 [] 内必须是一个计算结果为字符串的表达式

book.edition = 6;                   // 给 book 创建一个名为 edition 的属性，「.」号运算符后的标识符不能是保留字
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;作为关联数组的对象&#34;&gt;作为关联数组的对象&lt;/h3&gt;

&lt;p&gt;当通过 [] 来访问对象属性时，属性名通过字符串来表示。字符串是 JavaScript 的数据类型，在程序运行时可以修改创建它们。因此，可以在 JavaScript 中使用下面这种代码来动态添加/查找属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var addr = &amp;quot;&amp;quot;;
for (i = 0; i &amp;lt; 4; i++) {
    addr += customer[&amp;quot;address&amp;quot; + i] + &#39;\n&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;继承&#34;&gt;继承&lt;/h3&gt;

&lt;p&gt;假设要查询对象 o 的属性 x，如果 o 中不存在 x，那么将会继续在 o 的原型对象中查询属性 x。如果原型对象中也没有 x，但这个原型对象还有原型，那么继续在这个原型对象的原型上执行查找，直到找到 x 或者找到一个原型是 null 的对象为止。可以看出来，原型的属性构成了一个「链接」，通过这个「链」可以实现属性的继承&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {}
o.x = 1;

var p = inherit(o);
p.y = 2;

var q = inherit(p);
q.z = 3;

var s = q.toString();   // =&amp;gt; &amp;quot;[object Object]&amp;quot;
q.x + q.y               // =&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;属性访问错误&#34;&gt;属性访问错误&lt;/h3&gt;

&lt;p&gt;属性访问并不总是返回或设置一个值，下页场景给对象 o 设置 属性 p 会失败：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;o 中的属性 p 是只读的（defineProperty() 方法中有一个例外，可以对可配置的只读属性重新赋值）&lt;/li&gt;
&lt;li&gt;o 中不存在自有属性 p：o 没有使用 setter 方法继承属性 p，并且 o 的可扩展性（extensible attribute）是 false。如果 o 中不存在 p，而且没有 setter 方法可供调用，则 p 一定会添加至 o 中。如果 o 不是可扩展的，那么在 o 中不能定义新的属性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;删除属性&#34;&gt;删除属性&lt;/h2&gt;

&lt;p&gt;使用 delete 运算符可以删除对象的属性，delete 运算符只能删除 &lt;strong&gt;自有属性&lt;/strong&gt;，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）&lt;/p&gt;

&lt;p&gt;如果删除成功或者删除了一个没有影响的值（不存在的属性），delete 表达式返回 true。当 delete 运算符的操作数不是一个对象的属性的时候也返回 true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = { x: 1 }
delete o.x;             // =&amp;gt; true
delete o.x;             // =&amp;gt; true x 并不存在
delete o.toString;      // =&amp;gt; true toString 是继承属性
delete 1                // =&amp;gt; true 不是对象属性
this.b = 1;
delete b;               // =&amp;gt; true 删除全局对象上的变量 b

delete Object.property  // =&amp;gt; false
var x = 1;
delete this.x;          // =&amp;gt; false 不能删除这个属性，因为是通过 var 声明的
function f() {}
delete f                // =&amp;gt; false 不能删除全局函数
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;检测属性&#34;&gt;检测属性&lt;/h2&gt;

&lt;p&gt;可以通过 in 运算符、hasOwnProperty() 方法和 propertyIsEnumerable() 方法来检测对象是否存在某属性，propertyIsEnumerable 只有检测到是自有属性且这个属性的可枚举性为 true 时它才返回 true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = { x: 1 };
&amp;quot;x&amp;quot; in o;                          // =&amp;gt; true
&amp;quot;y&amp;quot; in o;                          // =&amp;gt; false
&amp;quot;toString&amp;quot; in o                    // =&amp;gt; true

o.hasOwnProperty(&amp;quot;x&amp;quot;)              // =&amp;gt; true
o.hasOwnProperty(&amp;quot;y&amp;quot;)              // =&amp;gt; false
o.hasOwnProperty(&amp;quot;toString&amp;quot;)       // =&amp;gt; false

var o = inherit({ y: 2});
o.x = 1;
o.propertyIsEnumerable(&amp;quot;x&amp;quot;)        // =&amp;gt; true
o.propertyIsEnumerable(&amp;quot;y&amp;quot;)        // =&amp;gt; false
o.propertyIsEnumerable(&amp;quot;toString&amp;quot;) // =&amp;gt; false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以通过判断属性是否是 undefined 来模拟 in 运算符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;o.x !== undefined;                 // =&amp;gt; true
o.y !== undefined;                 // =&amp;gt; false
o.toString !== undefined;          // =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而有一种场景只能使用 in 运算符而不能通过只判断 undefined 的方式。&lt;strong&gt;in 可以区分不存在的属性和存在但值为 undefined 的属性&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = { x: undefined }
o.x !== undefined           // =&amp;gt; false 存在 x，只是值为 undefined
o.y !== undefined           // =&amp;gt; false
&amp;quot;x&amp;quot; in o                    // =&amp;gt; true
&amp;quot;y&amp;quot; in o                    // =&amp;gt; false
delete o.x                  // =&amp;gt; true
&amp;quot;x&amp;quot; in o                    // =&amp;gt; false delete 后 o 完全不存在了
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;枚举属性&#34;&gt;枚举属性&lt;/h2&gt;

&lt;p&gt;许多工具库给 Object.prototype 添加了新的方法或者属性（通常不建议这么做），这些方法和属性可以被所有对象继承并使用。然而在 ECMAScript 5 标签之前，这些添加的方法是 &lt;strong&gt;不能定义为不可枚举的&lt;/strong&gt;，因此它们都可以在 for/in 循环枚举出来。为了避免这和践情况，需要过滤 for/in 循环返回的属性，下面两种方法是最常见的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.prototype.test = 1;
var o = { a: 1, b:2, c: function() {} };
for (p in o) {
    if (!o.hasOwnProperty(p)) continue;
    console.log(p);
}
for (p in o) {
    if (typeof o[p] === &amp;quot;function&amp;quot;) continue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了 for/in 循环之外，ECMAScript 5 定义了两个用以枚举属性名称的函数。第一个是 Object.keys()，它返回一个数组，由对象中的 &lt;strong&gt;可枚举的自有属性名称&lt;/strong&gt; 组成，第二个是 Object.getOwnPropertyNames()，它和上面的方法类似，只是它返回对象的 &lt;strong&gt;所有自有属性名称&lt;/strong&gt;，不仅仅是可枚举的属性&lt;/p&gt;

&lt;h2 id=&#34;属性-getter-和-setter&#34;&gt;属性 getter 和 setter&lt;/h2&gt;

&lt;p&gt;在 ECMAScript 5 中，属性的值可以用一个或两个方法替代，这两个方法就是 getter 和 setter。由它们定义的属性称做「存取器属性」（accessor property），不同于「数据属性」（data property），数据属性只有一个简单的值&lt;/p&gt;

&lt;p&gt;当程序查询存取器属性的值时，JavaScript 调用 getter 方法（无参数）。这个方法返回属性的存取表达式值。当程序设置一个存取器属性的值时，调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责「设置」属性值。可以忽略 setter 方法的返回值&lt;/p&gt;

&lt;p&gt;使用存取器属性写入的属性不具有可写性（writable）。如果属性同时具有 getter 和 setter 方法，那么它是一个读/写属性。哪果它只有 getter 方法，那么它是一个只读属性。如果只有 setter 方法，那么它是一个只写属性，读取只写属性总是返回 undefined&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var p = {
  x: 1.0,
  y: 1.0,

  get r() {
    return Math.sqrt(this.x*this.x + this.y*this.y);
  },
  set r(newValue) {
    var oldValue = Math.sqrt(this.x*this.x + this.y*this.y);
    var ratio = newValue/oldValue;

    this.x *= ratio;
    this.y *= ratio;
  },
  get theta() {
    return Math.atan2(this.y, this.x)
  }
};
p.r             // =&amp;gt; 1.4142135623730951
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;属性的特性&#34;&gt;属性的特性&lt;/h2&gt;

&lt;p&gt;除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。ECMAScript 3 程序创建的属性都是可写、可枚举、可配置的，且无法对这些特性做出修改。ECMAScript 5 中却提供了查询和设置这些属性鹅的 API，这些 API 对于库的开发者来说非常重要，因为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以通过这些 API 给原型对象添加方法，并将它们设置成不可枚举的，&lt;strong&gt;让它们看起来更像内置方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可以通过这些 API 给对象定义不修改或删除的属性借此「锁定」这个对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;数据属性&lt;/strong&gt; 的 4 个属性分别是它的值（value）、可写性（writable）、可枚举性（enumerable）和可配置性（configurable）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存取器属性&lt;/strong&gt; 不具有值（value）特性和可写性，它们的可写性是由 setter 方法存在与否决定，因此存取器属性的 4 个特性是读取（get）、写入（set）、可枚举性和可配置性&lt;/p&gt;

&lt;p&gt;为了实现属性特性的查询和设置操作，ECMAScript 5 中定义了一个名为「&lt;strong&gt;属性描述符&lt;/strong&gt;」（property descriptor）的对象，这个对象代表那 4 个特性。描述符对象的属性和它们所描述的属性特性是同名的。因此，数据属性的描述符对象的属性有 value, writable, enumerable 和 configurable。存取器属性描述符对象则用 get, set 属性代替 value, writable。其中 writable、enumerable 和 configurable 都是布尔值，get、set 都是函数值&lt;/p&gt;

&lt;p&gt;通过调用 Object.getOwnPropertyDescriptor() 可以获得某个对象特定属性的属性描述符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// =&amp;gt; {value: 1, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor({ x: 1}, &amp;quot;x&amp;quot;)
var random = {
    get octet() {
        return Math.floor(Math.random() * 256)
    },
    get uint16() {
        return Math.floor(Math.random() * 65536)
    },
    get int16() {
        return Math.floor(Math.random() * 65536 - 32768)
    }
}
// =&amp;gt; {set: undefined, get: function, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor(random, &amp;quot;octet&amp;quot;)
// =&amp;gt; undefined
Object.getOwnPropertyDescriptor({}, &amp;quot;x&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从函数名字就可以看出来 Object.getOwnPropertyDescriptor() 只能得到自有属性的描述符。继承属性的特性需要遍历原型链&lt;/p&gt;

&lt;p&gt;要想设置属性的特性，或者让新建属性具有某种特性，则需要调用 Object.defineProperty()，传入要修改的对象、要创建或者修改的属性的名称以前属性描述符对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {};
Object.defineProperty(o, &amp;quot;x&amp;quot;, {
    value: 1,
    writable: true,
    enumerable: false,
    configurable: true
});
// x 属性存在但不可枚举
Object.keys()       // =&amp;gt; []

Object.defineProperty(o, &amp;quot;x&amp;quot;, { writable: false })
o.x = 2             // 试图更改这个属性的值，会操作失败不报错，严格模式中则抛出类型错误异常
o.x                 // =&amp;gt; 1

// 将 x 从数据属性修改为存取器属性
Object.defineProperty(o, &amp;quot;x&amp;quot;, { value: 2 })
Object.defineProperty(o, &amp;quot;x&amp;quot;, { get: function() { return 0} }
o.x                 // =&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传入 Object.defineProperty() 的属性描述符对象 &lt;strong&gt;不必&lt;/strong&gt; 包含所有 4 个特性。对于创建属性来说，默认的特性值是 false 或 undefined。对于修改的已有属性来说，默认的特性值没有做任何修改。注意，这个方法要么修改已有属性要么新建自胡属性，但 &lt;strong&gt;不能修改继承属性&lt;/strong&gt;，想要同时修改或者创建多个属性则需要使用 Object.defineProperties()，使用方法可以参考 MDN &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties&#34;&gt;相关 api&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于那些不允许创建或者修改的属性来说，如果用 Object.defineProperty() 对其操作就会抛出类型错误异常，比如给一个不可扩展的对象新增属性就会抛出类型错误异常。&lt;strong&gt;可写性控制着对特定值特性的修改，可配置性控制着对其它特性的修改&lt;/strong&gt;，使用的时候以下情况会抛出类型错误异常：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性&lt;/li&gt;
&lt;li&gt;如果属性是不可配置的，则不能修改它的可配置性和可枚举性&lt;/li&gt;
&lt;li&gt;如果存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性&lt;/li&gt;
&lt;li&gt;如果数据属性是不可配置的，则不能将它转换为存取器属性&lt;/li&gt;
&lt;li&gt;如果数据属性是不可配置的，则不能将它的可写性从 false 修改为 true，但可以从 true  修改为 false&lt;/li&gt;
&lt;li&gt;如果数据属性是不可配置且不可写的，则不能修改它的值，然而 &lt;strong&gt;可配置但不可写的属性值是可以修改的&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 给 Object.prototype 添加一个不可枚举的 extend() 方法
// 这个方法继承自调用它的对象，将作为参数什入的对象属性都复制
Object.defineProperty(Object.prototype, &amp;quot;extend&amp;quot;, {
    writable: true,
    enumerable: false,
    configurable: true,
    value: function(o) {
        var names = Object.getOwnPropertyNames(0);

        for (var i = 0, l = names.length; i &amp;lt; l; i++) {
            if (names[i] in this) continue;

            var desc = Object.getOwnPropertyDescriptor(o, name[i]);
            Object.defineProperty(this, names[i], desc)
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;getter 和 setter 的老式 API&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在ECMAScript 5标准被采纳之前，大多数 JavaScript 的实现（IE 除外）已经可以支持对象直接量语法中的 get 和 set 写法。这些实现提供了非标准的老式 API 用来查询和设置 getter 和 setter。这些 API 由 4 个方法组成，所有对象都拥有这些方法。&lt;code&gt;__lookupGetter__()&lt;/code&gt; 和 &lt;code&gt;__lookupSetter__()&lt;/code&gt; 用以返回一个命名属性的 getter 和 setter 方法，&lt;code&gt;__defineSetter__()&lt;/code&gt; 和 &lt;code&gt;__defineGetter__()&lt;/code&gt; 用以定义 getter 和 setter&lt;/p&gt;

&lt;h2 id=&#34;对象的三个属性&#34;&gt;对象的三个属性&lt;/h2&gt;

&lt;p&gt;每个对象都胡与之相关的 &lt;strong&gt;原型&lt;/strong&gt;（prototype）、&lt;strong&gt;类&lt;/strong&gt;（class）和 &lt;strong&gt;可扩展性&lt;/strong&gt;（extensible attribute）&lt;/p&gt;

&lt;h3 id=&#34;原型属性&#34;&gt;原型属性&lt;/h3&gt;

&lt;p&gt;原型属性是在实例对象创建之初就设置好的，ECMAScript 5 中，对象作为参数传入 &lt;code&gt;Object.getPrototypeOf()&lt;/code&gt; 可以查看它的原型，在 ECMAScript 3 中，则没有与之等价的函数，但经常使用表达式 o.constructor.prototype 来检测一个对象的原型。通过 new 表达式创建的对象，通常继承一个 constructor 属性，这个属性指代创建这个对象的构造函数&lt;/p&gt;

&lt;p&gt;要想检测一个对象是否是另一个对象的原型（或者处于原型链中），请使用 isPrototypeOf() 方法，这个方法和 instanceof 运算符非常类似，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var p = { x:1 };
var o = Object.create(p);
p.isPrototypeOf(o)                  // =&amp;gt; true
Object.prototype.isPrototypeOf(o)   // =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;类属性&#34;&gt;类属性&lt;/h3&gt;

&lt;p&gt;对象的类属性是一个字符串，用以表示对象的类型信息。ECMAScript &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt; 都未提供设置这个属性的方法，并只有一种间接的方法可以查询它。默认的 toString() 方法（继承自 Object.prototype），返回了如下这种格式的字符串：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[object class]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以可以通过 toString() 方法返回的字符串截取处理取到 class 名，不过很多对象继承的 toString() 方法被重写了，为了能调用正确的 toString() 版本，必须间接地调用 Function.call() 方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function classof(o) {
    if (o === null) return &amp;quot;Null&amp;quot;;
    if (o === undefined) return &amp;quot;Undefined&amp;quot;;
    return Object.prototype.toString.call(o).slice(8, -2);
}
classof(null)     // =&amp;gt; &amp;quot;Null&amp;quot;
classof(1)        // =&amp;gt; &amp;quot;Number&amp;quot;
classof(&amp;quot;&amp;quot;)       // =&amp;gt; &amp;quot;String&amp;quot;
classof(true)     // =&amp;gt; &amp;quot;Boolean&amp;quot;
classof({})       // =&amp;gt; &amp;quot;Object&amp;quot;
classof([])       // =&amp;gt; &amp;quot;Array&amp;quot;
classof(/./)      // =&amp;gt; &amp;quot;Regexp&amp;quot;
classof(new Date) // =&amp;gt; &amp;quot;Date&amp;quot;
function f() {}
classof(new f())  // =&amp;gt; &amp;quot;Object&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;可扩展属性&#34;&gt;可扩展属性&lt;/h3&gt;

&lt;p&gt;可扩展性用以表示是否可以给对象是添加新属性。所有内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展属性是由 JavaScript 引擎定义的，ECMAScript 5 中，所有的内置对象和自定义对象都是可扩展的，除非将它们转换为不可扩展的，宿主对象的可扩展性也是由实现 ECMAScript 5 的 JavaScript 引擎定义的&lt;/p&gt;

&lt;p&gt;ECMAScript 5 定义了用来查询和设置对象可扩展性的函数：Object.isExtensible()，如果将对象转换为不可扩展的，需要调用 Object.preventExtensions()，不过一量旦将对象转换为不可扩展的，就无法再转换回去了。&lt;/p&gt;

&lt;p&gt;Object.seal() 和 Object.preventExtensions() 类似，除了能将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的，也就是说不能给对象添加新的属性，已有的属性也不能删除或配置，已封闭（sealed）的对象是不能解封的，可以使用 Object.isSealed() 来检测对象是否封闭&lt;/p&gt;

&lt;p&gt;Object.freeze() 将更严格地锁定对象 —— 「冻结」，它还可以将它自有的所有数据属性设置为只读，可以使用 Object.isFrozen() 来检测对象是否冻结&lt;/p&gt;

&lt;h2 id=&#34;序列化对象&#34;&gt;序列化对象&lt;/h2&gt;

&lt;p&gt;对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript 5 提供了内置函数 JSON.stringify 和 JSON.parse() 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON的全称是「JavaScript Object Notation」—— JavaScript 对象表示法，正如其名，它的语法和 JavaScript 对象与数组直接量的语法非常相近&lt;/p&gt;

&lt;p&gt;ECMAScript 3 环境中可以引用 &lt;a href=&#34;https://github.com/douglascrockford/JSON-js&#34;&gt;json2&lt;/a&gt; 类库来支持这两个序列化函数&lt;/p&gt;

&lt;p&gt;JSON 语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值，函数、RegExp、Error 对象和 undefined 值不能序列化和不愿。JSON.stringify() &lt;strong&gt;只能序列化对象可枚举的自有属性&lt;/strong&gt;，关于 JSON 对象更多 API 可以参考 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify&#34;&gt;JSON.stringify&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;对象方法&#34;&gt;对象方法&lt;/h2&gt;

&lt;h3 id=&#34;tostring-方法&#34;&gt;toString() 方法&lt;/h3&gt;

&lt;p&gt;toString() 方法没有参数，在需要将对象转换为字符串的时候，JavaScript 都调用这个方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var s = { x: 1, y: 1 }
s.toString();       // =&amp;gt; &amp;quot;[object Ojbect]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tolocalestring-方法&#34;&gt;toLocaleString() 方法&lt;/h3&gt;

&lt;p&gt;返回一个对象的本地化字符串。Object 中默认的 toLocaleString() 方法并不做任何本地化自身操作，它仅调用 toString() 方法并返回值。Date 和 Number 类对 toString() 方法做了定制，可以用它对数字、日期和时间做本地化的转换&lt;/p&gt;

&lt;h3 id=&#34;tojson-方法&#34;&gt;toJSON() 方法&lt;/h3&gt;

&lt;p&gt;Object.prototype 实际上不有定义 toJSON() 方法，但对于需要执行序列化的对象来说，JSON.stringify() 方法会调用 toJSON() 方法，如果存在则调用它，返回值即是序列化的结果，而不是原始对象，参见 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toJSON&#34;&gt;Date.toJSON&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;valueof-方法&#34;&gt;valueOf() 方法&lt;/h3&gt;

&lt;p&gt;valueOf() 和 toString() 方法非常类似，但往往当 JavaScript 需要 &lt;strong&gt;将对象转换为某种原始值而非字符串&lt;/strong&gt; 的时候才会用到它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript 就会自动调用这个方法，同样有些内置类自定义了 valueOf() 方法，比如 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/valueOf&#34;&gt;Date.valueOf&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 7 - 数组</title>
      <link>https://keelii.github.io/2016/06/23/javascript-definitive-guide-note-6/</link>
      <pubDate>Thu, 23 Jun 2016 19:10:28 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/06/23/javascript-definitive-guide-note-6/</guid>
      <description>&lt;p&gt;数组是值的 &lt;strong&gt;有序集合&lt;/strong&gt;。每个值（任意 JavaScript 数据类型）叫做一个元素，元素在数组中的位置叫索引。JavaScript 数组是无/弱类型的（untyped），数组元素可以是任意类型&lt;/p&gt;

&lt;p&gt;JavaScript 数组是 &lt;strong&gt;动态的&lt;/strong&gt;，根据需要它们会增长或缩减，创建的时候不须要声明一个固定的大小&lt;/p&gt;

&lt;p&gt;JavaScript 数组可能是 &lt;strong&gt;稀疏的&lt;/strong&gt;，数组元素索引不一定要连续&lt;/p&gt;

&lt;p&gt;JavaScript 数组是 JavaScript 对象的特殊形式。数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要 &lt;strong&gt;快很多&lt;/strong&gt;
&lt;/p&gt;

&lt;h2 id=&#34;创建数组&#34;&gt;创建数组&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var empty = [];             // 使用数组直接量创建一个空数组
var primes = [2, 3, 5, 7, 11];
var base = 1024；
var misc = [1.2, true, &amp;quot;a&amp;quot;, base + 1, [1,2,3], { a: 1}]     // 元素可以是任意值，甚至表达式
var count = [1, ,3];            // 数组有三个元素中间那个值为 undefined

var a = new Array();        // 调用构造函数 Array() 也可以创建数组
var a = new Array(10);
a.length;                   // =&amp;gt; 10 创建一个长度为 10 的数组
var a = new Array(1, 2, 3);
a;                          // =&amp;gt; [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数组元素的读和写&#34;&gt;数组元素的读和写&lt;/h2&gt;

&lt;p&gt;使用方括号 [] 操作符来访问数组中的一个元素，方括号左边是数组的引用，右边是一个返回 &lt;strong&gt;非负整数值&lt;/strong&gt; 的任意表达式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [&amp;quot;world&amp;quot;];
a[0]                    // =&amp;gt; &amp;quot;world&amp;quot;
a[1] = 3.14             // =&amp;gt; 写入第 1 个元素 3.14
a                       // =&amp;gt; [&amp;quot;world&amp;quot;, 3.14]
i = 2;
a[i] = 3;               // =&amp;gt; 写入第 2 个元素
a[i+1] = &amp;quot;hello&amp;quot;;       // =&amp;gt; 写入第 2 个元素
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用负数或者非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样如果如果凑巧使用了非负整数的字符串，它就当做数组索引，而非对象属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a[-1.23] = true             // 给数组 a 创建一个名为 &amp;quot;-1.23&amp;quot; 的属性
a[&amp;quot;1000&amp;quot;] = 0               // 这是数组的第 1001 个元素
a[1.000]                    // 和 a[1] 相等
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组 &lt;strong&gt;没有越界&lt;/strong&gt; 错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到 undefined 值，这一点类似于对象&lt;/p&gt;

&lt;h2 id=&#34;稀疏数组-sparse-arrays&#34;&gt;稀疏数组（Sparse Arrays）&lt;/h2&gt;

&lt;p&gt;通常，数组的 length 属性代表数组中的元素个数。如果是稀疏数组，length 属性值大于元素个数。当在数组直接量中省略值是不会创建稀疏数组。省略的元素是存在的只是值为 undefined。使用 Array() 构造函数或者手动指定 length 大于当前的数组可以创建稀疏数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a = new Array(5);       // 数组没元素，但 a.length 是 5
a = [];
a[1000] = 0;            // 赋值添加一个元素，但设置 length 为　1001
var a1 = [,,,];         // 数组是 [undefined, undefined, undefined]
var a2 = new Array(3);
var a3 = [1,,3];
0 in a1                 // =&amp;gt; true 非稀疏数组
0 in a2                 // =&amp;gt; false 稀疏数组
1 in a3                 // =&amp;gt; false 稀疏数组
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在一些旧版的实现中，[1,,3] 和 [1, undefined, 3] 却是一模一样的&lt;/p&gt;

&lt;h2 id=&#34;数组的长度&#34;&gt;数组的长度&lt;/h2&gt;

&lt;p&gt;每个数组都有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密数组，length 属性值代表数组中元素的个数，其值比数组中最大的索引大 1&lt;/p&gt;

&lt;p&gt;数组有两个 &lt;strong&gt;特殊行为&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果为一个数组元素赋值，它的索引 i 大于或者等于现有数组的长度时，length 属性的值将设置为 i + 1&lt;/li&gt;
&lt;li&gt;如果设置一个数组的 length 属性小于这个数组长度的非负整数 n 时，当前数组中那些索引值大于或等于 n 的元素将被从中删除&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a = [1,2,3,4,5];
a.length = 3;
a                   // =&amp;gt; [1,2,3]
a.length = 0;
a.length = 5;       // 长度为 5，类似 new Array(5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数组也继承了对象的一些方法，比如 Object.defineProperty(), 可以使用这个方法让数组的 length 属性变成只读&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a = [1,2,3]
Object.defineProperty(a, &amp;quot;length&amp;quot;, {
    writable: false
});
a.length = 0
a                   // =&amp;gt; [1,2,3] 不会改变
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数组元素的添加和删除&#34;&gt;数组元素的添加和删除&lt;/h2&gt;

&lt;p&gt;可以给新的索引赋值来添加元素，也可以调用 Array 对象的内置方法 push() 来在数组 &lt;strong&gt;末尾&lt;/strong&gt; 增加一个或者多个元素，或者用 unshift() 给数组头部插入一个元素，并且将其它元素依次移动到更高的索引处&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a = []
a[0] = &amp;quot;zero&amp;quot;
a[1] = &amp;quot;one&amp;quot;
a               // =&amp;gt; [&amp;quot;zero&amp;quot;, &amp;quot;one&amp;quot;]

a = []
a.push(&amp;quot;zero&amp;quot;)
a.push(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;)
a               // =&amp;gt; [&amp;quot;zero&amp;quot;, &amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;]
a.unshift(0)
a               // =&amp;gt; [0, &amp;quot;zero&amp;quot;, &amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用 delete 运算符来删除数组元素，效果和对数组元素赋值 undefined 类似，使用 delete 删除数组后数组的长度是不变的&lt;/p&gt;

&lt;h2 id=&#34;数组遍历&#34;&gt;数组遍历&lt;/h2&gt;

&lt;p&gt;使用 for 循环是遍历数组元素最常见的方法，for/in 也可以但并不推荐&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var keys = Object.keys(o);
var values = [];
for (var i = 0; i &amp;lt; keys.length; i++) {
    var key = keys[i];
    values[i] = o[key]
}

for (var i = 0; i &amp;lt; keys.length; i++) {
    if (!a[i]) continue;    // 跳过 null, undefined 和不存在的元素
}
for (var i = 0; i &amp;lt; keys.length; i++) {
    if (!(i in a)) continue;    // 只跳过不存在的元素
}
for (var i in a) {
    if (!a.hasOwnProperty(i)) continue; // 跳过继承属性
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ECMAScript 5 定义了一些遍历数组元素的新方法，比如 forEach()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1,2,3,4,5].forEach(function(x) {
    console.log(x);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;多维数组&#34;&gt;多维数组&lt;/h2&gt;

&lt;p&gt;JavaScript 并不支持真正的多维数组，但可以模拟出来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var table = new Array(10);
for (var i = 0; i &amp;lt; table.length; i++) {
    table[i] = new Array(10);
}

for (var row = 0; row &amp;lt; table.length; row++) {
    for (var col = 0; col &amp;lt; table[row].length; col++) {
        table[row][col] = row * col;
    }
}

table[5][7];        // =&amp;gt; 35
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数组方法&#34;&gt;数组方法&lt;/h2&gt;

&lt;p&gt;将所有元素都转化为字符串并通过分隔符链接起来，分隔符默认是逗号「,」&lt;/p&gt;

&lt;p&gt;与之相反的 split 方法则是把字符串按分割符分割开来并返回数组，并且分割符可以是正则表达式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [1,2,3];
a.join();               // =&amp;gt; &amp;quot;1,2,3&amp;quot;
a.join(&amp;quot; &amp;quot;)             // =&amp;gt; &amp;quot;1 2 3&amp;quot;
a.join(&amp;quot;&amp;quot;)              // =&amp;gt; &amp;quot;123&amp;quot;
new Array(10).join(&#39;-&#39;) // =&amp;gt; &amp;quot;----------&amp;quot;

var str = &amp;quot;Hello world&amp;quot;;
str.split(&#39; &#39;)          // =&amp;gt; [&amp;quot;Hello&amp;quot;, &amp;quot;world&amp;quot;]
var str = &amp;quot;0a1b2c3d&amp;quot;;
str.split(/\d/g);       // =&amp;gt; [&amp;quot;&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reverse&#34;&gt;reverse()&lt;/h3&gt;

&lt;p&gt;反转数组元素&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [1,2,3];
a.reverse();        // =&amp;gt; [3,2,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sort&#34;&gt;sort()&lt;/h3&gt;

&lt;p&gt;将数组中的元素排序并返回排序后的数组。不带参数调用 sort() 时，数组元素以字母表顺序排序，如果数组包含 undefined 元素，它们会被排到数组的尾部&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [&amp;quot;banana&amp;quot;, &amp;quot;cherry&amp;quot;, &amp;quot;apple&amp;quot;]
a.sort();               // =&amp;gt; [&amp;quot;apple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;cherry&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sort 方法可以接收一个函数参数，该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小于 0 的数值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [3,4,1,2]
a.sort()            // [1,2,3,4]
a.sort(function(a, b) {
    return b - a
})                  // [4,3,2,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;concat&#34;&gt;concat()&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Array.concat(value1, value2, &amp;hellip;, valueN)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创建并返回一个新数组，它的元素包括调用 concat 的原始数组元素和 concat 的每个参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [1,2,3]
a.concat(4,5)           // =&amp;gt; [1,2,3,4,5]
a.concat([4,5])         // =&amp;gt; [1,2,3,4,5]
a.concat([4,5], [6,7])  // =&amp;gt; [1,2,3,4,5,6,7]
a.concat(4, [5, [6,7]]) // =&amp;gt; [1,2,3,4,5,[6,7]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;slice&#34;&gt;slice()&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Array.slice([begin[, end]])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;返回指定数组的一个片段或子数组，它的两个参数分别指定了片段的开始和结束的 &lt;strong&gt;位置&lt;/strong&gt;，如果只指定一个参数（开始位置），返回的数组将包含从开始位置到数组结尾的所有元素，如果参数中出现了负数，它表示相对于数组中最后一个元素的位置，slice 不会修改原数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [1,2,3,4,5]
a.slice(0, 3)       // =&amp;gt; [1,2,3]
a.slice(3)          // =&amp;gt; [4,5]
a.slice()           // =&amp;gt; [1,2,3,4,5]
a.slice(1, -1)      // =&amp;gt; [2,3,4]
a.slice(-3, -2)     // =&amp;gt; [3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;splice&#34;&gt;splice()&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Array.splice(start, deleteCount[, item1[, item2[, &amp;hellip;]]])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;splice 方法是在数组中插入或删除元素的通用方法，会 &lt;strong&gt;修改&lt;/strong&gt; 调用的数组&lt;/p&gt;

&lt;p&gt;splice 能够从数组中删除元素、插入元素到数组中或者 &lt;strong&gt;同时完成&lt;/strong&gt; 这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其它部分仍然保持连续。splice 第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。splice 返回一个由删除元素组成的数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [1,2,3,4,5,6,7,8]
a.splice(4)             // =&amp;gt; [5,6,7,8]
a                       // =&amp;gt; [1,2,3,4]
a.splice(1,2)           // =&amp;gt; [2,3]
a                       // =&amp;gt; [1,4]
a.splice(1,1)           // =&amp;gt; [4]
a                       // =&amp;gt; [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;splice 前两个参数指定了需要删除的数组元素。其后任意个数参数指定了需要插入到数组中的元素&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [1,2,3,4,5]
a.splice(2, 0, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)        // =&amp;gt; 0
a                               // =&amp;gt; [1,2,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,3,4,5]
a.splice(2, 2, [1,2], 3)        // =&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]
a                               // =&amp;gt; [1,2,[1,2],3,3,4,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;push-和-pop&#34;&gt;push() 和 pop()&lt;/h3&gt;

&lt;p&gt;push 和 pop 方法谲诈将数组当做 &lt;a href=&#34;https://cloud.githubusercontent.com/assets/458894/16374650/f8b0fa6c-3c89-11e6-9e61-bc391f7f3cf4.png&#34;&gt;栈&lt;/a&gt; 来使用，push 方法在数组尾部添加一个或者多个元素，并返回新的数组长度。pop 删除数组的最后一个元素，减小数组长度并返回它删除的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var stack = [];
stack.push(1,2)         // =&amp;gt; 2 stack: [1,2]
stack.pop(1,2)          // =&amp;gt; 1 stack: [2]
stack.push(3)           // =&amp;gt; 2 stack: [1,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unshift-和-shift&#34;&gt;unshift() 和 shift()&lt;/h3&gt;

&lt;p&gt;unshift 在数组的头部添加一个或者多个元素，shift 删除数组的第一个元素并将其返回&lt;/p&gt;

&lt;p&gt;需要注意的是，当使用多个参数调用 unshift() 的时候，参数是一次性插入的，而非一次一个插入。这会影响插入到数组中元素的位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [4,5,6];
a.unshift(3)
a               // =&amp;gt; [3,4,5,6]
a.unshift(1,2)
a               // =&amp;gt; [1,2,3,4,5,6]如果一次一个插入的话结果应该是 [2,1,3,4,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ecmascript-5-的数组方法&#34;&gt;ECMAScript 5 的数组方法&lt;/h2&gt;

&lt;h3 id=&#34;foreach&#34;&gt;forEach()&lt;/h3&gt;

&lt;p&gt;forEach() 从头至尾遍历数组，为每个元素调用指定的函数。传递函数作为 forEach() 的第一个参数，然后 forEach() 使用三个参数调用该当函数：数组元素、元素的索引和数组本身。forEach() 无法在所有元素都传递给调用的函数之前终止遍历，除非 forEach() 方法放在一个 try 块中，并抛出一个异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1,2,3,4,5].forEach(function(value, index, arr) { arr[i] = v + 1 });
// =&amp;gt; [2,3,4,5,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;map&#34;&gt;map()&lt;/h3&gt;

&lt;p&gt;map() 方法将调用数组的每个元素传递给指定的函数，并返回一个数组。如果是稀疏数组，返回的也是相同方式的稀疏数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a = [1,2,3]
b = a.map(function(x) { return x*x })
b               // [1, 4, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filter&#34;&gt;filter()&lt;/h3&gt;

&lt;p&gt;filter() 方法返回数组元素是调用数组的一个 &lt;strong&gt;子集&lt;/strong&gt;。传递的函数是用来逻辑判定的（true 或 false），如果返回 true 或者能转化为 true 的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中，&lt;strong&gt;filter() 会跳过稀疏数组中缺少的元素&lt;/strong&gt;，总是返回稠密的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a = [5,4,3,2,1]
smallvalues = a.filter(function(x) { return x &amp;lt; 3 })    // [2, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;every-和-some&#34;&gt;every() 和 some()&lt;/h3&gt;

&lt;p&gt;数组的逻辑判定，它们对数组元素应用指定的函数进行判定，返回 true 或 false&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a = [1,2,3,4,5]
a.every(function(x) { return x &amp;lt; 10 })      // =&amp;gt; true 数组元素都少于 10
a.some(function(x) { return x%2 === 0 })    // =&amp;gt; true 数组中有一些值是偶数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，一旦 every() 和 some() 确认应该返回什么值时它们就会停止遍历数组元素（可以认为是惰性判断）。即：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;some() 在判定函数第一次返回 true 后就返回 true，不再进行遍历操作&lt;/li&gt;
&lt;li&gt;every() 在判定函数第一次返回 false 后就返回false，不再进行遍历操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;reduce-和-reduceright&#34;&gt;reduce() 和 reduceRight()&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Array.reduce(callback, [initialValue])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;reduct() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值，这在 &lt;strong&gt;函数式编程（functional programming）&lt;/strong&gt; 中是很常见的操作，也可以称为「注入」和「折叠」，他们只是执行化简操作的顺序不一样，一个从左到右，一个从右到左&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [1,2,3,4,5]
var sum = a.reduce(function(x, y) { return x + y }, 0)          // 数组求和
/**
+---------------------------------+
|                                 |
|     x      +     y     return   |
|                                 |
|   init: 0     a[0]: 1    1      |
|                                 |
|     1         a[1]: 2    3      |
|                                 |
|     3         a[2]: 3    6      |
|                                 |
|     6         a[3]: 4    10     |
|                                 |
|     10        a[4]: 5    15     |
|                                 |
+---------------------------------+
*/
var product = a.reduce(function(x, y) { return x * y }, 1)      // 数组求积
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;reduce 需要两个参数。第一个是执行化简操作的函数，它的任意就是用某种方法把两个值组合或化简为一个值，并返回化简后的值，第二个参数是传递给函数的初始值，如果没有指定初始值，它将使用数组的第一个元素作为其初始值。&lt;strong&gt;这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为 x,y&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;indexof-和-lastindexof&#34;&gt;indexOf() 和 lastIndexOf()&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Array.indexOf(searchElement[, fromIndex = 0])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;搜索整个数组中指定值的索引，没找到就返回 -1。indexOf() 从头至尾搜索，而 lastIndexOf() 则反向搜索。它们都接收第二个参数，指定数组中的一个索引，从这个索引处开始搜索&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a = [0,1,2,1,0]
a.indexOf(1)        // =&amp;gt; 1
a.lastIndexOf(1)    // =&amp;gt; 3
a.indexOf(3)        // =&amp;gt; -1

// 在数组中查找所有出现的 x，并返回一个包含匹配索引的数组
function findall(a, x) {
    var results = [];
    var len = a.length;
    var pos = 0;

    while(pos &amp;lt; len) {
        pos = a.indexOf(x, pos);
        if (pos === -1) break;

        results.push(pos)
        pos = pos + 1;
    }

    return results;
}
findall([1,2,3,1,3,2], 1)       // =&amp;gt; [0, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数组类型&#34;&gt;数组类型&lt;/h2&gt;

&lt;p&gt;ECMAScript 5 中可以使用 Array.isArray() 函数来判断是否为数组，在 ECMAScript 5 之前判断却没这么简单，因为 typeof 运算符操作数组返回的是「对象」，一般用下面的方法下判断是否是数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var isArray = Array.isArray || function(o) {
    return typeof o === &amp;quot;object&amp;quot; &amp;amp;&amp;amp;
            Object.prototype.toString.call(0) === &#39;[object Array]&#39;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;类数组对象&#34;&gt;类数组对象&lt;/h2&gt;

&lt;p&gt;JavaScript 数组的一些特性是其他对象没有的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当有新的元素添加到列表中时，自动更新 length 属性&lt;/li&gt;
&lt;li&gt;设置 length 为一个较小值将截断数组&lt;/li&gt;
&lt;li&gt;从 Array.prototype 中继承一些有用的方法&lt;/li&gt;
&lt;li&gt;其类属性为「Array」&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的「元素」&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = {}

var i = 0;
while (i &amp;lt; 10) {
    a[i] = i * i;
    i++;
}
a.length = i;
a               // =&amp;gt; { 0: 0, 1: 1, 2: 4, 3: 9 ..., length: 10 }

// 现在就可以当成真正的数组遍历它
var total = 0;
for (var j = 0; j &amp;lt; a.length; j++) {
    total+=a[j]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguments 对象就是一个类数组对象，DOM 方法 document.getElementsByTagName() 也返回类数组对象，它们都有数组的一些特性，比如索引访问、length 属性，但它们并不是真正的数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function isArrayLike(o) {
    if ( o &amp;amp;&amp;amp;
        typeof o === &amp;quot;object&amp;quot; &amp;amp;&amp;amp;
        isFinite(o.length) &amp;amp;&amp;amp;
        o.length &amp;gt;= 0 &amp;amp;&amp;amp;
        o.length === Math.floor(o.length) &amp;amp;&amp;amp;
        o.length &amp;lt; 4294967296 ) {       // 数组长度的最大值 2^32
        return true;
    } else {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript 数组方法是 &lt;strong&gt;特意定义为通用的&lt;/strong&gt;，它们不仅可以应用在数组而且可以应用在类数组对象上，一般使用 Array.prototype.method.call 来使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = {&amp;quot;0&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;1&amp;quot;: &amp;quot;b&amp;quot;, &amp;quot;2&amp;quot;: &amp;quot;c&amp;quot;, length: 3};
Array.prototype.join.call(a, &amp;quot;+&amp;quot;)           // =&amp;gt; &amp;quot;a+b+c&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;作为数组的字符串&#34;&gt;作为数组的字符串&lt;/h2&gt;

&lt;p&gt;在 ECMAScript 5 中，字符串的行为类似于 &lt;strong&gt;只读&lt;/strong&gt; 的数组。除子用 charAt() 方法来访问单个字符以外，还可以使用方括号：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var s = &amp;quot;test&amp;quot;;
s.charAt(0)         // =&amp;gt; &amp;quot;t&amp;quot;
s.[1]               // =&amp;gt; &amp;quot;e&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串的行为类似于数组的事实使得通用的数组方法可以应用到字符串上。不过请记住，字符串是 &lt;strong&gt;不可变值&lt;/strong&gt;，当把它们作为数组看待时，它们是只读的。所以诸如：push(), sort(), reverse 等 &lt;strong&gt;会修改数组&lt;/strong&gt; 的方法 如果被使用在字符串上是无效的，而且会导致错误并且没有相关提示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;s = &amp;quot;JavaScript&amp;quot;
Array.prototype.join.call(s, &amp;quot; &amp;quot;)       // =&amp;gt; &amp;quot;J a v a S c r i p t&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 4 - 表达式和运算符</title>
      <link>https://keelii.github.io/2016/06/20/javascript-definitive-guide-note-3/</link>
      <pubDate>Mon, 20 Jun 2016 19:10:28 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/06/20/javascript-definitive-guide-note-3/</guid>
      <description>&lt;p&gt;表达式（expression）是 JavaScript 中的一个短语（phrases），JavaScript 解释器会将其计算（evaluate）出一个结果。程序中的常量、变量名、数组访问等都是表达式&lt;/p&gt;

&lt;p&gt;简单表达式组合成复杂表达式最常用的方法就是使用运算符（operator）&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;原始表达式&#34;&gt;原始表达式&lt;/h2&gt;

&lt;p&gt;是最简单的表达式是「原始表达式」（primary expression）。是表达式的 &lt;strong&gt;最小单位&lt;/strong&gt; ———— 不再包含其他表达式。常量、直接量、关键字、变量都是原始表达式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.23
&amp;quot;hello&amp;quot;
/pattern/

true
false
null
this

i
sum
undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;对象和数组的始化表达式&#34;&gt;对象和数组的始化表达式&lt;/h2&gt;

&lt;p&gt;对象和数组的始化表达式实际上是一个新创建的对象和数组，这些表达式有时也称做「对象直接量」和「数组直接量」&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[]
[1+2, 3+4]

var sparseArray = [1,,,,,5]           // 数组分割逗号之前的元素可以省略，空位默认填充 undefined
var matrix = [[1,2,3], [4,5,6], [7,8,9]]

var p = { x: 2.3, y: -1.2}
var q = {}
q.x = 2.3; q.y = -1.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript 对数组始化表达式进行求值的时候，数组初始化表达式中的元素表达式也都会各自计算一次。也就是说，数组初始化表达式每次计算的值有可能是不同的&lt;/p&gt;

&lt;h2 id=&#34;函数定义表达式&#34;&gt;函数定义表达式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var square = function(x) { return x*x }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;属性访问表达式&#34;&gt;属性访问表达式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// expression.identifier
// expression[expression]

var o = { x:1, y:{z:3} };
var a = [0, 4, [5, 6]];
o.x             // =&amp;gt; 1 表达式 o 的 x 属性
o.y.z           // =&amp;gt; 3 表达式 o.y 的属性 z
o[&amp;quot;x&amp;quot;]          // =&amp;gt; 1 对象 o 的 x 属性
a[1]            // =&amp;gt; 4 表达式 a 中索引为 1 的元素
a[2][&amp;quot;1&amp;quot;]       // =&amp;gt; 6 表达式 a[2] 中索引为 1 的元素
a[0].x          // =&amp;gt; 1 表达式 a[0] 的 x 属性
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不管使用哪种形式的属性访问表达式，在「.」和「[」 &lt;strong&gt;之前的表达式总是会首先计算&lt;/strong&gt;。如果计算结果是 null 或者 undefined，表达式会抛出一个类型错误异常，因为这两个值都不能包含任意属性。如果运算结果不是对象（或者数组），JavaScript 会将其转换为对象。如果对象表达式后跟随一对方括号，则会计算方括号内的表达式的值并将它转换为字符串，&lt;strong&gt;不论哪种情况&lt;/strong&gt;，如果命名的属性不存在，那么整个属性访问表达式的值就是 undefined&lt;/p&gt;

&lt;h2 id=&#34;调用表达式&#34;&gt;调用表达式&lt;/h2&gt;

&lt;p&gt;JavaScript 中的调用表达式（invocation expression）是一种调用（或者执行）函数或者方法的语法表示。它以一个函数表达式开始，后面跟随一对圆括号，括号内是一个以逗号隔开的参数列表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;f(0)
Math.max(x, y, z)
a.sort()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;对象创建表达式&#34;&gt;对象创建表达式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;new Object()
new Point(2, 3)

// 如果不需要传入参数给构造函数，圆括号可以省略
new Object
new Date
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;运算符概述&#34;&gt;运算符概述&lt;/h2&gt;

&lt;p&gt;JavaScript 中的运算符用于自述表达式、比较表达式、逻辑表达式、赋值表达式等。大多数运算符都是由标点符号表示的，比如：「+」和「= 」，另外的一些运算符则是由关键字表示的，比如：delete 和 instanceof。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;表4-1&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;A&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;N&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;++&lt;/td&gt;
&lt;td&gt;前/后增量&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;lval→num&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;ndash;&lt;/td&gt;
&lt;td&gt;前/后增量&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;lval→num&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;求反&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;num→num&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;转换为数字&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;num→num&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;按位求反&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;int→int&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;逻辑非&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;bool→bo&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;delete&lt;/td&gt;
&lt;td&gt;删除属性&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;lval→bool&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;typeof&lt;/td&gt;
&lt;td&gt;检测操作数类型&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;any→str&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;td&gt;返回 undefined 值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;any→undef&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;*, /, %&lt;/td&gt;
&lt;td&gt;乘、除、求余&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;num,num→num&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+, -&lt;/td&gt;
&lt;td&gt;加减&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;num,num→num&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;字符串链接&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;str,str→str&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;左移位&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;int,int→int&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;有符号右移&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;int,int→int&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;无符号右移&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;int,int→int&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;, &amp;lt;=,&amp;gt;, &amp;gt;=&lt;/td&gt;
&lt;td&gt;比较顺序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;num,num→bool&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;, &amp;lt;=,&amp;gt;, &amp;gt;=&lt;/td&gt;
&lt;td&gt;比较在字母表中的顺序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;str,str→bool&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;instanceof&lt;/td&gt;
&lt;td&gt;测试对象类&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;obj,func→bool&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;测试属性是否存在&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;str,obj→bool&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;==&lt;/td&gt;
&lt;td&gt;判断相等&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;any,any→bool&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;判断不等&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;any,any→bool&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;===&lt;/td&gt;
&lt;td&gt;判断恒等&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;any,any→bool&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;!==&lt;/td&gt;
&lt;td&gt;判断非恒等&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;any,any→bool&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;按位与&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;int,int→int&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;按位异或&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;int,int→int&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;按位或&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;int,int→int&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;按位与&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;any,any→any&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;td&gt;逻辑或&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;L&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;any,any→any&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;?:&lt;/td&gt;
&lt;td&gt;条件运算符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td&gt;bool,any,any→any&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;变量赋值或对象属性赋值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;lval,any→any&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;*=, /=, %=, += &lt;br&gt; -=, &amp;amp;=, ^=, | = &lt;br&gt; &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=, &amp;gt;&amp;gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;运算且赋值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;lval,any→any&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;操作数的个数&#34;&gt;操作数的个数&lt;/h3&gt;

&lt;p&gt;运算符可以根据操作数的个数进行分类，JavaScript 中的大多数运算符（比如「*」乘法运算符）是一个二元运算符（binary operator），将两个表达式合并成一个稍复杂的表达式。JavaScript 同样支持一元运算符（unary operator），表达式 -x 中的「-」运算符就是一个一元运算符，是将操作数 x 求负值。JavaScript 支持一个三元运算符（ternary operator），条件判断运算符「?:」，它将三个表达式合并成一个表达式&lt;/p&gt;

&lt;h3 id=&#34;操作数的类型和结果类型&#34;&gt;操作数的类型和结果类型&lt;/h3&gt;

&lt;p&gt;JavaScript 运算符通常会根据需要对操作数进行类型转换。乘法运算符「*」希望操作数为籽安，但是表达式 &amp;ldquo;3&amp;rdquo; * &amp;ldquo;5&amp;rdquo; 却是合法的，因为 JavaScript 会将操作数转换为数字。结果是数字类型的 15&lt;/p&gt;

&lt;p&gt;一些运算符对操作数类型有着不同程度的依赖。比如加法运算符「+」可以对数字进行加法，也可以做字符串连接。同样「&amp;lt;」比较运算符可以进行数值大小比较，也可以比较字符在字母表中的次序先后&lt;/p&gt;

&lt;h3 id=&#34;左值-lvalues&#34;&gt;左值（lvalues）&lt;/h3&gt;

&lt;p&gt;左传是一个古老的术语，它指「表达式只能出现在赋值运算符的左侧」。在 JavaScript 中，变量、对象属性、数组元素均是左值，ECMAScript 规范中允许内置函数返回一个左值，但自定义函数则不能&lt;/p&gt;

&lt;h3 id=&#34;运算符的副作用-opreator-side-effects&#34;&gt;运算符的副作用（opreator side effects）&lt;/h3&gt;

&lt;p&gt;计算一个简单的表达式（比如 2*3）不会对程序的运行状态造成任何影响，程序后续执行的计算也不会受到该计算的影响。而有一些表达式则具有很多副作用，赋值运算符是最明显的一个例子：如果给一个变量或者属性赋值，那么那些使用这个变量或者属性的表达式的值都会发生改变。「++」和「&amp;ndash;」与些类似，因为它们包含 &lt;strong&gt;隐式的&lt;/strong&gt; 赋值。delete 运算符同样有副作用删除一个属性就像（但不完全一样）给这个属性赋值 undefined&lt;/p&gt;

&lt;h3 id=&#34;运算符优先级&#34;&gt;运算符优先级&lt;/h3&gt;

&lt;p&gt;如果你不确定你所使用的运算符的优先级，最简单的方法就是使用圆括号来强行指定运算次序&lt;/p&gt;

&lt;h3 id=&#34;运算符的结合性&#34;&gt;运算符的结合性&lt;/h3&gt;

&lt;p&gt;表 4-1 标题为 A 的列说明了运算符的结合性。&lt;strong&gt;L 指从左至右结合，R 指从右至左结合&lt;/strong&gt;。结合性指定了在多个具有同样优先级的运算符表达式中的运算顺序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;w = x - y - z;              // 减法运算符具有从左至右的结合性
x = ~-y                     // 等价于 ~(-y)
w = x = y = z               // 等价于 w = (x = (y = z))
q = a?b:c?d:e?f:g           // 等价于 q = a?b:(c?d:(e?f:g))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运算顺序&#34;&gt;运算顺序&lt;/h3&gt;

&lt;p&gt;运算符优先级和结合性规定了它们在复杂的表达式中的运算顺序，但并没有规定子表达式的计算过程中的运算顺序。JavaScript 总是严格按照从左至右的顺序来计算表达式。例如，在表达式 w = x + y * z 中，将首先计算子表达式 w， 然后计算 x, y 和 z，然后，y,z 相乘，再加上 x 的值，最后赋值给表达式 w 所指代的变量或者属性&lt;/p&gt;

&lt;p&gt;假设存在 a = 1，那么「b = (a++) + a」将如何计算呢？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;计算 b&lt;/li&gt;
&lt;li&gt;计算 a++ （假设为 c）&lt;/li&gt;
&lt;li&gt;计算 a&lt;/li&gt;
&lt;li&gt;计算 c + a&lt;/li&gt;
&lt;li&gt;将 c + a 的结果赋值给 b&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;按照「++」的定义，第 [2] 步中 a++ 的结果依然是 1，即 c 为 1，随后 a 立即增 1， 因此在执行第 [3] 步时，a 的值已经是 2。所以 b 的结果为 3&lt;/p&gt;

&lt;h2 id=&#34;算术表达式&#34;&gt;算术表达式&lt;/h2&gt;

&lt;p&gt;所有那些无法转换数字的操作数都转换为 NaN 值，如果操作数（或者转换结果）是 NaN 值，算术运算的结果也是 NaN。&lt;/p&gt;

&lt;h3 id=&#34;运算符&#34;&gt;「+」运算符&lt;/h3&gt;

&lt;p&gt;加号的转换规则 &lt;strong&gt;优先&lt;/strong&gt; 考虑字符串链接，如果其中一个操作数是字符串或者转换为字符串的对象，另外一个操作数将会转换为字符串，加法将进行字符串的连接操作&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;加法操作符的行为表现为：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果其中一个操作数是对象，则对象会遵循对象到原始值的转换规则转换成原始类值：日期对象通过 toString() 方法执行转换，其它对象则通过 valueOf() 方法执行转换（如果 valueOf 谅坂加一个原始值的话）。由于多数对象都不具备可用的 valueOf() 方法，因为它们会通过 toString() 方法来执行转换&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在进行了对象到原始值的转换后，如果其中一个操作数是字符串的话，另外一个操作数也会被转换为字符串，然后进行字符串连接&lt;/li&gt;
&lt;li&gt;否则，两个操作数都将转换为数字（或者 NaN），然后进行加法操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;1 + 2                   // =&amp;gt; 3
&amp;quot;1&amp;quot; + &amp;quot;2&amp;quot;               // =&amp;gt; &amp;quot;12&amp;quot;
&amp;quot;1&amp;quot; + 2                 // =&amp;gt; &amp;quot;12&amp;quot;
1 + {}                  // =&amp;gt; &amp;quot;1[object Object]&amp;quot;
true + true             // =&amp;gt; 2
2 + null                // =&amp;gt; 2
2 + undefined           // =&amp;gt; NaN

1 + 2 + &amp;quot; blind mice&amp;quot;    // =&amp;gt; &amp;quot;3 blind mice&amp;quot;
1 + (2 + &amp;quot; blind mice&amp;quot;)  // =&amp;gt; &amp;quot;12 blind mice&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一元运算符&#34;&gt;一元运算符&lt;/h3&gt;

&lt;p&gt;一元运算符作用于一个单独的操作数，并产生一个新值。在 JavaScript 中一元运算符有很高的优先级，而且都是 &lt;strong&gt;右结合&lt;/strong&gt;（right-associative），「+」和「-」是一元运算符，也是二元运算符&lt;/p&gt;

&lt;h3 id=&#34;一元加法&#34;&gt;一元加法（+）&lt;/h3&gt;

&lt;p&gt;一元加运算符把操作数转换为数字（或者 NaN），并返回这个转换后的数字。如果操作数本身就是数字，则直接返回这个数字&lt;/p&gt;

&lt;h3 id=&#34;一元减&#34;&gt;一元减（-）&lt;/h3&gt;

&lt;p&gt;当「-」胜仗和一元运算时，它会根据需要把操作数转换为数字，然后改变运算结果的符号&lt;/p&gt;

&lt;h3 id=&#34;递增&#34;&gt;递增（++）&lt;/h3&gt;

&lt;p&gt;递增「++」运算符对其操作数进行增量（加一）操作，操作数是一个左传（lvalue）（变量、数组元素或对象属性）。运算符将操作数转换为数字，然后给数字加 1，并将加 1 后的数值重新赋值给变量、数组或者对象属性&lt;/p&gt;

&lt;p&gt;递增「++」运算符的返回值 &lt;strong&gt;依赖于&lt;/strong&gt; 它相对于操作数的位置。当运算符在操作数之前，称为「前增量」（pre-increment）运算符，它对操作数进行增量计算，并返回计算后的值。当运算符在操作数之后，称为「后增量」（post-increment）运算符，它对操作数进行增量计算，但返回未做增量计算的（unincremented）值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 1, j = ++i;     // i,j 都是 2
var i = 1, j = i++;     // i 是 2， j 是 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;递减&#34;&gt;递减（&amp;ndash;）&lt;/h3&gt;

&lt;p&gt;同递增&lt;/p&gt;

&lt;h3 id=&#34;位运算符&#34;&gt;位运算符&lt;/h3&gt;

&lt;p&gt;位运算符可以对由数字表壳的二进制数据进行更低层级的按位运算&lt;/p&gt;

&lt;p&gt;位运算要求它的操作数是整数，这些整数表示为 32 位整数而不是 64 位。必要时运算符先将操作数转换为数字，并将数字强制表示为 32 位整型，这时会魅力原格式中的小数部分和任何超过 32 位的二进制位。移位运算符要求右操作数在 0 ~ 31 之前。在将其操作数转换为无符号的 32 位整数后，它们将作序第 5 位之后的二进制位，以便生成一个位数正确的数字。需要注意的是，位运算符会将 NaN, Infinity, -Infinity 都转换为 0&lt;/p&gt;

&lt;h2 id=&#34;关系表达式&#34;&gt;关系表达式&lt;/h2&gt;

&lt;h3 id=&#34;相等和不等运算符&#34;&gt;相等和不等运算符&lt;/h3&gt;

&lt;p&gt;「==」和「===」运算符用于比较两个值是否相等，两个运算符 &lt;strong&gt;允许任意类型&lt;/strong&gt; 的操作数，如果操作数相等返回 true，否则返回 false。「===」也称为严格相等（strict equality）运算符，有时也称做恒等运算符（identity operator）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;严格相等运算符&lt;/strong&gt;「===」首先计算期操作数的值，然后比较这两个值，比较过程 &lt;strong&gt;没有任何类型转换&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果两个值类型不相同，则它们不相等&lt;/li&gt;
&lt;li&gt;如果两个值都是 null 或著都是 undefined，则它们不相等&lt;/li&gt;
&lt;li&gt;如果两个值都是布尔值 true 或 false，则它们相等&lt;/li&gt;
&lt;li&gt;如果其中一个值是 NaN，或者两个值都是 NaN，则它们不相等。NaN 和其他任何值都不相等，&lt;strong&gt;包括它本身&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果两个值为数字且数值相等。如果一个值为 0，另一个值为 -0，则它们同样相等&lt;/li&gt;
&lt;li&gt;如果两个值为字符串，且所售的对应位上的 16 位数完全相等，则它们相等。如果它们的长度或内容不同，则不相等。&lt;/li&gt;
&lt;li&gt;如果两个引用值指向同一个对象、数组或者函数，则它们是相等的。如果指向不同的对象，则不相等，尽管两个对象可能具有完全一样的属性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;相等运算符&lt;/strong&gt;「==」和恒等类似，但是如果操作数不是同一类型，相等运算符会尝试进行一些类型转换，然后比较：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果两个操作数的类型相同，则和上文所述的严格相等规则一样&lt;/li&gt;
&lt;li&gt;如果两个操作数类型不同，相等操作符也可能会认为它们相等。检测相等规则如下：

&lt;ul&gt;
&lt;li&gt;如果一个值是 null，另一个是 undefined，则它们相等&lt;/li&gt;
&lt;li&gt;如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后比较&lt;/li&gt;
&lt;li&gt;如果其中一个值是 true，则将其转换为 1 再进行比较。false 为 0&lt;/li&gt;
&lt;li&gt;如果一个值是对象，另一个值是数字或者字符串，则使用「转换规则」将对象转换为原始值，然后再比较&lt;/li&gt;
&lt;li&gt;其他不同类型之前的比较均不相等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;比较运算符&#34;&gt;比较运算符&lt;/h3&gt;

&lt;p&gt;比较运算符用来检测两个操作数的大小关系（数值大小或者字母表顺序），例如：&amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=&lt;/p&gt;

&lt;p&gt;比较运算符的操作数可能是任意类型。然而 &lt;strong&gt;只有数字和字符串才能真正执行比较操作&lt;/strong&gt;，因此那些不是数字和字符串的操作都将进行类型转换，规则如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果操作数为对象，那么这个对象将依照「转换规则」转换为原始值&lt;/li&gt;
&lt;li&gt;在对象转换为原始值之后，如果至少有一个操作数不是字符串，那么两个操作数都将转换为数字进行数值比较。0 和 -0 是相等的。Infinity 比其它任何数字都大（除它本身），如果一个操作数是（或者转换后是）NaN，那么比较操作符 &lt;strong&gt;总是&lt;/strong&gt; 返回 false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是，JavaScript 字符串是一个由 16 位整数值组成的序列，字符串的比较也只是两个字符的数值比较。字符串的比较是区分大小写的，所有的大写 ASCII 字母都「小于」小写的 ASCII 字母。比如比较「Zoo」和「aardvark」，结果为 true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;1 + 2               // =&amp;gt; 3
&amp;quot;1&amp;quot; + 2             // =&amp;gt; &amp;quot;12&amp;quot;
&amp;quot;11&amp;quot; &amp;lt; &amp;quot;3&amp;quot;          // =&amp;gt; true 字符串的比较
&amp;quot;11&amp;quot; &amp;lt; 3            // =&amp;gt; false 转换后数字的比较
&amp;quot;one&amp;quot; &amp;lt; 3           // =&amp;gt; false 数字的比较，&amp;quot;one&amp;quot;转换成 NaN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意比较运算符（&amp;lt;=, &amp;gt;=）并没有严格「大、小」于的说法&lt;/p&gt;

&lt;h3 id=&#34;in-运算符&#34;&gt;in 运算符&lt;/h3&gt;

&lt;p&gt;in 运算符希望它的左操作数是一个字符串或者可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为右操作数值的属性名，那么表达式返回 true，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var point = { x:1, y:1 }
&amp;quot;x&amp;quot; in point
&amp;quot;z&amp;quot; in point
&amp;quot;toString&amp;quot; in point
var data = [7,8,9]
&amp;quot;0&amp;quot; in data                 // =&amp;gt; true      data[&amp;quot;0&amp;quot;]
1 in data                   // =&amp;gt; true      data[1]
3 in data                   // =&amp;gt; false     data[3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;instanceof-运算符&#34;&gt;instanceof 运算符&lt;/h3&gt;

&lt;p&gt;instanceof 运算符希望左侧操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回 true，否则返回 false。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var d = new Date();
d instanceof Date;   // =&amp;gt; true
d instanceof Object; // =&amp;gt; true
d instanceof Number; // =&amp;gt; false

var a = [1,2,3];
a instanceof Array   // =&amp;gt; true
a instanceof Object  // =&amp;gt; true
a instanceof RegExp  // =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，&lt;strong&gt;所有的对象都是 Ojbect 的实例&lt;/strong&gt;。当通过 instanceof 判断一个对象是否是一个类的实例的时候，&lt;strong&gt;这个判断也会包含对「父类」&lt;/strong&gt;（superclass）的检测。如果左操作数不是对象的话，instanceof 返回 false。如果右操作数不是函数，则抛出一个类型错误异常&lt;/p&gt;

&lt;h2 id=&#34;逻辑表达式&#34;&gt;逻辑表达式&lt;/h2&gt;

&lt;h3 id=&#34;逻辑与&#34;&gt;逻辑与（&amp;amp;&amp;amp;）&lt;/h3&gt;

&lt;p&gt;如果逻辑与运算符的左操作数转换成逻辑值为假的时候 &amp;amp;&amp;amp; 操作符不会去计算右操作数，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = { x: 1 }
var p = null;
o &amp;amp;&amp;amp; o.x            // =&amp;gt; 1
p &amp;amp;&amp;amp; p.x            // =&amp;gt; null p 是伟假值，因此将其返回，并不计算 p.x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「&amp;amp;&amp;amp;」的行为有时候称做「短路」（short circuiting），我们经常看到很多代码利用这一我来有条件的执行代码，例如下面两条代码完全等价：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (a == b) stop();
(a == b) &amp;amp;&amp;amp; stop;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;逻辑或&#34;&gt;逻辑或（||）&lt;/h3&gt;

&lt;p&gt;|| 会首先计算第一个操作数的值，也就是说会首先计算左侧的表达式。如果计算结果为真值，就返回这个真值。否则，再计算第二个操作数的值，即右侧的表达式，并返回计算结果&lt;/p&gt;

&lt;p&gt;通常我们用「||」来从一组备选表达式中选出第一个真值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var max = max_width || preferences.max_width || 500

function copy(o, p) {
    p = p || {}         // 用来给函数参数添加默认值
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;逻辑非&#34;&gt;逻辑非（!）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 对于 p 和 q 取任意值，这两个等式都永远成立
!(p &amp;amp;&amp;amp; q) === !p || !q
!(p || q) === !p &amp;amp;&amp;amp; !q
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;赋值表达式&#34;&gt;赋值表达式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;i = 0
o.x = 1
(a = b) == 0              // b 的值赋给 a 再进行相等判断

i = j = k = 0;            // 把三个变量寝化为 0
total += sales_tax        // 带操作的赋值运算
total = total + sales_tax // 和上面等价
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;表4-2&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;等价于&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;+=&lt;/td&gt;
&lt;td&gt;a += b&lt;/td&gt;
&lt;td&gt;a = a + b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-=&lt;/td&gt;
&lt;td&gt;a -= b&lt;/td&gt;
&lt;td&gt;a = a - b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;*=&lt;/td&gt;
&lt;td&gt;a *= b&lt;/td&gt;
&lt;td&gt;a = a * b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/=&lt;/td&gt;
&lt;td&gt;a /= b&lt;/td&gt;
&lt;td&gt;a = a / b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;%=&lt;/td&gt;
&lt;td&gt;a %= b&lt;/td&gt;
&lt;td&gt;a = a % b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;a &amp;lt;&amp;lt;= b&lt;/td&gt;
&lt;td&gt;a = a &amp;lt;&amp;lt; b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;a &amp;gt;&amp;gt;= b&lt;/td&gt;
&lt;td&gt;a = a &amp;gt;&amp;gt; b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;a &amp;gt;&amp;gt;&amp;gt;= b&lt;/td&gt;
&lt;td&gt;a = a &amp;gt;&amp;gt;&amp;gt; b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;=&lt;/td&gt;
&lt;td&gt;a &amp;amp;= b&lt;/td&gt;
&lt;td&gt;a = a &amp;amp; b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;|=&lt;/td&gt;
&lt;td&gt;a |= b&lt;/td&gt;
&lt;td&gt;a = a | b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^=&lt;/td&gt;
&lt;td&gt;a ^= b&lt;/td&gt;
&lt;td&gt;a = a ^ b&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;表达式计算&#34;&gt;表达式计算&lt;/h2&gt;

&lt;h3 id=&#34;eval&#34;&gt;eval()&lt;/h3&gt;

&lt;p&gt;eval() 是一个函数，但是它通常被当成运算符。如果一个池娄调用了 eval()，那么解释器将无法对这个函数做进一步的优化。而将 eval() 定义为函数的另一个问题是，它可以被赋予其他的名字：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var f = eval;
var g = f;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eval() 只有一个参数。如果传入的参数不是字符串，它直接返回这个参数。如果参数是字符串，它会把字符串当成 JavaScript 代码进行编译（parse），如果编译失败则抛出一个语法错误（SyntaxError）异常。如果编译成功，则开始执行这段代码，并返回字符串中的最后一个表达式或者语句的值，如果最后一个表达式或者语句没有值，则最终返回 undefined&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;eval() 使用了调用它的变量作用域&lt;/strong&gt; 环境。也就是说，它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样&lt;/p&gt;

&lt;h3 id=&#34;全局-eval&#34;&gt;全局 eval()&lt;/h3&gt;

&lt;p&gt;eval() 具有更改局部变量的能力。ECMAScript 3 标准规定了任何解释器都不允许对 eval() 赋予别名，通过别名调用会抛出一个 EvalError 异常&lt;/p&gt;

&lt;p&gt;实际上，大多数的实现并不是这么做的。当通过别名调用时，eval()  会将其字符串当成顶层的全局代码来执行&lt;/p&gt;

&lt;p&gt;ECMAScript 5 是返回使用 EvalError 的，并且规范了 eval() 的行为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var geval = eval;
var x = &amp;quot;global&amp;quot;, y = &amp;quot;global&amp;quot;;
function f() {
    var x = &amp;quot;local&amp;quot;;
    eval(&amp;quot;x += &#39;changed&#39;&amp;quot;);
    return x
}
function g(){
    var y = &#39;local&#39;;
    geval(&amp;quot;y += &#39;changed&#39;&amp;quot;);
    return y
}

console.log(f(), x);
&amp;quot;changed global&amp;quot;
console.log(g(), y);
&amp;quot;globalchanged&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;严格-eval&#34;&gt;严格 eval()&lt;/h3&gt;

&lt;p&gt;ECMAScript 5 严格模式函数的行为施加了更多的限制，甚至对标识符 eval 的使用也施加了限制。当在严格模式下调用 eval() 时，或者 eval() 执行的代码段以「use strict」指令开始，这里的 eval() 是私有上下文环境中的局部 eval。也就是说，在严格模式下，eval 挂靠的代码段可以查询或者更改局部变量。但不能在局部作用域中定义新的变量或者函数，此外严格模式将「eval」列为保留字，这让 eval() 更像一个运算符。不能用一人上别名覆盖 eval() 函数。并且变量名、函数名、函数参数或者异常捕获的参数都不能取名为「eval」&lt;/p&gt;

&lt;h2 id=&#34;其它运算符&#34;&gt;其它运算符&lt;/h2&gt;

&lt;h3 id=&#34;条件运算符&#34;&gt;条件运算符（?:）&lt;/h3&gt;

&lt;p&gt;条件运算符是 JavaScript 中唯一的个三元运算符（三个操作数）。&lt;/p&gt;

&lt;p&gt;条件运算符的操作数可以是任意类型。第一个操作数当成布尔值，如果它是真值，那么将计算第二个操作数，并返回其计算结果。否则，如果第一个操作数是假值，那么将计算第三个操作数，并返回期计算结果。第二、三个操作数总是会计算其中一个，不可能同时执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;gretting = &amp;quot;hello &amp;quot; + (username ? username : &amp;quot;there&amp;quot;);

// 等价于下面的条件语句
gretting = &amp;quot;hello &amp;quot;;
if (username)
    gretting += username;
else
    gretting += &amp;quot;there&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;typeof-运算符&#34;&gt;typeof 运算符&lt;/h3&gt;

&lt;p&gt;typeof 是一元运算符，放在其单个操作数前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串&lt;/p&gt;

&lt;p&gt;&lt;em&gt;表4-3&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;typeof运算结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;undefined&lt;/td&gt;
&lt;td&gt;&amp;ldquo;undefined&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;&amp;ldquo;object&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;true/false&lt;/td&gt;
&lt;td&gt;&amp;ldquo;boolean&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;任意数字或者NaN&lt;/td&gt;
&lt;td&gt;&amp;ldquo;number&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;任意字符串&lt;/td&gt;
&lt;td&gt;&amp;ldquo;string&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;任意函数&lt;/td&gt;
&lt;td&gt;&amp;ldquo;function&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;任意内置对象（非函数）&lt;/td&gt;
&lt;td&gt;&amp;ldquo;object&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;任意宿主对象&lt;/td&gt;
&lt;td&gt;由编译器各自实现的字符串，但不是&lt;br&gt; &amp;ldquo;undefined&amp;rdquo;, &amp;ldquo;boolean&amp;rdquo;, &amp;ldquo;number&amp;rdquo;, &amp;ldquo;string&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;delete-运算符&#34;&gt;delete 运算符&lt;/h3&gt;

&lt;p&gt;delete 是一元运算符，它用来删除对象属性或者数组元素。就像赋值、递增/减运算符一样，delete 也是有副作用的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = { x: 1, y: 2 }
delete o.x                  // =&amp;gt; true 删除成功
&amp;quot;x&amp;quot; in o                    // =&amp;gt; false 没有 &amp;quot;x&amp;quot; 元素
var a = [1,2,3]
delete a[2]                 // =&amp;gt; true 删除最后一个元素成功
2 in a                      // =&amp;gt; false 不存在 2 这个元素
a.length                    // =&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，删除属性或者数组元素不难舍难分是设置了一个 undefined 值。当删除一个属性时，这个属性将不再存在。庋了一个不存在的属性将返回 undefined，但是可以通过 in 运算符来检测这个属性是否在对象中存在&lt;/p&gt;

&lt;p&gt;delete 希望他的操作数是一个左传，如果它不是左传，那么 delete 将 &lt;strong&gt;不进行任何操作同时返回 true&lt;/strong&gt;。否则，delete 将试图删除这个指定的左传。如果删除不成功，delete 将返回 true。然后并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，用户通过 var 语句声明的变量、function语句声明的函数 也不能删除&lt;/p&gt;

&lt;p&gt;ECMAScript 5 严格模式中，如果 delete 的操作数是非法的，比如变量、函数或者函数参数，delete 操作将抛出一个语法错误（SyntaxError）异常，只有操作数是一个属性访问表达式的时候它才会正常工作。在严格模式下，delete 删除不可配置的属性时会抛出一个错误异常，非严格模式下，不会报错，只是简单地返回了 false&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = { x:1, y: 2 }
delete o.x              // =&amp;gt; true
typeof o.x              // =&amp;gt; &amp;quot;undefined&amp;quot;
delete o.x              // =&amp;gt; true 删除一个不存在的属性
delete o                // =&amp;gt; false 不能删除通过 var 声明的变量

delete 1                // =&amp;gt; true 参数不是一个左值
this.x = 1              // =&amp;gt; 给全局对象一个属性 x，没使用 var
delete x                // =&amp;gt; 试图删除它，在非严格模式下返回 true，严格模式下会抛出异常，这时只能使用 delete this.x
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;void-运算符&#34;&gt;void 运算符&lt;/h3&gt;

&lt;p&gt;void 是一元运算符，它出现在操作数之前，操作数可以是任意类型。这个运算符不经常使用：操作数会照常计算，但忽略计算结果并返回 undefined。由于 void 会忽略操作数的值，因为在操作数具有副作用的时候使用 void 来让程序更具语义&lt;/p&gt;

&lt;p&gt;这个运算符最学用丰客户端的 URL —— javascript: URL 中，在 URL 中写带有副作用的表达式，而 void 则让浏览器不必显示这个表达式的计算结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;javascript: void window.open();&amp;quot;&amp;gt;打开一个窗口&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;逗号运算符&#34;&gt;逗号运算符&lt;/h3&gt;

&lt;p&gt;逗号运算符是二元运算符，它的操作数是任意类型。它首先计算左操作数，然后计算右操作数，最后返回右操作数的值，看下面的示例代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;i = 0, j = 1, k = 2;
// 和下面的代码基本上是等价的
i = 0; j = 1; k = 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总会计算左侧的表达式，但计算结果魅力掉，也就是说只有左侧表达式具有副作用，最常用的场景是 for 循环&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (var i = 0, j = 10; i &amp;lt; j; i++,j--)
    console.log(i+j);
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 1 - 简介</title>
      <link>https://keelii.github.io/2016/06/16/javascript-definitive-guide-note-0/</link>
      <pubDate>Thu, 16 Jun 2016 13:06:13 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/06/16/javascript-definitive-guide-note-0/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;第一章 主要介绍 JavaScript 的大概情况、基本语法。之前没有 JavaScript 基础的看不懂也没关系，后续章节会有进一步的详细说明，我会通读一遍 《&lt;a href=&#34;https://book.douban.com/subject/10549733/&#34;&gt;JavaScript 权威指南&lt;/a&gt;》，然后根据个人的理解整理出来我认为重要的核心概念，同时我也会参考原版英文版 &lt;a href=&#34;http://shop.oreilly.com/product/9780596805531.do&#34;&gt;JavaScript The Definitive Guide&lt;/a&gt;，取一些关键性、重要的单词做补充，以及对原版和译版做的一些勘误&lt;/p&gt;

&lt;p&gt;中文排版指南遵守 &lt;a href=&#34;https://github.com/mzlogin/chinese-copywriting-guidelines&#34;&gt;中文文案排版指北&lt;/a&gt;，欢迎批评批正&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;JavaScript 是面向 web 的编程语言，是一门 &lt;strong&gt;高阶的&lt;/strong&gt;（high-level）、&lt;strong&gt;动态的&lt;/strong&gt;（dynamic）、&lt;strong&gt;弱类型的&lt;/strong&gt;（untyped）&lt;strong&gt;解释型&lt;/strong&gt;（interpreted）编程语言，适合面向对象（oop）和函数式的（functional）编程风格。JavaScript 语法源自 Java 和 C，一等函数（first-class function）来自于 Scheme，它的基于原型继承来自于 Self&lt;/p&gt;

&lt;h2 id=&#34;javascript-的版本&#34;&gt;JavaScript 的版本&lt;/h2&gt;

&lt;p&gt;JavaScript 语言规范由 ECMA 国际发布，版本号一般叫做 ECMAScript x，如：ECMAScript 3, ECMAScript 5, ECMAScript 6，简称 ES x&lt;/p&gt;

&lt;p&gt;Mozilla 发布的 JavaScript 版本一般叫做 JavaScript x.x，如：JavaScript 1.3, JavaScript 1.5&lt;/p&gt;

&lt;p&gt;Micorsoft 发布的 JavaScript 版本一般叫做 &lt;a href=&#34;https://zh.wikipedia.org/wiki/JScript&#34;&gt;JScript&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以这么说 &lt;strong&gt;「Mozilla 和 Micorsoft 开发的浏览器中 JavaScript内核一般都实现了某个 ECMAScript 版本的规范」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JavaScript 语言核心有很多 API，比如：针对字符串、数组、正则、日期。但这些通常不包括输入输出 API（类似网络、存储、图形相关的特性），输入输出 API 一般是由 JavaScript 的宿主环境（host environment）提供的，通常是浏览器&lt;/p&gt;

&lt;h2 id=&#34;javascript-语言核心&#34;&gt;JavaScript 语言核心&lt;/h2&gt;

&lt;h3 id=&#34;变量-赋值&#34;&gt;变量/赋值&lt;/h3&gt;

&lt;p&gt;快速预览下 JavaScript 变量的用法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 双斜线之后内容是单行注释
/* 这是多行注释 */

// 变更是表示值的一个符号名字，通过 var 关键字声明
var x;              // 声明一个变量 x

// 值可以通过等号赋值给变量
x = 0               // 现在变量 x 的值为 0
x                   // =&amp;gt; 0 通过变量获取其值

// JavaScript 支持多种数据类型
x = 1;              // 数字
x = 0.01;           // 整数和实数都是数字（number）类型
x = &amp;quot;hello world&amp;quot;   // 字符串
x = &#39;JavaScript&#39;;   // ...
x = true;           // 布尔值
x = false;          // ...
x = null;           // 是一个特殊的值，意思是「空」
x = undefined;      // 和 null 非常累似

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;对象-数组&#34;&gt;对象/数组&lt;/h3&gt;

&lt;p&gt;JavaScript 中两个非常重要的数据类型是对象和数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 对象是名/值对的集合，或字符串到值映射的集合
var book = {                // 对象由花括号括起来
    topic: &#39;JavaScript&#39;,    // book 对象的属性 topic 的值是 &amp;quot;JavaScript&amp;quot;
    fat: true
};

// 通过「.」或「[]」来访问对象属性
book.topic                  // =&amp;gt; &amp;quot;JavaScript&amp;quot;
book.[&#39;fat&#39;]                // =&amp;gt; true
book.author = &#39;Flanagan&#39;    // 通过赋值给 book 对象创建一个新属性 author

// JavaScript 数组
var primes = [2, 3, 5, 7];
primes[0]                   // =&amp;gt; 2 通过数组下标访问第一个元素
primes.length               // =&amp;gt; 4 数组中元素的个数
primes[4] = 9               // =&amp;gt; 9 添加新元素
primes[6] = 11              // =&amp;gt; 11 此时数组变成 [2, 3, 5, 7, 9, undefined, 11], 长度也变为 7

// 对象数组
var points = [
    { x: 0, y: 0 },
    { x: 1, y: 1 }
];

// 数组对象
var data = {
    listA: [1, 3, 5],
    listB: [2, 4, 6]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;表达式-运算符&#34;&gt;表达式/运算符&lt;/h3&gt;

&lt;p&gt;通过方括号定义数组元素和通过花括号定义对象属性名和值的语法称为 &lt;strong&gt;初始化表达式&lt;/strong&gt;（initializer expression），表达式是 JavaScript 中的一个短语，这个短语可以通过运算得出一个值。通过「.」和「[]」来引用对象属性或数组元素的值就构成一个表达式。上面的代码中注释中箭头（=&amp;gt;）后的值就是表达式的运算结果&lt;/p&gt;

&lt;p&gt;JavaScript 中最常见的表达式写法就是像下面代码一样使用运算符（operator）,运算符作用于操作数，生成一个新的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 最常见的是算术运算符
3 + 2                     // =&amp;gt; 5 加法
3 - 2                     // =&amp;gt; 1 减法
3 * 2                     // =&amp;gt; 6 乘法
3 / 2                     // =&amp;gt; 1.5 除法
points[1].x - points[0].x // =&amp;gt; 1 复杂的操作数运算
&#39;3&#39; + &#39;2&#39;                 // =&amp;gt; &#39;32&#39; 字符串连接

                          // 运算符简写形式
var count = 0;
count++;                  // 自增1
count--;                  // 自减1
count += 2;               // 自加2, 相当于 count = count + 2
count *= 3;               // ...
count                     // =&amp;gt; 6 变量名本身也是表达式

var x = 2, y = 3
x == y                    // =&amp;gt; false
x != y                    // =&amp;gt; true
x &amp;lt; y                     // =&amp;gt; true
x &amp;lt;= y                    // =&amp;gt; true
x == y                    // =&amp;gt; false
&#39;two&#39; == &#39;three&#39;          // =&amp;gt; false
&#39;two&#39; &amp;gt; &#39;three&#39;           // =&amp;gt; true &#39;tw&#39; 在字母表中的索引大于 &#39;th&#39;
false == (x &amp;gt; y)          // =&amp;gt; true

                          // 逻辑运算符
(x == 2) &amp;amp;&amp;amp; (y == 3)      // true
(x &amp;gt; 2) &amp;amp;&amp;amp; (y &amp;lt; 3)        // false
!(x == y)                 // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 JavaScript 中的「短语」是表达式，那么整个句子就称做 &lt;strong&gt;语句&lt;/strong&gt;（statement），以分号结束的行都是一条语句。语句和表达式有很多共同之处&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;粗略了讲，表达式仅仅计算出一个值并不进行其它操作，不会改变程序的运行状态，而语句并不包含一个值（或者说它包含的值我们并不关心），但它们改变了程序运行状态&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;

&lt;p&gt;函数是带有名称（named）和参数的 JavaScript 代码片段，可以一次定义多次调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function plus1(x) {        // 定义了一个名为 plus1 的函数，带有参数 x
    return x + 1;          // 返回一个比传入参数大 1 的数值
}                          // 函数代码块是由花括号包裹起来的部分
plus1(3)                   // =&amp;gt; 4 函数调用结果为 3+1

var square = function(x) { // 函数是一种值，可以赋值给变量
    return x * x;
};

square(plus1(3))           // =&amp;gt; 16 在一个表达式中调用两个函数

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当函数和对象合写在一起时，当函数就变成了「方法」（method）:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 当函数赋值给对象的属性，我们称为「方法」，所有 JavaScript 对象都含有方法
var a = [];             // 创建一个空数组
a.push(1, 2, 3);        // 调用数组的添加元素方法
a.reverse();            // 调用数组的次序反转方法

// 自定义方法
points.dist = function() {
    var p1 = this[0];
    var p2 = this[1];
    var a = p2.x - p1.x;
    var b = p2.y - p1.y;
    return Math.sqrt(a*a + b*b) // 勾股定理，用 Math.sqrt 来计算平方根
}
points.dist();                  // =&amp;gt; 求得两个点之间的距离
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;面向对象&#34;&gt;面向对象&lt;/h3&gt;

&lt;p&gt;JavaScript 中的面向对象特性和传统语言的很大的区别，下面展示一个类用来表示 2D 平面中的几何点，这个类实例化后的对象有一个名为 r() 的方法，可以计算该点到原点的距离：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Point(x, y) {
    this.x = x;
    this.y = y;
}

// 通过给构造函数的 prototype 对象赋值，来给 Point 对象定义方法
Point.prototype.r = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
};

// 使用 new 关键字和构造函数来创建一个实例 p
var p = new Point(1, 1);

// Point 的实例对象 p（以及所有 Point 的实例对象）继承了方法 r()
p.r()               // =&amp;gt; 1.414...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;客户端的-javascript&#34;&gt;客户端的 JavaScript&lt;/h2&gt;

&lt;h3 id=&#34;嵌入到-html-中的-javascript&#34;&gt;嵌入到 HTML 中的 JavaScript&lt;/h3&gt;

&lt;p&gt;JavaScript 代码可以通过 &amp;lt;script&amp;gt; 标签来嵌入到 HTML 文件中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;script src=&amp;quot;外链脚本文件.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;正常 HTML 段落&amp;lt;/p&amp;gt;
    &amp;lt;script&amp;gt;
        // 这里可以写 JavaScript 代码
        // 通过弹出一个圣诞框来询问用户一个问题
        function moveon() {
            var answer = confirm(&#39;准备好了吗？&#39;);
            // 单击「确认」按钮，浏览器会跳转到 jd.com
            if (answer) window.location = &#39;jd.com&#39;;
        }

       setTimeout(moveon, 6000);
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-javascript-操作-dom&#34;&gt;使用 JavaScript 操作 DOM&lt;/h3&gt;

&lt;p&gt;JavaScript 可以通过浏览器提供的 DOM API 来操作 HTML 元素&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 调用 debug 传入字符串，JavaScript 会动态创建一个 HTML 节点并字符串内容显示其中
function debug(msg) {
    var log = document.getElementById(&#39;debuglog&#39;);

    if (!log) {
        log = document.createElement(&#39;div&#39;);
        log.id = &#39;debuglog&#39;;
        log.innerHTML = &#39;&amp;lt;h1&amp;gt; Debug Log &amp;lt;/h1&amp;gt;&#39;;
        document.body.appendChild(log);
    }

    var pre = document.createElement(&#39;pre&#39;);
    var text = document.createTextNode(msg);
    pre.appendChild(text);
    log.appendChild(pre);
}

debug(&#39;this is debug message&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-javascript-操作-css-样式&#34;&gt;使用 JavaScript 操作 CSS 样式&lt;/h3&gt;

&lt;p&gt;JavaScript 可以通过浏览器提供的 DOM API 来操作 HTML 元素，从而影响 CSS 样式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 设置元素的 CSS 属性 display/visiblity
function hide(el, reflow) {
    if (reflow) {
        el.style.display = &#39;none&#39;;    // 隐藏元素
    } else {
        el.style.visibility = &#39;hide&#39;; // 隐藏元素，但元素仍然占空间
    }
}
// 设置 HTML 元素的 class 属性，class 属性可以是多个（空格分割），如：&amp;lt;div class=&amp;quot;c1 c2 c3&amp;quot;&amp;gt;
function highlight(e) {
    if (!e.className) {
        e.className = &#39;hilite&#39;;
    } else {
        e.className += &#39; hilite&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-javascript-处理事件&#34;&gt;使用 JavaScript 处理事件&lt;/h3&gt;

&lt;p&gt;JavaScript 通过注册事件函数来定义文档/用户的行为，比如：点击，鼠标 hover 等&lt;/p&gt;

&lt;p&gt;给 HTML 元素添加事件处理程序的一种方法是直接给 HTML 元素添加行内的 on[event name]，比如给按钮绑定点击事件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;debug.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;hide.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
Hello
&amp;lt;button onclick=&amp;quot;hide(this, true);debug(&#39;hide button1&#39;)&amp;quot;&amp;gt;Hide1&amp;lt;/button&amp;gt;
&amp;lt;button onclick=&amp;quot;hide(this);debug(&#39;hide button2&#39;)&amp;quot;&amp;gt;Hide2&amp;lt;/button&amp;gt;
World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一种方法是调用元素的 &lt;strong&gt;添加事件处理函数&lt;/strong&gt;，通常是 addEventListener 或 attachEvent（IE专用）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 注册 onload 事件，效果和在 HTML 上写 onload 是一样的
// 不过只有部分 HTML 元素支持，比如： img 标签的 onload
window.onload = function() {
    var images = document.getElementsByTagName(&#39;img&#39;);

    for (var i = 0, l = images.length; i &amp;lt; l; i++) {
        var image = images[i];
        if ( image.addEventListener )
            image.addEventListener(&#39;click&#39;, hide, false);
        else
            image.attachEvent(&#39;onclick&#39;, hide);
    }

    function hide(event) { event.target.style.visibility = &#39;hidden&#39;; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-jquery-库&#34;&gt;使用 jQuery 库&lt;/h3&gt;

&lt;p&gt;使用 jQuery 类库会使 DOM 操作、事件绑定等操作非常方便，而且不用担心浏览器兼容问题（JavaScript api 层面的兼容）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function debug(msg) {
    var $log = $(&#39;#debuglog&#39;);
    if (!$log.length) {
        log = $(&#39;&amp;lt;div id=&amp;quot;debuglog&amp;quot;&amp;gt;&amp;lt;h1&amp;gt;Debug Log&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&#39;);
        log.appendTo(document.body)
    }

    log.append($(&#39;&amp;lt;pre /&amp;gt;&#39;).text(msg))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ECMAScript &lt;a href=&#34;https://zh.wikipedia.org/wiki/ECMAScript&#34;&gt;https://zh.wikipedia.org/wiki/ECMAScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JScript &lt;a href=&#34;https://zh.wikipedia.org/wiki/JScript&#34;&gt;https://zh.wikipedia.org/wiki/JScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 2 - 词法结构</title>
      <link>https://keelii.github.io/2016/06/16/javascript-definitive-guide-note-1/</link>
      <pubDate>Thu, 16 Jun 2016 13:06:13 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/06/16/javascript-definitive-guide-note-1/</guid>
      <description>&lt;p&gt;词法结构（Lexical Structure）是程序语言的一套基础性规则，用来描述如何使用这门语言来编写程序&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;字符集&#34;&gt;字符集&lt;/h2&gt;

&lt;p&gt;JavasSript 程序是用 &lt;a href=&#34;https://zh.wikipedia.org/wiki/Unicode&#34;&gt;Unicode&lt;/a&gt; &lt;strong&gt;字符集&lt;/strong&gt; 编写的，Unicode 是 ASCII 和 Latin-1 的超集，支持几乎所有在用的语言。ECMAScript 3 要求 JavaScript 的实现必须支持 Unicode 2.1 及后续版本，ECMAScript 5 则要求支持 Unicode 3 及其以后的版本&lt;/p&gt;

&lt;h2 id=&#34;区分大小写&#34;&gt;区分大小写&lt;/h2&gt;

&lt;p&gt;JavaScript 是区分大小写的。关键字、变量、函数名和所有的标识符（identifier）都必须采取一致的大小写形式&lt;/p&gt;

&lt;p&gt;需要注意的是 HTML, HTML 5（标签、属性名）并不区分大小写，XHTML 是区分大小写的，但是现代浏览器通常有容错能力，即使标签名、属性名大小写乱用也会正常解析。特别注意 HTML 标签的 &lt;strong&gt;属性值&lt;/strong&gt; 是区分大小写的，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- select 和 Select 是两个不同的 CSS 选择器 --&amp;gt;
&amp;lt;div class=&amp;quot;selector Selector&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;空格-换行和格式控制符号&#34;&gt;空格、换行和格式控制符号&lt;/h2&gt;

&lt;p&gt;JavaScript 会忽略程序中标识（token）之间的空格。多数情况下，JavaScript 会忽略换行符。&lt;/p&gt;

&lt;p&gt;JavaScript 会识别下面的空白字符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;普通空格字符（\u0020）&lt;/li&gt;
&lt;li&gt;水平制表符（\u0009）&lt;/li&gt;
&lt;li&gt;垂直制表符（\u000b）&lt;/li&gt;
&lt;li&gt;换页符（\u000c）&lt;/li&gt;
&lt;li&gt;不中断空白符（\u00a0）&lt;/li&gt;
&lt;li&gt;字节序标记（\ufeff）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript 会识别下面的字符识别为行结束符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;换行符（\u000a）&lt;/li&gt;
&lt;li&gt;回车符（\u000d）&lt;/li&gt;
&lt;li&gt;行分割符（\u2028）&lt;/li&gt;
&lt;li&gt;段分割符（\u2029）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;回车符加换行符在一起被解析为一个单行结束符&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;unicode-转义序列&#34;&gt;Unicode 转义序列&lt;/h2&gt;

&lt;p&gt;在有的计算机硬件和软件里面无法显示 Unicode 字符全集，JavaScript 定义了一种特殊序列，使用 6 个 ASCII 字符来代表任意 16 位 Unicode 内码。这些内码均以 \u 为前缀，其后跟随 4 个十六进制数。这种 Unicode 转义写法可以用在 JavaScript 字符串直接量、正则表达式直接量和标识符（除关键字）中。例如：&lt;/p&gt;

&lt;p&gt;{% raw %}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;quot;\u4F60\u597D\uFF0C\u4E16\u754C&amp;quot; === &amp;quot;你好，世界&amp;quot;   // =&amp;gt; true
// 注意由于 \u 后面的 4 个16进制数并不区分大小写，所以 unicode 码并不区分大小写
&amp;quot;\u4f60\u597d\uff0c\u4e16\u754c&amp;quot; === &amp;quot;你好，世界&amp;quot;   // =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;{% endraw %}&lt;/p&gt;

&lt;p&gt;注意中的 Unicode 码是不会被 JavaScript 转义的&lt;/p&gt;

&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;

&lt;p&gt;注释类似 Java 和 C，多行注释 &lt;strong&gt;不能嵌套&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;{% raw %}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 这是单行注释
/* 这是多行注释 */
/**
 * 这也是多行注释
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;{% endraw %}&lt;/p&gt;

&lt;h2 id=&#34;直接量&#34;&gt;直接量&lt;/h2&gt;

&lt;p&gt;直接量（literal）就是程序中直接使用的数据值&lt;/p&gt;

&lt;p&gt;{% raw %}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;12             // 数字
1.2            // 小数数字
&#39;hello&#39;        // 字符串
true           // 布尔真
false          // 布尔假
/javascript/gi // 正则表达式直接量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;{% endraw %}&lt;/p&gt;

&lt;h2 id=&#34;标识符和保留字&#34;&gt;标识符和保留字&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;标识符&lt;/strong&gt; （indetifiers）就是一个名字，用来对变量和函数命名，JavaScript 标识符必须以字母、下划线（_）或美元符（$）开头&lt;/p&gt;

&lt;p&gt;也可以使用 Unicode 字符全集，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var 你好 = &#39;你&#39;;
var π = 3.14;
你好                // =&amp;gt; &amp;quot;你&amp;quot;
π                   // =&amp;gt; 3.14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;保留字&lt;/strong&gt;（Reserved Words）是 JavaScript 用做自己关键字的标识符，写程序的时候要避免使用这些标识符来命名&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;break delete function return typeof case do if switch var catch else in this void continue false instanceof throw while debugger finally new true with default for null try&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ECMAScript 5 中多保留了这些关键字，未来可能会用到&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;class const enum export extends import super&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面这些关键字在普通 JavaScript 代码中是合法的，但是在严格模式下是保留字：&lt;/p&gt;

&lt;p&gt;implements let private public yield interface package protected static&lt;/p&gt;

&lt;p&gt;JavaScript 中定义了很多全局变量和当函数，要 &lt;strong&gt;避免&lt;/strong&gt; 使用这些名字做变量名或函数名，比如：arguments encodeURI JSON Math 等&lt;/p&gt;

&lt;h2 id=&#34;可选分号&#34;&gt;可选分号&lt;/h2&gt;

&lt;p&gt;通常来说 JavaScript 语句通常用分号（;）分隔，但是多数情况下 JavaScript 解析器会自动添加分号，所以有的程序员不喜欢加分号，如果代码有正确的书写这样也是可行的&lt;/p&gt;

&lt;p&gt;这样两个分号可以省略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = 3;
var b = 4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果写在一行就不能省略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = 3; var b = 4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a
a
=
3
console.log(a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript 将其解析为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a; a = 3; console.log(a);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;一般情况下如果一条语句以「(」、「[」、「/」，「+」或「-」开始，那么它极有可能和前一条语句合在一起解析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Unicode &lt;a href=&#34;https://zh.wikipedia.org/wiki/Unicode&#34;&gt;https://zh.wikipedia.org/wiki/Unicode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>《JavaScript 权威指南》读书笔记 3 - 类型、值和变量</title>
      <link>https://keelii.github.io/2016/06/16/javascript-definitive-guide-note-2/</link>
      <pubDate>Thu, 16 Jun 2016 13:06:13 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/06/16/javascript-definitive-guide-note-2/</guid>
      <description>&lt;p&gt;JavaScript 中的数据类型分为两类：原始类型（primitive type）和对象类型（object type）。原始类型包括数字、字符串和布尔值&lt;/p&gt;

&lt;p&gt;JavaScript 中有两个特殊的原始值：null（空）和 undefined（未定义），它们不是数字、字符串或布尔值。它们通常代表了各自特殊类型的唯一的成员&lt;/p&gt;

&lt;p&gt;除此之外的就是对象了。对象是属性（property）的集合，每个属性都由「名/值对」（值可以是原始值或者对象）构成。JavaScript 对象很多时候也是 JSON/map/hash/dict，只是在不同语言中叫法不一样
&lt;/p&gt;

&lt;p&gt;普通对象是「命名值」的 &lt;strong&gt;无序&lt;/strong&gt; 集合。数组则是一种有序集合对象&lt;/p&gt;

&lt;p&gt;JavaScript 还定义了另一种特殊对象 —— 函数。如果用来初始化（使用 new 运算符）一个新建的对象，我们把这个函数称作 &lt;strong&gt;构造函数&lt;/strong&gt;（constructor）。每个构造函数定义了一类（class）对象 —— 由构造函数初始化的对象组成的集合，常用的 JavaScript 核心类有 Array, Function, Date, RegExp, Error 等&lt;/p&gt;

&lt;p&gt;JavaScript 解释器（interpreter）有自己的内存管理机制，可以自动对内存进行垃圾回收 GC（garbage collection）。当 &lt;strong&gt;不再有任何引用指向一个对象&lt;/strong&gt;，解释器就会自动释放它占用的内存资源&lt;/p&gt;

&lt;p&gt;JavaScript 是一种面向对象的语言，几乎一切皆对象。数据类型本身可以定义方法（method）来使用&lt;/p&gt;

&lt;p&gt;从技术上讲，只有 JavaScript 对象才能拥有方法。然而数字、字符串和布尔值也可以拥有自己的方法。但是 null 和 undefined 是无法拥有方法的值&lt;/p&gt;

&lt;p&gt;JavaScript 数据类型还可以分为：可以拥有方法和不可以拥有方法类型、&lt;strong&gt;可变&lt;/strong&gt;（nutable）类型和 &lt;strong&gt;不可变&lt;/strong&gt;（imutable）类型&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;JavaScript 程序可以更改对象属性值和数组元素的值。数字、布尔值、null 和 undefined 属于不可变类型 —— 比如，修改一个数值的内容本身就说不通。字符串可以看成由字符组成的数组，你可能会认为它是可变的。然而在 JavaScript 中，字符串是不可变的。可以访问字符串任意位置的文本，但不能修改其内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JavaScript 可以自由地进行数据类型转换。比如程序期望使用字符串的地方使用了数字， JavaScript 会自动将数字转换为字符串。期望使用布尔值的地方使用了非布尔值也会自动进行相应转换&lt;/p&gt;

&lt;p&gt;JavaScript 变量是无/弱类型的（untyped）,变量可以被赋予任何类型的值，也可以动态改变不同类型的值。JavaScript 采用 &lt;strong&gt;词法作用域&lt;/strong&gt;（lexical scoping）。不在任何函数内声明的变量称做全局变量（global variable），函数内声明的变量具有函数作用域（function scope），且只在函数内可见&lt;/p&gt;

&lt;h2 id=&#34;数字&#34;&gt;数字&lt;/h2&gt;

&lt;p&gt;JavaScript &lt;strong&gt;不区分&lt;/strong&gt; 整数和浮点数。所有的数字均用浮点数值表示。JavaScript 采用 &lt;a href=&#34;https://zh.wikipedia.org/wiki/IEEE_754&#34;&gt;IEEE 754&lt;/a&gt; 标准定义的 64 位浮点格式表示数字&lt;/p&gt;

&lt;p&gt;当一个数字直接出现在 JavaScript 程序中，我们称为数字直接量（numberic literal）。JavaScript 支持多种格式的籽安直接量。注意，在任何数字直接量前添加负号（-）可以得到它们的负值。但负号是 &lt;strong&gt;一元 &lt;a href=&#34;https://zh.wikipedia.org/wiki/位操作&#34;&gt;求反&lt;/a&gt;&lt;/strong&gt; 运算符，并不是数字直接量语法组成部分&lt;/p&gt;

&lt;h3 id=&#34;整型直接量&#34;&gt;整型直接量&lt;/h3&gt;

&lt;p&gt;十进制整数，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;0
3
1000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;十六进制值，指直接量以「」或为前缀，其后跟随十六进制数串的直接量。十六进制值是 0 ~ 9 之间的数字和 a(A) ~ f(F) 之前的字母构成，a ~ f 的字母对应的表示数字 10 ~ 15&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;0x2Af5         // 8192 + 2560 + 240 + 5 = 10996（十进制）
/*
+-------------------------------------------------+
|                                                 |
|       2          A          F          5        |
|                                                 |
|       3          2          1          0        |
|                                                 |
|    2*16^3      A*16^2     F*16^1     5*16^0     |
|                                                 |
|    2*4096      10*256     15*16       5*1       |
|                                                 |
|     8192   +    2560   +   240    +    5        |
|                                                 |
|       十六进制 2AF5 转换成十进制为10996         |
|                                                 |
+-------------------------------------------------+
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ECMAScript 标准 &lt;strong&gt;不支持&lt;/strong&gt; 八进制直接量，ECMAScript 6 严格模式下不能使用八进制&lt;/p&gt;

&lt;h3 id=&#34;浮点型直接量&#34;&gt;浮点型直接量&lt;/h3&gt;

&lt;p&gt;浮点型直接量可以含有小数点，采用传统实数的写法。此外，还可以使用指数记数法表示浮点型直接量，即在实数后跟字母 e 或 E，后面再跟正负号，其后再加一个整形指数。这种记数方法表示的数值，是由前面的实数乘以 10 的指数次幂，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;3.14
2134.789
.33          // 0.33
6.02e23      // 6.02 乘以 10 的 23 次方
1.47e-32     // 1.47 乘以 10 的负 32 次方
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;javascript-中的算术运算&#34;&gt;JavaScript 中的算术运算&lt;/h3&gt;

&lt;p&gt;JavaScript 中的算术运算在 &lt;strong&gt;溢出&lt;/strong&gt;（overflow）、&lt;strong&gt;下溢&lt;/strong&gt;（underflow）或被零整除时不会报错，当数字运算结果超过了 JavaScript 所能表示的数字上限（溢出），结果为一个特殊的无穷大（infinity）值，相应的也有负无穷大（-infinity）值&lt;/p&gt;

&lt;p&gt;下溢是当运算结果无限接近于零并比 JavaScript 能表示的最小值还小的时候发生的一种情况。这种情况下，JavaScript 将会返回 0。当一个负数发生下溢时，JavaScript 返回一个特殊的值「负零」，这个值几乎和正常的零完全一样&lt;/p&gt;

&lt;p&gt;实零带除在 JavaScript 中并不报错：它会返回正或者负无穷大。但有一个例外，零除以零是没有意义的，这种整除运算结果也是一个非数字（not-a-number）值，用 NaN 表示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;1/0                      // =&amp;gt; Infinity
-1/0                     // =&amp;gt; -Infinity
Number.NEGATIVE_INFINITY // =&amp;gt; -Infinity
Number.MAX_VALUE         // =&amp;gt; 1.7976931348623157e+308
Number.MAX_VALUE + 1     // =&amp;gt; Infinity （经测试在 Chrome 里面并不是）
0/0                      // =&amp;gt; NaN
Number.MIN_VALUE / 2     // =&amp;gt; 0 发生下溢
-Number.MIN_VALUE / 2    // =&amp;gt; -0 负零
-1/Infinity              // =&amp;gt; -0
NaN == NaN               // =&amp;gt; false
isNaN(&#39;hello&#39;)           // =&amp;gt; false
isFinite(123)            // =&amp;gt; true 参数不是 NaN, Infinity 或 -Infinity 时返回 true
isFinite(-1/0)           // =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript 中的非数字值（NaN）和任何值都不相等，包括 NaN，&lt;code&gt;NaN == NaN&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 但是可以使用 isNaN 判断一个值是不是 NaN&lt;/p&gt;

&lt;h3 id=&#34;二进制浮点数和四舍五入错误&#34;&gt;二进制浮点数和四舍五入错误&lt;/h3&gt;

&lt;p&gt;IEEE-754 浮点表示法是一种二进制表示法，但是并不能精确表示十进制分数，在任何使用二进制浮点数的编程语言中都会有这个问题&lt;/p&gt;

&lt;p&gt;下面的代码中 x 和 y 的值非常 &lt;strong&gt;接近&lt;/strong&gt; 彼此和最终正确值。这种计算结果可以用途大多数的计算任务，&lt;strong&gt;这个问题也只有在比较两个值是否相等的时候才会出现&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;0.3 - 0.2           // =&amp;gt; 0.09999999999999998
0.2 - 0.1           // =&amp;gt; 0.1
var x = 0.3 - 0.2;
var y = 0.2 - 0.1;
x == y              // =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;日期和时间&#34;&gt;日期和时间&lt;/h3&gt;

&lt;p&gt;JavaScript 语言核心包括 Date() 构造函数，用来创建表示日期和时间对象，大致使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var then = new Date(2011, 0, 1);                // 2011 年 1 月 1 日
var later = new Date(2011, 0, 1, 17, 10, 30)    // 下午 5 点 10 分 30 秒
var elapsed = now - then;                       // 日期减法：计算时间间隔的毫秒数
later.getFullYear();                            // =&amp;gt; 2011
later.getMonth();                               // =&amp;gt; 0 月份从 0 开始
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;文本&#34;&gt;文本&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;字符串&lt;/strong&gt;（string）是一组 16 位值组成的不可变的有序序列，每个字符通常来自于 Unicode 字符集。字符串的长度（length）是其所含 16 位值的个数。字符串索引从零开始&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;quot;&amp;quot;  // 空字符串
&#39;testing&#39;
&amp;quot;3.14&amp;quot;
&amp;quot;Wouldn&#39;t you prefer O&#39;Reilly&#39;s book?&amp;quot;
&amp;quot;This string\nhas Two lines&amp;quot;  // 显示为两行
&amp;quot;one\
long\
line&amp;quot;   // 显示为单行，但是可以分行书写
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;转义字符&#34;&gt;转义字符&lt;/h3&gt;

&lt;p&gt;JavaScript 中转文字符用反斜线（\）加一个字符表示，比如 \n 就是一个转义字符，表示一个换行符&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;转义字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Unicode&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\o&lt;/td&gt;
&lt;td&gt;NUL 字符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;\u0000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;退格符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;\u0008&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;水平制表符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;\u0009&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;换行符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;\u0009&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;垂直制表符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;\u0009&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;换页符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;\u0009&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;回车符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;\u0009&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\&amp;rdquo;&lt;/td&gt;
&lt;td&gt;双引号&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;\u0009&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\&amp;rsquo;&lt;/td&gt;
&lt;td&gt;单引号&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;\u0009&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;td&gt;反斜线&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;\u0009&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\xXX&lt;/td&gt;
&lt;td&gt;2位十六进制数XX指定的 Latin-1 字符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\uXXXX&lt;/td&gt;
&lt;td&gt;4位十六进制数XX指定的 Unicode 字符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;字符串的使用&#34;&gt;字符串的使用&lt;/h3&gt;

&lt;p&gt;加号（+）运算符作用于字符串表示链接，字符串通过访问 length 属性得到长度&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var s = &amp;quot;hello world&amp;quot;
s.charAt(0)                 // =&amp;gt; &amp;quot;h&amp;quot; 下标为 0 的字符
s.substring(1, 4)           // =&amp;gt; &amp;quot;ell&amp;quot; 下标从 1 ~ 4 的字符
s.slice(1, 4)               // =&amp;gt; &amp;quot;ell&amp;quot; 同上
s.slice(-3)                 // =&amp;gt; &amp;quot;rld&amp;quot; 最后三个字符
s.indexOf(&amp;quot;l&amp;quot;)              // =&amp;gt; 2 字符 l 首次出现的下标
s.lastIndexOf(&amp;quot;l&amp;quot;)          // =&amp;gt; 10 字符 l 最后一次出现的下标
s.split(&amp;quot;, &amp;quot;)               // =&amp;gt; [&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;] 分割字符串
s.replace(&amp;quot;h&amp;quot;, &amp;quot;H&amp;quot;)         // =&amp;gt; &amp;quot;Hello, world&amp;quot; 全文字替换
s.toUpperCase()             // =&amp;gt; &amp;quot;HELLO, WORLD&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一定要记住，在 JavaScript 中字符串是固定不变的，类似 replace() 和 toUpperCase() 的方法都 &lt;strong&gt;返回新字符串&lt;/strong&gt;，原字符串本身并没有发生改变。在 ECMAScript 5 中字符串可以当做只读数组，可以通过下标访问单位字符&lt;/p&gt;

&lt;h3 id=&#34;模式匹配&#34;&gt;模式匹配&lt;/h3&gt;

&lt;p&gt;JavaScript 定义了 RegExp() 构造函数，用来创建表示文本匹配模式的对象。这些模式称为「正则表达式」（regular expression）， JavaScript 采用 Perl 中的正则表达式语法。String 和 RegExp 对象均定义了正则模式匹配、查找和替换的函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/^HTML/                       // 匹配以 HTML 开始的字符串
/[1-9][0-9]*/                 // 匹配一个非零数字，后面是任意个数字
/\bjavascript/i               // 匹配单词「javascript」，忽略大小写

var text = &amp;quot;testing: 1, 2, 3&amp;quot;
var pattern = /\d+/g          // 匹配所有包含一个或者多个数字的实例
pattern.test(text)            // =&amp;gt; true 匹配成功
text.search(pattern)          // =&amp;gt; 9 首次匹配成功的位置
text.match(pattern)           // =&amp;gt; [&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;] 所有匹配组成的数组
text.replace(pattern, &amp;quot;#&amp;quot;)    // =&amp;gt; &amp;quot;testing: #, #, #&amp;quot;
text.split(/\D+/)             // =&amp;gt; [&amp;quot;&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;] 用非数字字符截取字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;布尔值&#34;&gt;布尔值&lt;/h2&gt;

&lt;p&gt;JavaScript 中比较语句的结果通常都是布尔值，布尔值通常用于控制结构中。任意 JavaScript 的值都可以转换成布尔值。所有对象（数组）都会转换成 true, 面这些则都是 false&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;undefined
null
0
-0
NaN
&amp;quot;&amp;quot;     // 空字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;null-和-undefined&#34;&gt;null 和 undefined&lt;/h2&gt;

&lt;p&gt;null 是 JavaScript 语言的关键字，执行 typeof 运算返回 「object」，也就是说，可以将 null 认为是一个特殊的对象值，含义是「非对象」。但实际上，通常认为 null 是它自有类型的唯一一个成员，它可以表示数字、字符串或对象是「无值」的&lt;/p&gt;

&lt;p&gt;undefined 是一种取值，表明变量没有初始化，如果要查询对象属性或者数组元素的值时返回 undefined 则说明这个属性或者元素不存在。如果函数没有返回任何值，则返回 undefined引用没有提供实参的函数形参的值也只会得到 undefined。&lt;/p&gt;

&lt;p&gt;undefined 不是关键字，是 JavaScript 预定义的全局变量，它的值就是「未定义」。ECMAScript 3 中，undefined 是 &lt;strong&gt;可读/写的变量&lt;/strong&gt;，可以给它赋任意值。这个错误在 ECMAScript 5 中做了修正，变成了只读的。如果执行 typeof 运算得到 undefined 类型，则返回 &amp;ldquo;undefied&amp;rdquo;&lt;/p&gt;

&lt;p&gt;null 和 undefined 都 &lt;strong&gt;不包含任何属性和方法&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;全局对象&#34;&gt;全局对象&lt;/h2&gt;

&lt;p&gt;全局对象的属性是全局定义的符号，JavaScript 程序可以直接使用。当解释器启动时，它将创建一个新的全局对象，并给它一组初始属性：&lt;/p&gt;

&lt;p&gt;全局属性，比如 undefined, Infinity 和 NaN
全局函数，比如 isNaN(), parseInt(), eval()
构造函数，比如 Date(), RegExp(), String(), Object() 和 Array()
全局对象，比如 Math 和 JSON&lt;/p&gt;

&lt;p&gt;全局对象的 &lt;strong&gt;初始属性&lt;/strong&gt; 并不是保留字（可以被污染/重写），但它们应该当做保留字来对待。对于客户端的 JavaScript 来讲，Window 对象定义了一些额外的全局属性&lt;/p&gt;

&lt;h2 id=&#34;包装对象&#34;&gt;包装对象&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var s = &amp;quot;test&amp;quot;, n = 1, b = true;
var S = new String(s);
var N = new Number(N);
var B = new Boolean(b);

s == S                  // =&amp;gt; true
s === S                 // =&amp;gt; false
typeof s                // =&amp;gt; &amp;quot;string&amp;quot;
typeof S                // =&amp;gt; &amp;quot;object&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过 Number() 或 Boolean() 构造函数来显式创建包装对象，JavaScript 会在必要的时候将包装对象转换成原始值。上段代码中的对象 S, N 和 B 常常但不总是表现的和值 s, n 和 b 一样。「==」运算符将原始值和其包装对象视为相等，但「===」全等运算符将它们视为不等，通过 typeof 运算符可以看到原始值和其包装对象的不同&lt;/p&gt;

&lt;h2 id=&#34;不可变的原始值和可变的对象引用&#34;&gt;不可变的原始值和可变的对象引用&lt;/h2&gt;

&lt;p&gt;JavaScript 中原始值（undefined, null, 布尔值，数字和字符串）和对象（包括数组和函数）有着根本的区别，&lt;strong&gt;原始值是不可更改的&lt;/strong&gt;，比如字符串的所有方法都是新返回一个值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var s = &amp;quot;hello&amp;quot;;
s.toUpperCase();    // =&amp;gt; &amp;quot;HELLO&amp;quot;
s                   // =&amp;gt; &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象和原始值不同，首先，它他是 &lt;strong&gt;可变的&lt;/strong&gt; —— 值可以修改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = { x: 1};
o.x = 2;
oxy = 3;

var a = [1,2,3]
a[0] = 0;
a[3] = 4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;对象的比较并非值的比较，即使两个对象包含同样的属性及相同的值&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {x:1}, p = {x:1};
o === p                 // =&amp;gt; false
var a = [], b = [];
a === b                 // =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常将对象𤠕引用类型（reference type）,以此来和 JavaScript 基本类型区分开。按术语的叫法，对象值都是引用（reference）,对象的比较均是引用的比较：&lt;strong&gt;当且仅当它们引用同一个基本对象时，它们才相等&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [];
var b = a;
b[0] = 1;
a[0]        // =&amp;gt; 1 变量 a 也会修改
a === b     // =&amp;gt; true a 和 b 引用一个相同的数组，所以它们相等
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;类型转换&#34;&gt;类型转换&lt;/h2&gt;

&lt;p&gt;JavaScript 中的取值类型非常灵活，从布尔值可以看到这一点：当 JavaScript 期望使用一个布尔值的时候，你可以提供任意类型值， JavaScript 将根据需要自行转换类型。这在其它类型转换中同样适用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;10 + &amp;quot; objects&amp;quot;         // =&amp;gt; &amp;quot;10 objects&amp;quot; 数字 10 转换成字符串
&amp;quot;7&amp;quot; * &amp;quot;4&amp;quot;               // =&amp;gt; 28 两个字符串均转换为数字
var n = 1 - &amp;quot;x&amp;quot;         // =&amp;gt; NaN 字符串 &amp;quot;x&amp;quot; 无法转换为数字
n + &amp;quot; objects&amp;quot;          // =&amp;gt; &amp;quot;NaN objects&amp;quot; NaN 转换为字符串 &amp;quot;NaN&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;常用值转换成对应的类型结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;表3-1&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;字符串&lt;/th&gt;
&lt;th&gt;数字&lt;/th&gt;
&lt;th&gt;布尔值&lt;/th&gt;
&lt;th&gt;对象&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;undefined&lt;/td&gt;
&lt;td&gt;&amp;ldquo;undefined&amp;rdquo;&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;throws TypeError&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;&amp;ldquo;null&amp;rdquo;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;throws TypeError&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;&amp;ldquo;true&amp;rdquo;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;new Boolean(true)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;&amp;ldquo;false&amp;rdquo;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;new Boolean(false)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;rdquo;&amp;rdquo; (空字符串)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;new String(&amp;ldquo;&amp;rdquo;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;ldquo;1.2&amp;rdquo; (非空数字)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1.2&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;new String(&amp;ldquo;1.2&amp;rdquo;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;ldquo;one&amp;rdquo; (非空，非数字)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;new String(&amp;ldquo;one&amp;rdquo;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&amp;ldquo;0&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;new Number(0)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-0&lt;/td&gt;
&lt;td&gt;&amp;ldquo;0&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;new Number(-0)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;&amp;ldquo;NaN&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;new Number(NaN)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Infinity&lt;/td&gt;
&lt;td&gt;&amp;ldquo;Infinity&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;new Number(Infinity)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-Infinity&lt;/td&gt;
&lt;td&gt;&amp;rdquo;-Infinity&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;new Number(-Infinity)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 (无穷大，非零)&lt;/td&gt;
&lt;td&gt;&amp;ldquo;1&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;new Number(1)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;{} (任意对象)&lt;/td&gt;
&lt;td&gt;参考 §3.8.3&lt;/td&gt;
&lt;td&gt;参考 §3.8.3&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[] (任意数组)&lt;/td&gt;
&lt;td&gt;&amp;rdquo;&amp;rdquo;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;1 个数字元素&#34;&gt;9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&amp;ldquo;9&amp;rdquo;&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;其它数组&#34;&gt;&amp;lsquo;a&amp;rsquo;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;use join() method&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;function(){} (任意函数)&lt;/td&gt;
&lt;td&gt;参考 §3.8.3&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;转换和相等性&#34;&gt;转换和相等性&lt;/h3&gt;

&lt;p&gt;以下结果均为 true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;null == undefined
&amp;quot;0&amp;quot; == 0
0 == false
&amp;quot;0&amp;quot; == false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;显式类型转换&#34;&gt;显式类型转换&lt;/h3&gt;

&lt;p&gt;显式类型转换最简单的方法就是使用 Boolean(), Number(), String() 或 Object() 函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Number(&amp;quot;3&amp;quot;)     // =&amp;gt; 3
String(false)   // =&amp;gt; &amp;quot;false&amp;quot;
Boolean([])     // =&amp;gt; true
Object(3)       // =&amp;gt; new Number(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了 null 和 undefined 之外 &lt;strong&gt;任何值&lt;/strong&gt; 都具有 toString() 方法&lt;/p&gt;

&lt;p&gt;JavaScript 中的某些运算符会做隐式的类型转换。如果「+」运算符的一个操作数是字符串，它将会把另外一个操作数转换为字符串。一元「!」运算符将其操作数转换为布尔值并取反&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;x + &amp;quot;&amp;quot;      // 等价于 String(x)
+x          // 等价于 Number(x)
!!x         // 等价于 Boolean(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Number 类型定义的 toString() 方法可以接收表示转换基数的可选参数，默认是基于十进制的，toFixed(), toExponential(), toPrecision() 三个方法都会适当地进行四舍五入或填充 0&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var n = 17
binary_sting = n.toString(2)        // 转换为 &amp;quot;10001&amp;quot;
octal_string = &amp;quot;0&amp;quot; + n.toString(8)  // 转换为 &amp;quot;021&amp;quot;
hex_string = &amp;quot;0x&amp;quot; + n.toString(16)  // 转换为 &amp;quot;0x11&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 Number() 转换函数传入一个字符串，它会试图将其转换为一个整数或浮点数直接量，这个方法只能基于十进制数进行转换，并且不能出现 &lt;strong&gt;非法的尾随字符&lt;/strong&gt;。parseInt() 和 parseFloat() 函数（全局函数，不属于任何类的方法）更加灵活。如果字符前缀是「0x」或「0X」，parseInt() 将其解释为十六进制数，parseInt() 和 parseFloat() 都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略 &lt;strong&gt;后面的内容&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;parseInt(&amp;quot;3 blind mice&amp;quot;)        // =&amp;gt; 3
parseFloat(&amp;quot; 3.14 meters&amp;quot;)      // =&amp;gt; 3.14
parseInt(0xFF)                  // =&amp;gt; 255
parseInt(&amp;quot;0.1&amp;quot;)                 // =&amp;gt; 0
parseInt(&amp;quot;.1&amp;quot;)                  // =&amp;gt; NaN
parseFloat(&amp;quot;$72.47&amp;quot;)            // =&amp;gt; NaN
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;对象转换为原始值&#34;&gt;对象转换为原始值&lt;/h3&gt;

&lt;p&gt;所有对象继承了两个转换方法 toString(), valueOf()&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;toString()&lt;/strong&gt; 的作用是返回一个反映这个对象的字符串&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;({x:1, y:2}).toString()             // =&amp;gt; &amp;quot;[object Object]&amp;quot;
[1,2,3].toString()                  // ==&amp;gt; &amp;quot;1,2,3&amp;quot;
(function(x) { f(x); }).toString()  // =&amp;gt; &amp;quot;function(x) {\n f(x);\n }&amp;quot;
/\d+/g.toString()                   // =&amp;gt; &amp;quot;/\\d+/g&amp;quot;
new Date(2010,0,1).toString()       // =&amp;gt; &amp;quot;Fri Jan 01 2010 00:00:00 GMT+0800 (中国标准时间)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;valueOf()&lt;/strong&gt; 这个方法的作答并未详细定义：如果存在任意原始值，它就默认将对象转换为表示它的原始值。复合值默认返回对象本身&lt;/p&gt;

&lt;p&gt;JavaScript 中对象到字符串的转换经过了如下这些步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果对象具有 toString() 方法，调用后，如果返回一个原始值，JavaScript 将这个值转换为字符串，并返回&lt;/li&gt;
&lt;li&gt;如果没有 toString() 方法，或者这个方法并不返回一个原始值，那么 JavaScript 会调用 valueOf() 方法，如果存在这个方法，则调用它。如果返回值是原始值，就将这个值值的为字符串并返回&lt;/li&gt;
&lt;li&gt;否则，无法从 toString() 和 valueOf() 获得一个原始值，这些将抛出一个类型错误异常&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var now = new Date();
typeof (now +1)             // =&amp;gt; &amp;quot;string&amp;quot; 「+」将日期转换为字符串
typeof (now -1)             // =&amp;gt; &amp;quot;number&amp;quot; 「-」使用对象到数字的转换
now == now.toString()       // =&amp;gt; true
now &amp;gt; (now - 1)             // =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;变量声明&#34;&gt;变量声明&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i;
var sum;
var i, sum;     // 单 var 声明多个变量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果未在 var 声明语句中给变量指定初始值，那么虽然声明了这个变量，但在给它存入一个值之前，它的初始值就是 undefined&lt;/p&gt;

&lt;p&gt;JavaScript 是弱类型语言，变量可以是任意数据类型，下面的写法是合法的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 10;
i = &amp;quot;ten&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;变量作用域&#34;&gt;变量作用域&lt;/h2&gt;

&lt;p&gt;变量作用域（scope）是程序源代码中定义它的区域。在函数体内，局部变量的优先级高于 &lt;strong&gt;同名&lt;/strong&gt; 的全局变量，并且函数内部可以修改外部变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var scope = &amp;quot;global&amp;quot;;
function checkScope() {
  var scope = &#39;local&#39;;
  return scope
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在声明全局变量时可以不使用 var 前缀，但在声明局部变量时 &lt;strong&gt;一定&lt;/strong&gt; 要使用 var&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;scope = &amp;quot;global&amp;quot;;       // 定义一个全局变量
function checkScope2() {
    scope = &#39;local&#39;;
    myscope = &#39;local&#39;;

    return [scope, myscope]
}

checkScope2()           // =&amp;gt; [&#39;local&#39;, &#39;local&#39;]
scope                   // =&amp;gt; &amp;quot;local&amp;quot;
myscope                 // =&amp;gt; &amp;quot;local&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;函数作用域和声明提前-hoisting&#34;&gt;函数作用域和声明提前（Hoisting）&lt;/h3&gt;

&lt;p&gt;像一些类 C 的编程语言中，花括号（{}）内的每一段代码都具有各自的作用域，变量在声明它们的代码段之外是不可见的，我们称为 &lt;strong&gt;块级作用域&lt;/strong&gt;（block scope），而 JavaScript 中没有块级作用域。JavaScript 中使用了 &lt;strong&gt;函数作用域&lt;/strong&gt;（function scope）：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是可以被访问到的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面的代码中，在不同位置定义了变量 i,j 和 k，它们都在同一个作用域内。当调用 &lt;code&gt;test()&lt;/code&gt; if 语句并没有执行，但是变量 j 已经定义却没被始化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function test(o) {
    var i = 0;
    if ( typeof o === &#39;object&#39; ) {
        var j = 0;
        for (var k = 0; k &amp;lt; 10; k++) {
            console.log(k);
        }
        console.log(k);
    }
    console.log(j);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;JavaScript 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。这就意味着变量在声明之前甚至已经可用。JavaScript 的这个被非正式地称为声明提前（hoisting），即 JavaScript 函数里声明的所有变量（不包括赋值）都被「提前」到函数体的顶部 &lt;a href=&#34;http://www.slideshare.net/lijing00333/javascript-engine&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var scope = &amp;quot;global&amp;quot;;
function f() {
    console.log(scope);     // =&amp;gt; undefined
    var scope = &amp;quot;local&amp;quot;;
    console.log(scope);     // =&amp;gt; &amp;quot;local&amp;quot;
}
f();

function b() {
    console.log(scope);     // =&amp;gt; &amp;quot;global&amp;quot;
}
b();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中函数 f 的局部变量 scope 由于 &lt;strong&gt;声明提前&lt;/strong&gt;，代码刚执行进入 f 内部的时候 scope 就被赋值 undefined，这时局部变量优先级高于同名全局变量，所以就返回了 undefined，只有代码执行到 var 的时候 scope 才真正被赋值。所以函数 f 等价于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function f() {
    var scope;
    console.log(scope);     // =&amp;gt; undefined
    scope = &amp;quot;local&amp;quot;;
    console.log(scope);     // =&amp;gt; &amp;quot;local&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也是为什么建议函数体内的变量尽量放在上面，避免造成混乱或者误解&lt;/p&gt;

&lt;h3 id=&#34;作为属性的变量&#34;&gt;作为属性的变量&lt;/h3&gt;

&lt;p&gt;当声明一个 JavaScript 全局变量时，实际上是定义了全局对象的一个属性。当使用 var 声明一个变量时，这个变量是无法通过 delete 运算符删除的。不使用 var 声明的全局变量却是可以被 delete 的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var truevar = 1;
fakevar = 2;                // 不用 var 创建一个全局变量
this.fakevar2 = 3;
delete truevar              // =&amp;gt; false 不可删除
delete fakevar              // =&amp;gt; true
delete this.fakevar2        // =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;作用域链-scope-chain&#34;&gt;作用域链（scope chain）&lt;/h3&gt;

&lt;p&gt;JavaScript 是基于 &lt;strong&gt;词法作用域&lt;/strong&gt;（lexically scoped）的语言：通过阅读包含变量定义在内的源代码就能知道变量的作用域&lt;/p&gt;

&lt;p&gt;每一段 JavaScript 代码（全局代码或函数）都有一个与之关联的作用域链。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码「作用域中」的变量。当 JavaScript 需要查找变量 x 值的时候（这个过程称做「变量解析」（valable resolution）），它会从链中的第一个对象开始查找，如果有则直接使用，如果没有 JavaScript 就会继续查找链上的下一个对象，以此类推。如果作用域名链上没有任何一个对象含有属性 x，那么就认为这段代码的作用域链接上不存在 x，并最终抛出一个引用错误（ReferenceError）异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a();
function a() {
    alert(&#39;1&#39;);
}
a();
function a() {
    alert(&#39;2&#39;);
}
a();
var a = function() {
    alert(&#39;3&#39;);
};
a();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;引用&#34;&gt;引用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;IEEE 754 &lt;a href=&#34;https://zh.wikipedia.org/wiki/IEEE_754&#34;&gt;https://zh.wikipedia.org/wiki/IEEE_754&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;位操作 &lt;a href=&#34;https://zh.wikipedia.org/wiki/位操作&#34;&gt;https://zh.wikipedia.org/wiki/位操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JavaScript Engine &lt;a href=&#34;http://www.slideshare.net/lijing00333/javascript-engine&#34;&gt;http://www.slideshare.net/lijing00333/javascript-engine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>