<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Something]]></title>
  <link href="http://keelii.github.io/categories/javascript/atom.xml" rel="self"/>
  <link href="http://keelii.github.io/"/>
  <updated>2016-09-30T20:11:24+08:00</updated>
  <id>http://keelii.github.io/</id>
  <author>
    <name><![CDATA[keelii]]></name>
    <email><![CDATA[keeliizhou@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript 浏览器事件]]></title>
    <link href="http://keelii.github.io/2016/09/29/javascript-browser-event/"/>
    <updated>2016-09-29T17:22:29+08:00</updated>
    <id>http://keelii.github.io/2016/09/29/javascript-browser-event</id>
    <content type="html"><![CDATA[<h2>JavaScript、浏览器、事件之间的关系</h2>

<p>JavaScript 程序采用了异步事件驱动编程（Event-driven programming）模型，维基百科对它的解释是：</p>

<blockquote><p>事件驱动程序设计（英语：Event-driven programming）是一种电脑程序设计模型。这种模型的程序运行流程是由用户的动作（如鼠标的按键，键盘的按键动作）或者是由其他程序的消息来决定的。相对于批处理程序设计（batch programming）而言，程序运行的流程是由程序员来决定。批量的程序设计在初级程序设计教学课程上是一种方式。然而，事件驱动程序设计这种设计模型是在交互程序（Interactive program）的情况下孕育而生的</p></blockquote>

<!-- more -->


<p>简页言之，在 web 前端编程里面 JavaScript 通过浏览器提供的事件模型 API 和用户交互，接收用户的输入</p>

<p>另一方面用户的行为是不确定的，也就是说不知道用户什么时候发生点击、滚动这些动作。这种场景是传统的同步编程模型没法解决的，因为你不可能等用户操作完了才执行后面的代码</p>

<p>比如我们在 Python 里面调用接收用户输入的方法 <code>raw_input()</code> 后终端就会一直等待用户的输入，直到输入完成才会执行后面的代码逻辑。但是在下面这段 NodeJS 代码中，接收用户输入的方法 <code>process.stdin.read</code> 是在一个事件中调用的。后面的代码不会被阻塞（blocked）</p>

<pre><code class="javascript">'use strict';

process.stdin.on('readable', () =&gt; {
    var chunk = process.stdin.read();
    if (chunk !== null) {
        process.stdout.write(`Async output data: ${chunk}`);
    }
});

process.stdin.on('end', () =&gt; {
    process.stdout.write('end');
});

console.log('Will not be blocked');
</code></pre>

<p>事件驱动程序模型基本的实现原理基本上都是使用 <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">事件循环（Event Loop）</a>，这部分内容涉及浏览器事件模型、回调原理，有兴趣的去链接里面学习下</p>

<p>需要说明的是在客户端 JavaScript 中像 setTimeout, XMLHTTPRequest 这类 API <strong>并不是</strong> JavaScript 语言本身就有的。而是 JavaScript 的宿主环境（在客户端 JavaScript 中就是浏览器），同样像 DOM、BOM、Event API 都是浏览器提供的</p>

<h3>事件绑定的方法</h3>

<h4>DOM 元素行内绑定</h4>

<p>直接在 DOM 元素上通过设置 <code>on + eventType</code> 来绑定事件处理程序</p>

<pre><code class="html">&lt;a href="#none" onclick="alert('clicked.')"&gt;点击我&lt;/a&gt;
</code></pre>

<p>这种绑定方法是最原始的，有两个缺点：</p>

<ol>
<li>事件处理程序和 HTML 结构混杂在一起</li>
</ol>


<p>早期在结构、样式、表现分离的时代被视为最佳实践，现在看来在很多 MVX 框架中将事件绑定和 DOM 结构放在一起处理，这样似乎更方便维护（不用来回切换 HTML,JavaScript 文件），而且也符合可预见（predictable）性的规则</p>

<ol>
<li>命名空间冲突</li>
</ol>


<p>因为 <code>onclick</code> 中的 JavaScript 代码片段执行环境是全局作用域。然而在 JavaScript 语言中并没有相关的命名空间特性。所以就很容易造成命名空间的冲突，非要用这种方法绑定事件的话只能用对象来做一些封装</p>

<h4>古老的绑定方法</h4>

<p>使用 DOM Element 上面的 <code>on + eventType</code> 属性 API</p>

<p>```html
<a href="#none" id="button">click me</a></p>

<script>
    var el = getElementById('button');
    el.onclick = function() { alert('button clicked.') };
    el.onclick = function() { alert('button clicked (Rewrite event handler before).') };
</script>


<pre><code>
这种方法也有一个缺点，因为属性赋值会覆盖原值的。所以无法绑定 **多个** 事件处理函数，如果我们要注册多个 onload 事件处理程序的话就得自己封装一个方法来防止这种事情发生，下面这个例子可以解决这个问题
</code></pre>

<script>
function addLoadEvent(fn) {
    var oldonLoad = window.onload;
    if (typeof oldonLoad !== 'function') {
        window.onload = fn;
    } else {
        window.onload = function() {
            oldonLoad();
            fn();
        }
    }
}

addLoadEvent(function() { alert('onload 1') });
addLoadEvent(function() { alert('onload 2') });
</script>


<pre><code>
注意这只是个示例，生产环境很少会用到。一般用 DOM Ready 就可以了，因为 JavaScript 的执行通常不用等到页面资源全部加载完，DOM 加载完就可以了

#### 现代/标准的绑定方法

标准的绑定方法有两种，`addEventListener` 和 `attachEvent` 前者是标准浏览器支持的 API，后者是 IE 8 以下浏览器支持的 API。通常需要我们做个兼容封装
</code></pre>

<script>
    function addEvent(target, type, handler) {
        if (target.addEventListener) {
            target.addEventListener(type, handler, false);
        } else {
            target.attachEvent('on' + type, handler)
        }
    }

    addEvent(document, 'click', function() { alert(this === document) });
    addEvent(document, 'click', function() { alert(this === document) });
</script>


<pre><code>
上面的例子在 IE 8 以下和标准浏览器的效果是不一样的，问题就在于 `addEventListener` 中的事件回调函数中的 this 指向元素（target）本身，而 `attachEvent` 则指向 `window` 为了修复这个问题上面的 attachEvent 可以做一点小调整让其保持和 `addEventListener` 的效果一样，不过这样的话注册的 handler 就是个匿名函数，无法再移除！
</code></pre>

<script>
    function addEvent(target, type, handler) {
        if (target.addEventListener) {
            target.addEventListener(type, handler, false);
        } else {
            target.attachEvent('on' + type, function() {
                return handler.call(target)
            });
        }
    }

    addEvent(document, 'click', function() { alert(this === document) });
</script>


<pre><code>
当上面这几种情况同时出现的时候就比较有意思了，可以试试下面这段代码的你输出
</code></pre>

<p><a href="javascript:alert(1)" onclick="alert(2)" id="link">click me</a></p>

<script>
    var link = document.getElementById('link');
    link.onclick = function() { alert(3); }

    $('#link').bind('click', function() {
        alert(4);
    });
</script>


<pre><code>
## 事件对象

标准浏览器中在事件处理程序被调用时 **事件对象** 会通过参数传递给处理程序，IE 8 及以下浏览器中事件对象可以通过全局的 `window.event` 来访问。比如我们要获取当前点击的 DOM Element
</code></pre>

<script>
    addEvent(document, 'click', function(event) {
        // IE 8 以下 => undefined
        console.log(event);
    });
    addEvent(document, 'click', function(event) {
        event = event || window.event;
        // 标准浏览器 => [object HTMLHtmlElement]
        // IE 8 以下 => undefined
        console.log(event.target);
        var target = event.target || event.srcElement;

        console.log(target.tagName);
    });
</script>


<pre><code>
## 事件代理

有时候我们需要给 **不存在的**（可能将来会有）的一段 DOM 元素绑定事件，比如给一段 Ajax 请求完成后渲染的 DOM 节点绑定事件。一般绑定的逻辑会在渲染前执行，绑定的时候找不到元素所以并不能成功，当然你也可以把绑定事件的代码放在 Ajax 请求之后。这样做在一些事件逻辑简单的应用里面没问题，但是会加重数据渲染逻辑和事件处理的逻辑耦合。一但事件处理程序特别多的时候，我们通常建议把事件的逻辑和其它代码逻辑分离，这样方便维护。

为了解决这个问题，我们通常使用事件代理/委托（Event Delegation ）。而且通常来说使用 **事件代理的性能会比单独绑定事件高** 很多，我们来看个例子
</code></pre>

<ul id="list">
    <li id="item-1">item1</li>
    <li id="item-2">item2</li>
    <li id="item-3">item3</li>
    <li id="item-4">item4</li>
    <li id="item-5">item5</li>
</ul>


<pre><code>
假如 `ul` 中的 HTML 是 Ajax 异步插入的，通常我们的做法是 插入完成后遍历每个 li 绑定事件处理程序
</code></pre>

<ul id="list"></ul>


<script>
    function bindEvent(el, n) {
        addEvent(lis[i], 'click', function() { console.log(i); });
    }
    // 用 setTimeout 模拟 Ajax 伪代码
    setTimeout(function() {
        var ajaxData = '<li id="item-1">item1</li> <li id="item-2">item2</li> <li id="item-3">item3</li> <li id="item-4">item4</li> <li id="item-5">item5</li>';
        var ul = document.getElementById('list')
        ul.innerHTML(ajaxData);
        var lis = ul.getElementsByTagName('li');

        for (var i = 0; i < lis.length; i++) {
            bindEvent(lis[i], i);
        }
    }, 1000);
</script>


<pre><code>
我们再使用事件代理把事件绑定到 `ul` 元素上，我们知道很多事件可以冒并沿着 DOM 树传播到所有的父元素上，我们只需要判断目标元素是不是我们想绑定的真正元素即可
</code></pre>

<ul id="list"></ul>


<script>
function delegateEvent(el, eventType, fn) {
    addEvent(el, eventType, function(event) {
        event = event || window.event;
        var target = event.target || event.srcElement;
        fn(target);
    });
}

var el = document.getElementById('list');
// 用 setTimeout 模拟 Ajax 伪代码
setTimeout(function() {
    var ajaxData = '<li id="item-1">item1</li> <li id="item-2">item2</li> <li id="item-3">item3</li> <li id="item-4">item4</li> <li id="item-5">item5</li>';
    el.innerHTML(ajaxData)
}, 1000);

delegateEvent(el, 'click', function(target) {
    console.log(target.id);
});
</script>


<pre><code>
显然使用了事件代理之后，代码变少了。逻辑也很清晰，关键是以前需要 N 次的绑定操作现在只需要一次

## jQuery 中的事件绑定

以 jQuery1.6.4 为例，jQuery 提供了很多事件绑定的 API。例如： `delegate()`, `bind()`, `click()`, `hover()`, `one()`, `live()`，这些方法其实都是一些别名，核心是调用了 jQuery 底层事件的 `jQuery.event.add` 方法。其实现也是上文提到的 `addEventListener` 和 `attachEvent` 两个 API

这些 API 主要是为了方便绑定事件的各种场景，并且内部处理好了兼容性问题。还有一个比较好用的地方就是 `事件命名空间`。比如：两个弹出层都向 document 绑定了点击关闭事件，但是如果只想解绑其中一个。这时候使用命名空间再合适不过了。可以试试这个小例子 [Event Binding](http://jsbin.com/sacinereju/edit?html,output)
</code></pre>

<script>
    $(document).bind('click.handler1', function() { console.log(1);})
    $(document).bind('click.handler2', function() { console.log(2);})

    $(document).unbind('click.handler2');   // 解除指定的
    $(document).unbind('click');            // 解除所有点击事件
    $(document).unbind()                    // 解除所有事件
</script>


<p>```</p>

<h2>自定义事件与发布/订阅者设计模式</h2>

<p>自定义事件是设计模式中的 <a href="https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85">发布/订阅者</a> 的一种实现。发布者与订阅者松散地耦合，而且不需要关心对方的存在。<a href="https://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/">这里</a>有 NC 大师的一种实现。实际使用过程中，主要被运用在异步操作比较多的场景和不同系统之间消息通信，之前的<a href="/2016/07/31/something-have-to-say-with-JD-item/#TOC-25">文章</a>中有过一些实例</p>

<h2>引用</h2>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">事件驱动程序设计</a></li>
<li><a href="http://www.quirksmode.org/js/introevents.html">Introduction to Events</a></li>
<li><a href="https://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/">Custom events in JavaScript</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 15 - 脚本化文档]]></title>
    <link href="http://keelii.github.io/2016/08/12/javascript-definitive-guide-note-13/"/>
    <updated>2016-08-12T15:36:59+08:00</updated>
    <id>http://keelii.github.io/2016/08/12/javascript-definitive-guide-note-13</id>
    <content type="html"><![CDATA[<p>每个 Window 对象有一个 document 属性引用了 Document 对象。Document 对象表示窗口的内容，它是一个巨大的 API 中的核心对象，叫做文档对象模型（Document Obejct Model, DOM），用来展示和操作文档内容</p>

<!--more-->


<h2>DOM 概览</h2>

<p>HTML 或 XML 文档的嵌套元素在 DOM 中以「树」的形式展示。HTML 文档的树装结构包含表示 HTML 标签或元素（如 body, p）和表示文本字符串的节点，也可能包含表示 HTML 注释的节点</p>

<pre><code class="html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Simple Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Heading&lt;/h1&gt;
    &lt;p&gt;This is a &lt;i&gt;paragraph&lt;/i&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>置换成 DOM 树表示</p>

<pre><code class="html">
                    +------------+
                    |  Document  |
                    +-----+------+
                          |
                    +-----+------+
                    |   &lt;html&gt;   |
                    +-----+------+
                          |
     +--------------------+--------------------+
     |                                         |
+----+------+                             +----+-----+
|  &lt;head&gt;   |                             |  &lt;body&gt;  |
+----+------+                             +----+-----+
     |                                         |
+----+------+                     +------------+------------+
|  &lt;title&gt;  |                     |                         |
+-----------+                 +----+---+               +---------+
                              |  &lt;h1&gt;  |               |   &lt;p&gt;   |
+------------------+          +--------+               +---------+
| "Simple Document"|                                        |
+------------------+                            +-----------+-----------+
                                                |                       |
                                         +------+--------+         +----+-----+
                                         | "This is a"   |         |   &lt;i&gt;    |
                                         +---------------+         +----+-----+
                                                                        |
                                                                   +----+------+
                                                                   |"paragraph"|
                                                                   +-----------+
</code></pre>

<p>上图中每个方框是文档的一个节点（node），它表示一个 Node 对象。注意树形的根部是 Document 节点，它代表整个文档。代表 HTML 元素的节点是 Element 节点。代表文本的节点是 Text 节点。Document、Element 和 Text 是 Node 的子类</p>

<h2>选取文档元素</h2>

<h3>通过 ID 选择元素</h3>

<p>HTML 元素可以有一个 id 属性，在文档中该值必须 <strong>唯一</strong>，可以使用 getElementById() 方法选取一个基于唯一 ID 的元素</p>

<pre><code class="javascript">var section1 = document.getElementById('selection1');
</code></pre>

<p>在低于 IE 8 版本的浏览器中，<strong>getElementById() 对匹配元素的 ID 不区分大小写，而且也返回匹配 name 属性的元素</strong></p>

<h3>通过名字选取元素</h3>

<pre><code class="javascript">var radiobuttons = document.getElementsByName('favorite_color');
</code></pre>

<p>getElementsByName() 定义在 HTMLDocument 类中，而不在 Document 类中，所以它 <strong>只针对 HTML 文档可用</strong>，XML 中不可用。它返回一个 NodeList 对象，后者的行为类似一个包含若干 Element 对象的只读数组。在 IE 中，也会返回 id 属性匹配指定的元素</p>

<h3>通过标签名选取元素</h3>

<pre><code class="javascript">// 返回所有的 span 标签元素
var spans = document.getElementsByTagName('span');
// 返回所有元素
var allTags = document.getElementsByTagName('*');
// 选取第一个 span 里面的所有 a 标签
// Element 类也定义 getElementsByTagName() 方法，
// 它只取调用该方法的元素（spans）的后代元素
var links = spans[0].getElementsByTagName('a');
</code></pre>

<p>HTMLDocument 对象还定义了两个属性，它们指代特殊的单个元素而不是集合：<code>document.body</code> 是一个 HTML 文档的 <body> 元素；<code>document.head</code> 是 <head> 元素。这些属性总是会定义的。<strong>即使文档中没有 head 或 body 元素，浏览器也将隐式地创建他们</strong></p>

<blockquote><p>getElementsByName() 和 getElementsByTagName() 都返回 NodeList 对象，而类似 document.images 和 document.forms 的属性为 HTMLCollection 对象。
这些对象都是只读类数组对象。有 length 属性，也可以被索引到，也可以进行循环迭代</p></blockquote>

<h3>通过 CSS 类选取元素</h3>

<p>HTML 元素的 class 属性值是一个以空格隔开的列表，可以为空或者包含多个标识符</p>

<pre><code class="javascript">// 查找 class 属性追念 warning 的所有元素
var warnings = document.getElementsByClassName('warning')
</code></pre>

<p>注意除了 IE8 及以下低版本浏览器，getElementsByClassName() 在所有的浏览器中都实现了</p>

<h3>通过 CSS 选择器选取元素</h3>

<p>CSS 样式表有一种非常强大的语法，那就是选择器，用来描述文档中的若干元素</p>

<pre><code class="html">#nav          // id="nav" 的元素
div           // 所有 &lt;div&gt; 元素
.warning      // 所有 class 属性值包含 "warning" 的元素
p[lang="fr"]  // 所有属性 lang 为 fr 的 &lt;p&gt; 元素
*[lang="fr"]  // 所有属性 lang 为 fr 的元素
</code></pre>

<h2>文档结构和遍历</h2>

<h3>作为节点树的文档</h3>

<p>Document 对象、它的 Element 对象和文档中表示文本的 Text 对象都是 Node 对象。Node 对象有以下属性：</p>

<ul>
<li><strong>parentNode</strong> 该节点的父节点，Document 对象没有父节点，它的 parentNode 返回 null</li>
<li><strong>childNodes</strong> 只读的类数组对象（NodeList 对象），表示该节点的所有子节点</li>
<li><strong>firstChild、lastChild</strong> 该节点的子节点中的第一个或最后一个</li>
<li><strong>nextSibling、previoursSibling</strong> 该节点的兄弟节点中的前一个或下一个</li>
<li><strong>nodeType</strong> 该节点的类型

<ul>
<li><strong>11</strong> - DocumentFragment 节点</li>
<li><strong>9</strong> - Document 节点</li>
<li><strong>8</strong> - Comment 节点</li>
<li><strong>3</strong> - Text 节点</li>
<li><strong>1</strong> - Element 节点</li>
</ul>
</li>
<li><strong>nodeVlaue</strong> Text 节点或 Comment 节点的文本内容</li>
<li><strong>nodeName</strong> 元素标签名，以大写形式表示</li>
</ul>


<pre><code class="javascript">// 注意删除了空格和换行
// &lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;
document.childNodes[0].childNodes[1]      // =&gt; body 节点
document.firstChild.firstChild.nextSibling // =&gt; null title 节点的下个兄弟节点为 null
</code></pre>

<h2>属性</h2>

<p>HTML 元素由一个标签和一组称为属性（attribute）的名/值对组成</p>

<h3>HTML 属性作为 Element 的属性</h3>

<pre><code class="javascript">var image = document.getElementById('myimage');
var imgurl = image.src;

var f = document.forms[0];
f.action = 'http://www.example.com/submit.php';
f.method = 'POST';
</code></pre>

<p>HTML 属性名不区分大小写，但是 JavaScript 则区分。用 JavaScript 取元素属性名的时候一般用小写，如果属性名是多个单词用驼峰式的规则，例如：defaultChecked、tabIndex。如果属性是 JavaScript 中的保留字，一般用 html 前缀，比如 for 属性，使用 htmlFor 来访问。class 则不同，使用 className 来访问</p>

<h3>获取和设置非标准 HTML 属性</h3>

<pre><code class="javascript">var image = document.images[0];
// getAttribute 始终返回字符串
var width = parseInt(image.getAttribute('width'))
image.setAttribute('class', 'thumbnail)
</code></pre>

<h3>数据集属性</h3>

<p>有时候在 HTML 元素上绑定一些额外的信息会很有帮助（通常给 JavaScript 来读取），一般可以把信息存储在 HTML 属性上</p>

<p>HTML 5 提供了一个解决文案。在 HTML 5 文档中，任意以「data-」为前缀的小写的属性名称都是合法的。这些「数据集属性」将不会对元素表示产生影响</p>

<p>HTML 5 还在 Element 对象上定义了 dataset 属性。该属性指代一个对象，它的各个属性对应于去掉前缀的 data- 属性。因此 dataset.x 应该保存 data-x 属性的值。带连字符的属性对应于驼峰命名法属性名：data-jquery-test 属性就变成 dataset.jqueryTest 属性</p>

<h3>作为 HTML 的元素内容</h3>

<p>读取 Element 的 innerHTML 属性作为字符串标记返回那个元素的内容。设置元素的 innerHTML 属性则调用 Web 浏览器的解析器，用新的字符串内容解析替换当前内容</p>

<p>通常来说设置 innerHTML 效率很高，但是对 innerHTML 属性使用「+=」操作符时效率比较低下，因为它既要序列化又要解析</p>

<p>HTML 5 还标准化了 outerHTML 属性，表示返回包含标签本身的 HTML 内容</p>

<p>另外 IE 引入了一个 insertAdjacentHTML() 方法，它将任意的 HTML 标记字符串插入到指定的元素「相邻」的位置。标记是该方法的第二个参数。并且「相邻」的精确含义依赖于第一个参数的值。第一个参数为具有以下值之一的字符串：「beforebegin」、「afterbegin」、「beforeend」、「afterend」</p>

<pre><code class="html">    |&lt;div id="target"&gt;|This is the element content|&lt;/div&gt;|
    |                 |                           |      |
 beforebegin     afterbegin                  beforeend afterend
</code></pre>

<h3>作为纯文本的元素内容</h3>

<p>查询线文本形式的元素内容，
标准的方法是 Node 的 textContent 属性</p>

<pre><code class="javascript">var para = document.getElementsByTagName('p')[0]
var text = para.textContent;
para.textContent = 'Hello World!';
</code></pre>

<p>textContent 属性除 IE 其它浏览器都支持，不支持的可以用 innerText 属性来代替。textContent 属性就是将指定元素所有的后代 Text 节点简单地串联在一起。但是和 textContent 不同。innerText 不返回 script 元素的内容，它会忽略多余空白，并试图保留表格格式。同时 innerText 针对某些表格元素（如 table、tbody、tr）是只读的属性</p>

<pre><code class="javascript">function textContente(e) {
    var child, type, s = '';
    for (child = e.firstChild; child != null; child = child.nextSibling ) {
        type = child.nodeType;
        if ( type === 3 || type === 4 )
            s += child.nodeValue;
        else if ( type === 1 )
            s += textContent(child);
    }
    return s;
}
</code></pre>

<h2>创建、插入和删除节点</h2>

<p>一个简单的动态插入脚本的方法</p>

<pre><code class="javascript">function loadasyn(url) {
    var head = document.getElementsByTagName('head')[0];
    var s = document.createElement('script');
    s.src = url;
    head.appendChild(s);
}
</code></pre>

<h3>创建节点</h3>

<pre><code class="javascript">document.createElement('script')
document.createTextNode('text node content')
</code></pre>

<p>还有一种创建新文档节点的方法是复制已存在的节点。第个节点有一个 cloneNode() 方法来返回该节点的一个全新副本。给方法传递参数 true 也能够递归地复制所有后代节点，或传递参数 false 只执行一个浅复制</p>

<h3>插入节点</h3>

<p>下面代码展示了 insertBefore() 和 appendChild() 方法使用场景</p>

<pre><code class="javascript">function insertAt(parent, child, n) {
    if ( n &lt; 0 || n &gt; parent.childNodes.length ) throw new Error('invalid index');
    else if ( n == parent.childNodes.length ) parent.appendChild(child);
    else parent.insertBefore(child, parent.childNodes[n]);
}
</code></pre>

<h3>删除和替换节点</h3>

<p>removeChild() 方法删除一个子节点并用一个新的节点取而代之</p>

<pre><code class="javascript">n.parentNode.removeChild(n);
n.parentNode.replaceChild(document.createTextNode('[ REDACTED ]'), n)
</code></pre>

<h3>使用 DocumentFragment</h3>

<p>DocumentFragment 是一种特殊的 Node，它作为其他节点的一个临时窗口。像这样创建一个 DocumentFragment：</p>

<pre><code class="javascript">var frag = document.createDocumentFragment();
</code></pre>

<p>像 Document 节点一样，DocumentFragment 是独立的，而不是任何其他文档的一部分。它的 parentNode 总是 null。但类似 Element，它可以有任意多的子节点，可以用 appendChild()、insertBefore() 等方法来操作它们</p>

<h2>文档和元素的几何开头和滚动</h2>

<h3>文档坐标和视口坐标</h3>

<p>元素的位置是以像素来表示的，向右代表 X 坐标增加，向下代表 Y 坐标增加。但是，有两个不同的点作为坐标系原点：元素的 X 和 Y 坐标可以相对于文档的左上角或者相对于在其中显示文档的视口左上角。在顶级窗口和标签页中，「视口」只是实际显示文档内容的浏览器的一部分：它 <strong>不包括</strong> 浏览器「外壳」（如菜单、工具条和标签页）。针对框架页中显示的文档，视口是定义了框架页的 iframe 元素。无论在何种情况下，当讨论元素的位置时，必须弄清楚所使用的坐标是文档坐标还是视口（窗口）坐标</p>

<p>如果文档比视口要小，或者说它还未出现滚动，则文档的左上角就是视口的左上角，文档和视口坐标系统是同一个。但是，一般来说，要在两种坐标系之间互相转换，必须加上或者减去滚动的偏移量（scroll offset）</p>

<p>为了在坐标系之间互相转换，我们需要判定浏览器窗口的流动条的位置。Window 对象的 pageXOffset 和 pageYOffset 属性在所有浏览器中提供这些值。除了 IE 8 以及更早的版本以外。也可以使用 scrollLeft 和 scrollTop 属性来获得滚动条的位置。令人迷惑的是，正常情况下通过查询文档的根节点（document.documentElement）来获取这些属性值，但在怪异模式下，必须在文档的 body 元素上查询它们，下面这个是一种兼容方法</p>

<pre><code class="javascript">function getScrollOffsets(w) {
    w = w || window;
    if ( w.pageXOffset != null ) return { x: w.pageXOffset, y: pageYOffset };

    var d = w.document;
    if ( document.compatMode == 'CSS1Compat' )
        return { x: d.documentElement.scrollLeft, y: d.documentElement.scrollTop };

    return { x: d.body.scrollLeft, y: d.body.scrollTop };
}
</code></pre>

<h3>查询元素的尺寸</h3>

<p>判定一个元素的尺寸和位置最简单的方法是调用它的 getBoundingClientRect() 方法。该方法是在 IE 5 中引入的，而珔当前的所有浏览器都实现了（然而并非如此）。它不需要参数，返回一个有 left, right, top 和 bottom 属性的对象</p>

<h3>滚动</h3>

<p>window 对象的 scrollTop() 方法接受一个点的 X 和 Y 坐标，并作为滚动条的偏移量设置它们。也就是窗口滚动到指定的点出现在视口的左上角</p>

<h3>关于元素尺寸、位置和溢出更多的信息</h3>

<p>getBoundingClientRect() 方法在所有当前的浏览器上都有定义，但如果需要支持老式浏览器就不行了。元素的尺寸比较简单：任何 HTML 元素的只读属性 offsetWidth 和 offsetHeight 以 CSS 像素返回它的屏幕尺寸。返回尺寸 <strong>包含</strong> 元素的边框和内边距，除去了外边距</p>

<p>所有 HTML 元素拥有 offsetLeft 和 offsetTop 属性来返回元素的 X 和 Y 坐标。对于很多元素，这些值是文档坐标，并直接指定元素的位置。<strong>但对于已定位的元素的后代元素和一些其他元素（如表格），这些属性返回的坐标是相对于祖先元素的而非文档。</strong> offsetParent 属性指定这些属性所相对的父元素。如果 offsetParent 为 null，这些属性都是文档坐标，因此，一般来说用 offsetLeft 和 offsetTop 来计算元素 e 的位置需要一个循环：</p>

<pre><code class="javascript">function getElementPosition(e) {
    var x = 0, y = 0;
    while (e != null) {
        x += e.offsetLeft;
        y += e.offsetTop;
        e = e.offsetParent;
    }
    return { x: x, y: y };
}
</code></pre>

<p>除了这些名字以 offset 开头的属性外，所有的文档元素定义了其它的两组属性，基名称一组以 client 开头，另一组以 scroll 开头。即，每个 HTML 元素都有以下这些属性：</p>

<pre><code class="html">offsetWidth         clientWidth          scrollWidth
offsetHeight        clientHeight         scrollHeight
offsetLeft          clientLeft           scrollLeft
offsetTop           clientTop            scrollTop
offsetParent
</code></pre>

<p>clientWidth 和 clientHeight 类似 offsetWidth 和 offsetHeight，不同的是它们 <strong>不包含边框大小</strong>，只包含内容和它的内边距。同时，如果浏览器在内边距和边框之间添加了滚动条，clientWidth 和 clientHeight 在其返回值中也不包含滚动条。内联元素，clientWidth 和 clientHeight 总是返回 0</p>

<h2>HTML 表单</h2>

<p><em>表 15-1 HTML 表单元素</em></p>

<table>
<thead>
<tr>
<th> HTML 元素                                                       </th>
<th> 类型属性          </th>
<th> 事件处理程序 </th>
<th> 描述和事件                                                           </th>
</tr>
</thead>
<tbody>
<tr>
<td> &lt;input type=&ldquo;button&rdquo;&gt; or<br> &lt;button type=&ldquo;button&rdquo;&gt; </td>
<td> “button”          </td>
<td> onclick      </td>
<td> 按钮                                                                 </td>
</tr>
<tr>
<td> &lt;input type=&ldquo;checkbox&rdquo;&gt;                                   </td>
<td> “checkbox”        </td>
<td> onchange     </td>
<td> 复选按钮                                                             </td>
</tr>
<tr>
<td> &lt;input type=&ldquo;file&rdquo;&gt;                                       </td>
<td> “file”            </td>
<td> onchange     </td>
<td> 文件域，value 属性只读                                               </td>
</tr>
<tr>
<td> &lt;input type=&ldquo;hidden&rdquo;&gt;                                     </td>
<td> “hidden”          </td>
<td> none         </td>
<td> 数据由表单提交，但对用户不可见                                       </td>
</tr>
<tr>
<td> &lt;option&gt;                                                  </td>
<td> none              </td>
<td> none         </td>
<td> Select 对象的单个选项，事件对象 <br> 在 Select 对象上，而不是 option </td>
</tr>
<tr>
<td> &lt;input type=&ldquo;password&rdquo;&gt;                                   </td>
<td> “password”        </td>
<td> onchange     </td>
<td> 密码输出框，输入的字符不可见                                         </td>
</tr>
<tr>
<td> &lt;input type=&ldquo;radio&rdquo;&gt;                                      </td>
<td> “radio”           </td>
<td> onchange     </td>
<td> 单选按钮                                                             </td>
</tr>
<tr>
<td> &lt;input type=&ldquo;reset&rdquo;&gt; or<br> &lt;button type=&ldquo;reset&rdquo;&gt;   </td>
<td> “reset”           </td>
<td> onclick      </td>
<td> 重置表单按钮                                                         </td>
</tr>
<tr>
<td> &lt;select&gt;                                                  </td>
<td> “select-one”      </td>
<td> onchange     </td>
<td> 单选下拉框                                                           </td>
</tr>
<tr>
<td> &lt;select multiple&gt;                                         </td>
<td> “select-multiple” </td>
<td> onchange     </td>
<td> 多选列表                                                             </td>
</tr>
<tr>
<td> &lt;input type=&ldquo;submit&rdquo;&gt; or<br> &lt;button type=&ldquo;submit&rdquo;&gt; </td>
<td> “submit”          </td>
<td> onclick      </td>
<td> 表单提交按钮                                                         </td>
</tr>
<tr>
<td> &lt;input type=&ldquo;text&rdquo;&gt;                                       </td>
<td> “text”            </td>
<td> onchange     </td>
<td> 单行文本输出域；type 默认 text                                       </td>
</tr>
<tr>
<td> &lt;textarea&gt;                                                </td>
<td> “textarea”        </td>
<td> onchange     </td>
<td> 多行文本输入域                                                       </td>
</tr>
</tbody>
</table>


<h3>选择框和选项元素</h3>

<p>Select 元素表示用户可以做出选择的一组选项（用 Option 元素表示）。浏览器通常将其渲染为下拉菜单的形式，但当指定其 size 属性值大于 1 时，它将显示为列表中的选项（可能有滚动条）。Select 元素的 multiple 属性决定了 Select 是不是可以多选</p>

<p>当用户选取或取消一个选项时， Select 元素触发 onchange 事件。针对「select-one」属性的 Select 元素，它的可读/写属性 selectedIndex 指定了哪个选项当前被选中。针对「select-multiple」元素，单个 selectedIndex 属性不足以表示被选中的一组选项。这种情况下需要遍历 options[] 数组的元素，检测每个 Option 对象的 selected 属性。注意 Option 并没有相关事件处理程序，一般只能给 Select 元素绑定事件</p>

<h2>其他文档特性</h2>

<h3>Document 的属性</h3>

<ul>
<li><strong>cookie</strong> 允许 JavaScript 读、写 HTTP cookie 的属性</li>
<li><strong>domain</strong> 允许当 Web 页面交互时，相同域名下互相信任的 Web 服务器之间协作放宽同源策略安全限制</li>
<li><strong>lastModified</strong> 包含文档修改时间的字符串</li>
<li><strong>location</strong> 与 Window 对象的 location 属性引用同一个 Location 对象</li>
<li><strong>referrer</strong> 如果有，它表示浏览器来到当前页面的上一个页面。与 HTTP 的 Referer 头信息内容相同</li>
<li><strong>title</strong> 文档中 title 标签的内容</li>
<li><strong>URL</strong> 文档的 URL，只读字符串而不是 Location 对象。该属性值与 location.href 的 <strong>初始值</strong>相同，不会发生变化</li>
</ul>


<h3>document.write() 方法</h3>

<p>document.write() 会将其字符串参数连接起来，然后将结果字符串插入到文档中调用它的脚本元素的位置。当脚本执行结束，浏览器解析生成输出并显示它。例如，下面代码把信息输出到一个静态的 HTML 文档中：</p>

<p>```html</p>

<script>
    document.write('Document title: ' + document.title);
    document.write('URL: ' + document.URL);
    document.write('Referred by: ' + document.referrer);
</script>


<p>```</p>

<p><strong>只有在解析文档时才能使用 write() 方法输出 HTML 到当前文档中</strong>。也就是说能够在 script 元素的顶层代码中调用 document.write()，就是因为这些脚本的执行是文档解析流程的一部分。如果将 docuemnt.write() 放在一个函数的定义中，而该函数的调用是从一个事件处理程序中发起的，产生的结果未必是你想要的——事实上，它会擦除当前文档和它包含的脚本。同理，在设置了 defer 或 async 属性的脚本中不要使用 document.write()</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 14 - Window 对象]]></title>
    <link href="http://keelii.github.io/2016/07/26/javascript-definitive-guide-note-12/"/>
    <updated>2016-07-26T11:35:42+08:00</updated>
    <id>http://keelii.github.io/2016/07/26/javascript-definitive-guide-note-12</id>
    <content type="html"><![CDATA[<p>本章介绍 window 对象的属性和方法</p>

<h2>计时器</h2>

<p>setTimeout() 和 setInterval() 可以用来注册指定时间之后调用的函数，不同的是 setInterval 会在指定毫秒数的间隔里重复调用。它们都返回一个值，这个值可以传递给 clearInterval/clearTimeout，用于取消后续函数的调用</p>

<!--more-->


<p>由于历史原因（通常不建议这么做），setTimeout 和 setInterval 的第一个参数可以作为字符串传入。如果是字符串，当到达指定时间时相当于执行 eval 字符串内容</p>

<pre><code class="javascript">// 4 秒后显示 log
var t1 = setTimeout(function () {
    console.log('show after 4s');
}, 4000);

function fn() { console.log('show every 1s'); }
setTimeout('fn()', 1000);
</code></pre>

<h2>浏览器定位和导航</h2>

<p>window 对象的 location 属性引用的是 location 对象，它表示窗口中当前显示的文档 URL。并且定义了方法来使窗口载入新的文档</p>

<p>document 对象上的 location 属性也引用到 location 对象：</p>

<pre><code class="javascript">window.location = document.location
</code></pre>

<p>document 对象也有一个 URL 属性，是文档首次载入后保存的该文档的 URL 静态字符串。如果定位到文档中的片段标识符（如#table-of-content，其实就是锚点），location 对象会做相应的更新，<strong>而 document.URL 属性不会</strong></p>

<h2>解析 URL</h2>

<p>location 对象的 href 属性是一个字符串，后者包含 URL 的完整文本。location 对象的 toString() 方法返回 href 属性的值，因此会隐式调用 toString() 的情况下，可以使用 location 代替 location.href</p>

<p>这个对象的其它属性——protocol, host, hostname, port, pathname 和 search 分别表示 URL 的各个部分。它们称为「URL 分解」属性，同时被 link 对象（通过 HTML 文档中的 a 和 area 元素创建）支持</p>

<p><img src="https://cloud.githubusercontent.com/assets/458894/17127989/2285a748-533c-11e6-946d-a1d129e845c7.gif" alt="url" /></p>

<h3>载入新的文档</h3>

<p>location 对象的 assign() 方法可以使用窗口载入并显示你指定的 URL 中的文档。replace() 方法也类似，但它在 <strong>载入新文档之前会从浏览器历史中把当前文档删除</strong>，assign 会产生一个新的历史记录，也就是说可以使用浏览器的返回按钮到上一页，replace 则不行</p>

<h2>浏览历史</h2>

<p>window 对象的 history 属性用来把窗口的浏览历史用文档和文档状态列表的形式表示。history 对象的 length 属性表示浏览历史列表中的元素数量，但是脚本并不能访问已保存的 URL</p>

<p>history 对象的 bace() 和 forward() 方法与浏览器的「后退」和「前端」按钮一样。go() 方法接收一个整数参数，可以在历史列表中向前（正数）或向后（负数）跳过任意多个页</p>

<pre><code class="javascript">history.go(-2);     // 后退两个历史记录
</code></pre>

<p>如果窗口包含多个子窗口（比如 iframe 元素），子窗口的浏览历史也会被记录，这音中着在主窗口调用 history.back() 可能会使子窗口跳转而主窗口不变</p>

<h2>浏览器和屏幕信息</h2>

<h3>navigator 对象</h3>

<p>window 对象的 navigator 属性引用的是包含浏览器厂商和版本信息的 navigator 对象。navigator 有四个属性用于提供关于运行中的浏览器版本信息，并且可以用来做浏览器嗅探</p>

<p><strong>appName</strong></p>

<p>Web 浏览器的全称。在 IE 中，就是「Microsoft Internet Explorer」，在 Firefox 中就是「Netscape」</p>

<p><strong>appVersion</strong></p>

<p>此属性通常以数字开始，并跟着包含浏览器厂商和版本信息的详细字符串。字符串前面的数字通常是 4.5 或 5.0，表示它是第 4 或 5 代兼容的浏览器</p>

<p><strong>userAgent</strong></p>

<p>浏览器在它的 USER-AGENT HTTP 头部中发送的字符串。这个属性通常包含 appVersion 中的所有信息，以及其它细节</p>

<p><strong>platform</strong></p>

<p>在其上运行浏览器的操作系统字符串</p>

<h3>screen 对象</h3>

<p>screen 对象提供有关窗口显示的大小和可用的颜色数量信息，属性 width 和 height 指定的是以像素为单位的窗口大小。属性 avilWidth 和 avilHeight 指定的是实际可用的显示大小，它们排除了像浏览器任务栏这样的特性所占用的屏幕空间</p>

<h2>对话框</h2>

<p>window 对象提供了 3 个方法来向用户显示简单的对话框。</p>

<p><strong>alert()</strong> 向用户显示一条消息并等待用户关闭
<strong>confirm()</strong> 也显示一条消息并要求用户单击「确定」或「取消」，并返回一个布尔值
<strong>prompt()</strong> 也显示一条消息并等待用户输入字符串，并返回那个字符串</p>

<pre><code class="javascript">do {
    var name = prompt('What is your name?');
    var correct = confirm('You entered: ' + name + '\n\
                            Click OK to processed or Cancel to re-enter')
} while(!correct)
</code></pre>

<p>这三个方法都会产生阻塞，也就是说，在用户关掉它们所显示的对话框之前，它们不会返回，这就意味着在弹出一个对话框前，代码就会停止运行。如果当前正在载入文档，也会停止载入。直到用户用要求的输入进行响应为止</p>

<h2>错误处理</h2>

<p>window 对象的 onerror 属性是一个事件处理程序，当未捕获的异常传播到调用栈上的时候就会触发它，并把错误消息输出到浏览器的 JavaScript 控制台上，onerror 事件处理函数调用通过三个字符串参数，而不是事件对象。分别是<code>错误信息</code>、<code>产生错误的页面地址</code>、<code>错误源代码的行号</code>，onerror 的返回值也很重要，如果 onerror 处理程序返回 false，表示它通知浏览器事件处理程序已经处理错误了，不需要其它操作。Firefox 则刚好相反</p>

<h2>作为 window 对象属性的文档元素</h2>

<p><strong>如果 HTML 文档中用 id 属性来为元素命名，并且如果 window 对象没有此名字的属性（并且这个id是个合法的标识符），window 对象会赋予一个属性，它的名字就是 id 属性的值</strong>，而它的值指向表示文档元素的 HTMLElement 对象</p>

<p>元素 ID 作为全局变量的隐式应用是 Web 浏览器进化过程中遗留的问题，主要是出于兼容性的考虑。<strong>但并不推荐使用这种做法</strong></p>

<h2>多窗口和窗体</h2>

<p>Web 浏览器的窗口中每一个标签页都是独立的「浏览上下文」（browsing context），每一个上下文都有独立的 window 对象，而且相互之间不干扰，也不知道其他标签页的存在</p>

<p>但是窗口并不总是和其它窗口完全没关系，因为可以通过脚本打开新的窗口或标签页。如果这么做就可以通过脚本跨窗口进行操作（参照之前的 <a href="/2016/07/14/javascript-definitive-guide-note-11/#TOC-16">同源策略</a>）</p>

<h3>打开和关闭窗口</h3>

<p>使用 window 对象的 open() 方法可以打开一个新的浏览器窗口</p>

<blockquote><p>var windowObjectReference = window.open(url, name, [features]);</p></blockquote>

<p>第一个参数 <code>url</code> 是要在新窗口中显示文档的 URL，如果参数省略，默认会使用空页面的 URL about:blank</p>

<p>第二个参数 <code>name</code> 表示打开窗口的名字，如果指定的是一个已经存在的窗口名字（并且脚本允许跳转到那个窗口），会直接用已存在的窗口。否则，会打开新的窗口，并将这个指定的名字赋值给它。如果省略此参数，会使用指定的名字「_blank」打开一个新的未命名窗口</p>

<p>第三个参数 <code>features</code>（非标准）是一个以逗号分隔的列表，包含表示打开窗口的大小和各种属性</p>

<p>open() 也可以有第四个参数，且只在第二个参数命名的是一个存在的窗口时才有用。它是一个布尔值，𡔬了由第一个参数指定的 URL 是应用替换掉窗口浏览器历史的当前条目（true），还是应该在窗口浏览历史中创建一个新的条目（false），后者是默认设置</p>

<p>open() 的返回值是代表命名或新创建的窗口的 window 对象。可以在自己的 JavaScript 代码中使用这个 windows 对象来引用新创建的窗口，就像用隐式的 window 对象 window 来引用运行代码的窗口一样：</p>

<pre><code class="javascript">var w = window.open();
w.alert('About to visit http://jd.com');
w.location = 'http://jd.com';
</code></pre>

<p>由 window.open() 方法创建的窗口中，opener 属性引用的是打开它的脚本的 window 对象，在其它窗口中，opener 为 null</p>

<pre><code class="javascript">w.opener !== null;      // =&gt; true
w.open().opener === w   // =&gt; true
</code></pre>

<p><strong>关闭窗口</strong></p>

<p>像 open() 方法一样，close() 用来关闭一个（脚本打开的）窗口，注意，<strong>大多数浏览器只允许自己关闭自己的 JavaScript 代码创建的窗口</strong>，要关闭其它窗口，可以用一个对话框提示用户，要求他关闭窗口的请求进行确认。在表示窗体而不是顶级窗口或者标签页上的 window 对象上执行 close() 方法不会有任何效果，它不能关闭一个窗体</p>

<p>即使一个窗口关闭了，代表它的 window 对象 <strong>仍然存在</strong>。已关闭的窗口会有一个值为 true 的 closed 属性，它的 document 会是 null， 它的方法通常也不会再工作</p>

<h3>窗体之间的关系</h3>

<p>任何窗口中的 JavaScript 代码都可以将自己的窗口引用为 window 或 self。窗体可以用 parent 属性引用包含它的窗口的 window 对象。如果一个窗口是顶级窗口或标签，那么其 parent 属性引用的就是这个窗口本身：</p>

<pre><code class="javascript">parent.history.back();
parent == self;            // 只有顶级窗口才会返回 true
</code></pre>

<p>如果一个窗体包含在另一个窗体中，而后者又包含在顶级窗口中，那么该窗体就可以使用 parent.parent 来引用顶级窗口。top 属性是一个通用的快捷方式，无论一个窗体被嵌套几层，它的 top 属性引用的都是指向包含它的顶级窗口。如果一个 window 对象代表的是一个顶级窗口，那么它的 top 属性就是窗口本身。对于那些顶级窗口的直接子窗体，top 属性就等价于 parent 属性</p>

<p>parent 和 top 属性允许脚本引用它的窗体的祖先。有不止一种方法可以引用窗口的子孙窗体。窗口是通过 iframe 元素创建的，可以获取其他元素的方法来获取一个表示 iframe 的元素对象，iframe 元素有 contentWindow 属性，引用该窗体的 window 对象。也可以反向操作，使用 window 对象的 frameElement 属性来引用被包含的 iframe 元素，对于顶级窗口来说 window 对象的 frameElement 属性为 null</p>

<pre><code class="javascript">// 假设页面有一个 id="f1" 的 iframe 元素
var iframeElement = document.getElementById('f1');
var iframeWindowObject = iframeElement.contentWindow;
// 对于 iframe 来说永远是 true
iframeWindowObject.frameElement === iframeElement
// 对于顶级窗口来说 frameElement 永远是 null
window.frameElement === null;
</code></pre>

<p>每个 window 上都会有一个 frames 属性，表示当前窗口里面引用的窗口。frames 是个类数组对象，并可以通过数字或者窗体名称（如 iframe name 属性）进行索引。注意 frames 元素引用的是窗口的 window 对象，而不是 iframe 元素</p>

<h3>交互窗口中的 JavaScript</h3>

<p>每个窗口都是它自身的 JavaScript 执行上下文，以 window 做为全局对象</p>

<p>设想一个 Web 页面里面有两个 iframe 元素，分别叫「A」和「B」，并假设这些窗体所包含的文档来自于相同的一个服务器，并且包含交互脚本。我们在窗体 A 里的脚本定义了一个变量 i：</p>

<pre><code class="javascript">var i = 3;
</code></pre>

<p>这个变量只是全局对象的一个属性，也是 window 对象的一个属性。窗体 A 中的代码可以用标识符 i 来引用变量，或者用 window 对象显示地引用这个变量：</p>

<pre><code class="javascript">i           // =&gt; 3
window.i    // =&gt; 3
</code></pre>

<p>由于窗体 B 中的脚本可以引用窗体 A 的 window 对象，因此它也可以引用那个 window 对象的属性：</p>

<pre><code class="javascript">parent.A.i = 4;             // 修改窗体 A 中的变量
parent.A.fun();             // 调用 A 窗体中的全局函数
var s = new parent.Set();   // 甚至可以构造父窗口中的对象
</code></pre>

<p>和用户定义的类不同，内置类（比如 String, Date 和 RegExp）都会在所有的窗口中自动预定义。但是要注意，<strong>每个窗口都有构造函数的一个独立副本和构造函数对应的原型对象的一个独立副本</strong>。例如，每个窗口都有自己的 String() 构造函数和 String.prototype 对象副本。因此，如果编写一个操作 JavaScript 字符串的新方法，并且通过把它赋值给当前窗口中的 String.prototype 对象而使它成为 String 类的一个方法，那么该窗口中的所有字符串就可以使用这个新方法。但是，<strong>别的窗口中定义的字符串不能使用这个新方法</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 13 - Web 浏览器中的 JavaScript]]></title>
    <link href="http://keelii.github.io/2016/07/14/javascript-definitive-guide-note-11/"/>
    <updated>2016-07-14T14:11:08+08:00</updated>
    <id>http://keelii.github.io/2016/07/14/javascript-definitive-guide-note-11</id>
    <content type="html"><![CDATA[<h2>客户端的 JavaScript</h2>

<p>Window 对象是所有客户端 JavaScript 特性和 API 的主要接入点。它表示 Web 浏览器的一个窗口或者窗体，并且可以用标识符 window 来引用它。Window 对象定义了一些属性，比如:</p>

<!--more-->


<pre><code class="javascript">// 页面跳转
window.location = 'http://www.oreilly.com/';
// 页面圣诞框
alert('Hello World')
setTimeout(function () { alert('Hello later World') }, 1000)
</code></pre>

<p>window 对象也是全局对象。可以省略「window.」来调用上面的方法。这意味着 windows 对象牌作用域链的顶部，它的属性和方法实际上是全局变量和全局函数。window 对象有一个引用自己的属性，叫做 window。如果需要引用窗口对象本身可以用这个属性，但是如果只想要引用全局窗口对象的属性，通常并不需要用 window</p>

<p>windows 对象还定义了很多其他重要的属性、方法和构造函数。其中最重要的一个属性是 document，它引用 Document 对象，后者表示显示在窗口中的文档。document 对象有一些重要方法，比如 getElementById() 获取一个 DOM 元素，它返回一个 Element 对象也有其他重要属性和方法，比如，给元素绑定点击事件 onclick</p>

<h2>在 HTML 里嵌入 JavaScript</h2>

<p>在 HTML 里嵌入 客户端 JavaScript 有 4 种方法：</p>

<ul>
<li>内联，放置在 &lt;script&gt; 和 &lt;/script&gt; 标签之间</li>
<li>外链，放置在由 script 标签的 src 属性指定的外部文件中</li>
<li>放置在 HTML 事件处理程序中，该事件处理程序由 onclick 或 on[eventType] 这样的 HTML 属性指定</li>
<li>放在一个 URL 里，这个 URL 使用特殊的「javascript:」协议</li>
</ul>


<p>```html</p>

<!--html 中的事件处理程序-->


<p><input type="checkbox" onchange="any_javascript_statement" /></p>

<!--url 中的javascript-->


<p><a href="javascript: new Date().toLocaleTimeString();">What time is it?</a>
```</p>

<p>使用外链 src 文件方式有一些优点：</p>

<ul>
<li>可以把 JavaScript 代码从 HTML 文件中删除，这有助于保持内容和行为的分离，从而简化 HTML 文件</li>
<li>如果多个 Web 页面共用相同的 JavaScript 代码，用 src 属性可以让你只管理一份代码，而不用在代码变更时每个页面都更新</li>
<li>如果一个 JavaScript 文件由多个页面共享，就只需要下载一次，以后的页面只要引用过就可以使用缓存检索它</li>
<li>src 属性值可以是任意的 URL，因此来自一个 Web 服务器的 JavaScript 程序或 Web 页面可以使用由 <strong>另外一个</strong> Web 服务器输出的代码，很多广告依赖与些</li>
<li>从其它网站载入脚本的能力，可以让我们更好地利用缓存，使用 CDN</li>
</ul>


<h3>脚本的类型</h3>

<p>script 标签默认的类型「type」是「text/javascript」，如果要使用不标准的脚本语言，如 Microsoft 的 VBScript（只有 IE 支持），就必须用 type 属性指定脚本的 MIME 类型：</p>

<p>```html</p>

<script type="text/vbscript">
// 这里是 VBScript 代码
</script>


<pre><code>
另外很多老的浏览器还支持 language 属性，作用和 type 一样，不过已经废弃了，不应该再使用了

当 Web 浏览器遇到 &amp;lt;script&amp;gt; 元素，并且这个元素包含其值不之前能点浏览器识别的 type 属性时，它会解析这个元素但不会尝试显示或执行它的内容。这意味着可以使用 &amp;lt;script&amp;gt; 来嵌入任意的文件数据到文档里，比如 [handlebars](http://handlebarsjs.com/) 模板引擎，通常把模板放在自定义 type 的 script 标签中：
</code></pre>

<script id="entry-template" type="text/x-handlebars-template">
    <div class="entry">
        <h1></h1>
        <div class="body">
            
        </div>
    </div>
</script>


<pre><code>
### 同步、异步和延迟的脚本

JavaScript 第一次添加到 Web 浏览器时，还没有 API 可以用来遍历和操作文档的结构和内容。当文档还在载入时，JavaScript 影响文档内容的唯一方法是使用 document.write() 方法
</code></pre>

<h1>Table of Factorials</h1>


<script>
function factorial(n) {
    if ( n <= 1 ) return n;
    else return n * factorial(n - 1);
}
document.write('<table>');
document.write('<tr><th>n</th><th>n!</th></tr>');
for (var i = 1; i <= 10; i++) {
    document.write('<tr><td>'+ i +'</td><td>'+ factorial(i) +'</td></tr>')
}
document.write('</table>');
document.write('Generated ad ' + new Date());
</script>


<pre><code>
当脚本把文本传递给 document.write() 时，这个文本被添加到文档输入流中，HTML 解析器会在当前位置创建一个文本节点，将文本插入这个文本节点后面。我们并不推荐使用 document.write()，但在某些场景下它有很重要的用途。当 HTML 解析器遇到 script 元素时，它默认 **必须先执行脚本**，然后恢复文档的解析和渲染。这对于内联脚本没什么问题，但如果脚本源代码是一个由 src 属性指定的外部文件，这意味着脚本后面的文档部分在下载和执行脚本之间，都不会出现在浏览器中

脚本的执行只在默认情况下是同步和阻塞的。script 标签可以有 defer 和 async 属性，这可以改变脚本的执行方式。HTML 5 说这些属性只在和 src 属性联合使用时才有效，但有些浏览器还支持延迟的内联脚本
</code></pre>

<script src="a.js" defer></script>


<script src="b.js" async></script>


<pre><code>
defer 和 async 属性都在告诉浏览器链接进来的脚本不会使用 document.write()，也不会生成文档内容，因此不蜂鸣器可以在下载脚本时继续解析和渲染文档，defer 属性使得浏览器延迟脚本的执行，直到文档的载入和解析完成，并可以操作。async 属性使得浏览器可以尽快地挂靠脚本，而不用在下载脚本时阻塞文档解析。如果 script 标签同时有两个属性，同时支持两者的浏览器会 **遵从 async 属性并忽略 defer 属性**

注意，延迟的脚本会按它们在文档里的 **出现顺序执行**。而异步脚本在它们载入后执行，这意味着它们可能会 **无序执行**

### 事件驱动的 JavaScript

上面的打印斐波那契数列程序在页面载入时开始挂靠，生成一些输出，这种程序今天已经不沉凶了。通常我们使用注册事件处理程序函数来写程序。之后在注册的事件发生时 **异步** 调用这些函数。

事件都有名字，比如 click, change, load, mouseover, keypress, readystatechange 等，如果想要程序响应一个事件，就需要注册一个事件处理函数

事件处理程序的属性名字一般都以「on」开始，后面跟着事件的名字。大部分浏览器中的事件会把一个对象传递给事件处理程序作为参数，那个对象的属性提供了事件的详细信息。比如，传递给点击事件的对象，会有一个属性说明鼠标的哪个按钮被点击了。（在 IE 里，这些事件信息被存储在全局 event 对象里，而不是传给处理程序的函数）

有些事件的目标是文档元素，它们会经常往上传递事件给文档树。这个过程叫做「**冒泡**」

关于事件传播顺序可以参考 ppk 的 [这篇文章](http://www.quirksmode.org/js/events_order.html)

### 客户端 JavaScript 线程模型

JavaScript 语言核心并不包含任何线程机制，并且客户端 JavaScript 传统上也没有定义任何线程机制。HTML 5 定义了一种作为后台线程的「WebWorker」，但是客户端 JavaScript 还像严格的单线程一样工作。甚至当可能并发执行的时候，客户端 JavaScript 也不会知道是否真的的有并行逻辑执行

单线程执行是𧫂让编程更加简单。编写代码时可以确保两个事件处理程序不会同一时刻运行，操作文档的内容时也不必操心会有其它线程试图同时修改应该没配，并且永远不需要在写 JavaScript 代码的时候操心锁、死锁和竟态条件（race condition）

单线程执行意味着浏览器 **必须在脚本和事件处理程序运行的时候停止响应用户输入**。这为 JavaScript 程序员带来了负担，它意味着 JavaScript 脚本和事件处理程序不能运行太长时间。如果一个脚本执行 **计算密集** 的任务，它将会使文档载入带来延迟，用户无法在脚本执行完成前看到内容。浏览器可能变得无法响应甚至崩溃

### 客户端 JavaScript 时间线

JavaScript 程序执行的时间线

1. Web 浏览器创建 Document 对象，并且开始解析 Web 页面，解析 HTML 元素和它们的文本内容后添加 Element 对象和 Text 节点到文档中。在这个阶段 document.readystate 属性的值是「loading」
2. 当 HTML 解析器遇到没有 async 和 defer 属性的 script 元素时，它把这些元素添加到文档中，然后执行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样脚本就可以用 document.write() 来把文本插入到输入流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为在它们执行时已经存在了。这样，同步脚本可以看到它自己的 script 元素和它们之前的文档内容
3. 当解析器遇到设置了 async 属性的 script 元素时，它开始下载脚本文本，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下载。异步脚本禁止使用 document.write() 方法。它们可以看到自己的 script 元素和它之前的所有文档元素，并且可能或干脆不可能访问其它的文档内容
4. 当文档完成解析，document.readyState 属性变成「interactive」
5. 所有有 defer 属性的脚本，会按它们在文档里出现的顺序执行。异步脚本可能也会在这个时间执行。延迟脚本能访问完整的文档树，禁止使用 document.write() 方法
6. 浏览器在 Document 对象上触发 DOMContentLoaded 事件。这标志着程序执行 **从同步脚本执行阶段转换到了异步事件驱动阶段**。但要注意，这时可能还胡异步脚本没有执行完成
7. 这时，文档已经完全解析完成，但是浏览器可能还在等待其它内容载入，如图片。当所有这些内容完成时，并且所有异步脚本完成载入和执行，document.readyState 属性改变为「complete」，Web 浏览器触发 window 对象上的 load 事件
8. 从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等

这是一条理想的时间线，但是所有浏览器都没支持它的全部细节，所有浏览器普遍都支持 load 事件，都会触发它，它是决定文档完全载入并可以操作最通用的技术，除了 IE 之外，document.readyState 属性已被大部分浏览器实现，但是属性的值在浏览器之间有细微的差别

## 兼容性和互用性

客户端 JavaScript 兼容性和互用性的问题可以归纳为以下三类：

**演化**

Web 平台一直在演变和发展当中。一个标准规范会倡导一个新的特性或 API。如果特性看起来有用，浏览器开发商实现它。如果足够多的开发商实现，开发者开始试用这个特性。有时新浏览器支持一些特性老的却不支持

**未实现**

比如，IE 8 不支持 convas 元素，虽然其它浏览器已经实现了它。IE 也没有对 DOM Level 2 Event 规范实现，即使这个规范在十年前就是标准化了

**bug**

每个浏览器都有 bug，并且没有按照规范准确地实现所有客户端 JavaScript API。有时候编写能兼容各个浏览器的 JavaScript 程序是个很麻烦的工作，必须要研究各种浏览器的兼容性问题

### 处理兼容性问题的类库

比如有的浏览器客户端不支持 canvas 元素，可以使用开源的「explorer canvas」项目，引用 excanvas.js 即可模拟 canvas 元素的功能

### 分级浏览器支持

分级浏览器支持（graded browser support）是由 Yahoo! 率先提出的一种测试技术。从某种维度对浏览器厂商/版本/操作系统进行分级。根据分级来确定哪些特性在哪些浏览器需要支持的程度

### 功能测试

功能测试（capability testing）是解决不兼容性问题的一种技术。比如添加事件 API，在标准浏览器里面是 addEventListener 而低版浏览器里面是 attachEvent，我们就可以通过特性检测来给一个添加事件的公共方法
</code></pre>

<script>
if (element.addEventListener) {
    element.addEventListener("keydown", handler, false);
} else if (element.attachEvent) {
    element.attachEvent("keydown", handler);
} else {
    element.onkeydown = handler
}
</script>


<pre><code>
### 怪异模式和标准模式

doctype 可以触发浏览器的渲染模式，IE 浏览器有怪异模式，可以通过 document.compatMode 属性判断是否是标准模式。如果返回值为「CSS1Compat」则说明浏览器工作在标准模式；如果值是「BackCompat」或者 「undefined」则说明工作在怪异模式

### 浏览器测试

通常我们用功能测试来处理兼容性问题，但有时候可能需要在某种浏览器中解决个别的 bug，同时又没有可用的特性 API，这里只能通过判断浏览器来做兼容性处理，通常可以使用浏览器 UA（user agent）来解析浏览器版本、类型等

### IE 里的条件注释

IE 浏览器中可以通过在 HTML 中添加特殊的注释来告诉浏览器代码在哪个浏览器中作用
</code></pre>

<!--[if IE 6]>
这里面的内容只会显示在 IE 6 浏览器中
<![endif]-->


<pre><code>
IE 的 JavaScript 解释器也支持条件注释，以文本 `/*@cc_on` 开头，以文本 `@*/`结束。下面的条件注释包含了只在 IE 中执行的代码
</code></pre>

<script><!--忽略 script 标签系统解析有问题-->
/*@cc_on
 @if (@_jscript)
    alert("in IE")
 @end
 @*/
</script>


<pre><code>
## 安全性

### JavaScript 不能做什么

Web 浏览器针对恶意代码的第一条防线就是它们不支持某些功能。例如，客户端的 JavaScript 没有权限来写入或删除计算机上的文件/目录，这意味着 JavaScript 不能删除数据或者植入病毒

类似地，客户端 JavaScript 没有任何通用的网络能力。HTML 5 有一个附属标准叫 WebSockets 定义了一个类套接字的 API，用于和指定的服务器通信。但是这些 API 都不允许对于范围更广的网络进行直接访问

浏览器针对恶意代码的第二条防线是在自己支持的某些功能上施加限制。比如：

* JavaScript 程序可以打开一个新的浏览器窗口，但是为了防止广告商滥用弹出窗口，很多浏览器限制了这一功能，使得只有为了响应鼠标单击这样的用户触发事件的时候，才能用它
* JavaScript 程序可以关闭 **自己打开的** 浏览器窗口，但是不允许不经过用户确认就关闭其它窗口
* HTML FileUpload 元素的 value 属性是只读的。如果可以设置这个属性，脚本就能设置它为任意期望的文件名，从而导致表单上传指定的文件（比如密码文件）内容到服务器
* 脚本不能读取从不同服务器载入的文档内容，除非这个就是包含该脚本的文档。类似地，一个脚本不能在来自不同服务器的文档上注册事件监听器。这就防止脚本窃取其他页面的用户输入

### 同源策略

同源策略是对 JavaScript 代码能够操作哪些 Web 内容的一条完整的安全限制。当 Web 页面使用多个 iframe 元素或者打开其它浏览器窗口的时候，这一策略通常就会发挥作用。在这情况下，同源策略负责管理窗口或窗体中的 JavaScript 代码以及和其它窗口或帧的交互

文档的来源包含协议、主机、以及载入文档的 URL 商品。从不同 Web 服务器载入的文档具有不同的来源。通过同一主机不同商品载入的文档具有不同来源。使用 `http:` 协议载入的文档和使用 `https:` 协议载入的文档具有不同的来源，**即使它们来自同一个服务器**

**脚本本身的来源和同源策略并不相关**，相关的是脚本所嵌入文档的来源。例如，来自主机 A 的脚本被包含到宿主 B 的一个 Web 页面中。这个脚本的 **来源（origin）** 是主机 B，并且可以完整地访问包含它的文档的内容。如果脚本打开一个新的窗口并载入来自主机 B 的另一个文档，脚本对这个文档的内容也具有完全的访问权限。但是如果脚本打开第三个窗口并载入一个来自主机 C 的文档（或者来自主机 A），同源策略就会发挥作用，阻止脚本访问这个文档

&gt; A 页面包含一个 B 脚本，B 脚本对 A 页面有完全的访问权限，如果 B 脚本控制打开一个 A 服务器上另外一个页面 C，那么脚本也可以访问这个 C 页面，如果 B 脚本控制打开了一个 D 页面，这时就会触发同源策略，即 B 脚本不可以访问 D 页面，**因为 A 和 C 同源，A 和 D 不同源**

**不严格的同源策略**

在某些情况下，同源策略就显得太过严格了，常常表现在多个子域名站点的场景中。比如：来自 A.yourdomain.com 的文档里脚本无法直接读取 B.yourdomain.com 页面的文档，不过可以通过设置 document.domain 为同一个主域来获取访问权限，即给两个域名下的页面都设置 `document.domain="yourdomain.com"`，这样以来两个文档就有了同源性可以相互访问

还有一项已经标准化的技术：**跨域资源共享**（Cross-Origin Resource Sharing）这个标准草案用新的「Origin:」请求头和新的 Access-Control-Allow-Origin 响应头来扩展 HTTP，它允许服务器用头信息显式地列出源，或使用能本符来匹配所有的源并允许由任何地址请求文件，这样就可以实现跨域的 HTTP 请求， XMLHttpRequest 也不会被同源策略所限制了

还有一种新技术，叫做跨文档消息（cross-document messaging），允许来自一个文档的脚本可以传递文本消息到另一个文档的脚本，而不管脚本的来源是否不同。调用 window 对象上的 postMessage() 方法，可以异步传递消息事件

### 跨站脚本

跨站脚本（Cross-site scripting），或者叫 XXS，这个术语表示一类安全问题。攻击者向目标 Web 站点注入 HTML 标签或者脚本

如果 Web 页面动态地产生文档内容，并且这些文档内容是用户提交的，如果没有过滤用户提交内容的话，这个页面很容易遭到跨站脚本攻击，比如：
</code></pre>

<script>
var name = decodeURIComponent(window.location.search.substring(1) || "");
document.write("hello " + name)
</script>


<pre><code>
当页面的 url 被手动拼成恶意参数提交时就会产生 XXS 攻击，比如：

&gt; http://example.com/greet.html?%3Cscript%3Ealert(%22XXS%20attack%22)%3C%2Fscript%3E

打开这个 url 就会弹出「XXS attack」，解决办法通过是对接收参数进行标签屏蔽
</code></pre>

<script>
name = name.replace(/</g, "&lt;").replace(/>/g, "&gt;");
</script>


<p>```</p>

<h2>客户端框架</h2>

<p>从某种意义上讲类库也是框架，它们对 Web 浏览器提供的标准和专用 API 进行封闭，向上提供更高级别的 API，用以更高效地进行客户端编程开发。一但使用就要用框架定义的 API 来写代码，后面有专门的章节讲 jQuery，除了这个常用的类库还有一些其它广泛使用的：</p>

<ul>
<li><a href="http://prototypejs.org/">Prototype</a></li>
<li><a href="https://dojotoolkit.org/">Dojo</a></li>
<li><a href="http://yuilibrary.com/">YUI</a></li>
<li><a href="https://developers.google.com/closure/">Closure</a></li>
<li><a href="http://www.gwtproject.org/">GWT</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 11 - 服务器端的 JavaScript]]></title>
    <link href="http://keelii.github.io/2016/07/10/javascript-definitive-guide-note-10/"/>
    <updated>2016-07-10T19:47:18+08:00</updated>
    <id>http://keelii.github.io/2016/07/10/javascript-definitive-guide-note-10</id>
    <content type="html"><![CDATA[<h2>用 Node 实现异步 I/O</h2>

<p>Node 是基于 C++ 的调整 JavaScript 解释器，绑定了用于进程、文件和网络套接字等底层 Unix API，还绑定了 HTTP 客户端和服务器 API。除了一些专门命名的同步方法外，Node 的绑定是异步的，且 Node 程序默认绝不阻塞，这意味着它们通过具备强大的可伸缩能力并能有效地处理高负荷。由于 API 是异步的，因此 Node 依赖事件处理程序，其通常使用嵌套函数和闭包来实现</p>

<!--more-->


<p>Node 在其全局对象中实现了所有标准的 ECMAScript 5 构造函数、属性和函数。除此之外，它也支持客户端講器函数集 setTimeout(), setInterval()</p>

<p>Node 在 process 名字空间中定义了其它重要的 <strong>全局</strong> 属性：</p>

<pre><code class="javascript">process.version         // Node 的版本字符串信息
process.argv            // 'node' 命令行数组参数，argv[0] 是 "node"
process.pid             // 进程 id
process.getuid()        // 返回用户 id
process.cwd()           // 返回当前的工作目录
process.chdir()         // 改变当目录
process.exit()          // 退出
</code></pre>

<p>在有的情况下，可以使用 Node 的事件机制。Node 对象产生事件（称为事件触发器(event emitter)），定义 on() 方法来注册处理程序。当传入参数时，将事件类型（一个字符串）作为第一参数，处理程序函数作为第二参数。不同的事件类型传递给处理程序函数的参数不同：</p>

<pre><code class="javascript">emitter.on(name, f)
emitter.addListener(name, f)
emitter.once(name, f)
emitter.removeListener(name, f)
emitter.removeListeners(name)
</code></pre>

<p>上面的 process 全局对象也是一个事件触发器，它继承了 EventEmitter 类</p>

<pre><code class="javascript">process.on('exit', function () { console.log('Goodbye'); });
process.on('uncaughException', function (e) { console.log(Exception, e); });
</code></pre>

<p>Node 的文件和文件系统 API 位于「fs」模块中，这个模块提供了大部分方法的「同步版本」。任何名字以「Sync」结尾的方法都是一个 <strong>阻塞方法</strong>，它返回一个值或抛出一个异常，不以「Sync」结尾的文件系统方法都是非阻塞的，它们会把结果或者错误传给指定的回调函数</p>

<pre><code class="javascript">// 同步读取文件，指定编码获取文本而不是字节
var text = fs.readFileSync('config.json', 'utf8');
// 异步读取二进制文件，通过传递函数获得数据
fs.readFile('image.png', function (err, buffer) {
    if (err) throw err;
    process(buffer);
})
</code></pre>

<p>类似地，存在用来写文件的 writeFile() 和 writeFileSync() 函数：</p>

<pre><code class="javascript">fs.writeFile('config.json', JSON.stringify(json))
</code></pre>

<p>「net」模块是用于基于 TCP 网络的 API，下面是 Node 中一个非常简单的 TCP 服务器</p>

<pre><code class="javascript">var net = require('net');
var server = net.createServer();
server.listen(2000, function() { console.log('Listening on port 2000'); });
server.on('connection', function (stream) {
    console.log('Accepting connection from', stream.remoteAddress);
    stream.on('data', function (data) {
        stream.write(data)
    });
    stream.on('end', function(data) {
        console.log('Connection closed');
    });
});
</code></pre>

<h3>Node 示例：HTTP 服务器</h3>

<pre><code class="javascript">var http = require('http');

var hostname = '127.0.0.1';
var port = 3000;

var server = http.createServer(function(req, res) {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'text/plain');
    res.end('Hello World\n');
});

server.listen(port, hostname, function() {
    console.log('Server running at http://$s:%s/', hostname, port);
});
</code></pre>
]]></content>
  </entry>
  
</feed>
