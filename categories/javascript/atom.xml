<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Something]]></title>
  <link href="http://keelii.github.io/categories/javascript/atom.xml" rel="self"/>
  <link href="http://keelii.github.io/"/>
  <updated>2016-07-18T09:46:54+08:00</updated>
  <id>http://keelii.github.io/</id>
  <author>
    <name><![CDATA[keelii]]></name>
    <email><![CDATA[keeliizhou@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 12 - Web 浏览器中的 JavaScript]]></title>
    <link href="http://keelii.github.io/2016/07/14/javascript-definitive-guide-note-11/"/>
    <updated>2016-07-14T14:11:08+08:00</updated>
    <id>http://keelii.github.io/2016/07/14/javascript-definitive-guide-note-11</id>
    <content type="html"><![CDATA[<h2>客户端的 JavaScript</h2>

<p>Window 对象是所有客户端 JavaScript 特性和 API 的主要接入点。它表示 Web 浏览器的一个窗口或者窗体，并且可以用标识符 window 来引用它。Window 对象定义了一些属性，比如:</p>

<!--more-->


<pre><code class="javascript">// 页面跳转
window.location = 'http://www.oreilly.com/';
// 页面圣诞框
alert('Hello World')
setTimeout(function () { alert('Hello later World') }, 1000)
</code></pre>

<p>window 对象也是全局对象。可以省略「window.」来调用上面的方法。这意味着 windows 对象牌作用域链的顶部，它的属性和方法实际上是全局变量和全局函数。window 对象有一个引用自己的属性，叫做 window。如果需要引用窗口对象本身可以用这个属性，但是如果只想要引用全局窗口对象的属性，通常并不需要用 window</p>

<p>windows 对象还定义了很多其他重要的属性、方法和构造函数。其中最重要的一个属性是 document，它引用 Document 对象，后者表示显示在窗口中的文档。document 对象有一些重要方法，比如 getElementById() 获取一个 DOM 元素，它返回一个 Element 对象也有其他重要属性和方法，比如，给元素绑定点击事件 onclick</p>

<h2>在 HTML 里嵌入 JavaScript</h2>

<p>在 HTML 里嵌入 客户端 JavaScript 有 4 种方法：</p>

<ul>
<li>内联，放置在 &lt;script&gt; 和 &lt;/script&gt; 标签之间</li>
<li>外链，放置在由 script 标签的 src 属性指定的外部文件中</li>
<li>放置在 HTML 事件处理程序中，该事件处理程序由 onclick 或 on[eventType] 这样的 HTML 属性指定</li>
<li>放在一个 URL 里，这个 URL 使用特殊的「javascript:」协议</li>
</ul>


<p>```html</p>

<!--html 中的事件处理程序-->


<p><input type="checkbox" onchange="any_javascript_statement" /></p>

<!--url 中的javascript-->


<p><a href="javascript: new Date().toLocaleTimeString();">What time is it?</a>
```</p>

<p>使用外链 src 文件方式有一些优点：</p>

<ul>
<li>可以把 JavaScript 代码从 HTML 文件中删除，这有助于保持内容和行为的分离，从而简化 HTML 文件</li>
<li>如果多个 Web 页面共用相同的 JavaScript 代码，用 src 属性可以让你只管理一份代码，而不用在代码变更时每个页面都更新</li>
<li>如果一个 JavaScript 文件由多个页面共享，就只需要下载一次，以后的页面只要引用过就可以使用缓存检索它</li>
<li>src 属性值可以是任意的 URL，因此来自一个 Web 服务器的 JavaScript 程序或 Web 页面可以使用由 <strong>另外一个</strong> Web 服务器输出的代码，很多广告依赖与些</li>
<li>从其它网站载入脚本的能力，可以让我们更好地利用缓存，使用 CDN</li>
</ul>


<h3>脚本的类型</h3>

<p>script 标签默认的类型「type」是「text/javascript」，如果要使用不标准的脚本语言，如 Microsoft 的 VBScript（只有 IE 支持），就必须用 type 属性指定脚本的 MIME 类型：</p>

<p>```html</p>

<script type="text/vbscript">
// 这里是 VBScript 代码
</script>


<pre><code>
另外很多老的浏览器还支持 language 属性，作用和 type 一样，不过已经废弃了，不应该再使用了

当 Web 浏览器遇到 &amp;lt;script&amp;gt; 元素，并且这个元素包含其值不之前能点浏览器识别的 type 属性时，它会解析这个元素但不会尝试显示或执行它的内容。这意味着可以使用 &amp;lt;script&amp;gt; 来嵌入任意的文件数据到文档里，比如 [handlebars](http://handlebarsjs.com/) 模板引擎，通常把模板放在自定义 type 的 script 标签中：
</code></pre>

<script id="entry-template" type="text/x-handlebars-template">
    <div class="entry">
        <h1></h1>
        <div class="body">
            
        </div>
    </div>
</script>


<pre><code>
### 同步、异步和延迟的脚本

JavaScript 第一次添加到 Web 浏览器时，还没有 API 可以用来遍历和操作文档的结构和内容。当文档还在载入时，JavaScript 影响文档内容的唯一方法是使用 document.write() 方法
</code></pre>

<h1>Table of Factorials</h1>


<script>
function factorial(n) {
    if ( n <= 1 ) return n;
    else return n * factorial(n - 1);
}
document.write('<table>');
document.write('<tr><th>n</th><th>n!</th></tr>');
for (var i = 1; i <= 10; i++) {
    document.write('<tr><td>'+ i +'</td><td>'+ factorial(i) +'</td></tr>')
}
document.write('</table>');
document.write('Generated ad ' + new Date());
</script>


<pre><code>
当脚本把文本传递给 document.write() 时，这个文本被添加到文档输入流中，HTML 解析器会在当前位置创建一个文本节点，将文本插入这个文本节点后面。我们并不推荐使用 document.write()，但在某些场景下它有很重要的用途。当 HTML 解析器遇到 script 元素时，它默认 **必须先执行脚本**，然后恢复文档的解析和渲染。这对于内联脚本没什么问题，但如果脚本源代码是一个由 src 属性指定的外部文件，这意味着脚本后面的文档部分在下载和执行脚本之间，都不会出现在浏览器中

脚本的执行只在默认情况下是同步和阻塞的。script 标签可以有 defer 和 async 属性，这可以改变脚本的执行方式。HTML 5 说这些属性只在和 src 属性联合使用时才有效，但有些浏览器还支持延迟的内联脚本
</code></pre>

<script src="a.js" defer></script>


<script src="b.js" async></script>


<pre><code>
defer 和 async 属性都在告诉浏览器链接进来的脚本不会使用 document.write()，也不会生成文档内容，因此不蜂鸣器可以在下载脚本时继续解析和渲染文档，defer 属性使得浏览器延迟脚本的执行，直到文档的载入和解析完成，并可以操作。async 属性使得浏览器可以尽快地挂靠脚本，而不用在下载脚本时阻塞文档解析。如果 script 标签同时有两个属性，同时支持两者的浏览器会 **遵从 async 属性并忽略 defer 属性**

注意，延迟的脚本会按它们在文档里的 **出现顺序执行**。而异步脚本在它们载入后执行，这意味着它们可能会 **无序执行**

### 事件驱动的 JavaScript

上面的打印斐波那契数列程序在页面载入时开始挂靠，生成一些输出，这种程序今天已经不沉凶了。通常我们使用注册事件处理程序函数来写程序。之后在注册的事件发生时 **异步** 调用这些函数。

事件都有名字，比如 click, change, load, mouseover, keypress, readystatechange 等，如果想要程序响应一个事件，就需要注册一个事件处理函数

事件处理程序的属性名字一般都以「on」开始，后面跟着事件的名字。大部分浏览器中的事件会把一个对象传递给事件处理程序作为参数，那个对象的属性提供了事件的详细信息。比如，传递给点击事件的对象，会有一个属性说明鼠标的哪个按钮被点击了。（在 IE 里，这些事件信息被存储在全局 event 对象里，而不是传给处理程序的函数）

有些事件的目标是文档元素，它们会经常往上传递事件给文档树。这个过程叫做「**冒泡**」

关于事件传播顺序可以参考 ppk 的 [这篇文章](http://www.quirksmode.org/js/events_order.html)

### 客户端 JavaScript 线程模型

JavaScript 语言核心并不包含任何线程机制，并且客户端 JavaScript 传统上也没有定义任何线程机制。HTML 5 定义了一种作为后台线程的「WebWorker」，但是客户端 JavaScript 还像严格的单线程一样工作。甚至当可能并发执行的时候，客户端 JavaScript 也不会知道是否真的的有并行逻辑执行

单线程执行是𧫂让编程更加简单。编写代码时可以确保两个事件处理程序不会同一时刻运行，操作文档的内容时也不必操心会有其它线程试图同时修改应该没配，并且永远不需要在写 JavaScript 代码的时候操心锁、死锁和竟态条件（race condition）

单线程执行意味着浏览器 **必须在脚本和事件处理程序运行的时候停止响应用户输入**。这为 JavaScript 程序员带来了负担，它意味着 JavaScript 脚本和事件处理程序不能运行太长时间。如果一个脚本执行 **计算密集** 的任务，它将会使文档载入带来延迟，用户无法在脚本执行完成前看到内容。浏览器可能变得无法响应甚至崩溃

### 客户端 JavaScript 时间线

JavaScript 程序执行的时间线

1. Web 浏览器创建 Document 对象，并且开始解析 Web 页面，解析 HTML 元素和它们的文本内容后添加 Element 对象和 Text 节点到文档中。在这个阶段 document.readystate 属性的值是「loading」
2. 当 HTML 解析器遇到没有 async 和 defer 属性的 script 元素时，它把这些元素添加到文档中，然后执行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样脚本就可以用 document.write() 来把文本插入到输入流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为在它们执行时已经存在了。这样，同步脚本可以看到它自己的 script 元素和它们之前的文档内容
3. 当解析器遇到设置了 async 属性的 script 元素时，它开始下载脚本文本，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下载。异步脚本禁止使用 document.write() 方法。它们可以看到自己的 script 元素和它之前的所有文档元素，并且可能或干脆不可能访问其它的文档内容
4. 当文档完成解析，document.readyState 属性变成「interactive」
5. 所有有 defer 属性的脚本，会按它们在文档里出现的顺序执行。异步脚本可能也会在这个时间执行。延迟脚本能访问完整的文档树，禁止使用 document.write() 方法
6. 浏览器在 Document 对象上触发 DOMContentLoaded 事件。这标志着程序执行 **从同步脚本执行阶段转换到了异步事件驱动阶段**。但要注意，这时可能还胡异步脚本没有执行完成
7. 这时，文档已经完全解析完成，但是浏览器可能还在等待其它内容载入，如图片。当所有这些内容完成时，并且所有异步脚本完成载入和执行，document.readyState 属性改变为「complete」，Web 浏览器触发 window 对象上的 load 事件
8. 从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等

这是一条理想的时间线，但是所有浏览器都没支持它的全部细节，所有浏览器普遍都支持 load 事件，都会触发它，它是决定文档完全载入并可以操作最通用的技术，除了 IE 之外，document.readyState 属性已被大部分浏览器实现，但是属性的值在浏览器之间有细微的差别

## 兼容性和互用性

客户端 JavaScript 兼容性和互用性的问题可以归纳为以下三类：

**演化**

Web 平台一直在演变和发展当中。一个标准规范会倡导一个新的特性或 API。如果特性看起来有用，浏览器开发商实现它。如果足够多的开发商实现，开发者开始试用这个特性。有时新浏览器支持一些特性老的却不支持

**未实现**

比如，IE 8 不支持 convas 元素，虽然其它浏览器已经实现了它。IE 也没有对 DOM Level 2 Event 规范实现，即使这个规范在十年前就是标准化了

**bug**

每个浏览器都有 bug，并且没有按照规范准确地实现所有客户端 JavaScript API。有时候编写能兼容各个浏览器的 JavaScript 程序是个很麻烦的工作，必须要研究各种浏览器的兼容性问题

### 处理兼容性问题的类库

比如有的浏览器客户端不支持 canvas 元素，可以使用开源的「explorer canvas」项目，引用 excanvas.js 即可模拟 canvas 元素的功能

### 分级浏览器支持

分级浏览器支持（graded browser support）是由 Yahoo! 率先提出的一种测试技术。从某种维度对浏览器厂商/版本/操作系统进行分级。根据分级来确定哪些特性在哪些浏览器需要支持的程度

### 功能测试

功能测试（capability testing）是解决不兼容性问题的一种技术。比如添加事件 API，在标准浏览器里面是 addEventListener 而低版浏览器里面是 attachEvent，我们就可以通过特性检测来给一个添加事件的公共方法
</code></pre>

<script>
if (element.addEventListener) {
    element.addEventListener("keydown", handler, false);
} else if (element.attachEvent) {
    element.attachEvent("keydown", handler);
} else {
    element.onkeydown = handler
}
</script>


<pre><code>
### 怪异模式和标准模式

doctype 可以触发浏览器的渲染模式，IE 浏览器有怪异模式，可以通过 document.compatMode 属性判断是否是标准模式。如果返回值为「CSS1Compat」则说明浏览器工作在标准模式；如果值是「BackCompat」或者 「undefined」则说明工作在怪异模式

### 浏览器测试

通常我们用功能测试来处理兼容性问题，但有时候可能需要在某种浏览器中解决个别的 bug，同时又没有可用的特性 API，这里只能通过判断浏览器来做兼容性处理，通常可以使用浏览器 UA（user agent）来解析浏览器版本、类型等

### IE 里的条件注释

IE 浏览器中可以通过在 HTML 中添加特殊的注释来告诉浏览器代码在哪个浏览器中作用
</code></pre>

<!--[if IE 6]>
这里面的内容只会显示在 IE 6 浏览器中
<![endif]-->


<pre><code>
IE 的 JavaScript 解释器也支持条件注释，以文本 `/*@cc_on` 开头，以文本 `@*/`结束。下面的条件注释包含了只在 IE 中执行的代码
</code></pre>

<script><!--忽略 script 标签系统解析有问题-->
/*@cc_on
 @if (@_jscript)
    alert("in IE")
 @end
 @*/
</script>


<pre><code>
## 安全性

### JavaScript 不能做什么

Web 浏览器针对恶意代码的第一条防线就是它们不支持某些功能。例如，客户端的 JavaScript 没有权限来写入或删除计算机上的文件/目录，这意味着 JavaScript 不能删除数据或者植入病毒

类似地，客户端 JavaScript 没有任何通用的网络能力。HTML 5 有一个附属标准叫 WebSockets 定义了一个类套接字的 API，用于和指定的服务器通信。但是这些 API 都不允许对于范围更广的网络进行直接访问

浏览器针对恶意代码的第二条防线是在自己支持的某些功能上施加限制。比如：

* JavaScript 程序可以打开一个新的浏览器窗口，但是为了防止广告商滥用弹出窗口，很多浏览器限制了这一功能，使得只有为了响应鼠标单击这样的用户触发事件的时候，才能用它
* JavaScript 程序可以关闭 **自己打开的** 浏览器窗口，但是不允许不经过用户确认就关闭其它窗口
* HTML FileUpload 元素的 value 属性是只读的。如果可以设置这个属性，脚本就能设置它为任意期望的文件名，从而导致表单上传指定的文件（比如密码文件）内容到服务器
* 脚本不能读取从不同服务器载入的文档内容，除非这个就是包含该脚本的文档。类似地，一个脚本不能在来自不同服务器的文档上注册事件监听器。这就防止脚本窃取其他页面的用户输入

### 同源策略

同源策略是对 JavaScript 代码能够操作哪些 Web 内容的一条完整的安全限制。当 Web 页面使用多个 iframe 元素或者打开其它浏览器窗口的时候，这一策略通常就会发挥作用。在这情况下，同源策略负责管理窗口或窗体中的 JavaScript 代码以及和其它窗口或帧的交互

文档的来源包含协议、主机、以及载入文档的 URL 商品。从不同 Web 服务器载入的文档具有不同的来源。通过同一主机不同商品载入的文档具有不同来源。使用 `http:` 协议载入的文档和使用 `https:` 协议载入的文档具有不同的来源，**即使它们来自同一个服务器**

**脚本本身的来源和同源策略并不相关**，相关的是脚本所嵌入文档的来源。例如，来自主机 A 的脚本被包含到宿主 B 的一个 Web 页面中。这个脚本的 **来源（origin）** 是主机 B，并且可以完整地访问包含它的文档的内容。如果脚本打开一个新的窗口并载入来自主机 B 的另一个文档，脚本对这个文档的内容也具有完全的访问权限。但是如果脚本打开第三个窗口并载入一个来自主机 C 的文档（或者来自主机 A），同源策略就会发挥作用，阻止脚本访问这个文档

&gt; A 页面包含一个 B 脚本，B 脚本对 A 页面有完全的访问权限，如果 B 脚本控制打开一个 A 服务器上另外一个页面 C，那么脚本也可以访问这个 C 页面，如果 B 脚本控制打开了一个 D 页面，这时就会触发同源策略，即 B 脚本不可以访问 D 页面，**因为 A 和 C 同源，A 和 D 不同源**

**不严格的同源策略**

在某些情况下，同源策略就显得太过严格了，常常表现在多个子域名站点的场景中。比如：来自 A.yourdomain.com 的文档里脚本无法直接读取 B.yourdomain.com 页面的文档，不过可以通过设置 document.domain 为同一个主域来获取访问权限，即给两个域名下的页面都设置 `document.domain="yourdomain.com"`，这样以来两个文档就有了同源性可以相互访问

还有一项已经标准化的技术：**跨域资源共享**（Cross-Origin Resource Sharing）这个标准草案用新的「Origin:」请求头和新的 Access-Control-Allow-Origin 响应头来扩展 HTTP，它允许服务器用头信息显式地列出源，或使用能本符来匹配所有的源并允许由任何地址请求文件，这样就可以实现跨域的 HTTP 请求， XMLHttpRequest 也不会被同源策略所限制了

还有一种新技术，叫做跨文档消息（cross-document messaging），允许来自一个文档的脚本可以传递文本消息到另一个文档的脚本，而不管脚本的来源是否不同。调用 window 对象上的 postMessage() 方法，可以异步传递消息事件

### 跨站脚本

跨站脚本（Cross-site scripting），或者叫 XXS，这个术语表示一类安全问题。攻击者向目标 Web 站点注入 HTML 标签或者脚本

如果 Web 页面动态地产生文档内容，并且这些文档内容是用户提交的，如果没有过滤用户提交内容的话，这个页面很容易遭到跨站脚本攻击，比如：
</code></pre>

<script>
var name = decodeURIComponent(window.location.search.substring(1) || "");
document.write("hello " + name)
</script>


<pre><code>
当页面的 url 被手动拼成恶意参数提交时就会产生 XXS 攻击，比如：

&gt; http://example.com/greet.html?%3Cscript%3Ealert(%22XXS%20attack%22)%3C%2Fscript%3E

打开这个 url 就会弹出「XXS attack」，解决办法通过是对接收参数进行标签屏蔽
</code></pre>

<script>
name = name.replace(/</g, "&lt;").replace(/>/g, "&gt;");
</script>


<p>```</p>

<h2>客户端框架</h2>

<p>从某种意义上讲类库也是框架，它们对 Web 浏览器提供的标准和专用 API 进行封闭，向上提供更高级别的 API，用以更高效地进行客户端编程开发。一但使用就要用框架定义的 API 来写代码，后面有专门的章节讲 jQuery，除了这个常用的类库还有一些其它广泛使用的：</p>

<ul>
<li><a href="http://prototypejs.org/">Prototype</a></li>
<li><a href="https://dojotoolkit.org/">Dojo</a></li>
<li><a href="http://yuilibrary.com/">YUI</a></li>
<li><a href="https://developers.google.com/closure/">Closure</a></li>
<li><a href="http://www.gwtproject.org/">GWT</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 11 - 服务器端的 JavaScript]]></title>
    <link href="http://keelii.github.io/2016/07/10/javascript-definitive-guide-note-10/"/>
    <updated>2016-07-10T19:47:18+08:00</updated>
    <id>http://keelii.github.io/2016/07/10/javascript-definitive-guide-note-10</id>
    <content type="html"><![CDATA[<h2>用 Node 实现异步 I/O</h2>

<p>Node 是基于 C++ 的调整 JavaScript 解释器，绑定了用于进程、文件和网络套接字等底层 Unix API，还绑定了 HTTP 客户端和服务器 API。除了一些专门命名的同步方法外，Node 的绑定是异步的，且 Node 程序默认绝不阻塞，这意味着它们通过具备强大的可伸缩能力并能有效地处理高负荷。由于 API 是异步的，因此 Node 依赖事件处理程序，其通常使用嵌套函数和闭包来实现</p>

<!--more-->


<p>Node 在其全局对象中实现了所有标准的 ECMAScript 5 构造函数、属性和函数。除此之外，它也支持客户端講器函数集 setTimeout(), setInterval()</p>

<p>Node 在 process 名字空间中定义了其它重要的 <strong>全局</strong> 属性：</p>

<pre><code class="javascript">process.version         // Node 的版本字符串信息
process.argv            // 'node' 命令行数组参数，argv[0] 是 "node"
process.pid             // 进程 id
process.getuid()        // 返回用户 id
process.cwd()           // 返回当前的工作目录
process.chdir()         // 改变当目录
process.exit()          // 退出
</code></pre>

<p>在有的情况下，可以使用 Node 的事件机制。Node 对象产生事件（称为事件触发器(event emitter)），定义 on() 方法来注册处理程序。当传入参数时，将事件类型（一个字符串）作为第一参数，处理程序函数作为第二参数。不同的事件类型传递给处理程序函数的参数不同：</p>

<pre><code class="javascript">emitter.on(name, f)
emitter.addListener(name, f)
emitter.once(name, f)
emitter.removeListener(name, f)
emitter.removeListeners(name)
</code></pre>

<p>上面的 process 全局对象也是一个事件触发器，它继承了 EventEmitter 类</p>

<pre><code class="javascript">process.on('exit', function () { console.log('Goodbye'); });
process.on('uncaughException', function (e) { console.log(Exception, e); });
</code></pre>

<p>Node 的文件和文件系统 API 位于「fs」模块中，这个模块提供了大部分方法的「同步版本」。任何名字以「Sync」结尾的方法都是一个 <strong>阻塞方法</strong>，它返回一个值或抛出一个异常，不以「Sync」结尾的文件系统方法都是非阻塞的，它们会把结果或者错误传给指定的回调函数</p>

<pre><code class="javascript">// 同步读取文件，指定编码获取文本而不是字节
var text = fs.readFileSync('config.json', 'utf8');
// 异步读取二进制文件，通过传递函数获得数据
fs.readFile('image.png', function (err, buffer) {
    if (err) throw err;
    process(buffer);
})
</code></pre>

<p>类似地，存在用来写文件的 writeFile() 和 writeFileSync() 函数：</p>

<pre><code class="javascript">fs.writeFile('config.json', JSON.stringify(json))
</code></pre>

<p>「net」模块是用于基于 TCP 网络的 API，下面是 Node 中一个非常简单的 TCP 服务器</p>

<pre><code class="javascript">var net = require('net');
var server = net.createServer();
server.listen(2000, function() { console.log('Listening on port 2000'); });
server.on('connection', function (stream) {
    console.log('Accepting connection from', stream.remoteAddress);
    stream.on('data', function (data) {
        stream.write(data)
    });
    stream.on('end', function(data) {
        console.log('Connection closed');
    });
});
</code></pre>

<h3>Node 示例：HTTP 服务器</h3>

<pre><code class="javascript">var http = require('http');

var hostname = '127.0.0.1';
var port = 3000;

var server = http.createServer(function(req, res) {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'text/plain');
    res.end('Hello World\n');
});

server.listen(port, hostname, function() {
    console.log('Server running at http://$s:%s/', hostname, port);
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 10 - 正则表达式的模式匹配]]></title>
    <link href="http://keelii.github.io/2016/07/06/javascript-definitive-guide-note-9/"/>
    <updated>2016-07-06T12:43:30+08:00</updated>
    <id>http://keelii.github.io/2016/07/06/javascript-definitive-guide-note-9</id>
    <content type="html"><![CDATA[<p>正则表达式（regular expression）是一个描述字符模式的对象。在 JavaScript 中 String 和 RegExp 都定义了相关方法对文本进行模式匹配、检索和替换</p>

<!-- more -->


<h2>正则表达式的定义</h2>

<p>JavaScript 中的正则表达式用 RegExp 对象表示，可以使用 RegExp() 构造函数来创建 RegExp 对象，不过也可以通过两个双斜杠「/reg/」以正则直接量的形式创建</p>

<pre><code class="javascript">var pattern = /s$/;             // 通过直接量创建
var pattern = new RegExp('s$'); // 通过构造函数创建
</code></pre>

<h3>直接量字符</h3>

<p>JavaScript 正则表达式语法也支持非字母的字符匹配，这些字符需要通过反斜线（\）作为前缀进行转义</p>

<p><em>表10-1</em></p>

<table>
<thead>
<tr>
<th> 字符       </th>
<th> 匹配                                  </th>
</tr>
</thead>
<tbody>
<tr>
<td> 字母和数字 </td>
<td> 自身                                  </td>
</tr>
<tr>
<td> \0         </td>
<td> NUL 字符（\u0000）                    </td>
</tr>
<tr>
<td> \t         </td>
<td> 制表符（\u0009）                      </td>
</tr>
<tr>
<td> \n         </td>
<td> 换行符（\u000A）                      </td>
</tr>
<tr>
<td> \v         </td>
<td> 垂直制表符（\u000B）                  </td>
</tr>
<tr>
<td> \f         </td>
<td> 换页符（\u000C）                      </td>
</tr>
<tr>
<td> \r         </td>
<td> 回车符（\u000D）                      </td>
</tr>
<tr>
<td> \xnn       </td>
<td> 由十六进制数 nn 指定的拉丁字符        </td>
</tr>
<tr>
<td> \uxxxx     </td>
<td> 由十六进制数 xxxx 指定的 unicode 字符 </td>
</tr>
<tr>
<td> \cX        </td>
<td> 控制字符 ^x                           </td>
</tr>
</tbody>
</table>


<p>正则表达式中，许多标点符号也具有特殊含义，它们是：</p>

<blockquote><p>^ $ . * + ? = ! : | \ / ( ) { }</p></blockquote>

<h3>字符类</h3>

<p>将直接量字符单独放进方括号内组成了字符类（charactor class）</p>

<p><em>表10-2</em></p>

<table>
<thead>
<tr>
<th> 字符   </th>
<th> 匹配                                               </th>
</tr>
</thead>
<tbody>
<tr>
<td> [&hellip;]  </td>
<td> 方括号内的任意字符                                 </td>
</tr>
<tr>
<td> [^&hellip;] </td>
<td> 不在方括号内的任意字符                             </td>
</tr>
<tr>
<td> .      </td>
<td> 除换行符和其它 Unicode 行终止符之外的任意字符      </td>
</tr>
<tr>
<td> \w     </td>
<td> 任何 ASCII 字符组成的单词，等价于 [a-zA-Z0-9]      </td>
</tr>
<tr>
<td> \W     </td>
<td> 任何不是 ASCII 字符组成的单词，等价于 [^a-zA-Z0-9] </td>
</tr>
<tr>
<td> \s     </td>
<td> 任何 Unicode 空白符                                </td>
</tr>
<tr>
<td> \S     </td>
<td> 任何非 Unicode 空白符                              </td>
</tr>
<tr>
<td> \d     </td>
<td> 任何 ASCII 数字，等价于 [0-9]                      </td>
</tr>
<tr>
<td> \D     </td>
<td> 任何非 ASCII 数字，等价于 [^0-9]                   </td>
</tr>
<tr>
<td> [\b]   </td>
<td> 退格直接量                                         </td>
</tr>
</tbody>
</table>


<h3>重复</h3>

<p><em>表10-3</em></p>

<table>
<thead>
<tr>
<th> 字符   </th>
<th> 含义                                                           </th>
</tr>
</thead>
<tbody>
<tr>
<td> {n, m} </td>
<td> 匹配前一项至少 n 次，但不能超过 m 次                           </td>
</tr>
<tr>
<td> {n,}   </td>
<td> 匹配前一项 n 次或者更多次                                      </td>
</tr>
<tr>
<td> {n}    </td>
<td> 匹配前一项 n 次                                                </td>
</tr>
<tr>
<td> ?      </td>
<td> 匹配前一项 0 次或者 1 次，也就是说前一项是可选的，等价于 {0,1} </td>
</tr>
<tr>
<td> +      </td>
<td> 匹配前一项 1 次或者多次，等价于 {1,}                           </td>
</tr>
<tr>
<td> *      </td>
<td> 匹配前一项 0 次或者多次，等价于{0,}                            </td>
</tr>
</tbody>
</table>


<p>举例说明：</p>

<pre><code class="javascript">/\d{2,4}/           // 匹配 2 ~ 4 个数字
/\w{3}\d?/          // 匹配三个单词和一个可选的数字
/\s+java\s+/        // 匹配前后带有一个或者多个空白字符串 "java"
/[^(]*/             // 匹配一个或多个非左括号字符
</code></pre>

<h4>非贪婪的重复</h4>

<p>表10-3 中列出一匹配重复字符是尽可能多地匹配，而且允许后续的正则表达式继续匹配。因此，我们称之为「<strong>贪婪的</strong>」匹配。我们同样可以使用正则表达式进行非贪婪匹配。只需在特匹配的字符后跟随一个问题即可：「??」、「+?」、「*?」或「{1,5}?」</p>

<h3>选择、分级和引用</h3>

<p><em>表10-4</em></p>

<table>
<thead>
<tr>
<th> 字符   </th>
<th> 含义  </th>
</tr>
</thead>
<tbody>
<tr>
<td> |     </td>
<td> 选择，匹配的是该符号左边的子表达式或者右边的子表达式               </td>
</tr>
<tr>
<td> (&hellip;)  </td>
<td> 组合，将几个项组合为一个单元，这个单元可通过「*」、「+」、「?」和「|」等符号<br>加以修饰，而且可以记住和这个组合相匹配的字符串<br>以供此后的引用使用 </td>
</tr>
<tr>
<td> (?:&hellip;)</td>
<td> 只组合，把项组合到一个单元，但不记忆与该组想匹配的字符 </td>
</tr>
<tr>
<td> \n     </td>
<td> 和第 n 个分级第一次匹配的字符相匹配，组是圆括号中的子表达式<br>（也有可能是嵌套的），组索引是从左到右的左括号数，<br>「(?:」形式的分组不编码 </td>
</tr>
</tbody>
</table>


<h3>指定匹配位置</h3>

<p><em>表10-5</em></p>

<table>
<thead>
<tr>
<th> 字符  </th>
<th> 含义                                                                       </th>
</tr>
</thead>
<tbody>
<tr>
<td> ^     </td>
<td> 匹配字符串的开头                                                           </td>
</tr>
<tr>
<td> $     </td>
<td> 匹配字符串的结尾                                                           </td>
</tr>
<tr>
<td> \b    </td>
<td> 匹配一个单词的边界                                                         </td>
</tr>
<tr>
<td> \B    </td>
<td> 匹配非单词边界的位置                                                       </td>
</tr>
<tr>
<td> (?=p) </td>
<td> 零宽正向先行断言，要求接下来的字符都与 p 匹配，但不能包括匹配 p 的那些字符 </td>
</tr>
<tr>
<td> (?!p) </td>
<td> 零宽负向先行断言，要求接下来的字符都不与 p 匹配                            </td>
</tr>
</tbody>
</table>


<h3>标识</h3>

<blockquote><p>/reg/flag</p></blockquote>

<p>标识是放在斜扛右边的，通常有 i, g, m 三种</p>

<ul>
<li>i 执行不区分大小写的匹配</li>
<li>g 执行一个全局匹配，即 找到所有的匹配，而不是找到第一个就停止</li>
<li>m 多行匹配模式</li>
</ul>


<h2>用于模式匹配的 string 方法</h2>

<p>String 支持 4 种使用正则表达式的方法</p>

<h3>String.prototype.search()</h3>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search">search()</a> 方法返回第一个与之匹配的子串起始位置，如果找不到匹配的子串，它将返回 -1</p>

<pre><code class="javascript">"JavaScript".search(/script/i);         // =&gt; 4
</code></pre>

<p>如果 search() 参数不是正则表达式，则首先会 <strong>通过 RegExp 构造函数将它转换成正则表达式</strong>，search() 方法不支持全局检索，因为它 <strong>忽略</strong> 正则表达式参数中的标识 g</p>

<h3>String.prototype.replace()</h3>

<blockquote><p>str.replace(regexp|substr, newSubStr|function)</p></blockquote>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace">replace()</a> 方法用以执行检索与替换操作，正则表达式如果带标识 g，则会替换所有匹配子串</p>

<pre><code class="javascript">// 将所有不区分大小写的 javascript 都替换成 JavaScript
text.replace(/javascript/gi);

// 用中文引号替换英文应该引号，同时要保持引号之间的内容（存储在 $1 中）没有被修改
var quote = /"([^"]*)"/g;
text.replace(quote, '“$1”')
</code></pre>

<h3>String.prototype.match()</h3>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match">match()</a> 方法返回一个由匹配结果组成的数组，如果没有标识全局搜索，match() 只检索第一个匹配</p>

<pre><code class="javascript">"1 plus 2 equals 3".match(/\d+/g);  // =&gt; ["1", "2", "3"]
</code></pre>

<h2>RegExp 对象</h2>

<blockquote><p>RegExp(pattern [, flags])</p></blockquote>

<p>RegExp 构造函数一般用在动态创建正则表达式的时候，这种情况往往没办法通过写死在代码中的正则直接量来实现，比如检索字符串是用户输出的</p>

<h3>RegExp 的属性</h3>

<p>每个 RegExp 对象都包含 5 个属性：</p>

<ul>
<li>source 只读字符串，包含正则表达式的文本</li>
<li>global 只读布尔值，说明正则表达式是否带全局标识 g</li>
<li>ignoreCase 也是一个只读布尔值，说明正则表达式是否带标识 i</li>
<li>multiline 也是一个只读布尔值，说明正则表达式是否带标识 m</li>
<li>lastIndex 它是一个可读/写的整数。如果匹配模式带有 g 标识，这个属性存储在整个字符串中下一次检索的开始位置</li>
</ul>


<h3>RegExp 的方法</h3>

<h4>exec()</h4>

<p>exec() 对一个指定的字符串执行一个正则表达式，如果没有找到任何匹配，它就返回 null，但如果它找到一个匹配，将返回一个数组</p>

<pre><code class="javascript">var pattern = /Java/g;
var text = "JavaScript is more fun than Java!";
var result;
while((result = pattern.exec(text)) != null) {
    console.log("Matched '%s' at position '%s'; next search begins at %s",
        result[0],
        result.index,
        pattern.lastIndex);
}
// Matched 'Java' at position '0'; next search begins at 4
// Matched 'Java' at position '28'; next search begins at 32
</code></pre>

<h4>test()</h4>

<p>test() 对方法转入字符串进行检测，匹配到结果返回 true，否则返回 false</p>

<pre><code class="javascript">var pattern = /java/i;
pattern.test('JavaScript');     // =&gt; true
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 9 - 类和模块]]></title>
    <link href="http://keelii.github.io/2016/07/02/javascript-definitive-guide-note-8/"/>
    <updated>2016-07-02T13:58:30+08:00</updated>
    <id>http://keelii.github.io/2016/07/02/javascript-definitive-guide-note-8</id>
    <content type="html"><![CDATA[<p>每个 JavaScript 对象都是一个属性集合，相互之间没有任何联系。在 JavaScript 中也可以定义对象的类，让每个对象都共享某些属性，这种「共享」的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或者定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。这些行为通常是由类定义的，而且为所有实例所共享。例如，假设有一个 Complex 的类用来表示复数， 同时还定义了一些复数运算，一个 Complex 实例应当包含实数的实部和虚部（状态），同样 Complex 类还会定义复数的加法和乘法操作（行为）</p>

<!--more-->


<p>JavaScript 中类的一个重要特性是「<strong>动态可继承</strong>」（dynamically extendable），我们可以将类看做是类型，本章会介绍一种编程哲学 —— 「<a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"><strong>鸭子类型</strong></a>」（duck-typing），它弱化了对象的类型，强化了对象的功能</p>

<h2>类和原型</h2>

<p>在 JavaScript 中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。在之前的 <a href="/2016/06/23/javascript-definitive-guide-note-5/#TOC-4">章节</a> 里定义了 inherit() 函数，这个函数返回一个新创建的对象，后者继承自某个原型对象。如果定义一个原型对象，然后通过 inherit() 函数创建一个继承自它的对象，这样就定义了一个 JavaScript 类。通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象</p>

<pre><code class="javascript">// 一个简单的实现表示值的范围的类
function range(from, to) {
    var r = inherit(range.methods);

    r.from = from;
    r.to = to;
    return r;
}
range.methods = {
    includes: function(x) {
        return this.from &lt;= x &amp;&amp; x &lt;= this.to;
    },
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    }
    toString: function() {
        return "(" + this.from + "..." + this.to + ")";
    }
}
var r = range(1, 3);
r.includes(2)           // =&gt; true
r.foreach(console.log)
// =&gt; 1
// =&gt; 2
// =&gt; 3
console.log(r);         // =&gt; (1...3)
</code></pre>

<p>这段代码定义了一个工厂方法 range()，用来创建新的范围对象。range.methods 属性用来快捷地存放定义类的原型对象。range() 函数给每个范围对象都定义了 from 和 to 属性，用以定义范围的起始和结束位置，这两个属性是 <strong>非共享</strong> 的，当然也是不可继承的。</p>

<h2>类和构造函数</h2>

<p>上节中展示了定义类的一种方法，但是这种方法并不常用，它没定义构造函数。构造函数是用来初始化新创建的对象的。调用构造函数的一个重要特征是，构造函数的 prototype 属性被用做新对象的原型。这意味着 <strong>通过同一个构造函数创建的所有对象都继承自一个相同的对象</strong>，因此它们都是同一个类的成员</p>

<p><em>例9-2</em></p>

<pre><code class="javascript">function Range(from, to) {
    this.from = from;
    this.to = to;
}
Range.prototype = {
    includes: function(x) {
        return this.from &lt;= x &amp;&amp; x &lt;= this.to;
    },
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    }
    toString: function() {
        return "(" + this.from + "..." + this.to + ")";
    }
};
var r = new Range(1, 3)
r.includes(2)       // =&gt; true
r.foreach(console.log)
// =&gt; 1
// =&gt; 2
// =&gt; 3
console.log(r);    // =&gt; "(1...3)"
</code></pre>

<p>从某种意义上讲，定义构造函数既是定义类，并且 <strong>类名首字母要大写</strong>，而普通普通的函数和方法都是首字母小写，Range() 构造函数是通过 new 关键字调用的，而在上一节的工厂函数则不必使用 new。通过 new 调用不必再用  inherit 来创建对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个对象</p>

<h3>构造函数的类的标识</h3>

<p>上文提到，原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。而初始化对象的状态的构造函数则不能作为类的标识，两个构造函数的 prototype 属性可能指责同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的</p>

<p>构造函数的名字通常用做类名，比如我们说 Range() 构造函数创建 Range 对象。然而，更根本地讲，当使用 instancdof 运算符来检测对象是否属于某个类时会用到构造函数。假设有一个对象 r，我们想知道它是否是 Range 对象，可以这样判断</p>

<pre><code class="javascript">r instanceof Range  // 如果 r 继承自 Range.prototype，则返回 true
</code></pre>

<p>实际上 instanceof 运算符并不会检查 r 是否是由 Range() 构造函数初始化而来，而是 <strong>检查 r 是否继承自 Range.prototype</strong></p>

<h3>constructor 属性</h3>

<blockquote><p>每个 JavaScript 函数（bind除外）都自动拥有一个 prototype 属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性 constructor。constructor 属性的值是一个函数对象</p></blockquote>

<pre><code class="javascript">var F = function() {};
var p = F.prototype;
var c = p.constructor;
c === F                 // =&gt; true
</code></pre>

<p>图 9-1 展示了构造函数和原型对象之间的关系，包括原型到构造函数的反向引用以及构造函数创建的实例</p>

<p><em>图9-1</em></p>

<pre><code class="javascript">   构 造 函 数                      原 型                        实 例
+------------------+       +------------------+          +---------------+
|                  |       |                  | inherits |               |
|  Range()         &lt;---------- contructor     &lt;----------+ new Range(2)  |
|                  |       |                  |          |               |
|                  |       |                  |          +---------------+
|                  |       |   includes       |
|   prototype  ------------&gt;                  |
|                  |       |   foreach        |          +---------------+
|                  |       |                  | inherits |               |
|                  |       |   toString       &lt;----------+ new Range(3,4)|
|                  |       |                  |          |               |
|                  |       |                  |          +---------------+
+------------------+       +------------------+
</code></pre>

<p>例9-2中定义的 Range 类使用它自身的一个新对象重写预定义的 Range.prototype 对象。这个新定义的原型对象不含有 constructor 属性。因此 Range 类的实例也不含有 constructor 属性。我匀可以通过补救措施来修正这个问题，显式给原型添加一个构造函数：</p>

<pre><code class="javascript">Range.prototype = {
    constructor: Range,
    incluces: function() {/*code*/}
};
// 当然也可以使用给 prototype 指定方法赋值的方式，避免重写整个 prototype
Range.prototype.includes = function() {/*code*/}
</code></pre>

<h2>JavaScript 中 Java 式的类继承</h2>

<p>在 Java 或者其它类似强类型面向对象语言中，类成员可能是这样的：</p>

<p><strong>实例字段</strong> 它们是基于实例的属性或变量，用以保存独立对象的状态</p>

<p><strong>实例方法</strong> 它们是类的所有实例共享方法，由每个独立的实例调用</p>

<p><strong>类字段</strong> 这些属性或变量是属于类的，而不属于类的某个实例</p>

<p><strong>类方法</strong> 这些方法是属于类的，而不属于类的某个实例</p>

<p>JavaScript 和 Java 的一个不同之处在于，JavaScript 中的函数都是以值的形式出现的，方法和字段之间并没有太大的区别。如果属性是函数，那么这个属性就定义一个方法，否则，它只是一个普通的属性或「字段」</p>

<h2>类和类型</h2>

<h3>instanceof 运算符</h3>

<p>之前我们已经了解过 instanceof 运算符。左操作数是待检测其类的对象，右操作数是定义类的构造函数。如果 o 继承自 c.prototype，则表达式 o instanceof c 值返回 true。这里的继承可以不是直接继承，如果 o 所继承的对象继承自另一个对象，后一个对象继承自 c.prototype，这个表达式的运算结果也是 true</p>

<p>构造函数是类的公共标识，但原型是唯一的标识。尽管 instanceof 运算符的右操作数是构造函数，但计算过程实际上是检测了对象的继承关系，而不是检测创建对象的构造函数</p>

<h3>constructor 属性</h3>

<p>另一种识别对象是否属于某个类的方法是使用 constructor 属性，因为构造函数是类的公共标识，所以最直接的方法就是使用 constructor 属性，比如：</p>

<pre><code class="javascript">function typeAndValue(x) {
    if (x == null) return "";
    switch(x.constructor) {
        case: Number:
            return "Number: " + x;
        case: String:
            return "String: " + x;
        case: Date:
            return "Date: " + x;
        case: RegExp:
            return "RegExp: " + x;
        case: Complex:
            return "Complex: " + x;
    }
}
</code></pre>

<p>使用 constructor 属性检测对象属于某个类的技术不足之处和 instanceof 一样。在 <strong>多个执行上下文</strong> 场景中它是无法正常工作的（比如在浏览器窗口的多个框架子页面中）。在这种情况下每个框架页面各自拥有独立的构造函数集合。比如一个框架页面中的 Array 构造函数和另一个构架页面的 Array 构造函数不是同一个</p>

<h3>鸭子类型</h3>

<p>上面描述的检测对象的类的各种技术多少都会有些问题，至少在客户端 JavaScript 中是如此。解决办法就是规避掉这些问题：<strong>不要关注「对象是什么」，而是关注「对象能做什么」</strong>。这种思考问题的方式在 Python 和 Ruby 中右学普遍，称为「鸭子类型」</p>

<blockquote><p>像鸭子一样走路、游泳并且嘎嘎叫的鸟就是鸭子</p></blockquote>

<p>这又让我想起了《蝙蝠侠》里面的那句话：</p>

<blockquote><p>It’s not who you are underneath, it’s what you do that defines you</p></blockquote>

<h2>JavaScript 中的面向对象技术</h2>

<h3>一个例子：集合类</h3>

<p>集合（set）是一种数据结构，用来表示非重复值的无序集合。集合有添加值、检测值是否存在等方法，下面的例子实现了一个更加通用的 Set 类</p>

<pre><code class="javascript">function Set() {
    this.values = {};
    this.n = 0;
    this.add.apply(this, arguments)
}
Set.prototype.add = function () {
    for (var i = 0; i &lt; arguments.length; i++) {
        var val = arguments[i];
        var str = Set._v2s(val);
        if (!this.values.hasOwnProperty(str)) {
            this.values[str] = val;
            this.n++;
        }
    }

    return this;
}
Set.prototype.remove = function () {
    for (var i = 0; i &lt; arguments.length; i++) {
        var str = Set._v2s(arguments[i]);
        if (this.values.hasOwnProperty(str)) {
            delete this.values[str];
            this.n--;
        }
    }
}
Set.prototype.contains = function (value) {
    return this.values.hasOwnProperty(Set._v2s(value))
}
Set.prototype.size = function () {
    return this.n;
}
Set.prototype.foreach = function(f, context) {
    for (var s in this.values) {
        if (this.values.hasOwnProperty(s)) {
            f.call(context, this.values[s]);
        }
    }
}
Set._v2s = function (val) {
    switch (val) {
        case undefined:     return 'u';
        case null:          return 'n';
        case true:          return 't';
        case false:         return 'f';
        default:
            switch (typeof val) {
                case 'number': return '#' + val;
                case 'string': return '"' + val;
                default: return '@' + objectId(val)
            }
    }
    function objectId(o) {
        var prop = "|**objectid**|";
        if (!o.hasOwnProperty(prop)) {
            o[prop] = Set._v2s.nex++;
        }
        return o[prop];
    }
}
Set._v2s.next = 100;

var s = new Set(1,2,3);
s.values;       // =&gt; Object {#1: 1, #2: 2, #3: 3}
var s1 = new Set(1,2,3,3,2,1, null, undefined)
s1.values;      // =&gt; Object {#1: 1, #2: 2, #3: 3, n: null, u: undefined}
s1.remove(null, undefined);
s1.values;      // =&gt; Object {#1: 1, #2: 2, #3: 3}
</code></pre>

<h3>构造函数的重载和工厂方法</h3>

<p>有时候，我们希望对象的初始化有多种方式，比如 Set 对象，我们想专入一个数组或者类数组，而不是多个参数来初始化它，我们可以加一些判断来实现重载（overload）</p>

<pre><code class="javascript">// 重载
function Set() {
    this.values = {};
    this.n = 0;

    if (arguments.length == 1 &amp;&amp; isArrayLike(arguments[0])) {
        this.add.apply(this, arguments[0])
    } else {
        this.add.apply(this, arguments)
    }
}

// 工厂方法: 可以从数组创建一个集合对象
Set.fromArray = function(a) {
    var s = new Set();
    s.add.apply(s, a)
    return s;
}
// Set 类的一个辅助构造函数
function SetFromArray(a) {
    Set.apply(this, a);
}
SetFromArray.prototype = Set.prototype;
var s = new SetFromArray([1,2,3]);
s instanceof Set        // =&gt; true
</code></pre>

<h2>子类</h2>

<p>在面向对象编程中，类 B 可以继承自另外一个类 A。我们将 A 称为父类（superclass），将 B 称为子类（subclass）。B 的实例从 A继承了所有的实例方法。类 B 可以定义自己的实例类方法，有些方法可以重载类 A 中的同名方法，如果 B 的方法重载了 A 中的方法，B 中的重载方法可能会调用 A 中的重载类 A 方法，这种做法称为「方法链」（method chaining）。同样子类的构造函数 B() 有时需要调用父类的构造函数 A()，这种做法称为「构造函数链」（constructor chaining）。子类还可以有子类，当涉及类的层次结构时，往往需要定义抽象类（abstract class）。抽象类中定义的方法没有实现。抽象类中的抽象方法是在抽象类的具体子类中实现的</p>

<h3>定义子类</h3>

<p>JavaScript 的对象可以从类的原型对象中继承属性。如果 O 是类 B 的实例，B 是 A 的子类，那么 O 也一定从 A 中继承了属性。为此，首先要确保 B 的原型对象继承自 A 的原型对象，通过 inherit() 函数可以实现</p>

<pre><code class="javascript">B.prototype = inherit(A.prototype);
B.prototype.constructor = B;
</code></pre>

<h3>构造函数和方法链</h3>

<p>我们定义一个 Set 的子类 NonNullSet，它不允许 null 和 undefined 作为集合成员，这就需要在子类的 add() 方法中对 null 和 undefined 值做检测。它需要完全重新实现一个 add() 方法</p>

<pre><code class="javascript">function NonNullSet() {
    Set.apply(this, arguments);
}
NonNullSet.prototype = inherit(Set.prototype);
NonNullSet.prototype.constructor = NonNullSet;
NonNullSet.prototype.add = function() {
    for (var i = 0; i &lt; arguments.length; i++) {
        if (arguments[i] == null) {
            throw new Error("Cant't add null or undefined to a NonNullSet");
        }
    }
    return Set.prototype.add.apply(this, arguments);
};
</code></pre>

<h3>组合 vs 子类</h3>

<p>上节中定义的集合可以根据特定的标准对集合成员做限制，而且使用了子类的技术来实现这种功能</p>

<p>然后还有一种更好的方法来完成这种需求，既面向对象编程中一条广为人知的设计原则：「组合优于继承」。这样，可以利用组合的原理定义一个新的集合实现，它「包装」了另外一个集合对象，在将受限制的成员过滤掉之后会用到这个集合对象</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 8 - 函数]]></title>
    <link href="http://keelii.github.io/2016/06/29/javascript-definitive-guide-note-7/"/>
    <updated>2016-06-29T20:22:22+08:00</updated>
    <id>http://keelii.github.io/2016/06/29/javascript-definitive-guide-note-7</id>
    <content type="html"><![CDATA[<p>函数是一段 JavaScript 代码，定义一次，可以被执行多次。JavaScript 函数是参数化的：函数定义会包括一个形参（parameter）的标识符列表，这些参数在函数体中像 <strong>局部变量</strong> 一样工作，函数被调用的时候会为形参提供实参（argument）的值。使用实参的值计算返回值，成为该函数的 <strong><a href="/2016/06/20/javascript-definitive-guide-note-3/#TOC-4">调用表达式</a></strong>值，调用上下文（invocation context）可以用 this 引用，嵌套函数可以构成闭包（closure）</p>

<!-- more -->


<h2>函数定义</h2>

<p>使用 function 关键字来定义一个函数，可以用在函数定义表达式或者函数声明语句里</p>

<pre><code class="javascript">// 打印对象名称和值
function printprops(o) {
    for(var p in o)
        console.log(p + ": " + o[p] + "\n");
}
// 递归调用计算阶乘
function factorial(x) {
    if (x &lt;= 1) return 1;
    return x * factorial(x - 1);
}
// 函数定义表大式，函数名称可以省略
var square = function(x) { return x * x; }
</code></pre>

<p>return 语句导致函数停止执行，并返回它的表达式给调用都。如果 return 语句没有一个与之相关的表达式，则它返回 undefined 值，没有 return 语句也会默认返回 undefined 值给调用者</p>

<p><strong>嵌套函数</strong></p>

<pre><code class="javascript">function hypotenuse(a, b) {
    function square(x) { return x*x; }
    return Math.sqrt(square(a) + square(b));
}
</code></pre>

<p>嵌套函数的作用域规则：它们可以访问嵌套它们的函数的参数和变量。上面的代码里，内部函数 square() 可以读写外部函数 hypotenuse() 定义的参数 a 和 b</p>

<h2>函数调用</h2>

<p>有 4 种方式来调用 JavaScript 函数：</p>

<ul>
<li>作为函数</li>
<li>作为（对象）方法</li>
<li>作为构造函数</li>
<li>通过它们的 call() 和 apply() 方法间接调用</li>
</ul>


<h3>函数调用</h3>

<blockquote><p>function_name(param1, param2);</p></blockquote>

<h3>方法调用</h3>

<blockquote><p>object.method(param1, param2);</p></blockquote>

<pre><code class="javascript">// 对象直接量
var calculator = {
    operand1: 1,
    operand2: 1,
    add: function() {
        this.result = this.operand1 + this.operand2;
    },
    add1: function(a) {
        this.operand1 + a;
        return this;
    },
    add2: function(b) {
        this.operand2 + a;
        return this;
    }
};
calculator.add();
calculator.result       // =&gt; 2
// 使用对象属性访问表达式调用方法
calculator['result']    // =&gt; 2
// 链式调用
calculator.add1(1).add2(2)
calculator.operand1         // =&gt; 2
calculator.operand2         // =&gt; 3
</code></pre>

<h3>构造函数调用</h3>

<blockquote><p>new Object(param1, param2);</p></blockquote>

<p>如果没有参数可以省略括号 <code>new Object</code></p>

<h3>间接调用</h3>

<blockquote><p>function_name.call()</p></blockquote>

<p>JavaScript 中的 <strong>函数也是对象</strong>，和其它 JavaScript 对象没什么区别，函数对象也可以包含方法。其中两个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply()</a> 可以用来间接地调用函数。两个方法都允许显式地指定调用所需的 this 值</p>

<h2>函数的实参和形参</h2>

<p>JavaScript 的函数定义不用指定形参的类型，调用传入的实参也可以是任意类型，JavaScript <strong>甚至</strong> 不检查传入实参的个数</p>

<h3>可选形参</h3>

<p>如果调用函数的时候传入的实参比指定的形参少，剩下的形参都将设置为 undefined 值，通常使用逻辑与运算符给形参指定默认值</p>

<pre><code class="javascript">function getName(name) {
    // 如果 name 传入值则使用传入值，否则使用默认值 "no name"
    // 通常建议可选参数放在参数列表最后
    name = name || "no name";

    // code

    return name;
}
</code></pre>

<h3>可变长的实参列表：实参对象</h3>

<p>当调用函数的时候传入实参人个数超过形参个数时（和上面相反），没有办法直接获得未命名值的引用。参数对象解决了这个问题，在函数体内，标识符 arguments 是指向实参对象的引用，参数对象是一个 <a href="/2016/06/23/javascript-definitive-guide-note-6/#TOC-23">类数组对象</a>，这样可以通过索引来访问实参了</p>

<pre><code class="javascript">function fn(x, y, z) {
    console.log(arguments);
}
fn(1,2,3)           // =&gt; [1,2,3]
fn(1,2,3,4,5)       // =&gt; [1,2,3,4,5]
</code></pre>

<p>实参对象的重要用处就是让函数可以操作任意数量的实参，比如我们自己实现一个数组的 push 方法</p>

<pre><code class="javascript">function push(arr /* optional items [, item ... [, item]] */) {
    var items = Array.prototype.slice.call(arguments, 1)
    for (var i = 0; i &lt; items.length; i++) {
        arr[arr.length] = items[i];
    }
}
var arr1 = [1,2,3];
push(arr1, 4,5,6);
arr1                // =&gt; [1, 2, 3, 4, 5, 6]
</code></pre>

<p>在非严格模式下，修改 arguments 元素的值，实参的值也会变。不过在 ECMAScript 5 中这个特性被移除了。在非严格模式中，函数里的 arguments 仅仅是个标识符。在严格模式中，它变成了一个保留字，严格模式中函数无法使用 arguments 作为 <strong>形参名</strong> 或者 <strong>局部变量名</strong>，也不能给它（arguments）赋值</p>

<pre><code class="javascript">
function f(x) {
    console.log(x);         // =&gt; 实参的初始值
    arguments[0] = null;
    console.log(x);         // =&gt; 非严格返回 null， 非严格返回 1
}
f(1)
</code></pre>

<h4>callee 和 caller 属性</h4>

<p>除了数组元素，实参对象还定义了 callee 和 caller 属性。严格模式中对这两个属性读写操作会产生一个类型错误，非严格模式下，ECMAScript 标准规范规定 callee 属性指代当前正在执行的函数。caller 是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数。通过 caller 属性可以访问调用栈，callee 属性在某些时候非常有用，比如在匿名函数中通过 callee 来递归调用自身</p>

<pre><code class="javascript">var factorial = function(x) {
    if (x &lt;= 1) return 1;
    return x * arguments.callee(x-1);
}
</code></pre>

<h3>将对象属性用做实参</h3>

<p>当一个函数包含超过三个形参时，很难记住参数顺序。这时我们可以用名/值对的形式来传入参数，这样参数的顺序就无关紧要了（然后名/值对里面的键名还是得记住）</p>

<pre><code class="javascript">function arraycopy(from, from_start, to, to_start, length) {
}
function easycopycopy(args) {
    arraycopy(args.from,
              args.from_start || 0,
              args.to,
              args.to_start || 0,
              args.length);
}
var a = [1,2,3,4], b = [];
easycopy({ from: a, to: b, length:4 })
</code></pre>

<h3>实参类型</h3>

<p>JavaScript 函数中形参并未声明类型，在形参数传入之前也未做任何类型检查，JavaScript 会在必要的时候进行类型转换，因此如果函数期望接收一个出神入化串实参，而调用函数时传入其它类型的值，所传入的值会在函数体内将其转换为字符串</p>

<h2>作为值的函数</h2>

<p>函数的定义和调用是 JavaScript 的词法特性，其它语言也一样。然而在 JavaScript 中，函数不仅仅是一种语法，也可以是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组元素中，作为参数传入另外一个函数等</p>

<pre><code class="javascript">function square(x) { return x*x; }
var s = square;
square(4) == s(4)       // =&gt; true

var a = [ function square(x) { return x*x; }, 20 ];
a[0](a[1]);             // =&gt; 400

// 将函数用做值
function add(x, y) { return x + y; }
function subtract(x, y) { return x - y; }
function multiply(x, y) { return x * y; }
function divide(x, y) { return x / y; }

function operate(operator, operand1, operand2) {
    return operator(operand1, operand2)
}
// =&gt; 25 (2 + 3) + (4 * 5)
var i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5))
</code></pre>

<h4>自定义函数属性</h4>

<p>JavaScript 中函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有 <strong>属性</strong>。当函数需要一个 <strong>静态变量</strong> 来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量</p>

<pre><code class="javascript">// 注意静态变量不必在函数后面声明
uniqueInteger.counter = 0;

function uniqueInteger() {
    // 注意 ++counter 和 count++ 不一样
    return ++uniqueInteger.counter;
}
</code></pre>

<p>下面这个函数 factirial() 使用了自身的属性（将自身当做数组来对待）来缓存上一次的计算结果：</p>

<pre><code class="javascript">// 计算阶乘
function factorial(n) {
    if (isFinite(n) &amp;&amp; n &gt; 0 &amp;&amp; n == Math.round(n)) {
        if (!(n in factorial)) {
            factorial[n] = n * factorial(n-1)
        }
        return factorial[n]
    } else {
        return NaN;
    }
}
// 初始化缓存以保存这种基本情况
factorial[1] = 1;
</code></pre>

<h2>作为命名空间的函数</h2>

<pre><code class="javascript">(function(/*paramater*/) {
    // 模块代码
    // 这个模块使用的所有变量（通过 var 声明）都是局部变量
    // 不会污染全局命名空间
})(/*arguments*/);

(function(win, doc) {
    var obj = {
        privateMethod: function() {},
        publicMethod: function() {}
    };

    win.yourPublicAPIMethodName = obj.publicMethod
})(window, document);
</code></pre>

<p>使用 <strong><a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">立即执行函数表达式（IIFE）</a></strong> 可以隔离代码块的命名空间，在匿名函数中声明的变量只在内部有效，不会对全局产生影响，同时可以有选择地向全局输出变量用来给外部代码访问</p>

<h2>闭包</h2>

<blockquote><p>词法作用域（lexical scoping）的执行依赖于变量作用域，这个作用域是在函数 <strong>定义时</strong> 决定的，而不是函数调用时，为了实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为「闭包」</p></blockquote>

<p>从技术角度讲，所有的 JavaScript 函数都是闭包：它们都是对象，它们都关联到作用域链。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事情就变得非常我刚好和。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象 <strong>作为返回值返回</strong> 的时候，这种事情就发生了</p>

<p>先看一下嵌套函数的词法作用域规则：</p>

<pre><code class="javascript">// 例 1
var scope = "global scope";
function checkscope() {
    var scope = "local scope";
    function f() { return scope;}
    return f();
}
checkscope();       // =&gt; "local scope"
// 例 2
var scope = "global scope";
function checkscope() {
    var scope = "local scope";
    function f() { return scope;}
    return f;
}
checkscope()()      // =&gt; "local scope"
</code></pre>

<p>在例 2 中我们将 checkscope 返回值 f 调用的括号移动到了 checkscope 调用后面。复习一下作用域的基本规则：JavaScript 函数的执行用到了作用域链，这个作用域链是函数 <strong>定义的时候</strong> 创建的，嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管在何时执行函数当 f()，这种绑定在执行 f() 时依然有效。因此最后一行代码返回「local scope」而不是「global scope」。简而言之，闭包的这个特性强大到让人吃惊：它们可以捕捉到局部变量（和参数），<strong>并一直保存下来</strong></p>

<p>很多程序员觉得闭包非常难理解，他们觉得在外部函数中定义的局部变量在函数返回后就不存在了，那么嵌套的函数如何能调用不存在的作用域链呢？如果你想搞清楚这个问题，还得更深入地了解类似 C 语言这种更底层的编程语言，并了解基于栈的 CPU 架构 <strong>如果一个函数的尾部变量定义在 CPU 的栈中，那么当函数返回时它们的确就不存在了</strong></p>

<p><a href="#TOC-13">上节</a>中的 uniqueInteger() 函数，这个函数有一个问题，函数本身是全局可访问的，这个 counter 很可能被外部修改。如果使用闭包就没有这个问题</p>

<pre><code class="javascript">var uniqueInteger = (function() {
    var counter = 0;
    return function() {
        return ++counter;
    }
})();
</code></pre>

<p>上面的代码将匿名立即执行函数赋值给 uniqueInteger 变量，所以函数的返回值赋值给变量 uniqueInteger，内部变量 counter 只在函数体内部可以访问，外部无法操作</p>

<p>私有变量也可以被多个闭包访问到，比如：</p>

<pre><code class="javascript">function counter() {
    var n = 0;
    return {
        count: function() { return n++ },
        reset: function() { n = 0 }
    }
}
// 创建两个计数器
var c = counter(), d = counter();
c.count()       // =&gt; 0 互
c.count()       // =&gt; 1 不
d.count()       // =&gt; 0 干
d.count()       // =&gt; 1 扰
c.reset()       // =&gt; 0 重置 c
d.count()       // =&gt; 2 不影响 d
</code></pre>

<p>在同一个作用域链中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是一种非常重要的技术，但是要特别小心那些不希望共享的变量往往不经意间共享给了其它的闭包，了解这一点也很重要</p>

<pre><code class="javascript">function constfunc(v) { return function() { return v; } }

var funcs = [];
for(var i = 0; i &lt; 10; i++) {
    funcs[i] = constfunc(i);
}
</code></pre>

<p>如果这样写就完全不一样了</p>

<pre><code class="javascript">function constfuncs() {
    var funcs = [];
    for (var i = 0; i &lt; 10; i++) {
        funcs[i] = function() {
            return i;
        };
    }
    return funcs;
}
var funcs = constfuncs();
funcs[5]()                  // =&gt; 10 !!!
</code></pre>

<p>上面这段代码循环创建了 10 个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量 i。当 constfuncs() 返回时，变量的 i 值是 10，所有的闭包都共享这一个值，因此，数组中的函数的返回值是同一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域链都是「活动的（live）」，记住这一点非常重要。嵌套的当函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照（static snapshot）</p>

<p>书写闭包的时候还需注意一件事情，this 是 JavaScript 的关键字，不是变量。正如之前讨论的，每个函数调用都包含一个 this 值，如果闭包在外部函数里是无法访问 this 的，除非外部函数将 this 默契为一个变量</p>

<pre><code class="javascript">function outerFn() {
    var self = this;

    function innerFn() {
        // self.xxxx
    }
}
</code></pre>

<h2>函数属性、方法和构造函数</h2>

<p>在 JavaScript 中，函数是值，对函数执行 typeof 运算会返回字符串 &ldquo;function"，但是函数是 JavaScript 中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，像普通对象一样。甚至可以用 Function() 构造函数来创建新的函数对象</p>

<h3>prototype 属性</h3>

<p>每一个当函数都包含一个 prototype 属性，这个属性是指向一个对象的引用，这个对象称做「原型对象」（prototype object）。每一个函数都包含不同的原型对象。当将函数胜仗构造函数的时候，新创建的对象会从原型对象上继承属性</p>

<h3>call() 和 apply() 方法</h3>

<blockquote><p>fun.call(thisArg[, arg1[, arg2[, &hellip;]]])</p>

<p>fun.apply(thisArg[, argsArray])</p></blockquote>

<p>我们可以将 call 和 apply 看做是某个对象的方法，通过调用方法的形式来间接调用函数</p>

<pre><code class="javascript">// 将对象 o 中名为 m 的方法替换为另外一个方法
function trace(o, m) {
    var original = o[m];
    o[m] = function() {
        console.log(new Date, "Entering: ", m);
        var result = original.apply(this, arguments)
        console.log(new Date, "Exiting: ", m);
    }
}
</code></pre>

<p>trace() 函数接收两个参数，一个对象和一个方法名，它将指定的方法替换为一个新方法，这个新方法就是「包裹」原始方法的另一个泛函数。这种动态修改已有方法的做法有时称做「猴子补丁 monkey-patching」</p>

<h3>bind() 方法</h3>

<blockquote><p>fun.bind(thisArg[, arg1[, arg2[, &hellip;]]])</p></blockquote>

<p>bind 方法是 ECMAScript 5 中新增的方法，但在 ECMAScript 3 中可以模拟出来。主要用于将函数绑定到某个对象。当在函数 f 上调用 bind 方法并传入一个对象 o 做参数，这个方法将返回一个新的函数。调用新的函数将会把原始的函数 f <strong>当做 o 的方法来调用</strong>。传入新函数的任何实参都将传入原始函数</p>

<pre><code class="javascript">function f(y) { return this.x + y; }
var o = { x: 1};
var g = f.bind(o);
g(2)                // =&gt; 3
</code></pre>

<p>可以通过下面代码实现 bind 方法</p>

<pre><code class="javascript">function bind(f, o) {
    if (f.bind) {
        return f.bind(o);
    } else {
        return f.apply(ok arguments)
    }
}
</code></pre>

<p>bind 方法还有一些其他应用：除了第一个实参之外，传入 bind 的实参也会绑定至 this，这个附带的应用是一种常见的函数式编程技术，有时也被称为「<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a>」（currying）</p>

<pre><code class="javascript">var sum = function(x, y) { return x + y }

var succ = sum.bind(null, 1)
succ(2)     // =&gt; 3

function f(y, z) { return this.x + y + z }
var g = f.bind({x:1}, 2)
g(3)        // =&gt; 6
</code></pre>

<p>注意 bind 方法有些特性是模拟不出来的</p>

<h3>toString() 方法</h3>

<p>和所有的 JavaScript 对象一样，函数也有 toString 方法，ECMAScript 规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数的 toString 方法的实现都返回函数的完成源码。内置函数往往返回一个类似 &ldquo;[native code]&rdquo; 的字符串作为函数体</p>

<h3>Function() 构造函数</h3>

<blockquote><p>new Function ([arg1[, arg2[, &hellip;argN]],] functionBody)</p></blockquote>

<p>关于 Function() 构造函数有几点需要特别注意：</p>

<ul>
<li>Function() 构造函数允许 JavaScript 在运行时动态地创建并编译函数</li>
<li>每次调用 Function() 构造函数都会解析函数体，执行效率会受影响。</li>
<li>Function() 构造函数创建的函数 <strong>并不是使用词法作用域</strong>，相反，函数体代码的编译总是会在顶层函数执行，效果类似在全局作用域中执行 eval()</li>
</ul>


<pre><code class="javascript">var scope = "global";
function constructFunction() {
    var scope = "local";
    return new Function("return scope");
}
constructFunction()();  // =&gt; "global"
</code></pre>

<h3>可调用的对象</h3>

<p>「类数组对象」类似数组但并不是真正的数组，「可调用对象（callable object）」类似于函数但并不是真正的函数。可调用对象在两个 JavaScript 实现中不能算作函数。首先，IE Web 浏览器（IE 6 及之前的版本）实现了客户端方法（如 Window.alert() 和 Document.getElementById()），使用了可调用的宿主对象，而不是内置函数对象，IE 中的这些方法在其它浏览器中都存在，但它们本质上不是 Function 对象。IE 9 将它们实现为真正的函数，因此这类可调用的对象将越来越罕见</p>

<p>另外一个常见的可调用对象是 RegExp 对象，对 RegExp 执行 typeof 运算的结果并不统一，有些返回 &ldquo;function&rdquo; 有些返回 &ldquo;object"。可以使用下面的方法判断是不是真正的函数对象</p>

<pre><code class="javascript">function isFunction(o) {
    return Object.prototype.toString.call(x) === "[object Function]"
}
</code></pre>

<h2>函数式编程</h2>

<p>JavaScript 并不是一种像 List 或 Haskell 的函数式编程语言，但在 JavaScript 中可以像操控对象一样操控函数，也就是说可以在 JavaScript 中应用函数式编程技术</p>

<h3>使用函数处理数组</h3>

<p>假设有一个数组，元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话代码一般会是这样：</p>

<pre><code class="javascript">var data = [1,1,3,5,5]
var total = 0;
for (var i = 0; i &lt; data.length; i++) {
    total += data[i];
}
var mean = total / data.length;                 // =&gt; 3

total = 0;
for (var i = 0; i &lt; data.length; i++) {
    var deviation = data[i] - mean;
    total += deviation * deviation;
}
var stddev = Math.sqrt(total/(data.length-1))   // =&gt; 2
</code></pre>

<p>可以使用数组方法 map() 和 reduce() 来实现同样的计算，这种实现极其乘法：</p>

<pre><code class="javascript">var sum = function(x, y) { return x + y; }
var square = function(x) { return x*x; }

var data = [1,1,3,5,5]
var mean = data.reduce(sum)/data.length;
var deviations = data.map(function(x) { return x-mean; })
var stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length-1))
</code></pre>

<p>当然 ECMAScript 3 并没有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a>， <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">reduce</a> 这两个方法，不过我们也可以自己实现一个 Polyfill，可以参考链接里面的内容</p>

<h3>高阶函数</h3>

<p>所谓高阶函数（higher-order function）就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数</p>

<pre><code class="javascript">function not(f) {
    return function() {
        var result = f.apply(this, arguments);
        return !result;
    }
}
var even = function(x) {
    return x % 2 == 0;
}
var odd = not(even);
[1,1,3,5,5].every(odd)          // =&gt; true
</code></pre>

<p>mapper() 函数也是一个高阶函数，它接收一个函数作为参数，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上，这个函数使用了之前定义的 map() 函数</p>

<pre><code class="javascript">function mapper(f) {
    return function(a) { return map(a, f); }
}
var increment = function(x) { return x + 1; }
var incrementer = mapper(increment);
incrementer([1,2,3])  // =&gt; [2,3,4]
</code></pre>

<p>还有一个更常见的例子，它接收两个函数 f() 和 g()，并返回一个新的函数用以计算 f(g())</p>

<pre><code class="javascript">function compose(f, g) {
    return function() {
        return f.call(this, g.apply(this, arguments))
    }
}
var square = function(x) { return x * x; }
var sum = function(x, y) { return x + y; }
var squareofsum = compose(square, sum)
squareofsum(2, 3)           // =&gt; 25
/* - 伪代码执行过程大致如下 -
    arguments: 2, 3
    return square.call(this, sum.apply(this, arguments))
    return square.call(this, sum(2, 3))
    return square.call(this, 5)
    arguments: 5
    return square(5)
    return 25
*/
</code></pre>

<h3>不完全函数</h3>

<p>函数 <a href="/2016/06/29/javascript-definitive-guide-note-7/#TOC-19">f()</a> 的 bind() 方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用函数 f()。我们说它把函数「绑定至」对象并传入一部分参数。bind() 方法只是将实参放在左侧，也就是说传入 bind() 的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入 bind() 的实参放在右侧</p>

<pre><code class="javascript">// 将类数组对象转换为真正的数组
function array(arr, n) { return Array.prototype.slice.call(arr, n || 0); }

// 这个函数的实参传递到左侧
function partialLeft(f) {
    var args = arguments;

    return function() {
        var a = array(args, 1);
        a = a.concat(array(arguments))
        return f.apply(this, a)
    }
}
function partialRight(f) {
    var args = arguments;

    return function() {
        var a = array(arguments)
        a = a.concat(array(args, 1))
        return f.apply(this, a)
    }
}

function partial(f) {
    var args = arguments;

    return function() {
        var a = array(args, 1)
        var i = 0, j = 0;
        for (; i &lt; a.length; i++) {
            if ( a[i] === undefined ) a[i] = arguments[j++];
        }
        a = a.concat(array(arguments, j))
        return f.apply(this, a);
    }
}

var f = function(x, y, z) { return x * (y - z) }
partialLeft(f, 2)(3, 4)             // =&gt; -2 2 * (3-4)
partialRight(f, 2)(3, 4)            // =&gt; 6 3 * (4-2)
partial(f, undefined, 2)(3, 4)      // =&gt; -6 3 * (2-4)
</code></pre>

<h3>记忆</h3>

<p>上面的 <a href="/2016/06/29/javascript-definitive-guide-note-7/#TOC-13">章节</a> 中定义了一个阶乘函数，它可以将上次的计算结果缓存起来。在函数式程序当中，这种缓存技巧叫做「记忆」（memorization）。下面的代码展示了一个高阶函数，memorize() 接收一个函数作为实参，并返回带有记忆能力的函数</p>

<pre><code class="javascript">function memorize(f) {
    var cache = {};

    return function() {
        // 将实参转换为字符串形式，并胜仗缓存的键名
        var key = arguments.length + Array.prototype.join.call(arguments, ",")
        if ( key in cache ) {
            return cache[key];
        } else {
            return cache[key] = f.apply(this, arguments)
        }
    }
}
function factorial (num) {
    console.log('Actually invoked.');
    if (num &lt; 0) {
        return -1;
    } else if (num === 0 || num === 1) {
        return 1;
    } else {
        return (num * factorial(num - 1));
    }
}

var cached_factorial = memorize(factorial);

cached_factorial(3)
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 6
cached_factorial(3)
// =&gt; 6

/**
 * 注意下面的调用方式将不会缓存
 * 因为新建了多个闭包，闭包在每
 * 调用一次 memorize 就返回一
 * 份新的 cache 变量
 */
memorize(factorial)(3)
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 6
memorize(factorial)(3)
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 6
</code></pre>
]]></content>
  </entry>
  
</feed>
