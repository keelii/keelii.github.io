<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Something]]></title>
  <link href="http://keelii.github.io/categories/javascript/atom.xml" rel="self"/>
  <link href="http://keelii.github.io/"/>
  <updated>2016-07-04T10:50:34+08:00</updated>
  <id>http://keelii.github.io/</id>
  <author>
    <name><![CDATA[keelii]]></name>
    <email><![CDATA[keeliizhou@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 9 - 类和模块]]></title>
    <link href="http://keelii.github.io/2016/07/02/javascript-definitive-guide-note-8/"/>
    <updated>2016-07-02T13:58:30+08:00</updated>
    <id>http://keelii.github.io/2016/07/02/javascript-definitive-guide-note-8</id>
    <content type="html"><![CDATA[<p>每个 JavaScript 对象都是一个属性集合，相互之间没有任何联系。在 JavaScript 中也可以定义对象的类，让每个对象都共享某些属性，这种「共享」的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或者定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。这些行为通常是由类定义的，而且为所有实例所共享。例如，假设有一个 Complex 的类用来表示复数， 同时还定义了一些复数运算，一个 Complex 实例应当包含实数的实部和虚部（状态），同样 Complex 类还会定义复数的加法和乘法操作（行为）</p>

<!--more-->


<p>JavaScript 中类的一个重要特性是「<strong>动态可继承</strong>」（dynamically extendable），我们可以将类看做是类型，本章会介绍一种编程哲学 —— 「<a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"><strong>鸭子类型</strong></a>」（duck-typing），它弱化了对象的类型，强化了对象的功能</p>

<h2>类和原型</h2>

<p>在 JavaScript 中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。在之前的 <a href="/2016/06/23/javascript-definitive-guide-note-5/#TOC-4">章节</a> 里定义了 inherit() 函数，这个函数返回一个新创建的对象，后者继承自某个原型对象。如果定义一个原型对象，然后通过 inherit() 函数创建一个继承自它的对象，这样就定义了一个 JavaScript 类。通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象</p>

<pre><code class="javascript">// 一个简单的实现表示值的范围的类
function range(from, to) {
    var r = inherit(range.methods);

    r.from = from;
    r.to = to;
    return r;
}
range.methods = {
    includes: function(x) {
        return this.from &lt;= x &amp;&amp; x &lt;= this.to;
    },
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    }
    toString: function() {
        return "(" + this.from + "..." + this.to + ")";
    }
}
var r = range(1, 3);
r.includes(2)           // =&gt; true
r.foreach(console.log)
// =&gt; 1
// =&gt; 2
// =&gt; 3
console.log(r);         // =&gt; (1...3)
</code></pre>

<p>这段代码定义了一个工厂方法 range()，用来创建新的范围对象。range.methods 属性用来快捷地存放定义类的原型对象。range() 函数给每个范围对象都定义了 from 和 to 属性，用以定义范围的起始和结束位置，这两个属性是 <strong>非共享</strong> 的，当然也是不可继承的。</p>

<h2>类和构造函数</h2>

<p>上节中展示了定义类的一种方法，但是这种方法并不常用，它没定义构造函数。构造函数是用来初始化新创建的对象的。调用构造函数的一个重要特征是，构造函数的 prototype 属性被用做新对象的原型。这意味着 <strong>通过同一个构造函数创建的所有对象都继承自一个相同的对象</strong>，因此它们都是同一个类的成员</p>

<p><em>例9-2</em></p>

<pre><code class="javascript">function Range(from, to) {
    this.from = from;
    this.to = to;
}
Range.prototype = {
    includes: function(x) {
        return this.from &lt;= x &amp;&amp; x &lt;= this.to;
    },
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    }
    toString: function() {
        return "(" + this.from + "..." + this.to + ")";
    }
};
var r = new Range(1, 3)
r.includes(2)       // =&gt; true
r.foreach(console.log)
// =&gt; 1
// =&gt; 2
// =&gt; 3
console.log(r);    // =&gt; "(1...3)"
</code></pre>

<p>从某种意义上讲，定义构造函数既是定义类，并且 <strong>类名首字母要大写</strong>，而普通普通的函数和方法都是首字母小写，Range() 构造函数是通过 new 关键字调用的，而在上一节的工厂函数则不必使用 new。通过 new 调用不必再用  inherit 来创建对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个对象</p>

<h3>构造函数的类的标识</h3>

<p>上文提到，原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。而初始化对象的状态的构造函数则不能作为类的标识，两个构造函数的 prototype 属性可能指责同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的</p>

<p>构造函数的名字通常用做类名，比如我们说 Range() 构造函数创建 Range 对象。然而，更根本地讲，当使用 instancdof 运算符来检测对象是否属于某个类时会用到构造函数。假设有一个对象 r，我们想知道它是否是 Range 对象，可以这样判断</p>

<pre><code class="javascript">r instanceof Range  // 如果 r 继承自 Range.prototype，则返回 true
</code></pre>

<p>实际上 instanceof 运算符并不会检查 r 是否是由 Range() 构造函数初始化而来，而是 <strong>检查 r 是否继承自 Range.prototype</strong></p>

<h3>constructor 属性</h3>

<blockquote><p>每个 JavaScript 函数（bind除外）都自动拥有一个 prototype 属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性 constructor。constructor 属性的值是一个函数对象</p></blockquote>

<pre><code class="javascript">var F = function() {};
var p = F.prototype;
var c = p.constructor;
c === F                 // =&gt; true
</code></pre>

<p>图 9-1 展示了构造函数和原型对象之间的关系，包括原型到构造函数的反向引用以及构造函数创建的实例</p>

<p><em>图9-1</em></p>

<pre><code class="javascript">   构 造 函 数                      原 型                        实 例
+------------------+       +------------------+          +---------------+
|                  |       |                  | inherits |               |
|  Range()         &lt;---------- contructor     &lt;----------+ new Range(2)  |
|                  |       |                  |          |               |
|                  |       |                  |          +---------------+
|                  |       |   includes       |
|   prototype  ------------&gt;                  |
|                  |       |   foreach        |          +---------------+
|                  |       |                  | inherits |               |
|                  |       |   toString       &lt;----------+ new Range(3,4)|
|                  |       |                  |          |               |
|                  |       |                  |          +---------------+
+------------------+       +------------------+
</code></pre>

<p>例9-2中定义的 Range 类使用它自身的一个新对象重写预定义的 Range.prototype 对象。这个新定义的原型对象不含有 constructor 属性。因此 Range 类的实例也不含有 constructor 属性。我匀可以通过补救措施来修正这个问题，显式给原型添加一个构造函数：</p>

<pre><code class="javascript">Range.prototype = {
    constructor: Range,
    incluces: function() {/*code*/}
};
// 当然也可以使用给 prototype 指定方法赋值的方式，避免重写整个 prototype
Range.prototype.includes = function() {/*code*/}
</code></pre>

<h2>JavaScript 中 Java 式的类继承</h2>

<p>在 Java 或者其它类似强类型面向对象语言中，类成员可能是这样的：</p>

<p><strong>实例字段</strong> 它们是基于实例的属性或变量，用以保存独立对象的状态</p>

<p><strong>实例方法</strong> 它们是类的所有实例共享方法，由每个独立的实例调用</p>

<p><strong>类字段</strong> 这些属性或变量是属于类的，而不属于类的某个实例</p>

<p><strong>类方法</strong> 这些方法是属于类的，而不属于类的某个实例</p>

<p>JavaScript 和 Java 的一个不同之处在于，JavaScript 中的函数都是以值的形式出现的，方法和字段之间并没有太大的区别。如果属性是函数，那么这个属性就定义一个方法，否则，它只是一个普通的属性或「字段」</p>

<h2>类和类型</h2>

<h3>instanceof 运算符</h3>

<p>之前我们已经了解过 instanceof 运算符。左操作数是待检测其类的对象，右操作数是定义类的构造函数。如果 o 继承自 c.prototype，则表达式 o instanceof c 值返回 true。这里的继承可以不是直接继承，如果 o 所继承的对象继承自另一个对象，后一个对象继承自 c.prototype，这个表达式的运算结果也是 true</p>

<p>构造函数是类的公共标识，但原型是唯一的标识。尽管 instanceof 运算符的右操作数是构造函数，但计算过程实际上是检测了对象的继承关系，而不是检测创建对象的构造函数</p>

<h3>constructor 属性</h3>

<p>另一种识别对象是否属于某个类的方法是使用 constructor 属性，因为构造函数是类的公共标识，所以最直接的方法就是使用 constructor 属性，比如：</p>

<pre><code class="javascript">function typeAndValue(x) {
    if (x == null) return "";
    switch(x.constructor) {
        case: Number:
            return "Number: " + x;
        case: String:
            return "String: " + x;
        case: Date:
            return "Date: " + x;
        case: RegExp:
            return "RegExp: " + x;
        case: Complex:
            return "Complex: " + x;
    }
}
</code></pre>

<p>使用 constructor 属性检测对象属于某个类的技术不足之处和 instanceof 一样。在 <strong>多个执行上下文</strong> 场景中它是无法正常工作的（比如在浏览器窗口的多个框架子页面中）。在这种情况下每个框架页面各自拥有独立的构造函数集合。比如一个框架页面中的 Array 构造函数和另一个构架页面的 Array 构造函数不是同一个</p>

<h3>鸭子类型</h3>

<p>上面描述的检测对象的类的各种技术多少都会有些问题，至少在客户端 JavaScript 中是如此。解决办法就是规避掉这些问题：<strong>不要关注「对象是什么」，而是关注「对象能做什么」</strong>。这种思考问题的方式在 Python 和 Ruby 中右学普遍，称为「鸭子类型」</p>

<blockquote><p>像鸭子一样走路、游泳并且嘎嘎叫的鸟就是鸭子</p></blockquote>

<p>这又让我想起了《蝙蝠侠》里面的那句话：</p>

<blockquote><p>It’s not who you are underneath, it’s what you do that defines you</p></blockquote>

<h2>JavaScript 中的面向对象技术</h2>

<h3>一个例子：集合类</h3>

<p>集合（set）是一种数据结构，用来表示非重复值的无序集合。集合有添加值、检测值是否存在等方法，下面的例子实现了一个更加通用的 Set 类</p>

<pre><code class="javascript">function Set() {
    this.values = {};
    this.n = 0;
    this.add.apply(this, arguments)
}
Set.prototype.add = function () {
    for (var i = 0; i &lt; arguments.length; i++) {
        var val = arguments[i];
        var str = Set._v2s(val);
        if (!this.values.hasOwnProperty(str)) {
            this.values[str] = val;
            this.n++;
        }
    }

    return this;
}
Set.prototype.remove = function () {
    for (var i = 0; i &lt; arguments.length; i++) {
        var str = Set._v2s(arguments[i]);
        if (this.values.hasOwnProperty(str)) {
            delete this.values[str];
            this.n--;
        }
    }
}
Set.prototype.contains = function (value) {
    return this.values.hasOwnProperty(Set._v2s(value))
}
Set.prototype.size = function () {
    return this.n;
}
Set.prototype.foreach = function(f, context) {
    for (var s in this.values) {
        if (this.values.hasOwnProperty(s)) {
            f.call(context, this.values[s]);
        }
    }
}
Set._v2s = function (val) {
    switch (val) {
        case undefined:     return 'u';
        case null:          return 'n';
        case true:          return 't';
        case false:         return 'f';
        default:
            switch (typeof val) {
                case 'number': return '#' + val;
                case 'string': return '"' + val;
                default: return '@' + objectId(val)
            }
    }
    function objectId(o) {
        var prop = "|**objectid**|";
        if (!o.hasOwnProperty(prop)) {
            o[prop] = Set._v2s.nex++;
        }
        return o[prop];
    }
}
Set._v2s.next = 100;

var s = new Set(1,2,3);
s.values;       // =&gt; Object {#1: 1, #2: 2, #3: 3}
var s1 = new Set(1,2,3,3,2,1, null, undefined)
s1.values;      // =&gt; Object {#1: 1, #2: 2, #3: 3, n: null, u: undefined}
s1.remove(null, undefined);
s1.values;      // =&gt; Object {#1: 1, #2: 2, #3: 3}
</code></pre>

<h3>构造函数的重载和工厂方法</h3>

<p>有时候，我们希望对象的初始化有多种方式，比如 Set 对象，我们想专入一个数组或者类数组，而不是多个参数来初始化它，我们可以加一些判断来实现重载（overload）</p>

<pre><code class="javascript">// 重载
function Set() {
    this.values = {};
    this.n = 0;

    if (arguments.length == 1 &amp;&amp; isArrayLike(arguments[0])) {
        this.add.apply(this, arguments[0])
    } else {
        this.add.apply(this, arguments)
    }
}

// 工厂方法: 可以从数组创建一个集合对象
Set.fromArray = function(a) {
    var s = new Set();
    s.add.apply(s, a)
    return s;
}
// Set 类的一个辅助构造函数
function SetFromArray(a) {
    Set.apply(this, a);
}
SetFromArray.prototype = Set.prototype;
var s = new SetFromArray([1,2,3]);
s instanceof Set        // =&gt; true
</code></pre>

<h2>子类</h2>

<p>在面向对象编程中，类 B 可以继承自另外一个类 A。我们将 A 称为父类（superclass），将 B 称为子类（subclass）。B 的实例从 A继承了所有的实例方法。类 B 可以定义自己的实例类方法，有些方法可以重载类 A 中的同名方法，如果 B 的方法重载了 A 中的方法，B 中的重载方法可能会调用 A 中的重载类 A 方法，这种做法称为「方法链」（method chaining）。同样子类的构造函数 B() 有时需要调用父类的构造函数 A()，这种做法称为「构造函数链」（constructor chaining）。子类还可以有子类，当涉及类的层次结构时，往往需要定义抽象类（abstract class）。抽象类中定义的方法没有实现。抽象类中的抽象方法是在抽象类的具体子类中实现的</p>

<h3>定义子类</h3>

<p>JavaScript 的对象可以从类的原型对象中继承属性。如果 O 是类 B 的实例，B 是 A 的子类，那么 O 也一定从 A 中继承了属性。为此，首先要确保 B 的原型对象继承自 A 的原型对象，通过 inherit() 函数可以实现</p>

<pre><code class="javascript">B.prototype = inherit(A.prototype);
B.prototype.constructor = B;
</code></pre>

<h3>构造函数和方法链</h3>

<p>我们定义一个 Set 的子类 NonNullSet，它不允许 null 和 undefined 作为集合成员，这就需要在子类的 add() 方法中对 null 和 undefined 值做检测。它需要完全重新实现一个 add() 方法</p>

<pre><code class="javascript">function NonNullSet() {
    Set.apply(this, arguments);
}
NonNullSet.prototype = inherit(Set.prototype);
NonNullSet.prototype.constructor = NonNullSet;
NonNullSet.prototype.add = function() {
    for (var i = 0; i &lt; arguments.length; i++) {
        if (arguments[i] == null) {
            throw new Error("Cant't add null or undefined to a NonNullSet");
        }
    }
    return Set.prototype.add.apply(this, arguments);
};
</code></pre>

<h3>组合 vs 子类</h3>

<p>上节中定义的集合可以根据特定的标准对集合成员做限制，而且使用了子类的技术来实现这种功能</p>

<p>然后还有一种更好的方法来完成这种需求，既面向对象编程中一条广为人知的设计原则：「组合优于继承」。这样，可以利用组合的原理定义一个新的集合实现，它「包装」了另外一个集合对象，在将受限制的成员过滤掉之后会用到这个集合对象</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 8 - 函数]]></title>
    <link href="http://keelii.github.io/2016/06/29/javascript-definitive-guide-note-7/"/>
    <updated>2016-06-29T20:22:22+08:00</updated>
    <id>http://keelii.github.io/2016/06/29/javascript-definitive-guide-note-7</id>
    <content type="html"><![CDATA[<p>函数是一段 JavaScript 代码，定义一次，可以被执行多次。JavaScript 函数是参数化的：函数定义会包括一个形参（parameter）的标识符列表，这些参数在函数体中像 <strong>局部变量</strong> 一样工作，函数被调用的时候会为形参提供实参（argument）的值。使用实参的值计算返回值，成为该函数的 <strong><a href="/2016/06/20/javascript-definitive-guide-note-3/#TOC-4">调用表达式</a></strong>值，调用上下文（invocation context）可以用 this 引用，嵌套函数可以构成闭包（closure）</p>

<!-- more -->


<h2>函数定义</h2>

<p>使用 function 关键字来定义一个函数，可以用在函数定义表达式或者函数声明语句里</p>

<pre><code class="javascript">// 打印对象名称和值
function printprops(o) {
    for(var p in o)
        console.log(p + ": " + o[p] + "\n");
}
// 递归调用计算阶乘
function factorial(x) {
    if (x &lt;= 1) return 1;
    return x * factorial(x - 1);
}
// 函数定义表大式，函数名称可以省略
var square = function(x) { return x * x; }
</code></pre>

<p>return 语句导致函数停止执行，并返回它的表达式给调用都。如果 return 语句没有一个与之相关的表达式，则它返回 undefined 值，没有 return 语句也会默认返回 undefined 值给调用者</p>

<p><strong>嵌套函数</strong></p>

<pre><code class="javascript">function hypotenuse(a, b) {
    function square(x) { return x*x; }
    return Math.sqrt(square(a) + square(b));
}
</code></pre>

<p>嵌套函数的作用域规则：它们可以访问嵌套它们的函数的参数和变量。上面的代码里，内部函数 square() 可以读写外部函数 hypotenuse() 定义的参数 a 和 b</p>

<h2>函数调用</h2>

<p>有 4 种方式来调用 JavaScript 函数：</p>

<ul>
<li>作为函数</li>
<li>作为（对象）方法</li>
<li>作为构造函数</li>
<li>通过它们的 call() 和 apply() 方法间接调用</li>
</ul>


<h3>函数调用</h3>

<blockquote><p>function_name(param1, param2);</p></blockquote>

<h3>方法调用</h3>

<blockquote><p>object.method(param1, param2);</p></blockquote>

<pre><code class="javascript">// 对象直接量
var calculator = {
    operand1: 1,
    operand2: 1,
    add: function() {
        this.result = this.operand1 + this.operand2;
    },
    add1: function(a) {
        this.operand1 + a;
        return this;
    },
    add2: function(b) {
        this.operand2 + a;
        return this;
    }
};
calculator.add();
calculator.result       // =&gt; 2
// 使用对象属性访问表达式调用方法
calculator['result']    // =&gt; 2
// 链式调用
calculator.add1(1).add2(2)
calculator.operand1         // =&gt; 2
calculator.operand2         // =&gt; 3
</code></pre>

<h3>构造函数调用</h3>

<blockquote><p>new Object(param1, param2);</p></blockquote>

<p>如果没有参数可以省略括号 <code>new Object</code></p>

<h3>间接调用</h3>

<blockquote><p>function_name.call()</p></blockquote>

<p>JavaScript 中的 <strong>函数也是对象</strong>，和其它 JavaScript 对象没什么区别，函数对象也可以包含方法。其中两个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply()</a> 可以用来间接地调用函数。两个方法都允许显式地指定调用所需的 this 值</p>

<h2>函数的实参和形参</h2>

<p>JavaScript 的函数定义不用指定形参的类型，调用传入的实参也可以是任意类型，JavaScript <strong>甚至</strong> 不检查传入实参的个数</p>

<h3>可选形参</h3>

<p>如果调用函数的时候传入的实参比指定的形参少，剩下的形参都将设置为 undefined 值，通常使用逻辑与运算符给形参指定默认值</p>

<pre><code class="javascript">function getName(name) {
    // 如果 name 传入值则使用传入值，否则使用默认值 "no name"
    // 通常建议可选参数放在参数列表最后
    name = name || "no name";

    // code

    return name;
}
</code></pre>

<h3>可变长的实参列表：实参对象</h3>

<p>当调用函数的时候传入实参人个数超过形参个数时（和上面相反），没有办法直接获得未命名值的引用。参数对象解决了这个问题，在函数体内，标识符 arguments 是指向实参对象的引用，参数对象是一个 <a href="/2016/06/23/javascript-definitive-guide-note-6/#TOC-23">类数组对象</a>，这样可以通过索引来访问实参了</p>

<pre><code class="javascript">function fn(x, y, z) {
    console.log(arguments);
}
fn(1,2,3)           // =&gt; [1,2,3]
fn(1,2,3,4,5)       // =&gt; [1,2,3,4,5]
</code></pre>

<p>实参对象的重要用处就是让函数可以操作任意数量的实参，比如我们自己实现一个数组的 push 方法</p>

<pre><code class="javascript">function push(arr /* optional items [, item ... [, item]] */) {
    var items = Array.prototype.slice.call(arguments, 1)
    for (var i = 0; i &lt; items.length; i++) {
        arr[arr.length] = items[i];
    }
}
var arr1 = [1,2,3];
push(arr1, 4,5,6);
arr1                // =&gt; [1, 2, 3, 4, 5, 6]
</code></pre>

<p>在非严格模式下，修改 arguments 元素的值，实参的值也会变。不过在 ECMAScript 5 中这个特性被移除了。在非严格模式中，函数里的 arguments 仅仅是个标识符。在严格模式中，它变成了一个保留字，严格模式中函数无法使用 arguments 作为 <strong>形参名</strong> 或者 <strong>局部变量名</strong>，也不能给它（arguments）赋值</p>

<pre><code class="javascript">
function f(x) {
    console.log(x);         // =&gt; 实参的初始值
    arguments[0] = null;
    console.log(x);         // =&gt; 非严格返回 null， 非严格返回 1
}
f(1)
</code></pre>

<h4>callee 和 caller 属性</h4>

<p>除了数组元素，实参对象还定义了 callee 和 caller 属性。严格模式中对这两个属性读写操作会产生一个类型错误，非严格模式下，ECMAScript 标准规范规定 callee 属性指代当前正在执行的函数。caller 是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数。通过 caller 属性可以访问调用栈，callee 属性在某些时候非常有用，比如在匿名函数中通过 callee 来递归调用自身</p>

<pre><code class="javascript">var factorial = function(x) {
    if (x &lt;= 1) return 1;
    return x * arguments.callee(x-1);
}
</code></pre>

<h3>将对象属性用做实参</h3>

<p>当一个函数包含超过三个形参时，很难记住参数顺序。这时我们可以用名/值对的形式来传入参数，这样参数的顺序就无关紧要了（然后名/值对里面的键名还是得记住）</p>

<pre><code class="javascript">function arraycopy(from, from_start, to, to_start, length) {
}
function easycopycopy(args) {
    arraycopy(args.from,
              args.from_start || 0,
              args.to,
              args.to_start || 0,
              args.length);
}
var a = [1,2,3,4], b = [];
easycopy({ from: a, to: b, length:4 })
</code></pre>

<h3>实参类型</h3>

<p>JavaScript 函数中形参并未声明类型，在形参数传入之前也未做任何类型检查，JavaScript 会在必要的时候进行类型转换，因此如果函数期望接收一个出神入化串实参，而调用函数时传入其它类型的值，所传入的值会在函数体内将其转换为字符串</p>

<h2>作为值的函数</h2>

<p>函数的定义和调用是 JavaScript 的词法特性，其它语言也一样。然而在 JavaScript 中，函数不仅仅是一种语法，也可以是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组元素中，作为参数传入另外一个函数等</p>

<pre><code class="javascript">function square(x) { return x*x; }
var s = square;
square(4) == s(4)       // =&gt; true

var a = [ function square(x) { return x*x; }, 20 ];
a[0](a[1]);             // =&gt; 400

// 将函数用做值
function add(x, y) { return x + y; }
function subtract(x, y) { return x - y; }
function multiply(x, y) { return x * y; }
function divide(x, y) { return x / y; }

function operate(operator, operand1, operand2) {
    return operator(operand1, operand2)
}
// =&gt; 25 (2 + 3) + (4 * 5)
var i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5))
</code></pre>

<h4>自定义函数属性</h4>

<p>JavaScript 中函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有 <strong>属性</strong>。当函数需要一个 <strong>静态变量</strong> 来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量</p>

<pre><code class="javascript">// 注意静态变量不必在函数后面声明
uniqueInteger.counter = 0;

function uniqueInteger() {
    // 注意 ++counter 和 count++ 不一样
    return ++uniqueInteger.counter;
}
</code></pre>

<p>下面这个函数 factirial() 使用了自身的属性（将自身当做数组来对待）来缓存上一次的计算结果：</p>

<pre><code class="javascript">// 计算阶乘
function factorial(n) {
    if (isFinite(n) &amp;&amp; n &gt; 0 &amp;&amp; n == Math.round(n)) {
        if (!(n in factorial)) {
            factorial[n] = n * factorial(n-1)
        }
        return factorial[n]
    } else {
        return NaN;
    }
}
// 初始化缓存以保存这种基本情况
factorial[1] = 1;
</code></pre>

<h2>作为命名空间的函数</h2>

<pre><code class="javascript">(function(/*paramater*/) {
    // 模块代码
    // 这个模块使用的所有变量（通过 var 声明）都是局部变量
    // 不会污染全局命名空间
})(/*arguments*/);

(function(win, doc) {
    var obj = {
        privateMethod: function() {},
        publicMethod: function() {}
    };

    win.yourPublicAPIMethodName = obj.publicMethod
})(window, document);
</code></pre>

<p>使用 <strong><a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">立即执行函数表达式（IIFE）</a></strong> 可以隔离代码块的命名空间，在匿名函数中声明的变量只在内部有效，不会对全局产生影响，同时可以有选择地向全局输出变量用来给外部代码访问</p>

<h2>闭包</h2>

<blockquote><p>词法作用域（lexical scoping）的执行依赖于变量作用域，这个作用域是在函数 <strong>定义时</strong> 决定的，而不是函数调用时，为了实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为「闭包」</p></blockquote>

<p>从技术角度讲，所有的 JavaScript 函数都是闭包：它们都是对象，它们都关联到作用域链。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事情就变得非常我刚好和。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象 <strong>作为返回值返回</strong> 的时候，这种事情就发生了</p>

<p>先看一下嵌套函数的词法作用域规则：</p>

<pre><code class="javascript">// 例 1
var scope = "global scope";
function checkscope() {
    var scope = "local scope";
    function f() { return scope;}
    return f();
}
checkscope();       // =&gt; "local scope"
// 例 2
var scope = "global scope";
function checkscope() {
    var scope = "local scope";
    function f() { return scope;}
    return f;
}
checkscope()()      // =&gt; "local scope"
</code></pre>

<p>在例 2 中我们将 checkscope 返回值 f 调用的括号移动到了 checkscope 调用后面。复习一下作用域的基本规则：JavaScript 函数的执行用到了作用域链，这个作用域链是函数 <strong>定义的时候</strong> 创建的，嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管在何时执行函数当 f()，这种绑定在执行 f() 时依然有效。因此最后一行代码返回「local scope」而不是「global scope」。简而言之，闭包的这个特性强大到让人吃惊：它们可以捕捉到局部变量（和参数），<strong>并一直保存下来</strong></p>

<p>很多程序员觉得闭包非常难理解，他们觉得在外部函数中定义的局部变量在函数返回后就不存在了，那么嵌套的函数如何能调用不存在的作用域链呢？如果你想搞清楚这个问题，还得更深入地了解类似 C 语言这种更底层的编程语言，并了解基于栈的 CPU 架构 <strong>如果一个函数的尾部变量定义在 CPU 的栈中，那么当函数返回时它们的确就不存在了</strong></p>

<p><a href="#TOC-13">上节</a>中的 uniqueInteger() 函数，这个函数有一个问题，函数本身是全局可访问的，这个 counter 很可能被外部修改。如果使用闭包就没有这个问题</p>

<pre><code class="javascript">var uniqueInteger = (function() {
    var counter = 0;
    return function() {
        return ++counter;
    }
})();
</code></pre>

<p>上面的代码将匿名立即执行函数赋值给 uniqueInteger 变量，所以函数的返回值赋值给变量 uniqueInteger，内部变量 counter 只在函数体内部可以访问，外部无法操作</p>

<p>私有变量也可以被多个闭包访问到，比如：</p>

<pre><code class="javascript">function counter() {
    var n = 0;
    return {
        count: function() { return n++ },
        reset: function() { n = 0 }
    }
}
// 创建两个计数器
var c = counter(), d = counter();
c.count()       // =&gt; 0 互
c.count()       // =&gt; 1 不
d.count()       // =&gt; 0 干
d.count()       // =&gt; 1 扰
c.reset()       // =&gt; 0 重置 c
d.count()       // =&gt; 2 不影响 d
</code></pre>

<p>在同一个作用域链中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是一种非常重要的技术，但是要特别小心那些不希望共享的变量往往不经意间共享给了其它的闭包，了解这一点也很重要</p>

<pre><code class="javascript">function constfunc(v) { return function() { return v; } }

var funcs = [];
for(var i = 0; i &lt; 10; i++) {
    funcs[i] = constfunc(i);
}
</code></pre>

<p>如果这样写就完全不一样了</p>

<pre><code class="javascript">function constfuncs() {
    var funcs = [];
    for (var i = 0; i &lt; 10; i++) {
        funcs[i] = function() {
            return i;
        };
    }
    return funcs;
}
var funcs = constfuncs();
funcs[5]()                  // =&gt; 10 !!!
</code></pre>

<p>上面这段代码循环创建了 10 个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量 i。当 constfuncs() 返回时，变量的 i 值是 10，所有的闭包都共享这一个值，因此，数组中的函数的返回值是同一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域链都是「活动的（live）」，记住这一点非常重要。嵌套的当函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照（static snapshot）</p>

<p>书写闭包的时候还需注意一件事情，this 是 JavaScript 的关键字，不是变量。正如之前讨论的，每个函数调用都包含一个 this 值，如果闭包在外部函数里是无法访问 this 的，除非外部函数将 this 默契为一个变量</p>

<pre><code class="javascript">function outerFn() {
    var self = this;

    function innerFn() {
        // self.xxxx
    }
}
</code></pre>

<h2>函数属性、方法和构造函数</h2>

<p>在 JavaScript 中，函数是值，对函数执行 typeof 运算会返回字符串 &ldquo;function"，但是函数是 JavaScript 中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，像普通对象一样。甚至可以用 Function() 构造函数来创建新的函数对象</p>

<h3>prototype 属性</h3>

<p>每一个当函数都包含一个 prototype 属性，这个属性是指向一个对象的引用，这个对象称做「原型对象」（prototype object）。每一个函数都包含不同的原型对象。当将函数胜仗构造函数的时候，新创建的对象会从原型对象上继承属性</p>

<h3>call() 和 apply() 方法</h3>

<blockquote><p>fun.call(thisArg[, arg1[, arg2[, &hellip;]]])</p>

<p>fun.apply(thisArg[, argsArray])</p></blockquote>

<p>我们可以将 call 和 apply 看做是某个对象的方法，通过调用方法的形式来间接调用函数</p>

<pre><code class="javascript">// 将对象 o 中名为 m 的方法替换为另外一个方法
function trace(o, m) {
    var original = o[m];
    o[m] = function() {
        console.log(new Date, "Entering: ", m);
        var result = original.apply(this, arguments)
        console.log(new Date, "Exiting: ", m);
    }
}
</code></pre>

<p>trace() 函数接收两个参数，一个对象和一个方法名，它将指定的方法替换为一个新方法，这个新方法就是「包裹」原始方法的另一个泛函数。这种动态修改已有方法的做法有时称做「猴子补丁 monkey-patching」</p>

<h3>bind() 方法</h3>

<blockquote><p>fun.bind(thisArg[, arg1[, arg2[, &hellip;]]])</p></blockquote>

<p>bind 方法是 ECMAScript 5 中新增的方法，但在 ECMAScript 3 中可以模拟出来。主要用于将函数绑定到某个对象。当在函数 f 上调用 bind 方法并传入一个对象 o 做参数，这个方法将返回一个新的函数。调用新的函数将会把原始的函数 f <strong>当做 o 的方法来调用</strong>。传入新函数的任何实参都将传入原始函数</p>

<pre><code class="javascript">function f(y) { return this.x + y; }
var o = { x: 1};
var g = f.bind(o);
g(2)                // =&gt; 3
</code></pre>

<p>可以通过下面代码实现 bind 方法</p>

<pre><code class="javascript">function bind(f, o) {
    if (f.bind) {
        return f.bind(o);
    } else {
        return f.apply(ok arguments)
    }
}
</code></pre>

<p>bind 方法还有一些其他应用：除了第一个实参之外，传入 bind 的实参也会绑定至 this，这个附带的应用是一种常见的函数式编程技术，有时也被称为「<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a>」（currying）</p>

<pre><code class="javascript">var sum = function(x, y) { return x + y }

var succ = sum.bind(null, 1)
succ(2)     // =&gt; 3

function f(y, z) { return this.x + y + z }
var g = f.bind({x:1}, 2)
g(3)        // =&gt; 6
</code></pre>

<p>注意 bind 方法有些特性是模拟不出来的</p>

<h3>toString() 方法</h3>

<p>和所有的 JavaScript 对象一样，函数也有 toString 方法，ECMAScript 规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数的 toString 方法的实现都返回函数的完成源码。内置函数往往返回一个类似 &ldquo;[native code]&rdquo; 的字符串作为函数体</p>

<h3>Function() 构造函数</h3>

<blockquote><p>new Function ([arg1[, arg2[, &hellip;argN]],] functionBody)</p></blockquote>

<p>关于 Function() 构造函数有几点需要特别注意：</p>

<ul>
<li>Function() 构造函数允许 JavaScript 在运行时动态地创建并编译函数</li>
<li>每次调用 Function() 构造函数都会解析函数体，执行效率会受影响。</li>
<li>Function() 构造函数创建的函数 <strong>并不是使用词法作用域</strong>，相反，函数体代码的编译总是会在顶层函数执行，效果类似在全局作用域中执行 eval()</li>
</ul>


<pre><code class="javascript">var scope = "global";
function constructFunction() {
    var scope = "local";
    return new Function("return scope");
}
constructFunction()();  // =&gt; "global"
</code></pre>

<h3>可调用的对象</h3>

<p>「类数组对象」类似数组但并不是真正的数组，「可调用对象（callable object）」类似于函数但并不是真正的函数。可调用对象在两个 JavaScript 实现中不能算作函数。首先，IE Web 浏览器（IE 6 及之前的版本）实现了客户端方法（如 Window.alert() 和 Document.getElementById()），使用了可调用的宿主对象，而不是内置函数对象，IE 中的这些方法在其它浏览器中都存在，但它们本质上不是 Function 对象。IE 9 将它们实现为真正的函数，因此这类可调用的对象将越来越罕见</p>

<p>另外一个常见的可调用对象是 RegExp 对象，对 RegExp 执行 typeof 运算的结果并不统一，有些返回 &ldquo;function&rdquo; 有些返回 &ldquo;object"。可以使用下面的方法判断是不是真正的函数对象</p>

<pre><code class="javascript">function isFunction(o) {
    return Object.prototype.toString.call(x) === "[object Function]"
}
</code></pre>

<h2>函数式编程</h2>

<p>JavaScript 并不是一种像 List 或 Haskell 的函数式编程语言，但在 JavaScript 中可以像操控对象一样操控函数，也就是说可以在 JavaScript 中应用函数式编程技术</p>

<h3>使用函数处理数组</h3>

<p>假设有一个数组，元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话代码一般会是这样：</p>

<pre><code class="javascript">var data = [1,1,3,5,5]
var total = 0;
for (var i = 0; i &lt; data.length; i++) {
    total += data[i];
}
var mean = total / data.length;                 // =&gt; 3

total = 0;
for (var i = 0; i &lt; data.length; i++) {
    var deviation = data[i] - mean;
    total += deviation * deviation;
}
var stddev = Math.sqrt(total/(data.length-1))   // =&gt; 2
</code></pre>

<p>可以使用数组方法 map() 和 reduce() 来实现同样的计算，这种实现极其乘法：</p>

<pre><code class="javascript">var sum = function(x, y) { return x + y; }
var square = function(x) { return x*x; }

var data = [1,1,3,5,5]
var mean = data.reduce(sum)/data.length;
var deviations = data.map(function(x) { return x-mean; })
var stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length-1))
</code></pre>

<p>当然 ECMAScript 3 并没有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a>， <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">reduce</a> 这两个方法，不过我们也可以自己实现一个 Polyfill，可以参考链接里面的内容</p>

<h3>高阶函数</h3>

<p>所谓高阶函数（higher-order function）就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数</p>

<pre><code class="javascript">function not(f) {
    return function() {
        var result = f.apply(this, arguments);
        return !result;
    }
}
var even = function(x) {
    return x % 2 == 0;
}
var odd = not(even);
[1,1,3,5,5].every(odd)          // =&gt; true
</code></pre>

<p>mapper() 函数也是一个高阶函数，它接收一个函数作为参数，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上，这个函数使用了之前定义的 map() 函数</p>

<pre><code class="javascript">function mapper(f) {
    return function(a) { return map(a, f); }
}
var increment = function(x) { return x + 1; }
var incrementer = mapper(increment);
incrementer([1,2,3])  // =&gt; [2,3,4]
</code></pre>

<p>还有一个更常见的例子，它接收两个函数 f() 和 g()，并返回一个新的函数用以计算 f(g())</p>

<pre><code class="javascript">function compose(f, g) {
    return function() {
        return f.call(this, g.apply(this, arguments))
    }
}
var square = function(x) { return x * x; }
var sum = function(x, y) { return x + y; }
var squareofsum = compose(square, sum)
squareofsum(2, 3)           // =&gt; 25
/* - 伪代码执行过程大致如下 -
    arguments: 2, 3
    return square.call(this, sum.apply(this, arguments))
    return square.call(this, sum(2, 3))
    return square.call(this, 5)
    arguments: 5
    return square(5)
    return 25
*/
</code></pre>

<h3>不完全函数</h3>

<p>函数 <a href="/2016/06/29/javascript-definitive-guide-note-7/#TOC-19">f()</a> 的 bind() 方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用函数 f()。我们说它把函数「绑定至」对象并传入一部分参数。bind() 方法只是将实参放在左侧，也就是说传入 bind() 的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入 bind() 的实参放在右侧</p>

<pre><code class="javascript">// 将类数组对象转换为真正的数组
function array(arr, n) { return Array.prototype.slice.call(arr, n || 0); }

// 这个函数的实参传递到左侧
function partialLeft(f) {
    var args = arguments;

    return function() {
        var a = array(args, 1);
        a = a.concat(array(arguments))
        return f.apply(this, a)
    }
}
function partialRight(f) {
    var args = arguments;

    return function() {
        var a = array(arguments)
        a = a.concat(array(args, 1))
        return f.apply(this, a)
    }
}

function partial(f) {
    var args = arguments;

    return function() {
        var a = array(args, 1)
        var i = 0, j = 0;
        for (; i &lt; a.length; i++) {
            if ( a[i] === undefined ) a[i] = arguments[j++];
        }
        a = a.concat(array(arguments, j))
        return f.apply(this, a);
    }
}

var f = function(x, y, z) { return x * (y - z) }
partialLeft(f, 2)(3, 4)             // =&gt; -2 2 * (3-4)
partialRight(f, 2)(3, 4)            // =&gt; 6 3 * (4-2)
partial(f, undefined, 2)(3, 4)      // =&gt; -6 3 * (2-4)
</code></pre>

<h3>记忆</h3>

<p>上面的 <a href="/2016/06/29/javascript-definitive-guide-note-7/#TOC-13">章节</a> 中定义了一个阶乘函数，它可以将上次的计算结果缓存起来。在函数式程序当中，这种缓存技巧叫做「记忆」（memorization）。下面的代码展示了一个高阶函数，memorize() 接收一个函数作为实参，并返回带有记忆能力的函数</p>

<pre><code class="javascript">function memorize(f) {
    var cache = {};

    return function() {
        // 将实参转换为字符串形式，并胜仗缓存的键名
        var key = arguments.length + Array.prototype.join.call(arguments, ",")
        if ( key in cache ) {
            return cache[key];
        } else {
            return cache[key] = f.apply(this, arguments)
        }
    }
}
function factorial (num) {
    console.log('Actually invoked.');
    if (num &lt; 0) {
        return -1;
    } else if (num === 0 || num === 1) {
        return 1;
    } else {
        return (num * factorial(num - 1));
    }
}

var cached_factorial = memorize(factorial);

cached_factorial(3)
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 6
cached_factorial(3)
// =&gt; 6

/**
 * 注意下面的调用方式将不会缓存
 * 因为新建了多个闭包，闭包在每
 * 调用一次 memorize 就返回一
 * 份新的 cache 变量
 */
memorize(factorial)(3)
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 6
memorize(factorial)(3)
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 6
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 7 - 数组]]></title>
    <link href="http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-6/"/>
    <updated>2016-06-23T19:10:28+08:00</updated>
    <id>http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-6</id>
    <content type="html"><![CDATA[<p>数组是值的 <strong>有序集合</strong>。每个值（任意 JavaScript 数据类型）叫做一个元素，元素在数组中的位置叫索引。JavaScript 数组是无/弱类型的（untyped），数组元素可以是任意类型</p>

<p>JavaScript 数组是 <strong>动态的</strong>，根据需要它们会增长或缩减，创建的时候不须要声明一个固定的大小</p>

<p>JavaScript 数组可能是 <strong>稀疏的</strong>，数组元素索引不一定要连续</p>

<p>JavaScript 数组是 JavaScript 对象的特殊形式。数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要 <strong>快很多</strong></p>

<!--more-->


<h2>创建数组</h2>

<pre><code class="javascript">var empty = [];             // 使用数组直接量创建一个空数组
var primes = [2, 3, 5, 7, 11];
var base = 1024；
var misc = [1.2, true, "a", base + 1, [1,2,3], { a: 1}]     // 元素可以是任意值，甚至表达式
var count = [1, ,3];            // 数组有三个元素中间那个值为 undefined

var a = new Array();        // 调用构造函数 Array() 也可以创建数组
var a = new Array(10);
a.length;                   // =&gt; 10 创建一个长度为 10 的数组
var a = new Array(1, 2, 3);
a;                          // =&gt; [1, 2, 3]
</code></pre>

<h2>数组元素的读和写</h2>

<p>使用方括号 [] 操作符来访问数组中的一个元素，方括号左边是数组的引用，右边是一个返回 <strong>非负整数值</strong> 的任意表达式</p>

<pre><code class="javascript">var a = ["world"];
a[0]                    // =&gt; "world"
a[1] = 3.14             // =&gt; 写入第 1 个元素 3.14
a                       // =&gt; ["world", 3.14]
i = 2;
a[i] = 3;               // =&gt; 写入第 2 个元素
a[i+1] = "hello";       // =&gt; 写入第 2 个元素
</code></pre>

<p>可以使用负数或者非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样如果如果凑巧使用了非负整数的字符串，它就当做数组索引，而非对象属性</p>

<pre><code class="javascript">a[-1.23] = true             // 给数组 a 创建一个名为 "-1.23" 的属性
a["1000"] = 0               // 这是数组的第 1001 个元素
a[1.000]                    // 和 a[1] 相等
</code></pre>

<p>事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组 <strong>没有越界</strong> 错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到 undefined 值，这一点类似于对象</p>

<h2>稀疏数组（Sparse Arrays）</h2>

<p>通常，数组的 length 属性代表数组中的元素个数。如果是稀疏数组，length 属性值大于元素个数。当在数组直接量中省略值是不会创建稀疏数组。省略的元素是存在的只是值为 undefined。使用 Array() 构造函数或者手动指定 length 大于当前的数组可以创建稀疏数组</p>

<pre><code class="javascript">a = new Array(5);       // 数组没元素，但 a.length 是 5
a = [];
a[1000] = 0;            // 赋值添加一个元素，但设置 length 为　1001
var a1 = [,,,];         // 数组是 [undefined, undefined, undefined]
var a2 = new Array(3);
var a3 = [1,,3];
0 in a1                 // =&gt; true 非稀疏数组
0 in a2                 // =&gt; false 稀疏数组
1 in a3                 // =&gt; false 稀疏数组
</code></pre>

<p>在一些旧版的实现中，[1,,3] 和 [1, undefined, 3] 却是一模一样的</p>

<h2>数组的长度</h2>

<p>每个数组都有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密数组，length 属性值代表数组中元素的个数，其值比数组中最大的索引大 1</p>

<p>数组有两个 <strong>特殊行为</strong>：</p>

<ol>
<li>如果为一个数组元素赋值，它的索引 i 大于或者等于现有数组的长度时，length 属性的值将设置为 i + 1</li>
<li>如果设置一个数组的 length 属性小于这个数组长度的非负整数 n 时，当前数组中那些索引值大于或等于 n 的元素将被从中删除</li>
</ol>


<pre><code class="javascript">a = [1,2,3,4,5];
a.length = 3;
a                   // =&gt; [1,2,3]
a.length = 0;
a.length = 5;       // 长度为 5，类似 new Array(5)
</code></pre>

<p>数组也继承了对象的一些方法，比如 Object.defineProperty(), 可以使用这个方法让数组的 length 属性变成只读</p>

<pre><code class="javascript">a = [1,2,3]
Object.defineProperty(a, "length", {
    writable: false
});
a.length = 0
a                   // =&gt; [1,2,3] 不会改变
</code></pre>

<h2>数组元素的添加和删除</h2>

<p>可以给新的索引赋值来添加元素，也可以调用 Array 对象的内置方法 push() 来在数组 <strong>末尾</strong> 增加一个或者多个元素，或者用 unshift() 给数组头部插入一个元素，并且将其它元素依次移动到更高的索引处</p>

<pre><code class="javascript">a = []
a[0] = "zero"
a[1] = "one"
a               // =&gt; ["zero", "one"]

a = []
a.push("zero")
a.push("one", "two")
a               // =&gt; ["zero", "one", "two"]
a.unshift(0)
a               // =&gt; [0, "zero", "one", "two"]
</code></pre>

<p>可以使用 delete 运算符来删除数组元素，效果和对数组元素赋值 undefined 类似，使用 delete 删除数组后数组的长度是不变的</p>

<h2>数组遍历</h2>

<p>使用 for 循环是遍历数组元素最常见的方法，for/in 也可以但并不推荐</p>

<pre><code class="javascript">var keys = Object.keys(o);
var values = [];
for (var i = 0; i &lt; keys.length; i++) {
    var key = keys[i];
    values[i] = o[key]
}

for (var i = 0; i &lt; keys.length; i++) {
    if (!a[i]) continue;    // 跳过 null, undefined 和不存在的元素
}
for (var i = 0; i &lt; keys.length; i++) {
    if (!(i in a)) continue;    // 只跳过不存在的元素
}
for (var i in a) {
    if (!a.hasOwnProperty(i)) continue; // 跳过继承属性
}
</code></pre>

<p>ECMAScript 5 定义了一些遍历数组元素的新方法，比如 forEach()</p>

<pre><code class="javascript">[1,2,3,4,5].forEach(function(x) {
    console.log(x);
});
</code></pre>

<h2>多维数组</h2>

<p>JavaScript 并不支持真正的多维数组，但可以模拟出来</p>

<pre><code class="javascript">var table = new Array(10);
for (var i = 0; i &lt; table.length; i++) {
    table[i] = new Array(10);
}

for (var row = 0; row &lt; table.length; row++) {
    for (var col = 0; col &lt; table[row].length; col++) {
        table[row][col] = row * col;
    }
}

table[5][7];        // =&gt; 35
</code></pre>

<h2>数组方法</h2>

<p>将所有元素都转化为字符串并通过分隔符链接起来，分隔符默认是逗号「,」</p>

<p>与之相反的 split 方法则是把字符串按分割符分割开来并返回数组，并且分割符可以是正则表达式</p>

<pre><code class="javascript">var a = [1,2,3];
a.join();               // =&gt; "1,2,3"
a.join(" ")             // =&gt; "1 2 3"
a.join("")              // =&gt; "123"
new Array(10).join('-') // =&gt; "----------"

var str = "Hello world";
str.split(' ')          // =&gt; ["Hello", "world"]
var str = "0a1b2c3d";
str.split(/\d/g);       // =&gt; ["", "a", "b", "c", "d"]
</code></pre>

<h3>reverse()</h3>

<p>反转数组元素</p>

<pre><code class="javascript">var a = [1,2,3];
a.reverse();        // =&gt; [3,2,1]
</code></pre>

<h3>sort()</h3>

<p>将数组中的元素排序并返回排序后的数组。不带参数调用 sort() 时，数组元素以字母表顺序排序，如果数组包含 undefined 元素，它们会被排到数组的尾部</p>

<pre><code class="javascript">var a = ["banana", "cherry", "apple"]
a.sort();               // =&gt; ["apple", "banana", "cherry"]
</code></pre>

<p>sort 方法可以接收一个函数参数，该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小于 0 的数值</p>

<pre><code class="javascript">var a = [3,4,1,2]
a.sort()            // [1,2,3,4]
a.sort(function(a, b) {
    return b - a
})                  // [4,3,2,1]
</code></pre>

<h3>concat()</h3>

<blockquote><p>Array.concat(value1, value2, &hellip;, valueN)</p></blockquote>

<p>创建并返回一个新数组，它的元素包括调用 concat 的原始数组元素和 concat 的每个参数</p>

<pre><code class="javascript">var a = [1,2,3]
a.concat(4,5)           // =&gt; [1,2,3,4,5]
a.concat([4,5])         // =&gt; [1,2,3,4,5]
a.concat([4,5], [6,7])  // =&gt; [1,2,3,4,5,6,7]
a.concat(4, [5, [6,7]]) // =&gt; [1,2,3,4,5,[6,7]]
</code></pre>

<h3>slice()</h3>

<blockquote><p>Array.slice([begin[, end]])</p></blockquote>

<p>返回指定数组的一个片段或子数组，它的两个参数分别指定了片段的开始和结束的 <strong>位置</strong>，如果只指定一个参数（开始位置），返回的数组将包含从开始位置到数组结尾的所有元素，如果参数中出现了负数，它表示相对于数组中最后一个元素的位置，slice 不会修改原数组</p>

<pre><code class="javascript">var a = [1,2,3,4,5]
a.slice(0, 3)       // =&gt; [1,2,3]
a.slice(3)          // =&gt; [4,5]
a.slice()           // =&gt; [1,2,3,4,5]
a.slice(1, -1)      // =&gt; [2,3,4]
a.slice(-3, -2)     // =&gt; [3]
</code></pre>

<h3>splice()</h3>

<blockquote><p>Array.splice(start, deleteCount[, item1[, item2[, &hellip;]]])</p></blockquote>

<p>splice 方法是在数组中插入或删除元素的通用方法，会 <strong>修改</strong> 调用的数组</p>

<p>splice 能够从数组中删除元素、插入元素到数组中或者 <strong>同时完成</strong> 这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其它部分仍然保持连续。splice 第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。splice 返回一个由删除元素组成的数组</p>

<pre><code class="javascript">var a = [1,2,3,4,5,6,7,8]
a.splice(4)             // =&gt; [5,6,7,8]
a                       // =&gt; [1,2,3,4]
a.splice(1,2)           // =&gt; [2,3]
a                       // =&gt; [1,4]
a.splice(1,1)           // =&gt; [4]
a                       // =&gt; [1]
</code></pre>

<p>splice 前两个参数指定了需要删除的数组元素。其后任意个数参数指定了需要插入到数组中的元素</p>

<pre><code class="javascript">var a = [1,2,3,4,5]
a.splice(2, 0, "a", "b")        // =&gt; 0
a                               // =&gt; [1,2,"a","b",3,4,5]
a.splice(2, 2, [1,2], 3)        // =&gt; ["a", "b"]
a                               // =&gt; [1,2,[1,2],3,3,4,5]
</code></pre>

<h3>push() 和 pop()</h3>

<p>push 和 pop 方法谲诈将数组当做 <a href="https://cloud.githubusercontent.com/assets/458894/16374650/f8b0fa6c-3c89-11e6-9e61-bc391f7f3cf4.png">栈</a> 来使用，push 方法在数组尾部添加一个或者多个元素，并返回新的数组长度。pop 删除数组的最后一个元素，减小数组长度并返回它删除的值</p>

<pre><code class="javascript">var stack = [];
stack.push(1,2)         // =&gt; 2 stack: [1,2]
stack.pop(1,2)          // =&gt; 1 stack: [2]
stack.push(3)           // =&gt; 2 stack: [1,3]
</code></pre>

<h3>unshift() 和 shift()</h3>

<p>unshift 在数组的头部添加一个或者多个元素，shift 删除数组的第一个元素并将其返回</p>

<p>需要注意的是，当使用多个参数调用 unshift() 的时候，参数是一次性插入的，而非一次一个插入。这会影响插入到数组中元素的位置</p>

<pre><code class="javascript">var a = [4,5,6];
a.unshift(3)
a               // =&gt; [3,4,5,6]
a.unshift(1,2)
a               // =&gt; [1,2,3,4,5,6]如果一次一个插入的话结果应该是 [2,1,3,4,5]
</code></pre>

<h2>ECMAScript 5 的数组方法</h2>

<h3>forEach()</h3>

<p>forEach() 从头至尾遍历数组，为每个元素调用指定的函数。传递函数作为 forEach() 的第一个参数，然后 forEach() 使用三个参数调用该当函数：数组元素、元素的索引和数组本身。forEach() 无法在所有元素都传递给调用的函数之前终止遍历，除非 forEach() 方法放在一个 try 块中，并抛出一个异常</p>

<pre><code class="javascript">[1,2,3,4,5].forEach(function(value, index, arr) { arr[i] = v + 1 });
// =&gt; [2,3,4,5,6]
</code></pre>

<h3>map()</h3>

<p>map() 方法将调用数组的每个元素传递给指定的函数，并返回一个数组。如果是稀疏数组，返回的也是相同方式的稀疏数组</p>

<pre><code class="javascript">a = [1,2,3]
b = a.map(function(x) { return x*x })
b               // [1, 4, 9]
</code></pre>

<h3>filter()</h3>

<p>filter() 方法返回数组元素是调用数组的一个 <strong>子集</strong>。传递的函数是用来逻辑判定的（true 或 false），如果返回 true 或者能转化为 true 的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中，<strong>filter() 会跳过稀疏数组中缺少的元素</strong>，总是返回稠密的</p>

<pre><code class="javascript">a = [5,4,3,2,1]
smallvalues = a.filter(function(x) { return x &lt; 3 })    // [2, 1]
</code></pre>

<h3>every() 和 some()</h3>

<p>数组的逻辑判定，它们对数组元素应用指定的函数进行判定，返回 true 或 false</p>

<pre><code class="javascript">a = [1,2,3,4,5]
a.every(function(x) { return x &lt; 10 })      // =&gt; true 数组元素都少于 10
a.some(function(x) { return x%2 === 0 })    // =&gt; true 数组中有一些值是偶数
</code></pre>

<p>注意，一旦 every() 和 some() 确认应该返回什么值时它们就会停止遍历数组元素（可以认为是惰性判断）。即：</p>

<ul>
<li>some() 在判定函数第一次返回 true 后就返回 true，不再进行遍历操作</li>
<li>every() 在判定函数第一次返回 false 后就返回false，不再进行遍历操作</li>
</ul>


<h3>reduce() 和 reduceRight()</h3>

<blockquote><p>Array.reduce(callback, [initialValue])</p></blockquote>

<p>reduct() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值，这在 <strong>函数式编程（functional programming）</strong> 中是很常见的操作，也可以称为「注入」和「折叠」，他们只是执行化简操作的顺序不一样，一个从左到右，一个从右到左</p>

<pre><code class="javascript">var a = [1,2,3,4,5]
var sum = a.reduce(function(x, y) { return x + y }, 0)          // 数组求和
/**
+---------------------------------+
|                                 |
|     x      +     y     return   |
|                                 |
|   init: 0     a[0]: 1    1      |
|                                 |
|     1         a[1]: 2    3      |
|                                 |
|     3         a[2]: 3    6      |
|                                 |
|     6         a[3]: 4    10     |
|                                 |
|     10        a[4]: 5    15     |
|                                 |
+---------------------------------+
*/
var product = a.reduce(function(x, y) { return x * y }, 1)      // 数组求积
</code></pre>

<p>reduce 需要两个参数。第一个是执行化简操作的函数，它的任意就是用某种方法把两个值组合或化简为一个值，并返回化简后的值，第二个参数是传递给函数的初始值，如果没有指定初始值，它将使用数组的第一个元素作为其初始值。<strong>这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为 x,y</strong></p>

<h3>indexOf() 和 lastIndexOf()</h3>

<blockquote><p>Array.indexOf(searchElement[, fromIndex = 0])</p></blockquote>

<p>搜索整个数组中指定值的索引，没找到就返回 -1。indexOf() 从头至尾搜索，而 lastIndexOf() 则反向搜索。它们都接收第二个参数，指定数组中的一个索引，从这个索引处开始搜索</p>

<pre><code class="javascript">a = [0,1,2,1,0]
a.indexOf(1)        // =&gt; 1
a.lastIndexOf(1)    // =&gt; 3
a.indexOf(3)        // =&gt; -1

// 在数组中查找所有出现的 x，并返回一个包含匹配索引的数组
function findall(a, x) {
    var results = [];
    var len = a.length;
    var pos = 0;

    while(pos &lt; len) {
        pos = a.indexOf(x, pos);
        if (pos === -1) break;

        results.push(pos)
        pos = pos + 1;
    }

    return results;
}
findall([1,2,3,1,3,2], 1)       // =&gt; [0, 3]
</code></pre>

<h2>数组类型</h2>

<p>ECMAScript 5 中可以使用 Array.isArray() 函数来判断是否为数组，在 ECMAScript 5 之前判断却没这么简单，因为 typeof 运算符操作数组返回的是「对象」，一般用下面的方法下判断是否是数组</p>

<pre><code class="javascript">var isArray = Array.isArray || function(o) {
    return typeof o === "object" &amp;&amp;
            Object.prototype.toString.call(0) === '[object Array]';
};
</code></pre>

<h2>类数组对象</h2>

<p>JavaScript 数组的一些特性是其他对象没有的：</p>

<ul>
<li>当有新的元素添加到列表中时，自动更新 length 属性</li>
<li>设置 length 为一个较小值将截断数组</li>
<li>从 Array.prototype 中继承一些有用的方法</li>
<li>其类属性为「Array」</li>
</ul>


<p>以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的「元素」</p>

<pre><code class="javascript">var a = {}

var i = 0;
while (i &lt; 10) {
    a[i] = i * i;
    i++;
}
a.length = i;
a               // =&gt; { 0: 0, 1: 1, 2: 4, 3: 9 ..., length: 10 }

// 现在就可以当成真正的数组遍历它
var total = 0;
for (var j = 0; j &lt; a.length; j++) {
    total+=a[j]
}
</code></pre>

<p>Arguments 对象就是一个类数组对象，DOM 方法 document.getElementsByTagName() 也返回类数组对象，它们都有数组的一些特性，比如索引访问、length 属性，但它们并不是真正的数组</p>

<pre><code class="javascript">function isArrayLike(o) {
    if ( o &amp;&amp;
        typeof o === "object" &amp;&amp;
        isFinite(o.length) &amp;&amp;
        o.length &gt;= 0 &amp;&amp;
        o.length === Math.floor(o.length) &amp;&amp;
        o.length &lt; 4294967296 ) {       // 数组长度的最大值 2^32
        return true;
    } else {
        return false;
    }
}
</code></pre>

<p>JavaScript 数组方法是 <strong>特意定义为通用的</strong>，它们不仅可以应用在数组而且可以应用在类数组对象上，一般使用 Array.prototype.method.call 来使用</p>

<pre><code class="javascript">var a = {"0": "a", "1": "b", "2": "c", length: 3};
Array.prototype.join.call(a, "+")           // =&gt; "a+b+c"
</code></pre>

<h2>作为数组的字符串</h2>

<p>在 ECMAScript 5 中，字符串的行为类似于 <strong>只读</strong> 的数组。除子用 charAt() 方法来访问单个字符以外，还可以使用方括号：</p>

<pre><code class="javascript">var s = "test";
s.charAt(0)         // =&gt; "t"
s.[1]               // =&gt; "e"
</code></pre>

<p>字符串的行为类似于数组的事实使得通用的数组方法可以应用到字符串上。不过请记住，字符串是 <strong>不可变值</strong>，当把它们作为数组看待时，它们是只读的。所以诸如：push(), sort(), reverse 等 <strong>会修改数组</strong> 的方法 如果被使用在字符串上是无效的，而且会导致错误并且没有相关提示</p>

<pre><code class="javascript">s = "JavaScript"
Array.prototype.join.call(s, " ")       // =&gt; "J a v a S c r i p t"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 6 - 对象]]></title>
    <link href="http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-5/"/>
    <updated>2016-06-23T19:10:28+08:00</updated>
    <id>http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-5</id>
    <content type="html"><![CDATA[<p>对象是 JavaScript 的基本数据类型。是一种复合值：将很多值聚合在一起。对象可以看做是无序集合，每个属性都是一个名/值对。这种基本数据结构还有很多叫法，比如「散列」（hash）、「散列表」（hashtable）、「字典」（dictionary）、「关联数组」（associative array）。JavaScript 还可以从一个称为 <strong>原型</strong> 的对象继承属性</p>

<p>JavaScript 对象是动态的 —— 可以新增属性也可以删除属性，除了字符串、数字、布尔值、null 和 undefined 之外，JavaScript 中的值都是对象</p>

<p>对象是可变的，通过引用操作对象原对象也会受到影响</p>

<!--more-->


<p>属性包括名字和值。名字是可以包含空字符串在内的 <strong>任意字符串</strong>，值可以是任意 JavaScript 值，或者（在 ECMAScript 5中）可以是一个 getter 或者 setter （或都有），每个属性还有一些与之相关的值称为「属性特性」（property attribute）：</p>

<ul>
<li>可写（writable）</li>
<li>可枚举（enumerable）</li>
<li>可配置（configurable），表明是否可以删除或者修改</li>
</ul>


<p>ECMAScript 5 之前，<strong>通过代码给对象创建的所有属性都是可写、可枚举和可配置的</strong></p>

<p>除了包含属性之外，每个对象还拥有三个相关的对象特性（object attribute）：</p>

<ul>
<li>对象的原型（prototype）指向另外一个对象，本对象的属性继承自它的原型对象</li>
<li>对象的类（class）是一个标识对象类型的字符串</li>
<li>对象的扩展标记（extensible flag）指明了（在 ECMAScript 5 中）是否可以向该对象添加新属性</li>
</ul>


<p>下面这些术语用来区分三类 JavaScript 对象和两类属性：</p>

<ul>
<li>内置对象（native object），由 ECMAScript 规范定义的对象或类。例如 数组、日期</li>
<li>宿主对象（host object），由 JavaScript 解释器所嵌入的宿主环境（比如浏览器）定义的。比如浏览器中的 HTMLElement，document</li>
<li>自定义对象（user-defined object），由运行中的 JavaScript 代码创建的对象</li>
<li>自有属性（own property），直接在对象中定义的属性</li>
<li>继承属性（inherited property）是在对象的原型对象中定义的属性</li>
</ul>


<h2>创建对象</h2>

<h3>对象直接量</h3>

<pre><code class="javascript">var empty = {}
var point = { x:0, y:0 }
var point2 = { x:point.x, y:point.y + 1 }
var book = {
    "main title": "JavaScript",
    "for": "all audiences",
    author: {
        firstname: "David",
        surname: "Flanagan"
    }
}
</code></pre>

<p>在 ECMAScript 5 中，保留字可以用做不带引号的属性名。然后对于 ECMAScript 3 来说，使用保留字作为属性名必须使用引号引起来。ECMAScript 5 中属性最后一个逗号会被忽略，但在 IE 中则报错</p>

<h3>通过 new 创建对象</h3>

<p>new 运算符创建并初始化一个新对象。new 后跟随一个函数调用。这里的函数称做构造函数（constructor），用来初始化一个新创建的对象。JavaScript 语言核心的原始类型都包含内置构造函数（另一方面也证实了 JavaScript 中一切皆对象）</p>

<pre><code class="javascript">var o = new Object();
var a = new Array();
var d = new Date();
var r = new RegExp('js');
</code></pre>

<h3>原型</h3>

<p>每一个 JavaScript 对象（null 除外）都和另一个对象相关联，这个对象就是「原型」，每一个对象都从原型继承属性</p>

<p>通过 new 创建的对象原型就是构造函数的 prototype 属性值，通过 new Object() 创建的对象也继承自 Obejct.property</p>

<p>没有原型对象的为数不多，Obejct.prototype 就是其中之一。它不继承任何属性，普通对象都具有原型。所有的内置构造函数都具有一个继承自 Object.prototype 的原型。例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性现时继承自 Date.prototype 和 Object.prototype，这一系列链接的原型对象就是所谓的「原型链」（prototype chain）</p>

<h3>Object.create()</h3>

<p>ECMAScript 5 定义了一个名为 Obejct.create() 的方法，用来创建一个新对象，其中第一个参数是这个对象的原型，第二个可选参数用来对对象的属性进行进一步描述，Object.create() 是一个 <strong>静态函数</strong>，不是提供给对象调用的方法</p>

<pre><code class="javascript">var o1 = Object.create({ x:1, y:2 });       // o1 继承了属性 x 和 y
var o2 = Obejct.create(null);               // o2 不继承任何属性和方法
</code></pre>

<p>在 ECMAScript 3 中可以用类似代码来模拟原型继承：</p>

<pre><code class="javascript">function inherit(p) {
    if (p == null) throw TypeError();
    if (Object.create) return Object.create(p);

    var t = typeof p;
    if (t !== "object" &amp;&amp; t !== "undefined") throw TypeError();

    function f() {}
    f.prototype = p;

    return new f();
}

var o = { x: "test o" }

var c = inherit(o);

c.x = "test c";

console.log(c.x);       // =&gt; "test c"
console.log(o.x);       // =&gt; "test o"
</code></pre>

<h2>属性的查询和设置</h2>

<pre><code class="javascript">var author = book.author;           // 取得 book 的 author 属性
var title = book["main title"];     // 使用 [] 访问属性时 [] 内必须是一个计算结果为字符串的表达式

book.edition = 6;                   // 给 book 创建一个名为 edition 的属性，「.」号运算符后的标识符不能是保留字
</code></pre>

<h3>作为关联数组的对象</h3>

<p>当通过 [] 来访问对象属性时，属性名通过字符串来表示。字符串是 JavaScript 的数据类型，在程序运行时可以修改创建它们。因此，可以在 JavaScript 中使用下面这种代码来动态添加/查找属性：</p>

<pre><code class="javascript">var addr = "";
for (i = 0; i &lt; 4; i++) {
    addr += customer["address" + i] + '\n';
}
</code></pre>

<h3>继承</h3>

<p>假设要查询对象 o 的属性 x，如果 o 中不存在 x，那么将会继续在 o 的原型对象中查询属性 x。如果原型对象中也没有 x，但这个原型对象还有原型，那么继续在这个原型对象的原型上执行查找，直到找到 x 或者找到一个原型是 null 的对象为止。可以看出来，原型的属性构成了一个「链接」，通过这个「链」可以实现属性的继承</p>

<pre><code class="javascript">var o = {}
o.x = 1;

var p = inherit(o);
p.y = 2;

var q = inherit(p);
q.z = 3;

var s = q.toString();   // =&gt; "[object Object]"
q.x + q.y               // =&gt; 3
</code></pre>

<h3>属性访问错误</h3>

<p>属性访问并不总是返回或设置一个值，下页场景给对象 o 设置 属性 p 会失败：</p>

<ul>
<li>o 中的属性 p 是只读的（defineProperty() 方法中有一个例外，可以对可配置的只读属性重新赋值）</li>
<li>o 中不存在自有属性 p：o 没有使用 setter 方法继承属性 p，并且 o 的可扩展性（extensible attribute）是 false。如果 o 中不存在 p，而且没有 setter 方法可供调用，则 p 一定会添加至 o 中。如果 o 不是可扩展的，那么在 o 中不能定义新的属性</li>
</ul>


<h2>删除属性</h2>

<p>使用 delete 运算符可以删除对象的属性，delete 运算符只能删除 <strong>自有属性</strong>，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）</p>

<p>如果删除成功或者删除了一个没有影响的值（不存在的属性），delete 表达式返回 true。当 delete 运算符的操作数不是一个对象的属性的时候也返回 true</p>

<pre><code class="javascript">var o = { x: 1 }
delete o.x;             // =&gt; true
delete o.x;             // =&gt; true x 并不存在
delete o.toString;      // =&gt; true toString 是继承属性
delete 1                // =&gt; true 不是对象属性
this.b = 1;
delete b;               // =&gt; true 删除全局对象上的变量 b

delete Object.property  // =&gt; false
var x = 1;
delete this.x;          // =&gt; false 不能删除这个属性，因为是通过 var 声明的
function f() {}
delete f                // =&gt; false 不能删除全局函数
</code></pre>

<h2>检测属性</h2>

<p>可以通过 in 运算符、hasOwnProperty() 方法和 propertyIsEnumerable() 方法来检测对象是否存在某属性，propertyIsEnumerable 只有检测到是自有属性且这个属性的可枚举性为 true 时它才返回 true</p>

<pre><code class="javascript">var o = { x: 1 };
"x" in o;                          // =&gt; true
"y" in o;                          // =&gt; false
"toString" in o                    // =&gt; true

o.hasOwnProperty("x")              // =&gt; true
o.hasOwnProperty("y")              // =&gt; false
o.hasOwnProperty("toString")       // =&gt; false

var o = inherit({ y: 2});
o.x = 1;
o.propertyIsEnumerable("x")        // =&gt; true
o.propertyIsEnumerable("y")        // =&gt; false
o.propertyIsEnumerable("toString") // =&gt; false
</code></pre>

<p>还可以通过判断属性是否是 undefined 来模拟 in 运算符</p>

<pre><code class="javascript">o.x !== undefined;                 // =&gt; true
o.y !== undefined;                 // =&gt; false
o.toString !== undefined;          // =&gt; true
</code></pre>

<p>然而有一种场景只能使用 in 运算符而不能通过只判断 undefined 的方式。<strong>in 可以区分不存在的属性和存在但值为 undefined 的属性</strong></p>

<pre><code class="javascript">var o = { x: undefined }
o.x !== undefined           // =&gt; false 存在 x，只是值为 undefined
o.y !== undefined           // =&gt; false
"x" in o                    // =&gt; true
"y" in o                    // =&gt; false
delete o.x                  // =&gt; true
"x" in o                    // =&gt; false delete 后 o 完全不存在了
</code></pre>

<h2>枚举属性</h2>

<p>许多工具库给 Object.prototype 添加了新的方法或者属性（通常不建议这么做），这些方法和属性可以被所有对象继承并使用。然而在 ECMAScript 5 标签之前，这些添加的方法是 <strong>不能定义为不可枚举的</strong>，因此它们都可以在 for/in 循环枚举出来。为了避免这和践情况，需要过滤 for/in 循环返回的属性，下面两种方法是最常见的：</p>

<pre><code class="javascript">Object.prototype.test = 1;
var o = { a: 1, b:2, c: function() {} };
for (p in o) {
    if (!o.hasOwnProperty(p)) continue;
    console.log(p);
}
for (p in o) {
    if (typeof o[p] === "function") continue;
}
</code></pre>

<p>除了 for/in 循环之外，ECMAScript 5 定义了两个用以枚举属性名称的函数。第一个是 Object.keys()，它返回一个数组，由对象中的 <strong>可枚举的自有属性名称</strong> 组成，第二个是 Object.getOwnPropertyNames()，它和上面的方法类似，只是它返回对象的 <strong>所有自有属性名称</strong>，不仅仅是可枚举的属性</p>

<h2>属性 getter 和 setter</h2>

<p>在 ECMAScript 5 中，属性的值可以用一个或两个方法替代，这两个方法就是 getter 和 setter。由它们定义的属性称做「存取器属性」（accessor property），不同于「数据属性」（data property），数据属性只有一个简单的值</p>

<p>当程序查询存取器属性的值时，JavaScript 调用 getter 方法（无参数）。这个方法返回属性的存取表达式值。当程序设置一个存取器属性的值时，调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责「设置」属性值。可以忽略 setter 方法的返回值</p>

<p>使用存取器属性写入的属性不具有可写性（writable）。如果属性同时具有 getter 和 setter 方法，那么它是一个读/写属性。哪果它只有 getter 方法，那么它是一个只读属性。如果只有 setter 方法，那么它是一个只写属性，读取只写属性总是返回 undefined</p>

<pre><code class="javascript">var p = {
  x: 1.0,
  y: 1.0,

  get r() {
    return Math.sqrt(this.x*this.x + this.y*this.y);
  },
  set r(newValue) {
    var oldValue = Math.sqrt(this.x*this.x + this.y*this.y);
    var ratio = newValue/oldValue;

    this.x *= ratio;
    this.y *= ratio;
  },
  get theta() {
    return Math.atan2(this.y, this.x)
  }
};
p.r             // =&gt; 1.4142135623730951
</code></pre>

<h2>属性的特性</h2>

<p>除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。ECMAScript 3 程序创建的属性都是可写、可枚举、可配置的，且无法对这些特性做出修改。ECMAScript 5 中却提供了查询和设置这些属性鹅的 API，这些 API 对于库的开发者来说非常重要，因为：</p>

<ul>
<li>可以通过这些 API 给原型对象添加方法，并将它们设置成不可枚举的，<strong>让它们看起来更像内置方法</strong></li>
<li>可以通过这些 API 给对象定义不修改或删除的属性借此「锁定」这个对象</li>
</ul>


<p><strong>数据属性</strong> 的 4 个属性分别是它的值（value）、可写性（writable）、可枚举性（enumerable）和可配置性（configurable）</p>

<p><strong>存取器属性</strong> 不具有值（value）特性和可写性，它们的可写性是由 setter 方法存在与否决定，因此存取器属性的 4 个特性是读取（get）、写入（set）、可枚举性和可配置性</p>

<p>为了实现属性特性的查询和设置操作，ECMAScript 5 中定义了一个名为「<strong>属性描述符</strong>」（property descriptor）的对象，这个对象代表那 4 个特性。描述符对象的属性和它们所描述的属性特性是同名的。因此，数据属性的描述符对象的属性有 value, writable, enumerable 和 configurable。存取器属性描述符对象则用 get, set 属性代替 value, writable。其中 writable、enumerable 和 configurable 都是布尔值，get、set 都是函数值</p>

<p>通过调用 Object.getOwnPropertyDescriptor() 可以获得某个对象特定属性的属性描述符</p>

<pre><code class="javascript">// =&gt; {value: 1, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor({ x: 1}, "x")
var random = {
    get octet() {
        return Math.floor(Math.random() * 256)
    },
    get uint16() {
        return Math.floor(Math.random() * 65536)
    },
    get int16() {
        return Math.floor(Math.random() * 65536 - 32768)
    }
}
// =&gt; {set: undefined, get: function, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor(random, "octet")
// =&gt; undefined
Object.getOwnPropertyDescriptor({}, "x")
</code></pre>

<p>从函数名字就可以看出来 Object.getOwnPropertyDescriptor() 只能得到自有属性的描述符。继承属性的特性需要遍历原型链</p>

<p>要想设置属性的特性，或者让新建属性具有某种特性，则需要调用 Object.defineProperty()，传入要修改的对象、要创建或者修改的属性的名称以前属性描述符对象：</p>

<pre><code class="javascript">var o = {};
Object.defineProperty(o, "x", {
    value: 1,
    writable: true,
    enumerable: false,
    configurable: true
});
// x 属性存在但不可枚举
Object.keys()       // =&gt; []

Object.defineProperty(o, "x", { writable: false })
o.x = 2             // 试图更改这个属性的值，会操作失败不报错，严格模式中则抛出类型错误异常
o.x                 // =&gt; 1

// 将 x 从数据属性修改为存取器属性
Object.defineProperty(o, "x", { value: 2 })
Object.defineProperty(o, "x", { get: function() { return 0} }
o.x                 // =&gt; 0
</code></pre>

<p>传入 Object.defineProperty() 的属性描述符对象 <strong>不必</strong> 包含所有 4 个特性。对于创建属性来说，默认的特性值是 false 或 undefined。对于修改的已有属性来说，默认的特性值没有做任何修改。注意，这个方法要么修改已有属性要么新建自胡属性，但 <strong>不能修改继承属性</strong>，想要同时修改或者创建多个属性则需要使用 Object.defineProperties()，使用方法可以参考 MDN <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">相关 api</a></p>

<p>对于那些不允许创建或者修改的属性来说，如果用 Object.defineProperty() 对其操作就会抛出类型错误异常，比如给一个不可扩展的对象新增属性就会抛出类型错误异常。<strong>可写性控制着对特定值特性的修改，可配置性控制着对其它特性的修改</strong>，使用的时候以下情况会抛出类型错误异常：</p>

<ul>
<li>如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性</li>
<li>如果属性是不可配置的，则不能修改它的可配置性和可枚举性</li>
<li>如果存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性</li>
<li>如果数据属性是不可配置的，则不能将它转换为存取器属性</li>
<li>如果数据属性是不可配置的，则不能将它的可写性从 false 修改为 true，但可以从 true  修改为 false</li>
<li>如果数据属性是不可配置且不可写的，则不能修改它的值，然而 <strong>可配置但不可写的属性值是可以修改的</strong></li>
</ul>


<pre><code class="javascript">// 给 Object.prototype 添加一个不可枚举的 extend() 方法
// 这个方法继承自调用它的对象，将作为参数什入的对象属性都复制
Object.defineProperty(Object.prototype, "extend", {
    writable: true,
    enumerable: false,
    configurable: true,
    value: function(o) {
        var names = Object.getOwnPropertyNames(0);

        for (var i = 0, l = names.length; i &lt; l; i++) {
            if (names[i] in this) continue;

            var desc = Object.getOwnPropertyDescriptor(o, name[i]);
            Object.defineProperty(this, names[i], desc)
        }
    }
});
</code></pre>

<p><strong>getter 和 setter 的老式 API</strong></p>

<p>在ECMAScript 5标准被采纳之前，大多数 JavaScript 的实现（IE 除外）已经可以支持对象直接量语法中的 get 和 set 写法。这些实现提供了非标准的老式 API 用来查询和设置 getter 和 setter。这些 API 由 4 个方法组成，所有对象都拥有这些方法。<code>__lookupGetter__()</code> 和 <code>__lookupSetter__()</code> 用以返回一个命名属性的 getter 和 setter 方法，<code>__defineSetter__()</code> 和 <code>__defineGetter__()</code> 用以定义 getter 和 setter</p>

<h2>对象的三个属性</h2>

<p>每个对象都胡与之相关的 <strong>原型</strong>（prototype）、<strong>类</strong>（class）和 <strong>可扩展性</strong>（extensible attribute）</p>

<h3>原型属性</h3>

<p>原型属性是在实例对象创建之初就设置好的，ECMAScript 5 中，对象作为参数传入 <code>Object.getPrototypeOf()</code> 可以查看它的原型，在 ECMAScript 3 中，则没有与之等价的函数，但经常使用表达式 o.constructor.prototype 来检测一个对象的原型。通过 new 表达式创建的对象，通常继承一个 constructor 属性，这个属性指代创建这个对象的构造函数</p>

<p>要想检测一个对象是否是另一个对象的原型（或者处于原型链中），请使用 isPrototypeOf() 方法，这个方法和 instanceof 运算符非常类似，例如：</p>

<pre><code class="javascript">var p = { x:1 };
var o = Object.create(p);
p.isPrototypeOf(o)                  // =&gt; true
Object.prototype.isPrototypeOf(o)   // =&gt; true
</code></pre>

<h3>类属性</h3>

<p>对象的类属性是一个字符串，用以表示对象的类型信息。ECMAScript 3/5 都未提供设置这个属性的方法，并只有一种间接的方法可以查询它。默认的 toString() 方法（继承自 Object.prototype），返回了如下这种格式的字符串：</p>

<blockquote><p>[object class]</p></blockquote>

<p>所以可以通过 toString() 方法返回的字符串截取处理取到 class 名，不过很多对象继承的 toString() 方法被重写了，为了能调用正确的 toString() 版本，必须间接地调用 Function.call() 方法</p>

<pre><code class="javascript">function classof(o) {
    if (o === null) return "Null";
    if (o === undefined) return "Undefined";
    return Object.prototype.toString.call(o).slice(8, -2);
}
classof(null)     // =&gt; "Null"
classof(1)        // =&gt; "Number"
classof("")       // =&gt; "String"
classof(true)     // =&gt; "Boolean"
classof({})       // =&gt; "Object"
classof([])       // =&gt; "Array"
classof(/./)      // =&gt; "Regexp"
classof(new Date) // =&gt; "Date"
function f() {}
classof(new f())  // =&gt; "Object"
</code></pre>

<h3>可扩展属性</h3>

<p>可扩展性用以表示是否可以给对象是添加新属性。所有内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展属性是由 JavaScript 引擎定义的，ECMAScript 5 中，所有的内置对象和自定义对象都是可扩展的，除非将它们转换为不可扩展的，宿主对象的可扩展性也是由实现 ECMAScript 5 的 JavaScript 引擎定义的</p>

<p>ECMAScript 5 定义了用来查询和设置对象可扩展性的函数：Object.isExtensible()，如果将对象转换为不可扩展的，需要调用 Object.preventExtensions()，不过一量旦将对象转换为不可扩展的，就无法再转换回去了。</p>

<p>Object.seal() 和 Object.preventExtensions() 类似，除了能将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的，也就是说不能给对象添加新的属性，已有的属性也不能删除或配置，已封闭（sealed）的对象是不能解封的，可以使用 Object.isSealed() 来检测对象是否封闭</p>

<p>Object.freeze() 将更严格地锁定对象 —— 「冻结」，它还可以将它自有的所有数据属性设置为只读，可以使用 Object.isFrozen() 来检测对象是否冻结</p>

<h2>序列化对象</h2>

<p>对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript 5 提供了内置函数 JSON.stringify 和 JSON.parse() 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON的全称是「JavaScript Object Notation」—— JavaScript 对象表示法，正如其名，它的语法和 JavaScript 对象与数组直接量的语法非常相近</p>

<p>ECMAScript 3 环境中可以引用 <a href="https://github.com/douglascrockford/JSON-js">json2</a> 类库来支持这两个序列化函数</p>

<p>JSON 语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值，函数、RegExp、Error 对象和 undefined 值不能序列化和不愿。JSON.stringify() <strong>只能序列化对象可枚举的自有属性</strong>，关于 JSON 对象更多 API 可以参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify</a></p>

<h2>对象方法</h2>

<h3>toString() 方法</h3>

<p>toString() 方法没有参数，在需要将对象转换为字符串的时候，JavaScript 都调用这个方法</p>

<pre><code class="javascript">var s = { x: 1, y: 1 }
s.toString();       // =&gt; "[object Ojbect]"
</code></pre>

<h3>toLocaleString() 方法</h3>

<p>返回一个对象的本地化字符串。Object 中默认的 toLocaleString() 方法并不做任何本地化自身操作，它仅调用 toString() 方法并返回值。Date 和 Number 类对 toString() 方法做了定制，可以用它对数字、日期和时间做本地化的转换</p>

<h3>toJSON() 方法</h3>

<p>Object.prototype 实际上不有定义 toJSON() 方法，但对于需要执行序列化的对象来说，JSON.stringify() 方法会调用 toJSON() 方法，如果存在则调用它，返回值即是序列化的结果，而不是原始对象，参见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toJSON">Date.toJSON</a></p>

<h3>valueOf() 方法</h3>

<p>valueOf() 和 toString() 方法非常类似，但往往当 JavaScript 需要 <strong>将对象转换为某种原始值而非字符串</strong> 的时候才会用到它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript 就会自动调用这个方法，同样有些内置类自定义了 valueOf() 方法，比如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/valueOf">Date.valueOf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 5 - 语句]]></title>
    <link href="http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-4/"/>
    <updated>2016-06-23T19:10:28+08:00</updated>
    <id>http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-4</id>
    <content type="html"><![CDATA[<p>表达式在 JavaScript 中是短语（phrases），那么语句（statements）就是 JavaScript 整句或命令，语句以分号结束。表达式计算出一个值，语句用来执行以使某件事情发生</p>

<!--more-->


<h2>表达式语句</h2>

<p>赋值语句、递增/减运算、delete 运算符删除对象属性、函数调用都是表达式语句</p>

<pre><code class="javascript">gretting = "Hello " + name;
i *= 3;
count++;
delete o.x;
alert(greeting)
window.close();
Math.cos(x)
cs = Math.cos(x);
</code></pre>

<h2>复合语句和空语句</h2>

<p>逗号运算符将几个表达式连接在一起形成一个表达式，同样，JavaScript 中还可以将多条语句联合在一起，形成一条复合语句（compound statement）。只须用花括号括起来即可，下面几行代码就可以当成一条单独语句</p>

<pre><code class="javascript">{
    x = Math.PI;
    cx = Math.cos(x);
    console.log("cos(x) = " cx);
}
</code></pre>

<p>需要注意的两点：</p>

<ul>
<li>语句块的结尾不需要分号。块中的原始语句 <strong>必须</strong> 以分号结束</li>
<li>语句块中的行缩进不是必须的，但是合理的缩进更容易理解</li>
<li>语句块并没有块级作用域名，语句块中声明的变量不是语句块私有的</li>
</ul>


<p>空语句（empty statement）允许包含 0 条语句，空语句在初化一个数组时偶尔会用到</p>

<pre><code class="javascript">var a = Array(50);
a                                           // =&gt; [undefined,,,,undefined]
for (i = 0; i &lt; a.length; a[i++] = 0) ;     // 初始化一个数组，注意末尾的分号不能少
a                                           // =&gt; [0,,,0]
</code></pre>

<p>这个循环中，所有操作都在表达式 a[i++]=0 中完成，这里并不需要任何循环体。然而 JavaScript 需要循环体中 <strong>至少包含一条语句</strong>，因此，这里只使用了一个单独的分号来表示一条空语句</p>

<h2>声明语句</h2>

<p>var 和 function 都是声明语句，声明语句本身什么也不做，只用来更好地组织代码的语义</p>

<h3>var</h3>

<p>var 语句用来声明一个或者多个变量，用法如下：</p>

<pre><code class="javascript">var name_1 [= value_1] [,..., name_n [= value_n]]
</code></pre>

<p>如果 var 语句出现在函数体内，那么它定义的是一个 <strong>局部变量</strong>，其作用域就是这个函数，如果在顶层代码中使用 var 语句，它声明的是 <strong>全局变量</strong>，整个程序中都是可用的</p>

<p>全局变量是全局对象的属性。然而通过 var 声明的全局变量 <strong>无法</strong> 通过 delete 删除</p>

<p>如果 var 语句中的变量没有指定初始化表达式，那么这个变量的值初始为 undefined</p>

<h3>function</h3>

<p>函数声明的语句的语法如下：</p>

<pre><code class="javascript">function fun_name([arg1 [, arg2 [..., argn]]]) {
    statements
}
</code></pre>

<pre><code class="javascript">var f = function(x) { return x+1; };        // 通过 var 声明函数
function f(x) { return x+1; }
</code></pre>

<h2>条件语句</h2>

<h3>if</h3>

<pre><code class="javascript">if (expression) {
    statement
}
</code></pre>

<p>这种形式中，需要计算 expression 的值，如果结果是真值，那么就执行 statement</p>

<p>为了避免歧义，建议 <strong>总是</strong> 给 if 语句添加花括号</p>

<h3>else if</h3>

<pre><code class="javascript">if (expression) {
    statement
} else if (expression) {
    statement
}
</code></pre>

<h3>switch</h3>

<pre><code class="javascript">switch(expression) {
    statement
}
</code></pre>

<h2>循环</h2>

<h3>while</h3>

<pre><code class="javascript">var count = 0;
while (count &lt; 10) {
    console.log(count);
    count++
}
</code></pre>

<h3>do/while</h3>

<pre><code class="javascript">function printArray(a) {
    var len = a.length, i = 0;
    if (len == 0) {
        console.log('Empty Array);
    } else {
        do {
            console.log(a[i]);
        } while(++i &lt; len);
    }
}
</code></pre>

<h3>for</h3>

<p>for 循环的 <strong>执行顺序</strong> 是：</p>

<ol>
<li>initialize</li>
<li>test 条件为真</li>
<li>statement</li>
<li>increment</li>
</ol>


<pre><code class="javascript">for (initialize; test; increment) {
    statement
}
</code></pre>

<p>多数情况下与之等价的 while 循环写法：</p>

<pre><code class="javascript">initialize;
while(test) {
    statement
    increment;
}
</code></pre>

<h3>for/in</h3>

<pre><code class="javascript">for (variable in object) {
    statement
}
</code></pre>

<p>variable 通常是一个变量名（也可以是个表达式），也可以是一个可以产生左值的表达式或者一个通过 var 语句声明的变量，总之必须是一个适用于赋值表达式左侧的值。object 是一个 <strong>表达式</strong>，这个表达式计算结果是一个对象</p>

<p>在执行 for/in 语句的过程中，JavaScript 解释器首先计算 object 表达式。如果表达式为 null 或者 undefined，解释器将会跳过循环并执行后续代码（ECMAScript 3 可能会抛出一个类型错误异常）。如果表达式等于一个原始值，这个原始值将会转换为与之对应的 <a href="/2016/06/16/javascript-definitive-guide-note-2/">包装对象</a>（wrapper object）否则，expression 本身已经是对象了。JavaScript 会依次遍历 <strong>可枚举</strong> 的对象属性来执行循环体语句</p>

<p>for/in 循环并不会遍历对象的所有属性，只有「可枚举」（emumerable）的属性才会遍历到。JavaScript 语言核心所定义的内置方法就 <strong>不是</strong>「可枚举的」，比如，所有对象都有方法 toString()，但 for/in 循环并不枚举 toString 这个属性，还有很多内置属性也是不可枚举的（nonenumerable）。而代码中定义的所有属性和方法都是可枚举的</p>

<p><strong>属性枚举的顺序</strong></p>

<p>ECMAScript 规范并没有指定 for/in 循环按照何种顺序来枚举对象属性。但实际上，主流浏览器厂商的 JavaScript 实现是按照 <strong>属性定义的先后顺序</strong> 来枚举简单对象的属性</p>

<h2>跳转</h2>

<p>JavaScript 中另一类语句是跳转语句（jump statement）。通常有 break, continue, return, throw</p>

<h3>标签语句</h3>

<p>语句是可以添加标签的，标签由语句前的标识符和冒号组成：</p>

<pre><code class="javascript">indetifier: statement
</code></pre>

<p>标识符必须是一个合法的 JavaScript 标识符</p>

<pre><code class="javascript">mainloop: while(token != null) {
    // statement
    continue mainloop;
}
</code></pre>

<h3>break 语句</h3>

<p>单独使用 break 语句的作用是立即退出最内层的 <strong>循环</strong> 或者 <strong>switch 语句</strong>，break 关键字后面也可以跟一个语句标签，当 break 和标签一块使用时，程序将跳转到这个标签所标识的语句块的结束</p>

<p><strong>不管 break 语句带不带标签，它的控制权都无法超过函数的边界</strong></p>

<h3>continue 语句</h3>

<p>类似于 break，但是它不退出循环，而是转而执行下一次循环。continue 语句只能在循环体内使用，其它地方使用会报错</p>

<p>在不同类型的循环中，continue 的行为也是有所区别：</p>

<ul>
<li>在 while 循环中，在循环开始处指定的 expression 会重复检测，如果检测结果为 true，循环休会从头开始执行</li>
<li>在 do/while 循环中，程序的执行直接跳到循环结尾处，这里会重新判断循环条件，之后才会继续下一次循环</li>
<li>在 for 循环中，首先计算自增表达式，然后再次检测 test 表达式，用以判断是否执行循环体</li>
<li>在 for/in 循环中，循环开始遍历下一个属性名，这个属性名赋给了指定的变量</li>
</ul>


<p>需要注意的是 continue 语句在 while 和 for 循环中的区别，while 循环直接进入一下轮的循环条件判断，但 for 循环首先计算其 increment 表达式，然后判断循环条件，所以 for 循环并不能完全等价模拟出 while 循环</p>

<pre><code class="javascript">// while 语句中的写法会造成死循环，for 语句则不会
// for 语句中的 increment 表达式总是会执行到
var i = 0;
while (i &lt; 10) {
    if (i &lt; 5 ) {
        continue;
    }
    console.log(i);
    i++;
}

for (var k = 1; k &lt; 10; k++) {
    if (k &lt; 5) {
        continue;
    }
    console.log(k);
}
</code></pre>

<h3>return 语句</h3>

<pre><code class="javascript">return expression;
</code></pre>

<p>return 语句 <strong>只能</strong> 出现在函数体内，如果不是的话会报语法错误。当执行到 return 语句的时候，函数终止执行，并返回 expression 的值给调用程序，例如：</p>

<pre><code class="javascript">function square(x) { return x*x; }
square(2)   // =&gt; 4
</code></pre>

<p>return 可以单独使用而不必带有 expression，这样的话函数会向调用程序返回 undefined</p>

<h3>throw 语句</h3>

<p>所谓异常（exception）是当发生了落地生根异常情况或错误时产生的一个信号。抛出异常（throw exception），就是用信号通知发生错误或者异常头部。捕获（catch）异常是指处理这个信号，即采取必要的手段从异常中恢复</p>

<pre><code class="javascript">throw expression;
</code></pre>

<p>expression 的值可以是任意类型的。当 JavaScript 解释器抛出异常的时候通常采用 Error 类型和其子类型</p>

<pre><code class="javascript">function factorial(x) {
    // 如果输出参数是非法的，则抛出一个异常
    if (x &lt; 0) throw new Error('x 不能是负数');
    for (var f = 1; x &gt; 1; f*= x, x--) ;
    return f;
}
</code></pre>

<p>当异常招聘时，JavaScript 解释器会 <strong>立即停止</strong> 当前正在执行的逻辑，并跳转到 <strong>就近的</strong> 异常处理程序。异常钼是程序是用 try/catch/finally 语句的 catch 从句编写的，JavaScript 会沿着方法的词法结构和调用栈向上传播</p>

<h3>try/catch/finally 语句</h3>

<p>try 从句定义了需要处理的异常所有代码块。catch 从句跟在其后，当 try 块内某处发生了异常时，调用 catch 内的代码逻辑。catch 从句后跟随 finally 块，后者中放置清理代码，不管 try 块中是否产生异常，finally 块内的逻辑总是会执行。尽管 catch 和 finally 都是可先的，但 try 从句需要至少二者之一（catch/finally）与之组成完整的语句。</p>

<p>try, catch 和 finally 语句块都 <strong>必须</strong> 使用花括号括起来，即使只有一条语句</p>

<pre><code class="javascript">try {
    // 通常来讲，这里的代码会从头执行到尾而不会产生任何问题，
    // 但有时会招聘一个异常，要么是由 throw 语句直接抛出，要
    // 么是通过调用一个方法间接抛出异常
} catch (e) {
    // 当且仅当 try 语句块抛出了异常，才会执行这里的代码
    // 这里可以通过局部变量 e 来警告对 Error 对象或者抛出的其他值的引用
    // 还可以通过 throw 语句重新抛出异常
} finally {
    // 不管 try 语句是否抛出了异常，这里的逻辑总是会执行，终止 try 语句块的方式有：
    // 1. 正常终止，执行完语句块的最后一条语句
    // 2. 通过 break, continue 或 return 语句终止
    // 3. 抛出一个异常，异常被 catch 从句捕获
    // 4. 抛出一个异常，异常未被捕获，继续向上传播
}
</code></pre>

<p>一般来说 JavaScript 使用 try/catch 语句的时候很少使用 finally。通常在一些后端语言 IO 操作中使用 finally 的比较多，比如打开一个文件，出现异常或者正常执行完 try 从句都需要关闭文件句柄</p>

<h2>其它语句类型</h2>

<p>with, debugger 和 use strict</p>

<h3>with 语句</h3>

<p>with 语句用于临时扩展作用域链，语法如下：</p>

<pre><code class="javascript">with (object) {
    statement
}
</code></pre>

<p>这条语句将 object 添加到 <strong>作用域链的头部</strong>，然后执行 statement，最后把作用域链恢复到原始状态</p>

<p>严格模式中是禁止使用 with 语句的，并且在非严格模式里也是 <strong>不推荐</strong> 使用 with 语句的。使用 with 语句的 JavaScript 代码非常难于优化，并且和没有使用 width 语句的代码相比，运行更慢</p>

<p>在对象嵌套层次很深的时候通常会使用 with 语句来简化代码编写。比如：</p>

<pre><code class="javascript">document.forms[0].address.value = 'a'
document.forms[0].name.value = 'b'
document.forms[0].job.value = 'c'

// 等价于
with (document.forms[0]) {
    address.value = 'a'
    name.value = 'b'
    job.value = 'c'
}
// 使用 with 语句减少了对象访问前缀，但是仍然可以不使用 with 解决这个问题
// 使用变量 f 缓存对象引用
var f = document.forms[0];
f.address.value = 'a'
f.name.value = 'b'
f.job.value = 'c'
</code></pre>

<p>只有在查找标识符的时候才会用到作用域链，创建新的变量的时候不使用</p>

<pre><code class="javascript">var d = 0;
var o = { a: 1, b: 2, c: 3};

with(o) {
   a = 2;
   d = 1
}
d           // =&gt; 1
o           // =&gt; {a: 2, b: 2, c: 3}
</code></pre>

<h3>debugger 语句</h3>

<p>debugger 语句通常什么也不做。当调试程序可用并运行的时候，JavaScript 解释器将会（非必需）以调试模式运行。这条语句用来产生一个断点（breakpoint），JavaScript 代码的挂靠会停止在断点的位置，这时可以使用调试器转出当前的变量、调用栈等</p>

<p>ECMAScript 5 中，debugger 语句正式加入到了语言规范里，在此之前注流浏览器厂商基本都已经实惠过了</p>

<h3>&lsquo;use strict&rsquo;</h3>

<p>&lsquo;use strict&rsquo; 是 ECMAScript 5 引入的一条指定。非常类似语句但不是，区别在于：</p>

<ul>
<li>它 <strong>不包含</strong>任何语言的关键字，指令仅仅是一个包含一个特殊字符串直接量的表达式，它是一条没有副作用的表达式语句，什么也没做</li>
<li>它只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。但不必一定出现在脚本或者函数休内的首行</li>
</ul>


<p>使用 &lsquo;use strict&rsquo; 指令的目的是说明（脚本或函数中）后续的代码将会解析为严格代码</p>

<p>严格代码以 <strong>严格模式</strong> 执行，严格模式悠了语言的重要缺陷，并提供健壮的查氏功能和增强的安全机制，和非严格模式的区别如下：</p>

<ul>
<li>严格模式中 <strong>禁止</strong> 使用 width 语句</li>
<li>严格模式中，所有的变量都要先声明，如果给一个未声明的变量、函数、函数参数、catch 从句参数或全局对象的属性赋值，将会抛出一个引用错误异常</li>
<li>严格模式中，调用的函数（不是方法）中的一个 this 值是 undefined（非严格模式下 this 值总是全局对象），可以利用这个特性来判断当前的 JavaScript 是否支持严格模式 <code>var hasStrictMode = (function() { "use strict"; return this === undefined }())</code></li>
<li>严格模式中，给只读属性赋值和给不可扩展的对象创建新成员都将抛出一个类型错误异常（非严格模式中不会报错）</li>
<li>严格模式中，传入 eval() 的代码不能在调用程序所在的上下文中声明变量或定义函数，非严格模式中可以</li>
<li>严格模式中，函数里的 arguments 对象拥有传入函数值的 <strong>静态副本</strong>。非严格模式下，arguments 里的数组元素和函数参数都指向同一个值的引用</li>
<li>严格模式中，当 delete 运算符后跟随非法的标识符（变量、函数、当函数参数）时，将会抛出一个语法错误异常</li>
<li>严格模式中试图删除一个 <strong>不可配置</strong> 的属性将抛出一个类型错误异常（非严格模式中，返回 false）</li>
<li>严格模式中，一个对象直接量中定义两个或多个 <strong>同名属性</strong> 将产生一个语法错误</li>
<li>严格模式中，函数声明中存在两个或多个同名参数将产生一个语法错误</li>
<li>严格模式中，<strong>不允许使用八进制</strong> 整数直接量（以 0 为前缀）</li>
<li>严格模式中，标识符 eval 和 arguments 当做关键字，它们的值是不能更改的，不能给它们赋值，也不能把它们声明为变量、函数名</li>
<li>严格模式中，限制了对调用栈的检测能力，在严格模式的函数中，arguments.caller 和 arguments.callee 都会抛出一个类型错误异常</li>
</ul>

]]></content>
  </entry>
  
</feed>
