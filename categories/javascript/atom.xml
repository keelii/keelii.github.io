<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Something]]></title>
  <link href="http://keelii.github.io/categories/javascript/atom.xml" rel="self"/>
  <link href="http://keelii.github.io/"/>
  <updated>2016-07-06T18:36:10+08:00</updated>
  <id>http://keelii.github.io/</id>
  <author>
    <name><![CDATA[keelii]]></name>
    <email><![CDATA[keeliizhou@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 10 - 正则表达式的模式匹配]]></title>
    <link href="http://keelii.github.io/2016/07/06/javascript-definitive-guide-note-9/"/>
    <updated>2016-07-06T12:43:30+08:00</updated>
    <id>http://keelii.github.io/2016/07/06/javascript-definitive-guide-note-9</id>
    <content type="html"><![CDATA[<p>正则表达式（regular expression）是一个描述字符模式的对象。在 JavaScript 中 String 和 RegExp 都定义了相关方法对文本进行模式匹配、检索和替换</p>

<!-- more -->


<h2>正则表达式的定义</h2>

<p>JavaScript 中的正则表达式用 RegExp 对象表示，可以使用 RegExp() 构造函数来创建 RegExp 对象，不过也可以通过两个双斜杠「/reg/」以正则直接量的形式创建</p>

<pre><code class="javascript">var pattern = /s$/;             // 通过直接量创建
var pattern = new RegExp('s$'); // 通过构造函数创建
</code></pre>

<h3>直接量字符</h3>

<p>JavaScript 正则表达式语法也支持非字母的字符匹配，这些字符需要通过反斜线（\）作为前缀进行转义</p>

<p><em>表10-1</em></p>

<table>
<thead>
<tr>
<th> 字符       </th>
<th> 匹配                                  </th>
</tr>
</thead>
<tbody>
<tr>
<td> 字母和数字 </td>
<td> 自身                                  </td>
</tr>
<tr>
<td> \0         </td>
<td> NUL 字符（\u0000）                    </td>
</tr>
<tr>
<td> \t         </td>
<td> 制表符（\u0009）                      </td>
</tr>
<tr>
<td> \n         </td>
<td> 换行符（\u000A）                      </td>
</tr>
<tr>
<td> \v         </td>
<td> 垂直制表符（\u000B）                  </td>
</tr>
<tr>
<td> \f         </td>
<td> 换页符（\u000C）                      </td>
</tr>
<tr>
<td> \r         </td>
<td> 回车符（\u000D）                      </td>
</tr>
<tr>
<td> \xnn       </td>
<td> 由十六进制数 nn 指定的拉丁字符        </td>
</tr>
<tr>
<td> \uxxxx     </td>
<td> 由十六进制数 xxxx 指定的 unicode 字符 </td>
</tr>
<tr>
<td> \cX        </td>
<td> 控制字符 ^x                           </td>
</tr>
</tbody>
</table>


<p>正则表达式中，许多标点符号也具有特殊含义，它们是：</p>

<blockquote><p>^ $ . * + ? = ! : | \ / ( ) { }</p></blockquote>

<h3>字符类</h3>

<p>将直接量字符单独放进方括号内组成了字符类（charactor class）</p>

<p><em>表10-2</em></p>

<table>
<thead>
<tr>
<th> 字符   </th>
<th> 匹配                                               </th>
</tr>
</thead>
<tbody>
<tr>
<td> [&hellip;]  </td>
<td> 方括号内的任意字符                                 </td>
</tr>
<tr>
<td> [^&hellip;] </td>
<td> 不在方括号内的任意字符                             </td>
</tr>
<tr>
<td> .      </td>
<td> 除换行符和其它 Unicode 行终止符之外的任意字符      </td>
</tr>
<tr>
<td> \w     </td>
<td> 任何 ASCII 字符组成的单词，等价于 [a-zA-Z0-9]      </td>
</tr>
<tr>
<td> \W     </td>
<td> 任何不是 ASCII 字符组成的单词，等价于 [^a-zA-Z0-9] </td>
</tr>
<tr>
<td> \s     </td>
<td> 任何 Unicode 空白符                                </td>
</tr>
<tr>
<td> \S     </td>
<td> 任何非 Unicode 空白符                              </td>
</tr>
<tr>
<td> \d     </td>
<td> 任何 ASCII 数字，等价于 [0-9]                      </td>
</tr>
<tr>
<td> \D     </td>
<td> 任何非 ASCII 数字，等价于 [^0-9]                   </td>
</tr>
<tr>
<td> [\b]   </td>
<td> 退格直接量                                         </td>
</tr>
</tbody>
</table>


<h3>重复</h3>

<p><em>表10-3</em></p>

<table>
<thead>
<tr>
<th> 字符   </th>
<th> 含义                                                           </th>
</tr>
</thead>
<tbody>
<tr>
<td> {n, m} </td>
<td> 匹配前一项至少 n 次，但不能超过 m 次                           </td>
</tr>
<tr>
<td> {n,}   </td>
<td> 匹配前一项 n 次或者更多次                                      </td>
</tr>
<tr>
<td> {n}    </td>
<td> 匹配前一项 n 次                                                </td>
</tr>
<tr>
<td> ?      </td>
<td> 匹配前一项 0 次或者 1 次，也就是说前一项是可选的，等价于 {0,1} </td>
</tr>
<tr>
<td> +      </td>
<td> 匹配前一项 1 次或者多次，等价于 {1,}                           </td>
</tr>
<tr>
<td> *      </td>
<td> 匹配前一项 0 次或者多次，等价于{0,}                            </td>
</tr>
</tbody>
</table>


<p>举例说明：</p>

<pre><code class="javascript">/\d{2,4}/           // 匹配 2 ~ 4 个数字
/\w{3}\d?/          // 匹配三个单词和一个可选的数字
/\s+java\s+/        // 匹配前后带有一个或者多个空白字符串 "java"
/[^(]*/             // 匹配一个或多个非左括号字符
</code></pre>

<h4>非贪婪的重复</h4>

<p>表10-3 中列出一匹配重复字符是尽可能多地匹配，而且允许后续的正则表达式继续匹配。因此，我们称之为「<strong>贪婪的</strong>」匹配。我们同样可以使用正则表达式进行非贪婪匹配。只需在特匹配的字符后跟随一个问题即可：「??」、「+?」、「*?」或「{1,5}?」</p>

<h3>选择、分级和引用</h3>

<p><em>表10-4</em></p>

<table>
<thead>
<tr>
<th> 字符   </th>
<th> 含义  </th>
</tr>
</thead>
<tbody>
<tr>
<td> |     </td>
<td> 选择，匹配的是该符号左边的子表达式或者右边的子表达式               </td>
</tr>
<tr>
<td> (&hellip;)  </td>
<td> 组合，将几个项组合为一个单元，这个单元可通过「*」、「+」、「?」和「|」等符号<br>加以修饰，而且可以记住和这个组合相匹配的字符串<br>以供此后的引用使用 </td>
</tr>
<tr>
<td> (?:&hellip;)</td>
<td> 只组合，把项组合到一个单元，但不记忆与该组想匹配的字符 </td>
</tr>
<tr>
<td> \n     </td>
<td> 和第 n 个分级第一次匹配的字符相匹配，组是圆括号中的子表达式<br>（也有可能是嵌套的），组索引是从左到右的左括号数，<br>「(?:」形式的分组不编码 </td>
</tr>
</tbody>
</table>


<h3>指定匹配位置</h3>

<p><em>表10-5</em></p>

<table>
<thead>
<tr>
<th> 字符  </th>
<th> 含义                                                                       </th>
</tr>
</thead>
<tbody>
<tr>
<td> ^     </td>
<td> 匹配字符串的开头                                                           </td>
</tr>
<tr>
<td> $     </td>
<td> 匹配字符串的结尾                                                           </td>
</tr>
<tr>
<td> \b    </td>
<td> 匹配一个单词的边界                                                         </td>
</tr>
<tr>
<td> \B    </td>
<td> 匹配非单词边界的位置                                                       </td>
</tr>
<tr>
<td> (?=p) </td>
<td> 零宽正向先行断言，要求接下来的字符都与 p 匹配，但不能包括匹配 p 的那些字符 </td>
</tr>
<tr>
<td> (?!p) </td>
<td> 零宽负向先行断言，要求接下来的字符都不与 p 匹配                            </td>
</tr>
</tbody>
</table>


<h3>标识</h3>

<blockquote><p>/reg/flag</p></blockquote>

<p>标识是放在斜扛右边的，通常有 i, g, m 三种</p>

<ul>
<li>i 执行不区分大小写的匹配</li>
<li>g 执行一个全局匹配，即 找到所有的匹配，而不是找到第一个就停止</li>
<li>m 多行匹配模式</li>
</ul>


<h2>用于模式匹配的 string 方法</h2>

<p>String 支持 4 种使用正则表达式的方法</p>

<h3>String.prototype.search()</h3>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search">search()</a> 方法返回第一个与之匹配的子串起始位置，如果找不到匹配的子串，它将返回 -1</p>

<pre><code class="javascript">"JavaScript".search(/script/i);         // =&gt; 4
</code></pre>

<p>如果 search() 参数不是正则表达式，则首先会 <strong>通过 RegExp 构造函数将它转换成正则表达式</strong>，search() 方法不支持全局检索，因为它 <strong>忽略</strong> 正则表达式参数中的标识 g</p>

<h3>String.prototype.replace()</h3>

<blockquote><p>str.replace(regexp|substr, newSubStr|function)</p></blockquote>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace">replace()</a> 方法用以执行检索与替换操作，正则表达式如果带标识 g，则会替换所有匹配子串</p>

<pre><code class="javascript">// 将所有不区分大小写的 javascript 都替换成 JavaScript
text.replace(/javascript/gi);

// 用中文引号替换英文应该引号，同时要保持引号之间的内容（存储在 $1 中）没有被修改
var quote = /"([^"]*)"/g;
text.replace(quote, '“$1”')
</code></pre>

<h3>String.prototype.match()</h3>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match">match()</a> 方法返回一个由匹配结果组成的数组，如果没有标识全局搜索，match() 只检索第一个匹配</p>

<pre><code class="javascript">"1 plus 2 equals 3".match(/\d+/g);  // =&gt; ["1", "2", "3"]
</code></pre>

<h2>RegExp 对象</h2>

<blockquote><p>RegExp(pattern [, flags])</p></blockquote>

<p>RegExp 构造函数一般用在动态创建正则表达式的时候，这种情况往往没办法通过写死在代码中的正则直接量来实现，比如检索字符串是用户输出的</p>

<h3>RegExp 的属性</h3>

<p>每个 RegExp 对象都包含 5 个属性：</p>

<ul>
<li>source 只读字符串，包含正则表达式的文本</li>
<li>global 只读布尔值，说明正则表达式是否带全局标识 g</li>
<li>ignoreCase 也是一个只读布尔值，说明正则表达式是否带标识 i</li>
<li>multiline 也是一个只读布尔值，说明正则表达式是否带标识 m</li>
<li>lastIndex 它是一个可读/写的整数。如果匹配模式带有 g 标识，这个属性存储在整个字符串中下一次检索的开始位置</li>
</ul>


<h3>RegExp 的方法</h3>

<h4>exec()</h4>

<p>exec() 对一个指定的字符串执行一个正则表达式，如果没有找到任何匹配，它就返回 null，但如果它找到一个匹配，将返回一个数组</p>

<pre><code class="javascript">var pattern = /Java/g;
var text = "JavaScript is more fun than Java!";
var result;
while((result = pattern.exec(text)) != null) {
    console.log("Matched '%s' at position '%s'; next search begins at %s",
        result[0],
        result.index,
        pattern.lastIndex);
}
// Matched 'Java' at position '0'; next search begins at 4
// Matched 'Java' at position '28'; next search begins at 32
</code></pre>

<h4>test()</h4>

<p>test() 对方法转入字符串进行检测，匹配到结果返回 true，否则返回 false</p>

<pre><code class="javascript">var pattern = /java/i;
pattern.test('JavaScript');     // =&gt; true
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 9 - 类和模块]]></title>
    <link href="http://keelii.github.io/2016/07/02/javascript-definitive-guide-note-8/"/>
    <updated>2016-07-02T13:58:30+08:00</updated>
    <id>http://keelii.github.io/2016/07/02/javascript-definitive-guide-note-8</id>
    <content type="html"><![CDATA[<p>每个 JavaScript 对象都是一个属性集合，相互之间没有任何联系。在 JavaScript 中也可以定义对象的类，让每个对象都共享某些属性，这种「共享」的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或者定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。这些行为通常是由类定义的，而且为所有实例所共享。例如，假设有一个 Complex 的类用来表示复数， 同时还定义了一些复数运算，一个 Complex 实例应当包含实数的实部和虚部（状态），同样 Complex 类还会定义复数的加法和乘法操作（行为）</p>

<!--more-->


<p>JavaScript 中类的一个重要特性是「<strong>动态可继承</strong>」（dynamically extendable），我们可以将类看做是类型，本章会介绍一种编程哲学 —— 「<a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"><strong>鸭子类型</strong></a>」（duck-typing），它弱化了对象的类型，强化了对象的功能</p>

<h2>类和原型</h2>

<p>在 JavaScript 中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。在之前的 <a href="/2016/06/23/javascript-definitive-guide-note-5/#TOC-4">章节</a> 里定义了 inherit() 函数，这个函数返回一个新创建的对象，后者继承自某个原型对象。如果定义一个原型对象，然后通过 inherit() 函数创建一个继承自它的对象，这样就定义了一个 JavaScript 类。通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象</p>

<pre><code class="javascript">// 一个简单的实现表示值的范围的类
function range(from, to) {
    var r = inherit(range.methods);

    r.from = from;
    r.to = to;
    return r;
}
range.methods = {
    includes: function(x) {
        return this.from &lt;= x &amp;&amp; x &lt;= this.to;
    },
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    }
    toString: function() {
        return "(" + this.from + "..." + this.to + ")";
    }
}
var r = range(1, 3);
r.includes(2)           // =&gt; true
r.foreach(console.log)
// =&gt; 1
// =&gt; 2
// =&gt; 3
console.log(r);         // =&gt; (1...3)
</code></pre>

<p>这段代码定义了一个工厂方法 range()，用来创建新的范围对象。range.methods 属性用来快捷地存放定义类的原型对象。range() 函数给每个范围对象都定义了 from 和 to 属性，用以定义范围的起始和结束位置，这两个属性是 <strong>非共享</strong> 的，当然也是不可继承的。</p>

<h2>类和构造函数</h2>

<p>上节中展示了定义类的一种方法，但是这种方法并不常用，它没定义构造函数。构造函数是用来初始化新创建的对象的。调用构造函数的一个重要特征是，构造函数的 prototype 属性被用做新对象的原型。这意味着 <strong>通过同一个构造函数创建的所有对象都继承自一个相同的对象</strong>，因此它们都是同一个类的成员</p>

<p><em>例9-2</em></p>

<pre><code class="javascript">function Range(from, to) {
    this.from = from;
    this.to = to;
}
Range.prototype = {
    includes: function(x) {
        return this.from &lt;= x &amp;&amp; x &lt;= this.to;
    },
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    }
    toString: function() {
        return "(" + this.from + "..." + this.to + ")";
    }
};
var r = new Range(1, 3)
r.includes(2)       // =&gt; true
r.foreach(console.log)
// =&gt; 1
// =&gt; 2
// =&gt; 3
console.log(r);    // =&gt; "(1...3)"
</code></pre>

<p>从某种意义上讲，定义构造函数既是定义类，并且 <strong>类名首字母要大写</strong>，而普通普通的函数和方法都是首字母小写，Range() 构造函数是通过 new 关键字调用的，而在上一节的工厂函数则不必使用 new。通过 new 调用不必再用  inherit 来创建对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个对象</p>

<h3>构造函数的类的标识</h3>

<p>上文提到，原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。而初始化对象的状态的构造函数则不能作为类的标识，两个构造函数的 prototype 属性可能指责同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的</p>

<p>构造函数的名字通常用做类名，比如我们说 Range() 构造函数创建 Range 对象。然而，更根本地讲，当使用 instancdof 运算符来检测对象是否属于某个类时会用到构造函数。假设有一个对象 r，我们想知道它是否是 Range 对象，可以这样判断</p>

<pre><code class="javascript">r instanceof Range  // 如果 r 继承自 Range.prototype，则返回 true
</code></pre>

<p>实际上 instanceof 运算符并不会检查 r 是否是由 Range() 构造函数初始化而来，而是 <strong>检查 r 是否继承自 Range.prototype</strong></p>

<h3>constructor 属性</h3>

<blockquote><p>每个 JavaScript 函数（bind除外）都自动拥有一个 prototype 属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性 constructor。constructor 属性的值是一个函数对象</p></blockquote>

<pre><code class="javascript">var F = function() {};
var p = F.prototype;
var c = p.constructor;
c === F                 // =&gt; true
</code></pre>

<p>图 9-1 展示了构造函数和原型对象之间的关系，包括原型到构造函数的反向引用以及构造函数创建的实例</p>

<p><em>图9-1</em></p>

<pre><code class="javascript">   构 造 函 数                      原 型                        实 例
+------------------+       +------------------+          +---------------+
|                  |       |                  | inherits |               |
|  Range()         &lt;---------- contructor     &lt;----------+ new Range(2)  |
|                  |       |                  |          |               |
|                  |       |                  |          +---------------+
|                  |       |   includes       |
|   prototype  ------------&gt;                  |
|                  |       |   foreach        |          +---------------+
|                  |       |                  | inherits |               |
|                  |       |   toString       &lt;----------+ new Range(3,4)|
|                  |       |                  |          |               |
|                  |       |                  |          +---------------+
+------------------+       +------------------+
</code></pre>

<p>例9-2中定义的 Range 类使用它自身的一个新对象重写预定义的 Range.prototype 对象。这个新定义的原型对象不含有 constructor 属性。因此 Range 类的实例也不含有 constructor 属性。我匀可以通过补救措施来修正这个问题，显式给原型添加一个构造函数：</p>

<pre><code class="javascript">Range.prototype = {
    constructor: Range,
    incluces: function() {/*code*/}
};
// 当然也可以使用给 prototype 指定方法赋值的方式，避免重写整个 prototype
Range.prototype.includes = function() {/*code*/}
</code></pre>

<h2>JavaScript 中 Java 式的类继承</h2>

<p>在 Java 或者其它类似强类型面向对象语言中，类成员可能是这样的：</p>

<p><strong>实例字段</strong> 它们是基于实例的属性或变量，用以保存独立对象的状态</p>

<p><strong>实例方法</strong> 它们是类的所有实例共享方法，由每个独立的实例调用</p>

<p><strong>类字段</strong> 这些属性或变量是属于类的，而不属于类的某个实例</p>

<p><strong>类方法</strong> 这些方法是属于类的，而不属于类的某个实例</p>

<p>JavaScript 和 Java 的一个不同之处在于，JavaScript 中的函数都是以值的形式出现的，方法和字段之间并没有太大的区别。如果属性是函数，那么这个属性就定义一个方法，否则，它只是一个普通的属性或「字段」</p>

<h2>类和类型</h2>

<h3>instanceof 运算符</h3>

<p>之前我们已经了解过 instanceof 运算符。左操作数是待检测其类的对象，右操作数是定义类的构造函数。如果 o 继承自 c.prototype，则表达式 o instanceof c 值返回 true。这里的继承可以不是直接继承，如果 o 所继承的对象继承自另一个对象，后一个对象继承自 c.prototype，这个表达式的运算结果也是 true</p>

<p>构造函数是类的公共标识，但原型是唯一的标识。尽管 instanceof 运算符的右操作数是构造函数，但计算过程实际上是检测了对象的继承关系，而不是检测创建对象的构造函数</p>

<h3>constructor 属性</h3>

<p>另一种识别对象是否属于某个类的方法是使用 constructor 属性，因为构造函数是类的公共标识，所以最直接的方法就是使用 constructor 属性，比如：</p>

<pre><code class="javascript">function typeAndValue(x) {
    if (x == null) return "";
    switch(x.constructor) {
        case: Number:
            return "Number: " + x;
        case: String:
            return "String: " + x;
        case: Date:
            return "Date: " + x;
        case: RegExp:
            return "RegExp: " + x;
        case: Complex:
            return "Complex: " + x;
    }
}
</code></pre>

<p>使用 constructor 属性检测对象属于某个类的技术不足之处和 instanceof 一样。在 <strong>多个执行上下文</strong> 场景中它是无法正常工作的（比如在浏览器窗口的多个框架子页面中）。在这种情况下每个框架页面各自拥有独立的构造函数集合。比如一个框架页面中的 Array 构造函数和另一个构架页面的 Array 构造函数不是同一个</p>

<h3>鸭子类型</h3>

<p>上面描述的检测对象的类的各种技术多少都会有些问题，至少在客户端 JavaScript 中是如此。解决办法就是规避掉这些问题：<strong>不要关注「对象是什么」，而是关注「对象能做什么」</strong>。这种思考问题的方式在 Python 和 Ruby 中右学普遍，称为「鸭子类型」</p>

<blockquote><p>像鸭子一样走路、游泳并且嘎嘎叫的鸟就是鸭子</p></blockquote>

<p>这又让我想起了《蝙蝠侠》里面的那句话：</p>

<blockquote><p>It’s not who you are underneath, it’s what you do that defines you</p></blockquote>

<h2>JavaScript 中的面向对象技术</h2>

<h3>一个例子：集合类</h3>

<p>集合（set）是一种数据结构，用来表示非重复值的无序集合。集合有添加值、检测值是否存在等方法，下面的例子实现了一个更加通用的 Set 类</p>

<pre><code class="javascript">function Set() {
    this.values = {};
    this.n = 0;
    this.add.apply(this, arguments)
}
Set.prototype.add = function () {
    for (var i = 0; i &lt; arguments.length; i++) {
        var val = arguments[i];
        var str = Set._v2s(val);
        if (!this.values.hasOwnProperty(str)) {
            this.values[str] = val;
            this.n++;
        }
    }

    return this;
}
Set.prototype.remove = function () {
    for (var i = 0; i &lt; arguments.length; i++) {
        var str = Set._v2s(arguments[i]);
        if (this.values.hasOwnProperty(str)) {
            delete this.values[str];
            this.n--;
        }
    }
}
Set.prototype.contains = function (value) {
    return this.values.hasOwnProperty(Set._v2s(value))
}
Set.prototype.size = function () {
    return this.n;
}
Set.prototype.foreach = function(f, context) {
    for (var s in this.values) {
        if (this.values.hasOwnProperty(s)) {
            f.call(context, this.values[s]);
        }
    }
}
Set._v2s = function (val) {
    switch (val) {
        case undefined:     return 'u';
        case null:          return 'n';
        case true:          return 't';
        case false:         return 'f';
        default:
            switch (typeof val) {
                case 'number': return '#' + val;
                case 'string': return '"' + val;
                default: return '@' + objectId(val)
            }
    }
    function objectId(o) {
        var prop = "|**objectid**|";
        if (!o.hasOwnProperty(prop)) {
            o[prop] = Set._v2s.nex++;
        }
        return o[prop];
    }
}
Set._v2s.next = 100;

var s = new Set(1,2,3);
s.values;       // =&gt; Object {#1: 1, #2: 2, #3: 3}
var s1 = new Set(1,2,3,3,2,1, null, undefined)
s1.values;      // =&gt; Object {#1: 1, #2: 2, #3: 3, n: null, u: undefined}
s1.remove(null, undefined);
s1.values;      // =&gt; Object {#1: 1, #2: 2, #3: 3}
</code></pre>

<h3>构造函数的重载和工厂方法</h3>

<p>有时候，我们希望对象的初始化有多种方式，比如 Set 对象，我们想专入一个数组或者类数组，而不是多个参数来初始化它，我们可以加一些判断来实现重载（overload）</p>

<pre><code class="javascript">// 重载
function Set() {
    this.values = {};
    this.n = 0;

    if (arguments.length == 1 &amp;&amp; isArrayLike(arguments[0])) {
        this.add.apply(this, arguments[0])
    } else {
        this.add.apply(this, arguments)
    }
}

// 工厂方法: 可以从数组创建一个集合对象
Set.fromArray = function(a) {
    var s = new Set();
    s.add.apply(s, a)
    return s;
}
// Set 类的一个辅助构造函数
function SetFromArray(a) {
    Set.apply(this, a);
}
SetFromArray.prototype = Set.prototype;
var s = new SetFromArray([1,2,3]);
s instanceof Set        // =&gt; true
</code></pre>

<h2>子类</h2>

<p>在面向对象编程中，类 B 可以继承自另外一个类 A。我们将 A 称为父类（superclass），将 B 称为子类（subclass）。B 的实例从 A继承了所有的实例方法。类 B 可以定义自己的实例类方法，有些方法可以重载类 A 中的同名方法，如果 B 的方法重载了 A 中的方法，B 中的重载方法可能会调用 A 中的重载类 A 方法，这种做法称为「方法链」（method chaining）。同样子类的构造函数 B() 有时需要调用父类的构造函数 A()，这种做法称为「构造函数链」（constructor chaining）。子类还可以有子类，当涉及类的层次结构时，往往需要定义抽象类（abstract class）。抽象类中定义的方法没有实现。抽象类中的抽象方法是在抽象类的具体子类中实现的</p>

<h3>定义子类</h3>

<p>JavaScript 的对象可以从类的原型对象中继承属性。如果 O 是类 B 的实例，B 是 A 的子类，那么 O 也一定从 A 中继承了属性。为此，首先要确保 B 的原型对象继承自 A 的原型对象，通过 inherit() 函数可以实现</p>

<pre><code class="javascript">B.prototype = inherit(A.prototype);
B.prototype.constructor = B;
</code></pre>

<h3>构造函数和方法链</h3>

<p>我们定义一个 Set 的子类 NonNullSet，它不允许 null 和 undefined 作为集合成员，这就需要在子类的 add() 方法中对 null 和 undefined 值做检测。它需要完全重新实现一个 add() 方法</p>

<pre><code class="javascript">function NonNullSet() {
    Set.apply(this, arguments);
}
NonNullSet.prototype = inherit(Set.prototype);
NonNullSet.prototype.constructor = NonNullSet;
NonNullSet.prototype.add = function() {
    for (var i = 0; i &lt; arguments.length; i++) {
        if (arguments[i] == null) {
            throw new Error("Cant't add null or undefined to a NonNullSet");
        }
    }
    return Set.prototype.add.apply(this, arguments);
};
</code></pre>

<h3>组合 vs 子类</h3>

<p>上节中定义的集合可以根据特定的标准对集合成员做限制，而且使用了子类的技术来实现这种功能</p>

<p>然后还有一种更好的方法来完成这种需求，既面向对象编程中一条广为人知的设计原则：「组合优于继承」。这样，可以利用组合的原理定义一个新的集合实现，它「包装」了另外一个集合对象，在将受限制的成员过滤掉之后会用到这个集合对象</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 8 - 函数]]></title>
    <link href="http://keelii.github.io/2016/06/29/javascript-definitive-guide-note-7/"/>
    <updated>2016-06-29T20:22:22+08:00</updated>
    <id>http://keelii.github.io/2016/06/29/javascript-definitive-guide-note-7</id>
    <content type="html"><![CDATA[<p>函数是一段 JavaScript 代码，定义一次，可以被执行多次。JavaScript 函数是参数化的：函数定义会包括一个形参（parameter）的标识符列表，这些参数在函数体中像 <strong>局部变量</strong> 一样工作，函数被调用的时候会为形参提供实参（argument）的值。使用实参的值计算返回值，成为该函数的 <strong><a href="/2016/06/20/javascript-definitive-guide-note-3/#TOC-4">调用表达式</a></strong>值，调用上下文（invocation context）可以用 this 引用，嵌套函数可以构成闭包（closure）</p>

<!-- more -->


<h2>函数定义</h2>

<p>使用 function 关键字来定义一个函数，可以用在函数定义表达式或者函数声明语句里</p>

<pre><code class="javascript">// 打印对象名称和值
function printprops(o) {
    for(var p in o)
        console.log(p + ": " + o[p] + "\n");
}
// 递归调用计算阶乘
function factorial(x) {
    if (x &lt;= 1) return 1;
    return x * factorial(x - 1);
}
// 函数定义表大式，函数名称可以省略
var square = function(x) { return x * x; }
</code></pre>

<p>return 语句导致函数停止执行，并返回它的表达式给调用都。如果 return 语句没有一个与之相关的表达式，则它返回 undefined 值，没有 return 语句也会默认返回 undefined 值给调用者</p>

<p><strong>嵌套函数</strong></p>

<pre><code class="javascript">function hypotenuse(a, b) {
    function square(x) { return x*x; }
    return Math.sqrt(square(a) + square(b));
}
</code></pre>

<p>嵌套函数的作用域规则：它们可以访问嵌套它们的函数的参数和变量。上面的代码里，内部函数 square() 可以读写外部函数 hypotenuse() 定义的参数 a 和 b</p>

<h2>函数调用</h2>

<p>有 4 种方式来调用 JavaScript 函数：</p>

<ul>
<li>作为函数</li>
<li>作为（对象）方法</li>
<li>作为构造函数</li>
<li>通过它们的 call() 和 apply() 方法间接调用</li>
</ul>


<h3>函数调用</h3>

<blockquote><p>function_name(param1, param2);</p></blockquote>

<h3>方法调用</h3>

<blockquote><p>object.method(param1, param2);</p></blockquote>

<pre><code class="javascript">// 对象直接量
var calculator = {
    operand1: 1,
    operand2: 1,
    add: function() {
        this.result = this.operand1 + this.operand2;
    },
    add1: function(a) {
        this.operand1 + a;
        return this;
    },
    add2: function(b) {
        this.operand2 + a;
        return this;
    }
};
calculator.add();
calculator.result       // =&gt; 2
// 使用对象属性访问表达式调用方法
calculator['result']    // =&gt; 2
// 链式调用
calculator.add1(1).add2(2)
calculator.operand1         // =&gt; 2
calculator.operand2         // =&gt; 3
</code></pre>

<h3>构造函数调用</h3>

<blockquote><p>new Object(param1, param2);</p></blockquote>

<p>如果没有参数可以省略括号 <code>new Object</code></p>

<h3>间接调用</h3>

<blockquote><p>function_name.call()</p></blockquote>

<p>JavaScript 中的 <strong>函数也是对象</strong>，和其它 JavaScript 对象没什么区别，函数对象也可以包含方法。其中两个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply()</a> 可以用来间接地调用函数。两个方法都允许显式地指定调用所需的 this 值</p>

<h2>函数的实参和形参</h2>

<p>JavaScript 的函数定义不用指定形参的类型，调用传入的实参也可以是任意类型，JavaScript <strong>甚至</strong> 不检查传入实参的个数</p>

<h3>可选形参</h3>

<p>如果调用函数的时候传入的实参比指定的形参少，剩下的形参都将设置为 undefined 值，通常使用逻辑与运算符给形参指定默认值</p>

<pre><code class="javascript">function getName(name) {
    // 如果 name 传入值则使用传入值，否则使用默认值 "no name"
    // 通常建议可选参数放在参数列表最后
    name = name || "no name";

    // code

    return name;
}
</code></pre>

<h3>可变长的实参列表：实参对象</h3>

<p>当调用函数的时候传入实参人个数超过形参个数时（和上面相反），没有办法直接获得未命名值的引用。参数对象解决了这个问题，在函数体内，标识符 arguments 是指向实参对象的引用，参数对象是一个 <a href="/2016/06/23/javascript-definitive-guide-note-6/#TOC-23">类数组对象</a>，这样可以通过索引来访问实参了</p>

<pre><code class="javascript">function fn(x, y, z) {
    console.log(arguments);
}
fn(1,2,3)           // =&gt; [1,2,3]
fn(1,2,3,4,5)       // =&gt; [1,2,3,4,5]
</code></pre>

<p>实参对象的重要用处就是让函数可以操作任意数量的实参，比如我们自己实现一个数组的 push 方法</p>

<pre><code class="javascript">function push(arr /* optional items [, item ... [, item]] */) {
    var items = Array.prototype.slice.call(arguments, 1)
    for (var i = 0; i &lt; items.length; i++) {
        arr[arr.length] = items[i];
    }
}
var arr1 = [1,2,3];
push(arr1, 4,5,6);
arr1                // =&gt; [1, 2, 3, 4, 5, 6]
</code></pre>

<p>在非严格模式下，修改 arguments 元素的值，实参的值也会变。不过在 ECMAScript 5 中这个特性被移除了。在非严格模式中，函数里的 arguments 仅仅是个标识符。在严格模式中，它变成了一个保留字，严格模式中函数无法使用 arguments 作为 <strong>形参名</strong> 或者 <strong>局部变量名</strong>，也不能给它（arguments）赋值</p>

<pre><code class="javascript">
function f(x) {
    console.log(x);         // =&gt; 实参的初始值
    arguments[0] = null;
    console.log(x);         // =&gt; 非严格返回 null， 非严格返回 1
}
f(1)
</code></pre>

<h4>callee 和 caller 属性</h4>

<p>除了数组元素，实参对象还定义了 callee 和 caller 属性。严格模式中对这两个属性读写操作会产生一个类型错误，非严格模式下，ECMAScript 标准规范规定 callee 属性指代当前正在执行的函数。caller 是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数。通过 caller 属性可以访问调用栈，callee 属性在某些时候非常有用，比如在匿名函数中通过 callee 来递归调用自身</p>

<pre><code class="javascript">var factorial = function(x) {
    if (x &lt;= 1) return 1;
    return x * arguments.callee(x-1);
}
</code></pre>

<h3>将对象属性用做实参</h3>

<p>当一个函数包含超过三个形参时，很难记住参数顺序。这时我们可以用名/值对的形式来传入参数，这样参数的顺序就无关紧要了（然后名/值对里面的键名还是得记住）</p>

<pre><code class="javascript">function arraycopy(from, from_start, to, to_start, length) {
}
function easycopycopy(args) {
    arraycopy(args.from,
              args.from_start || 0,
              args.to,
              args.to_start || 0,
              args.length);
}
var a = [1,2,3,4], b = [];
easycopy({ from: a, to: b, length:4 })
</code></pre>

<h3>实参类型</h3>

<p>JavaScript 函数中形参并未声明类型，在形参数传入之前也未做任何类型检查，JavaScript 会在必要的时候进行类型转换，因此如果函数期望接收一个出神入化串实参，而调用函数时传入其它类型的值，所传入的值会在函数体内将其转换为字符串</p>

<h2>作为值的函数</h2>

<p>函数的定义和调用是 JavaScript 的词法特性，其它语言也一样。然而在 JavaScript 中，函数不仅仅是一种语法，也可以是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组元素中，作为参数传入另外一个函数等</p>

<pre><code class="javascript">function square(x) { return x*x; }
var s = square;
square(4) == s(4)       // =&gt; true

var a = [ function square(x) { return x*x; }, 20 ];
a[0](a[1]);             // =&gt; 400

// 将函数用做值
function add(x, y) { return x + y; }
function subtract(x, y) { return x - y; }
function multiply(x, y) { return x * y; }
function divide(x, y) { return x / y; }

function operate(operator, operand1, operand2) {
    return operator(operand1, operand2)
}
// =&gt; 25 (2 + 3) + (4 * 5)
var i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5))
</code></pre>

<h4>自定义函数属性</h4>

<p>JavaScript 中函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有 <strong>属性</strong>。当函数需要一个 <strong>静态变量</strong> 来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量</p>

<pre><code class="javascript">// 注意静态变量不必在函数后面声明
uniqueInteger.counter = 0;

function uniqueInteger() {
    // 注意 ++counter 和 count++ 不一样
    return ++uniqueInteger.counter;
}
</code></pre>

<p>下面这个函数 factirial() 使用了自身的属性（将自身当做数组来对待）来缓存上一次的计算结果：</p>

<pre><code class="javascript">// 计算阶乘
function factorial(n) {
    if (isFinite(n) &amp;&amp; n &gt; 0 &amp;&amp; n == Math.round(n)) {
        if (!(n in factorial)) {
            factorial[n] = n * factorial(n-1)
        }
        return factorial[n]
    } else {
        return NaN;
    }
}
// 初始化缓存以保存这种基本情况
factorial[1] = 1;
</code></pre>

<h2>作为命名空间的函数</h2>

<pre><code class="javascript">(function(/*paramater*/) {
    // 模块代码
    // 这个模块使用的所有变量（通过 var 声明）都是局部变量
    // 不会污染全局命名空间
})(/*arguments*/);

(function(win, doc) {
    var obj = {
        privateMethod: function() {},
        publicMethod: function() {}
    };

    win.yourPublicAPIMethodName = obj.publicMethod
})(window, document);
</code></pre>

<p>使用 <strong><a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">立即执行函数表达式（IIFE）</a></strong> 可以隔离代码块的命名空间，在匿名函数中声明的变量只在内部有效，不会对全局产生影响，同时可以有选择地向全局输出变量用来给外部代码访问</p>

<h2>闭包</h2>

<blockquote><p>词法作用域（lexical scoping）的执行依赖于变量作用域，这个作用域是在函数 <strong>定义时</strong> 决定的，而不是函数调用时，为了实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为「闭包」</p></blockquote>

<p>从技术角度讲，所有的 JavaScript 函数都是闭包：它们都是对象，它们都关联到作用域链。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事情就变得非常我刚好和。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象 <strong>作为返回值返回</strong> 的时候，这种事情就发生了</p>

<p>先看一下嵌套函数的词法作用域规则：</p>

<pre><code class="javascript">// 例 1
var scope = "global scope";
function checkscope() {
    var scope = "local scope";
    function f() { return scope;}
    return f();
}
checkscope();       // =&gt; "local scope"
// 例 2
var scope = "global scope";
function checkscope() {
    var scope = "local scope";
    function f() { return scope;}
    return f;
}
checkscope()()      // =&gt; "local scope"
</code></pre>

<p>在例 2 中我们将 checkscope 返回值 f 调用的括号移动到了 checkscope 调用后面。复习一下作用域的基本规则：JavaScript 函数的执行用到了作用域链，这个作用域链是函数 <strong>定义的时候</strong> 创建的，嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管在何时执行函数当 f()，这种绑定在执行 f() 时依然有效。因此最后一行代码返回「local scope」而不是「global scope」。简而言之，闭包的这个特性强大到让人吃惊：它们可以捕捉到局部变量（和参数），<strong>并一直保存下来</strong></p>

<p>很多程序员觉得闭包非常难理解，他们觉得在外部函数中定义的局部变量在函数返回后就不存在了，那么嵌套的函数如何能调用不存在的作用域链呢？如果你想搞清楚这个问题，还得更深入地了解类似 C 语言这种更底层的编程语言，并了解基于栈的 CPU 架构 <strong>如果一个函数的尾部变量定义在 CPU 的栈中，那么当函数返回时它们的确就不存在了</strong></p>

<p><a href="#TOC-13">上节</a>中的 uniqueInteger() 函数，这个函数有一个问题，函数本身是全局可访问的，这个 counter 很可能被外部修改。如果使用闭包就没有这个问题</p>

<pre><code class="javascript">var uniqueInteger = (function() {
    var counter = 0;
    return function() {
        return ++counter;
    }
})();
</code></pre>

<p>上面的代码将匿名立即执行函数赋值给 uniqueInteger 变量，所以函数的返回值赋值给变量 uniqueInteger，内部变量 counter 只在函数体内部可以访问，外部无法操作</p>

<p>私有变量也可以被多个闭包访问到，比如：</p>

<pre><code class="javascript">function counter() {
    var n = 0;
    return {
        count: function() { return n++ },
        reset: function() { n = 0 }
    }
}
// 创建两个计数器
var c = counter(), d = counter();
c.count()       // =&gt; 0 互
c.count()       // =&gt; 1 不
d.count()       // =&gt; 0 干
d.count()       // =&gt; 1 扰
c.reset()       // =&gt; 0 重置 c
d.count()       // =&gt; 2 不影响 d
</code></pre>

<p>在同一个作用域链中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是一种非常重要的技术，但是要特别小心那些不希望共享的变量往往不经意间共享给了其它的闭包，了解这一点也很重要</p>

<pre><code class="javascript">function constfunc(v) { return function() { return v; } }

var funcs = [];
for(var i = 0; i &lt; 10; i++) {
    funcs[i] = constfunc(i);
}
</code></pre>

<p>如果这样写就完全不一样了</p>

<pre><code class="javascript">function constfuncs() {
    var funcs = [];
    for (var i = 0; i &lt; 10; i++) {
        funcs[i] = function() {
            return i;
        };
    }
    return funcs;
}
var funcs = constfuncs();
funcs[5]()                  // =&gt; 10 !!!
</code></pre>

<p>上面这段代码循环创建了 10 个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量 i。当 constfuncs() 返回时，变量的 i 值是 10，所有的闭包都共享这一个值，因此，数组中的函数的返回值是同一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域链都是「活动的（live）」，记住这一点非常重要。嵌套的当函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照（static snapshot）</p>

<p>书写闭包的时候还需注意一件事情，this 是 JavaScript 的关键字，不是变量。正如之前讨论的，每个函数调用都包含一个 this 值，如果闭包在外部函数里是无法访问 this 的，除非外部函数将 this 默契为一个变量</p>

<pre><code class="javascript">function outerFn() {
    var self = this;

    function innerFn() {
        // self.xxxx
    }
}
</code></pre>

<h2>函数属性、方法和构造函数</h2>

<p>在 JavaScript 中，函数是值，对函数执行 typeof 运算会返回字符串 &ldquo;function"，但是函数是 JavaScript 中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，像普通对象一样。甚至可以用 Function() 构造函数来创建新的函数对象</p>

<h3>prototype 属性</h3>

<p>每一个当函数都包含一个 prototype 属性，这个属性是指向一个对象的引用，这个对象称做「原型对象」（prototype object）。每一个函数都包含不同的原型对象。当将函数胜仗构造函数的时候，新创建的对象会从原型对象上继承属性</p>

<h3>call() 和 apply() 方法</h3>

<blockquote><p>fun.call(thisArg[, arg1[, arg2[, &hellip;]]])</p>

<p>fun.apply(thisArg[, argsArray])</p></blockquote>

<p>我们可以将 call 和 apply 看做是某个对象的方法，通过调用方法的形式来间接调用函数</p>

<pre><code class="javascript">// 将对象 o 中名为 m 的方法替换为另外一个方法
function trace(o, m) {
    var original = o[m];
    o[m] = function() {
        console.log(new Date, "Entering: ", m);
        var result = original.apply(this, arguments)
        console.log(new Date, "Exiting: ", m);
    }
}
</code></pre>

<p>trace() 函数接收两个参数，一个对象和一个方法名，它将指定的方法替换为一个新方法，这个新方法就是「包裹」原始方法的另一个泛函数。这种动态修改已有方法的做法有时称做「猴子补丁 monkey-patching」</p>

<h3>bind() 方法</h3>

<blockquote><p>fun.bind(thisArg[, arg1[, arg2[, &hellip;]]])</p></blockquote>

<p>bind 方法是 ECMAScript 5 中新增的方法，但在 ECMAScript 3 中可以模拟出来。主要用于将函数绑定到某个对象。当在函数 f 上调用 bind 方法并传入一个对象 o 做参数，这个方法将返回一个新的函数。调用新的函数将会把原始的函数 f <strong>当做 o 的方法来调用</strong>。传入新函数的任何实参都将传入原始函数</p>

<pre><code class="javascript">function f(y) { return this.x + y; }
var o = { x: 1};
var g = f.bind(o);
g(2)                // =&gt; 3
</code></pre>

<p>可以通过下面代码实现 bind 方法</p>

<pre><code class="javascript">function bind(f, o) {
    if (f.bind) {
        return f.bind(o);
    } else {
        return f.apply(ok arguments)
    }
}
</code></pre>

<p>bind 方法还有一些其他应用：除了第一个实参之外，传入 bind 的实参也会绑定至 this，这个附带的应用是一种常见的函数式编程技术，有时也被称为「<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a>」（currying）</p>

<pre><code class="javascript">var sum = function(x, y) { return x + y }

var succ = sum.bind(null, 1)
succ(2)     // =&gt; 3

function f(y, z) { return this.x + y + z }
var g = f.bind({x:1}, 2)
g(3)        // =&gt; 6
</code></pre>

<p>注意 bind 方法有些特性是模拟不出来的</p>

<h3>toString() 方法</h3>

<p>和所有的 JavaScript 对象一样，函数也有 toString 方法，ECMAScript 规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数的 toString 方法的实现都返回函数的完成源码。内置函数往往返回一个类似 &ldquo;[native code]&rdquo; 的字符串作为函数体</p>

<h3>Function() 构造函数</h3>

<blockquote><p>new Function ([arg1[, arg2[, &hellip;argN]],] functionBody)</p></blockquote>

<p>关于 Function() 构造函数有几点需要特别注意：</p>

<ul>
<li>Function() 构造函数允许 JavaScript 在运行时动态地创建并编译函数</li>
<li>每次调用 Function() 构造函数都会解析函数体，执行效率会受影响。</li>
<li>Function() 构造函数创建的函数 <strong>并不是使用词法作用域</strong>，相反，函数体代码的编译总是会在顶层函数执行，效果类似在全局作用域中执行 eval()</li>
</ul>


<pre><code class="javascript">var scope = "global";
function constructFunction() {
    var scope = "local";
    return new Function("return scope");
}
constructFunction()();  // =&gt; "global"
</code></pre>

<h3>可调用的对象</h3>

<p>「类数组对象」类似数组但并不是真正的数组，「可调用对象（callable object）」类似于函数但并不是真正的函数。可调用对象在两个 JavaScript 实现中不能算作函数。首先，IE Web 浏览器（IE 6 及之前的版本）实现了客户端方法（如 Window.alert() 和 Document.getElementById()），使用了可调用的宿主对象，而不是内置函数对象，IE 中的这些方法在其它浏览器中都存在，但它们本质上不是 Function 对象。IE 9 将它们实现为真正的函数，因此这类可调用的对象将越来越罕见</p>

<p>另外一个常见的可调用对象是 RegExp 对象，对 RegExp 执行 typeof 运算的结果并不统一，有些返回 &ldquo;function&rdquo; 有些返回 &ldquo;object"。可以使用下面的方法判断是不是真正的函数对象</p>

<pre><code class="javascript">function isFunction(o) {
    return Object.prototype.toString.call(x) === "[object Function]"
}
</code></pre>

<h2>函数式编程</h2>

<p>JavaScript 并不是一种像 List 或 Haskell 的函数式编程语言，但在 JavaScript 中可以像操控对象一样操控函数，也就是说可以在 JavaScript 中应用函数式编程技术</p>

<h3>使用函数处理数组</h3>

<p>假设有一个数组，元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话代码一般会是这样：</p>

<pre><code class="javascript">var data = [1,1,3,5,5]
var total = 0;
for (var i = 0; i &lt; data.length; i++) {
    total += data[i];
}
var mean = total / data.length;                 // =&gt; 3

total = 0;
for (var i = 0; i &lt; data.length; i++) {
    var deviation = data[i] - mean;
    total += deviation * deviation;
}
var stddev = Math.sqrt(total/(data.length-1))   // =&gt; 2
</code></pre>

<p>可以使用数组方法 map() 和 reduce() 来实现同样的计算，这种实现极其乘法：</p>

<pre><code class="javascript">var sum = function(x, y) { return x + y; }
var square = function(x) { return x*x; }

var data = [1,1,3,5,5]
var mean = data.reduce(sum)/data.length;
var deviations = data.map(function(x) { return x-mean; })
var stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length-1))
</code></pre>

<p>当然 ECMAScript 3 并没有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a>， <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">reduce</a> 这两个方法，不过我们也可以自己实现一个 Polyfill，可以参考链接里面的内容</p>

<h3>高阶函数</h3>

<p>所谓高阶函数（higher-order function）就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数</p>

<pre><code class="javascript">function not(f) {
    return function() {
        var result = f.apply(this, arguments);
        return !result;
    }
}
var even = function(x) {
    return x % 2 == 0;
}
var odd = not(even);
[1,1,3,5,5].every(odd)          // =&gt; true
</code></pre>

<p>mapper() 函数也是一个高阶函数，它接收一个函数作为参数，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上，这个函数使用了之前定义的 map() 函数</p>

<pre><code class="javascript">function mapper(f) {
    return function(a) { return map(a, f); }
}
var increment = function(x) { return x + 1; }
var incrementer = mapper(increment);
incrementer([1,2,3])  // =&gt; [2,3,4]
</code></pre>

<p>还有一个更常见的例子，它接收两个函数 f() 和 g()，并返回一个新的函数用以计算 f(g())</p>

<pre><code class="javascript">function compose(f, g) {
    return function() {
        return f.call(this, g.apply(this, arguments))
    }
}
var square = function(x) { return x * x; }
var sum = function(x, y) { return x + y; }
var squareofsum = compose(square, sum)
squareofsum(2, 3)           // =&gt; 25
/* - 伪代码执行过程大致如下 -
    arguments: 2, 3
    return square.call(this, sum.apply(this, arguments))
    return square.call(this, sum(2, 3))
    return square.call(this, 5)
    arguments: 5
    return square(5)
    return 25
*/
</code></pre>

<h3>不完全函数</h3>

<p>函数 <a href="/2016/06/29/javascript-definitive-guide-note-7/#TOC-19">f()</a> 的 bind() 方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用函数 f()。我们说它把函数「绑定至」对象并传入一部分参数。bind() 方法只是将实参放在左侧，也就是说传入 bind() 的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入 bind() 的实参放在右侧</p>

<pre><code class="javascript">// 将类数组对象转换为真正的数组
function array(arr, n) { return Array.prototype.slice.call(arr, n || 0); }

// 这个函数的实参传递到左侧
function partialLeft(f) {
    var args = arguments;

    return function() {
        var a = array(args, 1);
        a = a.concat(array(arguments))
        return f.apply(this, a)
    }
}
function partialRight(f) {
    var args = arguments;

    return function() {
        var a = array(arguments)
        a = a.concat(array(args, 1))
        return f.apply(this, a)
    }
}

function partial(f) {
    var args = arguments;

    return function() {
        var a = array(args, 1)
        var i = 0, j = 0;
        for (; i &lt; a.length; i++) {
            if ( a[i] === undefined ) a[i] = arguments[j++];
        }
        a = a.concat(array(arguments, j))
        return f.apply(this, a);
    }
}

var f = function(x, y, z) { return x * (y - z) }
partialLeft(f, 2)(3, 4)             // =&gt; -2 2 * (3-4)
partialRight(f, 2)(3, 4)            // =&gt; 6 3 * (4-2)
partial(f, undefined, 2)(3, 4)      // =&gt; -6 3 * (2-4)
</code></pre>

<h3>记忆</h3>

<p>上面的 <a href="/2016/06/29/javascript-definitive-guide-note-7/#TOC-13">章节</a> 中定义了一个阶乘函数，它可以将上次的计算结果缓存起来。在函数式程序当中，这种缓存技巧叫做「记忆」（memorization）。下面的代码展示了一个高阶函数，memorize() 接收一个函数作为实参，并返回带有记忆能力的函数</p>

<pre><code class="javascript">function memorize(f) {
    var cache = {};

    return function() {
        // 将实参转换为字符串形式，并胜仗缓存的键名
        var key = arguments.length + Array.prototype.join.call(arguments, ",")
        if ( key in cache ) {
            return cache[key];
        } else {
            return cache[key] = f.apply(this, arguments)
        }
    }
}
function factorial (num) {
    console.log('Actually invoked.');
    if (num &lt; 0) {
        return -1;
    } else if (num === 0 || num === 1) {
        return 1;
    } else {
        return (num * factorial(num - 1));
    }
}

var cached_factorial = memorize(factorial);

cached_factorial(3)
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 6
cached_factorial(3)
// =&gt; 6

/**
 * 注意下面的调用方式将不会缓存
 * 因为新建了多个闭包，闭包在每
 * 调用一次 memorize 就返回一
 * 份新的 cache 变量
 */
memorize(factorial)(3)
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 6
memorize(factorial)(3)
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 'Actually invoked.'
// =&gt; 6
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 7 - 数组]]></title>
    <link href="http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-6/"/>
    <updated>2016-06-23T19:10:28+08:00</updated>
    <id>http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-6</id>
    <content type="html"><![CDATA[<p>数组是值的 <strong>有序集合</strong>。每个值（任意 JavaScript 数据类型）叫做一个元素，元素在数组中的位置叫索引。JavaScript 数组是无/弱类型的（untyped），数组元素可以是任意类型</p>

<p>JavaScript 数组是 <strong>动态的</strong>，根据需要它们会增长或缩减，创建的时候不须要声明一个固定的大小</p>

<p>JavaScript 数组可能是 <strong>稀疏的</strong>，数组元素索引不一定要连续</p>

<p>JavaScript 数组是 JavaScript 对象的特殊形式。数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要 <strong>快很多</strong></p>

<!--more-->


<h2>创建数组</h2>

<pre><code class="javascript">var empty = [];             // 使用数组直接量创建一个空数组
var primes = [2, 3, 5, 7, 11];
var base = 1024；
var misc = [1.2, true, "a", base + 1, [1,2,3], { a: 1}]     // 元素可以是任意值，甚至表达式
var count = [1, ,3];            // 数组有三个元素中间那个值为 undefined

var a = new Array();        // 调用构造函数 Array() 也可以创建数组
var a = new Array(10);
a.length;                   // =&gt; 10 创建一个长度为 10 的数组
var a = new Array(1, 2, 3);
a;                          // =&gt; [1, 2, 3]
</code></pre>

<h2>数组元素的读和写</h2>

<p>使用方括号 [] 操作符来访问数组中的一个元素，方括号左边是数组的引用，右边是一个返回 <strong>非负整数值</strong> 的任意表达式</p>

<pre><code class="javascript">var a = ["world"];
a[0]                    // =&gt; "world"
a[1] = 3.14             // =&gt; 写入第 1 个元素 3.14
a                       // =&gt; ["world", 3.14]
i = 2;
a[i] = 3;               // =&gt; 写入第 2 个元素
a[i+1] = "hello";       // =&gt; 写入第 2 个元素
</code></pre>

<p>可以使用负数或者非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样如果如果凑巧使用了非负整数的字符串，它就当做数组索引，而非对象属性</p>

<pre><code class="javascript">a[-1.23] = true             // 给数组 a 创建一个名为 "-1.23" 的属性
a["1000"] = 0               // 这是数组的第 1001 个元素
a[1.000]                    // 和 a[1] 相等
</code></pre>

<p>事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组 <strong>没有越界</strong> 错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到 undefined 值，这一点类似于对象</p>

<h2>稀疏数组（Sparse Arrays）</h2>

<p>通常，数组的 length 属性代表数组中的元素个数。如果是稀疏数组，length 属性值大于元素个数。当在数组直接量中省略值是不会创建稀疏数组。省略的元素是存在的只是值为 undefined。使用 Array() 构造函数或者手动指定 length 大于当前的数组可以创建稀疏数组</p>

<pre><code class="javascript">a = new Array(5);       // 数组没元素，但 a.length 是 5
a = [];
a[1000] = 0;            // 赋值添加一个元素，但设置 length 为　1001
var a1 = [,,,];         // 数组是 [undefined, undefined, undefined]
var a2 = new Array(3);
var a3 = [1,,3];
0 in a1                 // =&gt; true 非稀疏数组
0 in a2                 // =&gt; false 稀疏数组
1 in a3                 // =&gt; false 稀疏数组
</code></pre>

<p>在一些旧版的实现中，[1,,3] 和 [1, undefined, 3] 却是一模一样的</p>

<h2>数组的长度</h2>

<p>每个数组都有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密数组，length 属性值代表数组中元素的个数，其值比数组中最大的索引大 1</p>

<p>数组有两个 <strong>特殊行为</strong>：</p>

<ol>
<li>如果为一个数组元素赋值，它的索引 i 大于或者等于现有数组的长度时，length 属性的值将设置为 i + 1</li>
<li>如果设置一个数组的 length 属性小于这个数组长度的非负整数 n 时，当前数组中那些索引值大于或等于 n 的元素将被从中删除</li>
</ol>


<pre><code class="javascript">a = [1,2,3,4,5];
a.length = 3;
a                   // =&gt; [1,2,3]
a.length = 0;
a.length = 5;       // 长度为 5，类似 new Array(5)
</code></pre>

<p>数组也继承了对象的一些方法，比如 Object.defineProperty(), 可以使用这个方法让数组的 length 属性变成只读</p>

<pre><code class="javascript">a = [1,2,3]
Object.defineProperty(a, "length", {
    writable: false
});
a.length = 0
a                   // =&gt; [1,2,3] 不会改变
</code></pre>

<h2>数组元素的添加和删除</h2>

<p>可以给新的索引赋值来添加元素，也可以调用 Array 对象的内置方法 push() 来在数组 <strong>末尾</strong> 增加一个或者多个元素，或者用 unshift() 给数组头部插入一个元素，并且将其它元素依次移动到更高的索引处</p>

<pre><code class="javascript">a = []
a[0] = "zero"
a[1] = "one"
a               // =&gt; ["zero", "one"]

a = []
a.push("zero")
a.push("one", "two")
a               // =&gt; ["zero", "one", "two"]
a.unshift(0)
a               // =&gt; [0, "zero", "one", "two"]
</code></pre>

<p>可以使用 delete 运算符来删除数组元素，效果和对数组元素赋值 undefined 类似，使用 delete 删除数组后数组的长度是不变的</p>

<h2>数组遍历</h2>

<p>使用 for 循环是遍历数组元素最常见的方法，for/in 也可以但并不推荐</p>

<pre><code class="javascript">var keys = Object.keys(o);
var values = [];
for (var i = 0; i &lt; keys.length; i++) {
    var key = keys[i];
    values[i] = o[key]
}

for (var i = 0; i &lt; keys.length; i++) {
    if (!a[i]) continue;    // 跳过 null, undefined 和不存在的元素
}
for (var i = 0; i &lt; keys.length; i++) {
    if (!(i in a)) continue;    // 只跳过不存在的元素
}
for (var i in a) {
    if (!a.hasOwnProperty(i)) continue; // 跳过继承属性
}
</code></pre>

<p>ECMAScript 5 定义了一些遍历数组元素的新方法，比如 forEach()</p>

<pre><code class="javascript">[1,2,3,4,5].forEach(function(x) {
    console.log(x);
});
</code></pre>

<h2>多维数组</h2>

<p>JavaScript 并不支持真正的多维数组，但可以模拟出来</p>

<pre><code class="javascript">var table = new Array(10);
for (var i = 0; i &lt; table.length; i++) {
    table[i] = new Array(10);
}

for (var row = 0; row &lt; table.length; row++) {
    for (var col = 0; col &lt; table[row].length; col++) {
        table[row][col] = row * col;
    }
}

table[5][7];        // =&gt; 35
</code></pre>

<h2>数组方法</h2>

<p>将所有元素都转化为字符串并通过分隔符链接起来，分隔符默认是逗号「,」</p>

<p>与之相反的 split 方法则是把字符串按分割符分割开来并返回数组，并且分割符可以是正则表达式</p>

<pre><code class="javascript">var a = [1,2,3];
a.join();               // =&gt; "1,2,3"
a.join(" ")             // =&gt; "1 2 3"
a.join("")              // =&gt; "123"
new Array(10).join('-') // =&gt; "----------"

var str = "Hello world";
str.split(' ')          // =&gt; ["Hello", "world"]
var str = "0a1b2c3d";
str.split(/\d/g);       // =&gt; ["", "a", "b", "c", "d"]
</code></pre>

<h3>reverse()</h3>

<p>反转数组元素</p>

<pre><code class="javascript">var a = [1,2,3];
a.reverse();        // =&gt; [3,2,1]
</code></pre>

<h3>sort()</h3>

<p>将数组中的元素排序并返回排序后的数组。不带参数调用 sort() 时，数组元素以字母表顺序排序，如果数组包含 undefined 元素，它们会被排到数组的尾部</p>

<pre><code class="javascript">var a = ["banana", "cherry", "apple"]
a.sort();               // =&gt; ["apple", "banana", "cherry"]
</code></pre>

<p>sort 方法可以接收一个函数参数，该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小于 0 的数值</p>

<pre><code class="javascript">var a = [3,4,1,2]
a.sort()            // [1,2,3,4]
a.sort(function(a, b) {
    return b - a
})                  // [4,3,2,1]
</code></pre>

<h3>concat()</h3>

<blockquote><p>Array.concat(value1, value2, &hellip;, valueN)</p></blockquote>

<p>创建并返回一个新数组，它的元素包括调用 concat 的原始数组元素和 concat 的每个参数</p>

<pre><code class="javascript">var a = [1,2,3]
a.concat(4,5)           // =&gt; [1,2,3,4,5]
a.concat([4,5])         // =&gt; [1,2,3,4,5]
a.concat([4,5], [6,7])  // =&gt; [1,2,3,4,5,6,7]
a.concat(4, [5, [6,7]]) // =&gt; [1,2,3,4,5,[6,7]]
</code></pre>

<h3>slice()</h3>

<blockquote><p>Array.slice([begin[, end]])</p></blockquote>

<p>返回指定数组的一个片段或子数组，它的两个参数分别指定了片段的开始和结束的 <strong>位置</strong>，如果只指定一个参数（开始位置），返回的数组将包含从开始位置到数组结尾的所有元素，如果参数中出现了负数，它表示相对于数组中最后一个元素的位置，slice 不会修改原数组</p>

<pre><code class="javascript">var a = [1,2,3,4,5]
a.slice(0, 3)       // =&gt; [1,2,3]
a.slice(3)          // =&gt; [4,5]
a.slice()           // =&gt; [1,2,3,4,5]
a.slice(1, -1)      // =&gt; [2,3,4]
a.slice(-3, -2)     // =&gt; [3]
</code></pre>

<h3>splice()</h3>

<blockquote><p>Array.splice(start, deleteCount[, item1[, item2[, &hellip;]]])</p></blockquote>

<p>splice 方法是在数组中插入或删除元素的通用方法，会 <strong>修改</strong> 调用的数组</p>

<p>splice 能够从数组中删除元素、插入元素到数组中或者 <strong>同时完成</strong> 这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其它部分仍然保持连续。splice 第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。splice 返回一个由删除元素组成的数组</p>

<pre><code class="javascript">var a = [1,2,3,4,5,6,7,8]
a.splice(4)             // =&gt; [5,6,7,8]
a                       // =&gt; [1,2,3,4]
a.splice(1,2)           // =&gt; [2,3]
a                       // =&gt; [1,4]
a.splice(1,1)           // =&gt; [4]
a                       // =&gt; [1]
</code></pre>

<p>splice 前两个参数指定了需要删除的数组元素。其后任意个数参数指定了需要插入到数组中的元素</p>

<pre><code class="javascript">var a = [1,2,3,4,5]
a.splice(2, 0, "a", "b")        // =&gt; 0
a                               // =&gt; [1,2,"a","b",3,4,5]
a.splice(2, 2, [1,2], 3)        // =&gt; ["a", "b"]
a                               // =&gt; [1,2,[1,2],3,3,4,5]
</code></pre>

<h3>push() 和 pop()</h3>

<p>push 和 pop 方法谲诈将数组当做 <a href="https://cloud.githubusercontent.com/assets/458894/16374650/f8b0fa6c-3c89-11e6-9e61-bc391f7f3cf4.png">栈</a> 来使用，push 方法在数组尾部添加一个或者多个元素，并返回新的数组长度。pop 删除数组的最后一个元素，减小数组长度并返回它删除的值</p>

<pre><code class="javascript">var stack = [];
stack.push(1,2)         // =&gt; 2 stack: [1,2]
stack.pop(1,2)          // =&gt; 1 stack: [2]
stack.push(3)           // =&gt; 2 stack: [1,3]
</code></pre>

<h3>unshift() 和 shift()</h3>

<p>unshift 在数组的头部添加一个或者多个元素，shift 删除数组的第一个元素并将其返回</p>

<p>需要注意的是，当使用多个参数调用 unshift() 的时候，参数是一次性插入的，而非一次一个插入。这会影响插入到数组中元素的位置</p>

<pre><code class="javascript">var a = [4,5,6];
a.unshift(3)
a               // =&gt; [3,4,5,6]
a.unshift(1,2)
a               // =&gt; [1,2,3,4,5,6]如果一次一个插入的话结果应该是 [2,1,3,4,5]
</code></pre>

<h2>ECMAScript 5 的数组方法</h2>

<h3>forEach()</h3>

<p>forEach() 从头至尾遍历数组，为每个元素调用指定的函数。传递函数作为 forEach() 的第一个参数，然后 forEach() 使用三个参数调用该当函数：数组元素、元素的索引和数组本身。forEach() 无法在所有元素都传递给调用的函数之前终止遍历，除非 forEach() 方法放在一个 try 块中，并抛出一个异常</p>

<pre><code class="javascript">[1,2,3,4,5].forEach(function(value, index, arr) { arr[i] = v + 1 });
// =&gt; [2,3,4,5,6]
</code></pre>

<h3>map()</h3>

<p>map() 方法将调用数组的每个元素传递给指定的函数，并返回一个数组。如果是稀疏数组，返回的也是相同方式的稀疏数组</p>

<pre><code class="javascript">a = [1,2,3]
b = a.map(function(x) { return x*x })
b               // [1, 4, 9]
</code></pre>

<h3>filter()</h3>

<p>filter() 方法返回数组元素是调用数组的一个 <strong>子集</strong>。传递的函数是用来逻辑判定的（true 或 false），如果返回 true 或者能转化为 true 的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中，<strong>filter() 会跳过稀疏数组中缺少的元素</strong>，总是返回稠密的</p>

<pre><code class="javascript">a = [5,4,3,2,1]
smallvalues = a.filter(function(x) { return x &lt; 3 })    // [2, 1]
</code></pre>

<h3>every() 和 some()</h3>

<p>数组的逻辑判定，它们对数组元素应用指定的函数进行判定，返回 true 或 false</p>

<pre><code class="javascript">a = [1,2,3,4,5]
a.every(function(x) { return x &lt; 10 })      // =&gt; true 数组元素都少于 10
a.some(function(x) { return x%2 === 0 })    // =&gt; true 数组中有一些值是偶数
</code></pre>

<p>注意，一旦 every() 和 some() 确认应该返回什么值时它们就会停止遍历数组元素（可以认为是惰性判断）。即：</p>

<ul>
<li>some() 在判定函数第一次返回 true 后就返回 true，不再进行遍历操作</li>
<li>every() 在判定函数第一次返回 false 后就返回false，不再进行遍历操作</li>
</ul>


<h3>reduce() 和 reduceRight()</h3>

<blockquote><p>Array.reduce(callback, [initialValue])</p></blockquote>

<p>reduct() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值，这在 <strong>函数式编程（functional programming）</strong> 中是很常见的操作，也可以称为「注入」和「折叠」，他们只是执行化简操作的顺序不一样，一个从左到右，一个从右到左</p>

<pre><code class="javascript">var a = [1,2,3,4,5]
var sum = a.reduce(function(x, y) { return x + y }, 0)          // 数组求和
/**
+---------------------------------+
|                                 |
|     x      +     y     return   |
|                                 |
|   init: 0     a[0]: 1    1      |
|                                 |
|     1         a[1]: 2    3      |
|                                 |
|     3         a[2]: 3    6      |
|                                 |
|     6         a[3]: 4    10     |
|                                 |
|     10        a[4]: 5    15     |
|                                 |
+---------------------------------+
*/
var product = a.reduce(function(x, y) { return x * y }, 1)      // 数组求积
</code></pre>

<p>reduce 需要两个参数。第一个是执行化简操作的函数，它的任意就是用某种方法把两个值组合或化简为一个值，并返回化简后的值，第二个参数是传递给函数的初始值，如果没有指定初始值，它将使用数组的第一个元素作为其初始值。<strong>这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为 x,y</strong></p>

<h3>indexOf() 和 lastIndexOf()</h3>

<blockquote><p>Array.indexOf(searchElement[, fromIndex = 0])</p></blockquote>

<p>搜索整个数组中指定值的索引，没找到就返回 -1。indexOf() 从头至尾搜索，而 lastIndexOf() 则反向搜索。它们都接收第二个参数，指定数组中的一个索引，从这个索引处开始搜索</p>

<pre><code class="javascript">a = [0,1,2,1,0]
a.indexOf(1)        // =&gt; 1
a.lastIndexOf(1)    // =&gt; 3
a.indexOf(3)        // =&gt; -1

// 在数组中查找所有出现的 x，并返回一个包含匹配索引的数组
function findall(a, x) {
    var results = [];
    var len = a.length;
    var pos = 0;

    while(pos &lt; len) {
        pos = a.indexOf(x, pos);
        if (pos === -1) break;

        results.push(pos)
        pos = pos + 1;
    }

    return results;
}
findall([1,2,3,1,3,2], 1)       // =&gt; [0, 3]
</code></pre>

<h2>数组类型</h2>

<p>ECMAScript 5 中可以使用 Array.isArray() 函数来判断是否为数组，在 ECMAScript 5 之前判断却没这么简单，因为 typeof 运算符操作数组返回的是「对象」，一般用下面的方法下判断是否是数组</p>

<pre><code class="javascript">var isArray = Array.isArray || function(o) {
    return typeof o === "object" &amp;&amp;
            Object.prototype.toString.call(0) === '[object Array]';
};
</code></pre>

<h2>类数组对象</h2>

<p>JavaScript 数组的一些特性是其他对象没有的：</p>

<ul>
<li>当有新的元素添加到列表中时，自动更新 length 属性</li>
<li>设置 length 为一个较小值将截断数组</li>
<li>从 Array.prototype 中继承一些有用的方法</li>
<li>其类属性为「Array」</li>
</ul>


<p>以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的「元素」</p>

<pre><code class="javascript">var a = {}

var i = 0;
while (i &lt; 10) {
    a[i] = i * i;
    i++;
}
a.length = i;
a               // =&gt; { 0: 0, 1: 1, 2: 4, 3: 9 ..., length: 10 }

// 现在就可以当成真正的数组遍历它
var total = 0;
for (var j = 0; j &lt; a.length; j++) {
    total+=a[j]
}
</code></pre>

<p>Arguments 对象就是一个类数组对象，DOM 方法 document.getElementsByTagName() 也返回类数组对象，它们都有数组的一些特性，比如索引访问、length 属性，但它们并不是真正的数组</p>

<pre><code class="javascript">function isArrayLike(o) {
    if ( o &amp;&amp;
        typeof o === "object" &amp;&amp;
        isFinite(o.length) &amp;&amp;
        o.length &gt;= 0 &amp;&amp;
        o.length === Math.floor(o.length) &amp;&amp;
        o.length &lt; 4294967296 ) {       // 数组长度的最大值 2^32
        return true;
    } else {
        return false;
    }
}
</code></pre>

<p>JavaScript 数组方法是 <strong>特意定义为通用的</strong>，它们不仅可以应用在数组而且可以应用在类数组对象上，一般使用 Array.prototype.method.call 来使用</p>

<pre><code class="javascript">var a = {"0": "a", "1": "b", "2": "c", length: 3};
Array.prototype.join.call(a, "+")           // =&gt; "a+b+c"
</code></pre>

<h2>作为数组的字符串</h2>

<p>在 ECMAScript 5 中，字符串的行为类似于 <strong>只读</strong> 的数组。除子用 charAt() 方法来访问单个字符以外，还可以使用方括号：</p>

<pre><code class="javascript">var s = "test";
s.charAt(0)         // =&gt; "t"
s.[1]               // =&gt; "e"
</code></pre>

<p>字符串的行为类似于数组的事实使得通用的数组方法可以应用到字符串上。不过请记住，字符串是 <strong>不可变值</strong>，当把它们作为数组看待时，它们是只读的。所以诸如：push(), sort(), reverse 等 <strong>会修改数组</strong> 的方法 如果被使用在字符串上是无效的，而且会导致错误并且没有相关提示</p>

<pre><code class="javascript">s = "JavaScript"
Array.prototype.join.call(s, " ")       // =&gt; "J a v a S c r i p t"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript 权威指南》读书笔记 6 - 对象]]></title>
    <link href="http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-5/"/>
    <updated>2016-06-23T19:10:28+08:00</updated>
    <id>http://keelii.github.io/2016/06/23/javascript-definitive-guide-note-5</id>
    <content type="html"><![CDATA[<p>对象是 JavaScript 的基本数据类型。是一种复合值：将很多值聚合在一起。对象可以看做是无序集合，每个属性都是一个名/值对。这种基本数据结构还有很多叫法，比如「散列」（hash）、「散列表」（hashtable）、「字典」（dictionary）、「关联数组」（associative array）。JavaScript 还可以从一个称为 <strong>原型</strong> 的对象继承属性</p>

<p>JavaScript 对象是动态的 —— 可以新增属性也可以删除属性，除了字符串、数字、布尔值、null 和 undefined 之外，JavaScript 中的值都是对象</p>

<p>对象是可变的，通过引用操作对象原对象也会受到影响</p>

<!--more-->


<p>属性包括名字和值。名字是可以包含空字符串在内的 <strong>任意字符串</strong>，值可以是任意 JavaScript 值，或者（在 ECMAScript 5中）可以是一个 getter 或者 setter （或都有），每个属性还有一些与之相关的值称为「属性特性」（property attribute）：</p>

<ul>
<li>可写（writable）</li>
<li>可枚举（enumerable）</li>
<li>可配置（configurable），表明是否可以删除或者修改</li>
</ul>


<p>ECMAScript 5 之前，<strong>通过代码给对象创建的所有属性都是可写、可枚举和可配置的</strong></p>

<p>除了包含属性之外，每个对象还拥有三个相关的对象特性（object attribute）：</p>

<ul>
<li>对象的原型（prototype）指向另外一个对象，本对象的属性继承自它的原型对象</li>
<li>对象的类（class）是一个标识对象类型的字符串</li>
<li>对象的扩展标记（extensible flag）指明了（在 ECMAScript 5 中）是否可以向该对象添加新属性</li>
</ul>


<p>下面这些术语用来区分三类 JavaScript 对象和两类属性：</p>

<ul>
<li>内置对象（native object），由 ECMAScript 规范定义的对象或类。例如 数组、日期</li>
<li>宿主对象（host object），由 JavaScript 解释器所嵌入的宿主环境（比如浏览器）定义的。比如浏览器中的 HTMLElement，document</li>
<li>自定义对象（user-defined object），由运行中的 JavaScript 代码创建的对象</li>
<li>自有属性（own property），直接在对象中定义的属性</li>
<li>继承属性（inherited property）是在对象的原型对象中定义的属性</li>
</ul>


<h2>创建对象</h2>

<h3>对象直接量</h3>

<pre><code class="javascript">var empty = {}
var point = { x:0, y:0 }
var point2 = { x:point.x, y:point.y + 1 }
var book = {
    "main title": "JavaScript",
    "for": "all audiences",
    author: {
        firstname: "David",
        surname: "Flanagan"
    }
}
</code></pre>

<p>在 ECMAScript 5 中，保留字可以用做不带引号的属性名。然后对于 ECMAScript 3 来说，使用保留字作为属性名必须使用引号引起来。ECMAScript 5 中属性最后一个逗号会被忽略，但在 IE 中则报错</p>

<h3>通过 new 创建对象</h3>

<p>new 运算符创建并初始化一个新对象。new 后跟随一个函数调用。这里的函数称做构造函数（constructor），用来初始化一个新创建的对象。JavaScript 语言核心的原始类型都包含内置构造函数（另一方面也证实了 JavaScript 中一切皆对象）</p>

<pre><code class="javascript">var o = new Object();
var a = new Array();
var d = new Date();
var r = new RegExp('js');
</code></pre>

<h3>原型</h3>

<p>每一个 JavaScript 对象（null 除外）都和另一个对象相关联，这个对象就是「原型」，每一个对象都从原型继承属性</p>

<p>通过 new 创建的对象原型就是构造函数的 prototype 属性值，通过 new Object() 创建的对象也继承自 Obejct.property</p>

<p>没有原型对象的为数不多，Obejct.prototype 就是其中之一。它不继承任何属性，普通对象都具有原型。所有的内置构造函数都具有一个继承自 Object.prototype 的原型。例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性现时继承自 Date.prototype 和 Object.prototype，这一系列链接的原型对象就是所谓的「原型链」（prototype chain）</p>

<h3>Object.create()</h3>

<p>ECMAScript 5 定义了一个名为 Obejct.create() 的方法，用来创建一个新对象，其中第一个参数是这个对象的原型，第二个可选参数用来对对象的属性进行进一步描述，Object.create() 是一个 <strong>静态函数</strong>，不是提供给对象调用的方法</p>

<pre><code class="javascript">var o1 = Object.create({ x:1, y:2 });       // o1 继承了属性 x 和 y
var o2 = Obejct.create(null);               // o2 不继承任何属性和方法
</code></pre>

<p>在 ECMAScript 3 中可以用类似代码来模拟原型继承：</p>

<pre><code class="javascript">function inherit(p) {
    if (p == null) throw TypeError();
    if (Object.create) return Object.create(p);

    var t = typeof p;
    if (t !== "object" &amp;&amp; t !== "undefined") throw TypeError();

    function f() {}
    f.prototype = p;

    return new f();
}

var o = { x: "test o" }

var c = inherit(o);

c.x = "test c";

console.log(c.x);       // =&gt; "test c"
console.log(o.x);       // =&gt; "test o"
</code></pre>

<h2>属性的查询和设置</h2>

<pre><code class="javascript">var author = book.author;           // 取得 book 的 author 属性
var title = book["main title"];     // 使用 [] 访问属性时 [] 内必须是一个计算结果为字符串的表达式

book.edition = 6;                   // 给 book 创建一个名为 edition 的属性，「.」号运算符后的标识符不能是保留字
</code></pre>

<h3>作为关联数组的对象</h3>

<p>当通过 [] 来访问对象属性时，属性名通过字符串来表示。字符串是 JavaScript 的数据类型，在程序运行时可以修改创建它们。因此，可以在 JavaScript 中使用下面这种代码来动态添加/查找属性：</p>

<pre><code class="javascript">var addr = "";
for (i = 0; i &lt; 4; i++) {
    addr += customer["address" + i] + '\n';
}
</code></pre>

<h3>继承</h3>

<p>假设要查询对象 o 的属性 x，如果 o 中不存在 x，那么将会继续在 o 的原型对象中查询属性 x。如果原型对象中也没有 x，但这个原型对象还有原型，那么继续在这个原型对象的原型上执行查找，直到找到 x 或者找到一个原型是 null 的对象为止。可以看出来，原型的属性构成了一个「链接」，通过这个「链」可以实现属性的继承</p>

<pre><code class="javascript">var o = {}
o.x = 1;

var p = inherit(o);
p.y = 2;

var q = inherit(p);
q.z = 3;

var s = q.toString();   // =&gt; "[object Object]"
q.x + q.y               // =&gt; 3
</code></pre>

<h3>属性访问错误</h3>

<p>属性访问并不总是返回或设置一个值，下页场景给对象 o 设置 属性 p 会失败：</p>

<ul>
<li>o 中的属性 p 是只读的（defineProperty() 方法中有一个例外，可以对可配置的只读属性重新赋值）</li>
<li>o 中不存在自有属性 p：o 没有使用 setter 方法继承属性 p，并且 o 的可扩展性（extensible attribute）是 false。如果 o 中不存在 p，而且没有 setter 方法可供调用，则 p 一定会添加至 o 中。如果 o 不是可扩展的，那么在 o 中不能定义新的属性</li>
</ul>


<h2>删除属性</h2>

<p>使用 delete 运算符可以删除对象的属性，delete 运算符只能删除 <strong>自有属性</strong>，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）</p>

<p>如果删除成功或者删除了一个没有影响的值（不存在的属性），delete 表达式返回 true。当 delete 运算符的操作数不是一个对象的属性的时候也返回 true</p>

<pre><code class="javascript">var o = { x: 1 }
delete o.x;             // =&gt; true
delete o.x;             // =&gt; true x 并不存在
delete o.toString;      // =&gt; true toString 是继承属性
delete 1                // =&gt; true 不是对象属性
this.b = 1;
delete b;               // =&gt; true 删除全局对象上的变量 b

delete Object.property  // =&gt; false
var x = 1;
delete this.x;          // =&gt; false 不能删除这个属性，因为是通过 var 声明的
function f() {}
delete f                // =&gt; false 不能删除全局函数
</code></pre>

<h2>检测属性</h2>

<p>可以通过 in 运算符、hasOwnProperty() 方法和 propertyIsEnumerable() 方法来检测对象是否存在某属性，propertyIsEnumerable 只有检测到是自有属性且这个属性的可枚举性为 true 时它才返回 true</p>

<pre><code class="javascript">var o = { x: 1 };
"x" in o;                          // =&gt; true
"y" in o;                          // =&gt; false
"toString" in o                    // =&gt; true

o.hasOwnProperty("x")              // =&gt; true
o.hasOwnProperty("y")              // =&gt; false
o.hasOwnProperty("toString")       // =&gt; false

var o = inherit({ y: 2});
o.x = 1;
o.propertyIsEnumerable("x")        // =&gt; true
o.propertyIsEnumerable("y")        // =&gt; false
o.propertyIsEnumerable("toString") // =&gt; false
</code></pre>

<p>还可以通过判断属性是否是 undefined 来模拟 in 运算符</p>

<pre><code class="javascript">o.x !== undefined;                 // =&gt; true
o.y !== undefined;                 // =&gt; false
o.toString !== undefined;          // =&gt; true
</code></pre>

<p>然而有一种场景只能使用 in 运算符而不能通过只判断 undefined 的方式。<strong>in 可以区分不存在的属性和存在但值为 undefined 的属性</strong></p>

<pre><code class="javascript">var o = { x: undefined }
o.x !== undefined           // =&gt; false 存在 x，只是值为 undefined
o.y !== undefined           // =&gt; false
"x" in o                    // =&gt; true
"y" in o                    // =&gt; false
delete o.x                  // =&gt; true
"x" in o                    // =&gt; false delete 后 o 完全不存在了
</code></pre>

<h2>枚举属性</h2>

<p>许多工具库给 Object.prototype 添加了新的方法或者属性（通常不建议这么做），这些方法和属性可以被所有对象继承并使用。然而在 ECMAScript 5 标签之前，这些添加的方法是 <strong>不能定义为不可枚举的</strong>，因此它们都可以在 for/in 循环枚举出来。为了避免这和践情况，需要过滤 for/in 循环返回的属性，下面两种方法是最常见的：</p>

<pre><code class="javascript">Object.prototype.test = 1;
var o = { a: 1, b:2, c: function() {} };
for (p in o) {
    if (!o.hasOwnProperty(p)) continue;
    console.log(p);
}
for (p in o) {
    if (typeof o[p] === "function") continue;
}
</code></pre>

<p>除了 for/in 循环之外，ECMAScript 5 定义了两个用以枚举属性名称的函数。第一个是 Object.keys()，它返回一个数组，由对象中的 <strong>可枚举的自有属性名称</strong> 组成，第二个是 Object.getOwnPropertyNames()，它和上面的方法类似，只是它返回对象的 <strong>所有自有属性名称</strong>，不仅仅是可枚举的属性</p>

<h2>属性 getter 和 setter</h2>

<p>在 ECMAScript 5 中，属性的值可以用一个或两个方法替代，这两个方法就是 getter 和 setter。由它们定义的属性称做「存取器属性」（accessor property），不同于「数据属性」（data property），数据属性只有一个简单的值</p>

<p>当程序查询存取器属性的值时，JavaScript 调用 getter 方法（无参数）。这个方法返回属性的存取表达式值。当程序设置一个存取器属性的值时，调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责「设置」属性值。可以忽略 setter 方法的返回值</p>

<p>使用存取器属性写入的属性不具有可写性（writable）。如果属性同时具有 getter 和 setter 方法，那么它是一个读/写属性。哪果它只有 getter 方法，那么它是一个只读属性。如果只有 setter 方法，那么它是一个只写属性，读取只写属性总是返回 undefined</p>

<pre><code class="javascript">var p = {
  x: 1.0,
  y: 1.0,

  get r() {
    return Math.sqrt(this.x*this.x + this.y*this.y);
  },
  set r(newValue) {
    var oldValue = Math.sqrt(this.x*this.x + this.y*this.y);
    var ratio = newValue/oldValue;

    this.x *= ratio;
    this.y *= ratio;
  },
  get theta() {
    return Math.atan2(this.y, this.x)
  }
};
p.r             // =&gt; 1.4142135623730951
</code></pre>

<h2>属性的特性</h2>

<p>除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。ECMAScript 3 程序创建的属性都是可写、可枚举、可配置的，且无法对这些特性做出修改。ECMAScript 5 中却提供了查询和设置这些属性鹅的 API，这些 API 对于库的开发者来说非常重要，因为：</p>

<ul>
<li>可以通过这些 API 给原型对象添加方法，并将它们设置成不可枚举的，<strong>让它们看起来更像内置方法</strong></li>
<li>可以通过这些 API 给对象定义不修改或删除的属性借此「锁定」这个对象</li>
</ul>


<p><strong>数据属性</strong> 的 4 个属性分别是它的值（value）、可写性（writable）、可枚举性（enumerable）和可配置性（configurable）</p>

<p><strong>存取器属性</strong> 不具有值（value）特性和可写性，它们的可写性是由 setter 方法存在与否决定，因此存取器属性的 4 个特性是读取（get）、写入（set）、可枚举性和可配置性</p>

<p>为了实现属性特性的查询和设置操作，ECMAScript 5 中定义了一个名为「<strong>属性描述符</strong>」（property descriptor）的对象，这个对象代表那 4 个特性。描述符对象的属性和它们所描述的属性特性是同名的。因此，数据属性的描述符对象的属性有 value, writable, enumerable 和 configurable。存取器属性描述符对象则用 get, set 属性代替 value, writable。其中 writable、enumerable 和 configurable 都是布尔值，get、set 都是函数值</p>

<p>通过调用 Object.getOwnPropertyDescriptor() 可以获得某个对象特定属性的属性描述符</p>

<pre><code class="javascript">// =&gt; {value: 1, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor({ x: 1}, "x")
var random = {
    get octet() {
        return Math.floor(Math.random() * 256)
    },
    get uint16() {
        return Math.floor(Math.random() * 65536)
    },
    get int16() {
        return Math.floor(Math.random() * 65536 - 32768)
    }
}
// =&gt; {set: undefined, get: function, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor(random, "octet")
// =&gt; undefined
Object.getOwnPropertyDescriptor({}, "x")
</code></pre>

<p>从函数名字就可以看出来 Object.getOwnPropertyDescriptor() 只能得到自有属性的描述符。继承属性的特性需要遍历原型链</p>

<p>要想设置属性的特性，或者让新建属性具有某种特性，则需要调用 Object.defineProperty()，传入要修改的对象、要创建或者修改的属性的名称以前属性描述符对象：</p>

<pre><code class="javascript">var o = {};
Object.defineProperty(o, "x", {
    value: 1,
    writable: true,
    enumerable: false,
    configurable: true
});
// x 属性存在但不可枚举
Object.keys()       // =&gt; []

Object.defineProperty(o, "x", { writable: false })
o.x = 2             // 试图更改这个属性的值，会操作失败不报错，严格模式中则抛出类型错误异常
o.x                 // =&gt; 1

// 将 x 从数据属性修改为存取器属性
Object.defineProperty(o, "x", { value: 2 })
Object.defineProperty(o, "x", { get: function() { return 0} }
o.x                 // =&gt; 0
</code></pre>

<p>传入 Object.defineProperty() 的属性描述符对象 <strong>不必</strong> 包含所有 4 个特性。对于创建属性来说，默认的特性值是 false 或 undefined。对于修改的已有属性来说，默认的特性值没有做任何修改。注意，这个方法要么修改已有属性要么新建自胡属性，但 <strong>不能修改继承属性</strong>，想要同时修改或者创建多个属性则需要使用 Object.defineProperties()，使用方法可以参考 MDN <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">相关 api</a></p>

<p>对于那些不允许创建或者修改的属性来说，如果用 Object.defineProperty() 对其操作就会抛出类型错误异常，比如给一个不可扩展的对象新增属性就会抛出类型错误异常。<strong>可写性控制着对特定值特性的修改，可配置性控制着对其它特性的修改</strong>，使用的时候以下情况会抛出类型错误异常：</p>

<ul>
<li>如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性</li>
<li>如果属性是不可配置的，则不能修改它的可配置性和可枚举性</li>
<li>如果存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性</li>
<li>如果数据属性是不可配置的，则不能将它转换为存取器属性</li>
<li>如果数据属性是不可配置的，则不能将它的可写性从 false 修改为 true，但可以从 true  修改为 false</li>
<li>如果数据属性是不可配置且不可写的，则不能修改它的值，然而 <strong>可配置但不可写的属性值是可以修改的</strong></li>
</ul>


<pre><code class="javascript">// 给 Object.prototype 添加一个不可枚举的 extend() 方法
// 这个方法继承自调用它的对象，将作为参数什入的对象属性都复制
Object.defineProperty(Object.prototype, "extend", {
    writable: true,
    enumerable: false,
    configurable: true,
    value: function(o) {
        var names = Object.getOwnPropertyNames(0);

        for (var i = 0, l = names.length; i &lt; l; i++) {
            if (names[i] in this) continue;

            var desc = Object.getOwnPropertyDescriptor(o, name[i]);
            Object.defineProperty(this, names[i], desc)
        }
    }
});
</code></pre>

<p><strong>getter 和 setter 的老式 API</strong></p>

<p>在ECMAScript 5标准被采纳之前，大多数 JavaScript 的实现（IE 除外）已经可以支持对象直接量语法中的 get 和 set 写法。这些实现提供了非标准的老式 API 用来查询和设置 getter 和 setter。这些 API 由 4 个方法组成，所有对象都拥有这些方法。<code>__lookupGetter__()</code> 和 <code>__lookupSetter__()</code> 用以返回一个命名属性的 getter 和 setter 方法，<code>__defineSetter__()</code> 和 <code>__defineGetter__()</code> 用以定义 getter 和 setter</p>

<h2>对象的三个属性</h2>

<p>每个对象都胡与之相关的 <strong>原型</strong>（prototype）、<strong>类</strong>（class）和 <strong>可扩展性</strong>（extensible attribute）</p>

<h3>原型属性</h3>

<p>原型属性是在实例对象创建之初就设置好的，ECMAScript 5 中，对象作为参数传入 <code>Object.getPrototypeOf()</code> 可以查看它的原型，在 ECMAScript 3 中，则没有与之等价的函数，但经常使用表达式 o.constructor.prototype 来检测一个对象的原型。通过 new 表达式创建的对象，通常继承一个 constructor 属性，这个属性指代创建这个对象的构造函数</p>

<p>要想检测一个对象是否是另一个对象的原型（或者处于原型链中），请使用 isPrototypeOf() 方法，这个方法和 instanceof 运算符非常类似，例如：</p>

<pre><code class="javascript">var p = { x:1 };
var o = Object.create(p);
p.isPrototypeOf(o)                  // =&gt; true
Object.prototype.isPrototypeOf(o)   // =&gt; true
</code></pre>

<h3>类属性</h3>

<p>对象的类属性是一个字符串，用以表示对象的类型信息。ECMAScript 3/5 都未提供设置这个属性的方法，并只有一种间接的方法可以查询它。默认的 toString() 方法（继承自 Object.prototype），返回了如下这种格式的字符串：</p>

<blockquote><p>[object class]</p></blockquote>

<p>所以可以通过 toString() 方法返回的字符串截取处理取到 class 名，不过很多对象继承的 toString() 方法被重写了，为了能调用正确的 toString() 版本，必须间接地调用 Function.call() 方法</p>

<pre><code class="javascript">function classof(o) {
    if (o === null) return "Null";
    if (o === undefined) return "Undefined";
    return Object.prototype.toString.call(o).slice(8, -2);
}
classof(null)     // =&gt; "Null"
classof(1)        // =&gt; "Number"
classof("")       // =&gt; "String"
classof(true)     // =&gt; "Boolean"
classof({})       // =&gt; "Object"
classof([])       // =&gt; "Array"
classof(/./)      // =&gt; "Regexp"
classof(new Date) // =&gt; "Date"
function f() {}
classof(new f())  // =&gt; "Object"
</code></pre>

<h3>可扩展属性</h3>

<p>可扩展性用以表示是否可以给对象是添加新属性。所有内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展属性是由 JavaScript 引擎定义的，ECMAScript 5 中，所有的内置对象和自定义对象都是可扩展的，除非将它们转换为不可扩展的，宿主对象的可扩展性也是由实现 ECMAScript 5 的 JavaScript 引擎定义的</p>

<p>ECMAScript 5 定义了用来查询和设置对象可扩展性的函数：Object.isExtensible()，如果将对象转换为不可扩展的，需要调用 Object.preventExtensions()，不过一量旦将对象转换为不可扩展的，就无法再转换回去了。</p>

<p>Object.seal() 和 Object.preventExtensions() 类似，除了能将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的，也就是说不能给对象添加新的属性，已有的属性也不能删除或配置，已封闭（sealed）的对象是不能解封的，可以使用 Object.isSealed() 来检测对象是否封闭</p>

<p>Object.freeze() 将更严格地锁定对象 —— 「冻结」，它还可以将它自有的所有数据属性设置为只读，可以使用 Object.isFrozen() 来检测对象是否冻结</p>

<h2>序列化对象</h2>

<p>对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript 5 提供了内置函数 JSON.stringify 和 JSON.parse() 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON的全称是「JavaScript Object Notation」—— JavaScript 对象表示法，正如其名，它的语法和 JavaScript 对象与数组直接量的语法非常相近</p>

<p>ECMAScript 3 环境中可以引用 <a href="https://github.com/douglascrockford/JSON-js">json2</a> 类库来支持这两个序列化函数</p>

<p>JSON 语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值，函数、RegExp、Error 对象和 undefined 值不能序列化和不愿。JSON.stringify() <strong>只能序列化对象可枚举的自有属性</strong>，关于 JSON 对象更多 API 可以参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify</a></p>

<h2>对象方法</h2>

<h3>toString() 方法</h3>

<p>toString() 方法没有参数，在需要将对象转换为字符串的时候，JavaScript 都调用这个方法</p>

<pre><code class="javascript">var s = { x: 1, y: 1 }
s.toString();       // =&gt; "[object Ojbect]"
</code></pre>

<h3>toLocaleString() 方法</h3>

<p>返回一个对象的本地化字符串。Object 中默认的 toLocaleString() 方法并不做任何本地化自身操作，它仅调用 toString() 方法并返回值。Date 和 Number 类对 toString() 方法做了定制，可以用它对数字、日期和时间做本地化的转换</p>

<h3>toJSON() 方法</h3>

<p>Object.prototype 实际上不有定义 toJSON() 方法，但对于需要执行序列化的对象来说，JSON.stringify() 方法会调用 toJSON() 方法，如果存在则调用它，返回值即是序列化的结果，而不是原始对象，参见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toJSON">Date.toJSON</a></p>

<h3>valueOf() 方法</h3>

<p>valueOf() 和 toString() 方法非常类似，但往往当 JavaScript 需要 <strong>将对象转换为某种原始值而非字符串</strong> 的时候才会用到它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript 就会自动调用这个方法，同样有些内置类自定义了 valueOf() 方法，比如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/valueOf">Date.valueOf</a></p>
]]></content>
  </entry>
  
</feed>
