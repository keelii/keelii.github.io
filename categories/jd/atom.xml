<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jd on Something</title>
    <link>https://keelii.com/categories/jd/</link>
    <description>Recent content in jd on Something</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 22 Dec 2016 15:55:52 +0800</lastBuildDate>
    
        <atom:link href="https://keelii.com/categories/jd/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>sku 多维属性状态判断算法</title>
      <link>https://keelii.com/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/</link>
      <pubDate>Thu, 22 Dec 2016 15:55:52 +0800</pubDate>
      
      <guid>https://keelii.com/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/</guid>
      <description>

&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;这个问题来源于选择商品属性的场景。比如我们买衣服、鞋子这类物件，一般都需要我们选择合适的颜色、尺码等属性&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t3118/276/4984729113/37788/61331934/585b8939Na04471ff.png&#34; alt=&#34;color_size&#34; /&gt;&lt;/p&gt;

&lt;p&gt;先了解一下 sku 的学术概念吧&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;最小库存管理单元（Stock Keeping Unit, SKU）是一个会计学名词，定义为库存管理中的最小可用单元，例如纺织品中一个SKU通常表示规格、颜色、款式，而在连锁零售门店中有时称单品为一个SKU。最小库存管理单元可以区分不同商品销售的最小单元，是科学管理商品的采购、销售、物流和财务管理以及POS和MIS系统的数据统计的需求，通常对应一个管理信息系统的编码。 —— form wikipedia &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E5%AD%98%E8%B4%A7%E5%8D%95%E4%BD%8D&#34;&gt;最小存货单位&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的结合上面的实例来说： sku 就是你上购物网站买到的最终商品，对应的上图中已选择的属性是：颜色 &lt;strong&gt;黑色&lt;/strong&gt; - 尺码 &lt;strong&gt;37&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我先看看后端数据结构一般是这样的，一个线性数组，每个元素是一个描述当前 sku 的 map，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
   { &amp;quot;颜色&amp;quot;: &amp;quot;红&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;大&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;A&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3158054&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;白&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;中&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;B&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3133859&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;蓝&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;小&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;C&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3516833&amp;quot; }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前端展示的时候显然需要 group 一下，按不同的属性分组，目的就是让用户按属性的维度去选择，group 后的数据大概是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;颜色&amp;quot;: [&amp;quot;红&amp;quot;, &amp;quot;白&amp;quot;, &amp;quot;蓝&amp;quot;],
    &amp;quot;尺码&amp;quot;: [&amp;quot;大&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;小&amp;quot;],
    &amp;quot;型号&amp;quot;: [&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的在网页上大概是这样的 UI&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3307/119/4891794144/3339/dbde7abe/585b9042N5e527489.png&#34; alt=&#34;ui_demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候，就会有一个问题，这些元子属性能组成的集合（用户的选择路径） &lt;strong&gt;远远大于&lt;/strong&gt; 真正可以组成的集合，比如上面的属性集合可以组合成一个 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF&#34;&gt;笛卡尔积&lt;/a&gt;，即。可以组合成以下序列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[
    [&amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot;],    // ✔
    [&amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;红&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot;],    // ✔
    [&amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;白&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;C&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;A&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;B&amp;quot;],
    [&amp;quot;蓝&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;C&amp;quot;]     // ✔
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据公式可以知道，&lt;strong&gt;一个由 3 个元素，每个元素是有 3 个元素的子集构成的集合，能组成的笛卡尔积一共有 3 的 3 次幂，也就是 27 种&lt;/strong&gt;，然而源数据只可以形成 3 种组合&lt;/p&gt;

&lt;p&gt;这种情况下最好能提前判断出来不可选的路径并置灰，告诉用户，否则会造成误解&lt;/p&gt;

&lt;h2 id=&#34;确定规则&#34;&gt;确定规则&lt;/h2&gt;

&lt;p&gt;看下图，如果我们定义红色为当前选中的商品的属性，即当前选中商品为 &lt;code&gt;红-大-A&lt;/code&gt;，这个时候如何确认其它非已选属性是否可以组成可选路径？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t3100/104/4921509103/3867/ea2bdd9b/585b9636Nc5d3efd4.png&#34; alt=&#34;ui_selected&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则是这样的：&lt;/strong&gt; 假设当前用户想选 &lt;code&gt;白-大-A&lt;/code&gt;，刚好这个选择路径是不存在的，那么我们就把 &lt;code&gt;白&lt;/code&gt; 置灰&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t3175/51/4906988054/3771/93679a78/585b9717Nf53b5e3e.png&#34; alt=&#34;ui_selected_disabled&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以此类推，如果要确认 &lt;code&gt;蓝&lt;/code&gt; 属性是否可用，需要查找 &lt;code&gt;蓝-大-A&lt;/code&gt; 路径是否存在&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;解决方法&#34;&gt;解决方法&lt;/h2&gt;

&lt;p&gt;根据上面的逻辑代码实现思路就有了：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;遍历所有非已选元素：&lt;code&gt;&amp;quot;白&amp;quot;, &amp;quot;蓝&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;遍历所有属性行： &lt;code&gt;&amp;quot;颜色&amp;quot;, &amp;quot;尺码&amp;quot;, &amp;quot;型号&amp;quot;&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;取： a) 当前元素 b) 非当前元素所在的其它属性已选元素，形成一个路径&lt;/li&gt;
&lt;li&gt;判断此路径是否存在，如果不存在将当前元素置灰&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看来问题似乎已经解决了，然而 &amp;hellip;&lt;/p&gt;

&lt;p&gt;我们忽略了一个非常重要的问题：上例中虽然 &lt;code&gt;白&lt;/code&gt; 元素置灰，但是实际上 &lt;code&gt;白&lt;/code&gt; 是可以被点击的！因为用户可以选择 &lt;code&gt;白-中-B&lt;/code&gt; 路径&lt;/p&gt;

&lt;p&gt;如果用户点击了 &lt;code&gt;白&lt;/code&gt; 情况就变得复杂了很多，我们假设用户 &lt;strong&gt;只选择了一个&lt;/strong&gt;元素 &lt;code&gt;白&lt;/code&gt;，此时如何判断其它未选元素是否可选？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t3238/138/4916973929/3751/11a121a7/585b9c36N668cd64b.png&#34; alt=&#34;ui_selected_one&#34; /&gt;&lt;/p&gt;

&lt;p&gt;即：如何确定 &lt;code&gt;&amp;quot;大&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;&lt;/code&gt; 需要置灰？ 注意我们并不需要确认 &lt;code&gt;&amp;quot;红&amp;quot;，&amp;quot;蓝&amp;quot;&lt;/code&gt; 是否可选，因为属性里面的元素都是 &lt;strong&gt;单选&lt;/strong&gt;，当前的属性里任何元素都可选的&lt;/p&gt;

&lt;h3 id=&#34;缩小问题规模&#34;&gt;缩小问题规模&lt;/h3&gt;

&lt;p&gt;我们先 &lt;strong&gt;缩小问题范围&lt;/strong&gt;：当前情况下（只有一个 &lt;code&gt;白&lt;/code&gt; 已选）如何确定尺码 &lt;code&gt;&amp;quot;大&amp;quot;&lt;/code&gt; 需要置灰？ 你可能会想到根据我们之间的逻辑，需要分别查找：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;白 - 大 - A&lt;/li&gt;
&lt;li&gt;白 - 大 - B&lt;/li&gt;
&lt;li&gt;白 - 大 - C&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他们都不存在的时候把尺码 &lt;code&gt;大&lt;/code&gt; 置灰，问题似乎也可以解决。其实这样是不对的，因为 &lt;strong&gt;型号没有被选择过&lt;/strong&gt;，所以只需要知道 &lt;code&gt;白-大&lt;/code&gt;是否可选即可&lt;/p&gt;

&lt;p&gt;同时还有一个问题，如果已选的个数不确定而且维度可以增加到不确定呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t3931/229/741708498/8439/ce1088f3/585ba187N9bf3b55d.png&#34; alt=&#34;ui_muli-attr&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这种情况下如果还按之前的算法，即使实现也非常复杂。这时候就要考虑换一种思维方式&lt;/p&gt;

&lt;h3 id=&#34;调整思路&#34;&gt;调整思路&lt;/h3&gt;

&lt;p&gt;之前我们都是反向思考，找出不可选应该置灰的元素。我们现在正向的考虑，如何确定属性是否可选。而且多维的情况下用户可以跳着选。比如：用户选了两个元素 &lt;code&gt;白，B&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t3292/20/4882441565/5337/7c12589c/585ba3f5Nc07d80f6.png&#34; alt=&#34;ui_muli-attr_two&#34; /&gt;  &lt;em&gt;图1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我们再回过头来看下 &lt;strong&gt;原始存在的数据&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[
   { &amp;quot;颜色&amp;quot;: &amp;quot;红&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;大&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;A&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3158054&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;白&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;中&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;B&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3133859&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;蓝&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;小&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;C&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3516833&amp;quot; }
]
// 即
[
   [ &amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot; ],   // 存在
   [ &amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot; ],   // 存在
   [ &amp;quot;蓝&amp;quot;, &amp;quot;小&amp;quot;, &amp;quot;C&amp;quot; ]    // 存在
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然：如果第一条数据 &lt;code&gt;&amp;quot;红&amp;quot;, &amp;quot;大&amp;quot;, &amp;quot;A&amp;quot;&lt;/code&gt; 存在，那么下面这些子组合 &lt;strong&gt;肯定都存在&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;红&lt;/li&gt;
&lt;li&gt;大&lt;/li&gt;
&lt;li&gt;A&lt;/li&gt;
&lt;li&gt;红 - 大&lt;/li&gt;
&lt;li&gt;红 - A&lt;/li&gt;
&lt;li&gt;大 - A&lt;/li&gt;
&lt;li&gt;红 - 大 - A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同理：如果第二条数据 &lt;code&gt;&amp;quot;白&amp;quot;, &amp;quot;中&amp;quot;, &amp;quot;B&amp;quot;&lt;/code&gt; 存在，那么下面这些子组合 &lt;strong&gt;肯定都存在&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;白&lt;/li&gt;
&lt;li&gt;中&lt;/li&gt;
&lt;li&gt;B&lt;/li&gt;
&lt;li&gt;白 - 中&lt;/li&gt;
&lt;li&gt;白 - B&lt;/li&gt;
&lt;li&gt;中 - B&lt;/li&gt;
&lt;li&gt;白 - 中 - B&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;我们提前把 &lt;strong&gt;所有存在的路径中的子组合&lt;/strong&gt; 算出来，算法上叫取集合所有子集，数学上叫 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%86%AA%E9%9B%86&#34;&gt;幂集&lt;/a&gt;， 形成一个所有存在的路径表，算法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * 取得集合的所有子集「幂集」
 arr = [1,2,3]

     i = 0, ps = [[]]:
         j = 0; j &amp;lt; ps.length =&amp;gt; j &amp;lt; 1:
             i=0, j=0 ps.push(ps[0].concat(arr[0])) =&amp;gt; ps.push([].concat(1)) =&amp;gt; [1]
                      ps = [[], [1]]

     i = 1, ps = [[], [1]] :
         j = 0; j &amp;lt; ps.length =&amp;gt; j &amp;lt; 2
             i=1, j=0 ps.push(ps[0].concat(arr[1])) =&amp;gt; ps.push([].concat(2))  =&amp;gt; [2]
             i=1, j=1 ps.push(ps[1].concat(arr[1])) =&amp;gt; ps.push([1].concat(2)) =&amp;gt; [1,2]
                      ps = [[], [1], [2], [1,2]]

     i = 2, ps = [[], [1], [2], [1,2]]
         j = 0; j &amp;lt; ps.length =&amp;gt; j &amp;lt; 4
             i=2, j=0 ps.push(ps[0].concat(arr[2])) =&amp;gt; ps.push([3])    =&amp;gt; [3]
             i=2, j=1 ps.push(ps[1].concat(arr[2])) =&amp;gt; ps.push([1, 3]) =&amp;gt; [1, 3]
             i=2, j=2 ps.push(ps[2].concat(arr[2])) =&amp;gt; ps.push([2, 3]) =&amp;gt; [2, 3]
             i=2, j=3 ps.push(ps[3].concat(arr[2])) =&amp;gt; ps.push([2, 3]) =&amp;gt; [1, 2, 3]
                      ps = [[], [1], [2], [1,2], [3], [1, 3], [2, 3], [1, 2, 3]]
 */
function powerset(arr) {
    var ps = [[]];
    for (var i=0; i &amp;lt; arr.length; i++) {
        for (var j = 0, len = ps.length; j &amp;lt; len; j++) {
            ps.push(ps[j].concat(arr[i]));
        }
    }
    return ps;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个存在的子集集合，再回头看 &lt;em&gt;图1&lt;/em&gt; 举例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t3292/20/4882441565/5337/7c12589c/585ba3f5Nc07d80f6.png&#34; alt=&#34;ui_muli-attr_two&#34; /&gt;  &lt;em&gt;图1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何确定 &lt;code&gt;红&lt;/code&gt; 可选？ 只需要确定 &lt;code&gt;红-B&lt;/code&gt; 可选&lt;/li&gt;
&lt;li&gt;如何确定 &lt;code&gt;中&lt;/code&gt; 可选？ 需要确定 &lt;code&gt;白-中-B&lt;/code&gt; 可选&lt;/li&gt;
&lt;li&gt;如何确定 &lt;code&gt;2G&lt;/code&gt; 可选？ 需要确定 &lt;code&gt;白-B-2G&lt;/code&gt; 可选&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法描述如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;遍历所有非已选元素

&lt;ol&gt;
&lt;li&gt;遍历所有属性行

&lt;ol&gt;
&lt;li&gt;取： a) 当前元素 b) 非当前元素所在的其它属性已选元素（如果当前属性中没已选元素，则跳过），形成一个路径&lt;/li&gt;
&lt;li&gt;判断此路径是否存在（在所有存在的路径表中查询），如果不存在将当前元素置灰&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以最开始的后端数据为例，生成的所有可选路径表如下：
注意路径用分割符号「-」分开是为了查找路径时方便，不用遍历&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;, &amp;quot;3133859&amp;quot;, &amp;quot;3516833&amp;quot;]
    },
    &amp;quot;红&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;大&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;红-大&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;A&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;红-A&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;大-A&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;红-大-A&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3158054&amp;quot;]
    },
    &amp;quot;白&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;中&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;白-中&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;B&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;白-B&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;中-B&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;白-中-B&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3133859&amp;quot;]
    },
    &amp;quot;蓝&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;小&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;蓝-小&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;C&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;蓝-C&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;小-C&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    },
    &amp;quot;蓝-小-C&amp;quot;: {
        &amp;quot;skus&amp;quot;: [&amp;quot;3516833&amp;quot;]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了更清楚的说明这个算法，再上一张图来解释下吧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3232/357/5124948788/54677/7df39060/58620377Nde9640c3.jpg&#34; alt=&#34;color-size-sel&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以根据上面的逻辑得出，计算状态后的界面应该是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t3160/115/5120711700/3214/2e9b7205/5862159bN7d072d5f.png&#34; alt=&#34;color_size_with_state&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在这种情况下如果用户点击 尺码 &lt;code&gt;中&lt;/code&gt; 应该怎么交互呢？&lt;/p&gt;

&lt;h3 id=&#34;优化体验&#34;&gt;优化体验&lt;/h3&gt;

&lt;p&gt;因为当前情况下路径 &lt;code&gt;红-中-A&lt;/code&gt; 并不存在，如果点击 &lt;code&gt;中&lt;/code&gt;，那么除了尺码 &lt;code&gt;中&lt;/code&gt; 之外其它的属性中 &lt;strong&gt;至少有一个&lt;/strong&gt; 属性和 &lt;code&gt;中&lt;/code&gt; 的路径搭配是不存在的&lt;/p&gt;

&lt;p&gt;交互方面需求是：如果不存在就高亮当前属性行，使用户必须选择到可以和 &lt;code&gt;中&lt;/code&gt; 组合存在的属性。而且用户之间选择过的属性要做一次缓存&lt;/p&gt;

&lt;p&gt;所以当点击不存在的属性时交互流程是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;无论当前属性存不存在，先高亮（选中）当前属性&lt;/li&gt;
&lt;li&gt;清除其它所有已选属性&lt;/li&gt;
&lt;li&gt;更新当前状态（只选当前属性）下的其它属性可选状态&lt;/li&gt;
&lt;li&gt;遍历非当前属性行的其它属性查找对应的在缓存中的已选属性&lt;/li&gt;
&lt;li&gt;如果缓存中对应的属性存在（可选），则默认选中缓存属性并 &lt;strong&gt;再次更新&lt;/strong&gt; 其它可选状态。不存在，则高亮当前属性行（深色背景）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个过程的流程图大概是这样的，点进不存在的属性就会进入「单选流程」&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t3232/297/5253318434/61277/1eb899ea/58653ae6Nf0a3ed56.png&#34; alt=&#34;select_diag&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假设后端数据是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[
   { &amp;quot;颜色&amp;quot;: &amp;quot;红&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;大&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;A&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3158054&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;白&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;大&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;A&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3158054&amp;quot; }, // 多加了一条
   { &amp;quot;颜色&amp;quot;: &amp;quot;白&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;中&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;B&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3133859&amp;quot; },
   { &amp;quot;颜色&amp;quot;: &amp;quot;蓝&amp;quot;, &amp;quot;尺码&amp;quot;: &amp;quot;小&amp;quot;, &amp;quot;型号&amp;quot;: &amp;quot;C&amp;quot;, &amp;quot;skuId&amp;quot;: &amp;quot;3516833&amp;quot; }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当前选中状态是：&lt;code&gt;白-大-A&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3235/190/5186335420/3376/e9633659/58624212Ne7f43d1f.png&#34; alt=&#34;color_size_demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果用户点击 &lt;code&gt;中&lt;/code&gt;。这个时候 &lt;code&gt;白-中&lt;/code&gt; 是存在的，但是 &lt;code&gt;中-A&lt;/code&gt; 并不存在，所以保留颜色 &lt;code&gt;白&lt;/code&gt;，高亮型号属性行：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t4111/305/936307630/3771/c6076a9c/58624270N59d19a52.png&#34; alt=&#34;color_size_demo_width_hl&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由此可见和 &lt;code&gt;白-中&lt;/code&gt; 能搭配存在型号只有 &lt;code&gt;B&lt;/code&gt;，而缓存的作用就是为了少让用户选一次颜色 &lt;code&gt;白&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;到这里，基本上主要的功能就实现了。比如库存逻辑处理方式也和不存属性一样，就不再赘述。唯一需要注意的地方是求幂集的复杂度问题&lt;/p&gt;

&lt;h2 id=&#34;算法复杂度&#34;&gt;算法复杂度&lt;/h2&gt;

&lt;p&gt;幂集算法的时间复杂度是 &lt;code&gt;O(2^n)&lt;/code&gt;，也就是说每条数据上面的属性（维度）越多，复杂度越高。sku 数据的多少并不重要，因为是常数级的线性增长，而维度是指数级的增长&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{1}       2^1 = 2
=&amp;gt; {},{1}
{1,2}     2^2 = 4
=&amp;gt; {},{1},{2},{1,2}
{1,2,3}   2^3 = 8
=&amp;gt; {},{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t3280/36/5011858321/16515/2187c9c/5864aa23N95cea203.png&#34; alt=&#34;powerset_test&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 chrome 里面简单跑了几个用例，可见这个算法非常低效，如果要使用这个算法，必须控制维度在合理范围内，而且不仅仅算法时间复杂度很高，生成最后的路径表也会非常大，相应的占用内存也很高。&lt;/p&gt;

&lt;p&gt;举个例子：如果有一个 10 维的 sku，那么最终生成的路径表会有 2^10 个（1024） key/value&lt;/p&gt;

&lt;p&gt;最终 demo 可以查看这个：
&lt;a href=&#34;http://codepen.io/keelii/pen/RoOzgb&#34;&gt;sku 多维属性状态判断&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;相关资料：
&lt;a href=&#34;http://git.shepherdwind.com/sku-search-algorithm.html&#34;&gt;sku组合查询算法探索&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践</title>
      <link>https://keelii.com/2016/11/17/best-practice-for-phantomjs-and-nodejs-at-jd-s-webdev-front-end-monitor-platform/</link>
      <pubDate>Thu, 17 Nov 2016 09:55:41 +0800</pubDate>
      
      <guid>https://keelii.com/2016/11/17/best-practice-for-phantomjs-and-nodejs-at-jd-s-webdev-front-end-monitor-platform/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文首发于 &lt;a href=&#34;http://www.infoq.com/cn/articles/practise-of-phantomjs-and-nodejs-in-jingdong&#34;&gt;infoQ&lt;/a&gt; 及「前端之巅」微信公众号（&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;amp;mid=2247484138&amp;amp;idx=1&amp;amp;sn=431702ee926dd3a92403bb58417d88d4&amp;amp;scene=2&amp;amp;srcid=0831H070dVHqyZ5Gg62tZRsl&amp;amp;from=timeline&amp;amp;isappinstalled=0&amp;amp;pass_ticket=UAxLVHRLr%2B46hzwgDjfAanLKPSIcnzOQLPJZtqRkoQeHy03khyC2aD7Lat9WgyiL&#34;&gt;微信群直播记录&lt;/a&gt;），感谢 infoQ 前端之巅尾尾同学对文章的整理和校对、微信群直播的组织策划。「前端之巅」是个非常棒的前端知识分享平台，想了解最前沿的前端知识资讯果断关注吧
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;为什么需要一个前端监控系统&#34;&gt;为什么需要一个前端监控系统&lt;/h2&gt;

&lt;p&gt;通常在一个大型的 Web 项目中有很多监控，比如后端的服务 API 监控，接口存活、调用、延迟等监控，这些一般都用来监控后台接口数据层面的信息。而且对于大型网站系统来说，从后端服务到前台展示会有很多层：内网 VIP、CDN 等。但是这些监控并不能准确地反应用户看到的前端页面状态，比如：页面第三方系统数据调用失败，模块加载异常，数据不正确，空白开天窗等。这时候就需要从前端 DOM 展示的角度去分析和收集用户真正看到的东西，从而检测出页面是否出现异常问题&lt;/p&gt;

&lt;h2 id=&#34;需要监控系统解决的问题&#34;&gt;需要监控系统解决的问题&lt;/h2&gt;

&lt;p&gt;页面通常出现以下问题时需要使用邮件、短信通知相关人员修复问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;状态码返回错误（50x, 40x）无法打开&lt;/li&gt;
&lt;li&gt;模块加载失败&lt;/li&gt;
&lt;li&gt;页面乱码&lt;/li&gt;
&lt;li&gt;数据正确性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;触发报警时要有现场快照，以便复现问题&lt;/p&gt;

&lt;h2 id=&#34;技术选型&#34;&gt;技术选型&lt;/h2&gt;

&lt;p&gt;监控的意义和回归测试的在本质上是一致的，都是对已上线功能进行回归测试，但不同的是监控需要做长期的可持续可循环的回归测试，而测试仅仅需要在上线之后做一次回归&lt;/p&gt;

&lt;p&gt;既然监控和测试的本质一致，那我们完全可以采用测试的方式来做监控系统。在自动化测试技术遍地开花的时代，不乏很多好用的自动化工具，我们只需要把这些自动化工具进行整合为我们所用即可&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NodeJS - 特别适用于网络密集型任务&lt;/li&gt;
&lt;li&gt;PhantomJS - 模拟无界面的浏览器，提供丰富的内核交互 API&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;nodejs&#34;&gt;NodeJS&lt;/h3&gt;

&lt;p&gt;NodeJS 是一个 JavaScript 运行环境，非阻塞 I/O 和异步、事件驱动，这几点对于我们构建基于 DOM 元素的监控是非常重要的&lt;/p&gt;

&lt;h3 id=&#34;phantomjs&#34;&gt;PhantomJS&lt;/h3&gt;

&lt;p&gt;PhantomJS 是一个基于 webkit 的浏览器引擎，可以使用 JavaScript API 来模拟浏览器的操作。它使用 QtWebKit 作为它的浏览器核心，使用 webkit 来编译解释执行 JavaScript 代码。也就是说任何你可以在 webkit 浏览器里做的事情，它都能做到&lt;/p&gt;

&lt;p&gt;它不仅是个隐形的浏览器，提供了诸如 CSS 选择器、支持 Web 标准、DOM 操作、JSON、HTML5、Canvas、SVG 等，同时也提供了处理文件 I/O 的操作等。PhantomJS 的用处可谓非常广泛，诸如网络监测、网页截屏、无浏览器的 Web 测试、页面访问自动化等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么不是 Selenium&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;做自动化测试的同学肯定都知道 Selenium。可以使用 Selenium 将测试用例在浏览器中执行，而且 Selenium 对各种平台和常见浏览器支持比较好，但是 Selenium 上手难度系数略高，而且使用Selenium 需要在服务器端安装浏览器&lt;/p&gt;

&lt;p&gt;考虑到监控主要任务在监控不在测试。系统并不需要太多考虑兼容性，而且监控功能相对单一，主要对页面进行功能上的回归测试，所以选择了 PhantomJS&lt;/p&gt;

&lt;h2 id=&#34;架构设计&#34;&gt;架构设计&lt;/h2&gt;

&lt;h3 id=&#34;架构概览&#34;&gt;架构概览&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17013271/ec2bc29e-4f4f-11e6-9591-0838a0243206.png&#34; alt=&#34;4&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;架构简述&#34;&gt;架构简述&lt;/h3&gt;

&lt;p&gt;对于 DOM 监控服务，在应用层面上进行了垂直划分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;规则管理系统&lt;/li&gt;
&lt;li&gt;规则队列生成器&lt;/li&gt;
&lt;li&gt;长时持续处理器&lt;/li&gt;
&lt;li&gt;PhantomJS 服务&lt;/li&gt;
&lt;li&gt;服务化 API&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在应用层面上进行的垂直划分可以对应用做分布式部署，提高处理能力。后期也方便做性能优化、系统改造扩展等&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;h3 id=&#34;前台规则录入&#34;&gt;前台规则录入&lt;/h3&gt;

&lt;p&gt;这是一个独立的 Web 系统，系统主要用来收集用户录入的页面信息、页面对应的规则、展示错误信息。通过调用后端页面抓取服务来完成页面检测的任务，系统可以创建三种类型的检测页面：常规监控、高级监控、可用性监控&lt;/p&gt;

&lt;h4 id=&#34;常规监控&#34;&gt;常规监控&lt;/h4&gt;

&lt;p&gt;录入一个页面地址，和若干检测规则。注意这里的检测规则，我们把常用的一些检测点抽象成了一条类似测试用例的语句。每条规则用来匹配页面上的一个 DOM 元素，用 DOM 元素的属性来和预期做匹配，如果匹配失败系统就会产生一条错误信息，后续交由报警系统处理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;匹配类型&lt;/strong&gt; 一般有这么几种：&lt;code&gt;长度、文本、HTML、属性&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;处理器&lt;/strong&gt; 类似编程语言中的操作符：&lt;code&gt;大于、大于等于、小于、小于等于、等于、正则&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样做的处就是，录入规则的人只要了解一点 DOM 选择器的知识就可以上手操作了，在我们内部通常是交由测试工程师统一完成规则的录入&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17012424/2963f11e-4f4a-11e6-96f1-a962c767e651.png&#34; alt=&#34;1&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;高级监控&#34;&gt;高级监控&lt;/h4&gt;

&lt;p&gt;主要用来提供高级页面测试的功能，一般由有经验的工程师来撰写测试用例。这个测试用例写起来会有一些学习成本，但是可以模拟 Web 页面操作，如：点击、鼠标移动等事件从而做到精确捕捉页面信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17012590/324509de-4f4b-11e6-9ddc-63e5a140b208.png&#34; alt=&#34;2&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;可用性监控&#34;&gt;可用性监控&lt;/h4&gt;

&lt;p&gt;可用性监控侧重于对页面的可访问性、内容正确性等比较 &lt;strong&gt;严重的问题&lt;/strong&gt; 做即时监控。通常这类页面我们只需要在程序里面启一个 Worker 不断的去获取页面 HTML 就可以对结果进行检测匹配了，所以我们选择了 NodeJS 来做异步的页面抓取队列，高效快速的完成这种网络密集型任务&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/17012775/7ccfad00-4f4c-11e6-80b6-60186069bdac.png&#34; alt=&#34;3&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;主动错误上报&#34;&gt;主动错误上报&lt;/h3&gt;

&lt;h4 id=&#34;页面脚本执行错误监控&#34;&gt;页面脚本执行错误监控&lt;/h4&gt;

&lt;p&gt;页面引入一段监控脚本来收集页面产成 error 事件返回的错误信息，自动上报给后端服务，在系统里面可以汇总所有报错信息，以及对应的客户端浏览器版本、操作系统、IP 地址等&lt;/p&gt;

&lt;h4 id=&#34;页面主动上报&#34;&gt;页面主动上报&lt;/h4&gt;

&lt;p&gt;这个功能需要对应的前端工程师在代码中调用错误上报 API，来主动提交错误信息。主要使用的场景有，页面异步服务延时无响应、模块降级兜底主动通知等。监控脚本提供几个简单的 API 来完成这项任务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// error 方法调用后立即上报错误信息并发出邮件、短信通知
errorTracker.error(&#39;错误描述&#39;)
// info 方法调用后立即上报信息，并在单位时间内仅产生一条邮件、短信通知
errorTracker.info(&#39;信息描述&#39;)
// log 方法调用后由报错检测是否达到设置阀值，最终确认是否报错
errorTracker.log(&#39;日志信息&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;后端页面抓取服务&#34;&gt;后端页面抓取服务&lt;/h3&gt;

&lt;p&gt;由于京东很多页面内容是异步加载的，像首页、单品等系统有许多第三方异步接口调用，使用后端程序抓取到的页面数据是同步的，并不能取到动态的 JavaScript 渲染的内容，所以就必须使用像 PhantomJS 这种能模拟浏览器的工具&lt;/p&gt;

&lt;p&gt;常规监控我们使用 PhantomJS 模拟浏览器打开页面进行抓取，然后将监控规则解析成 JavaScript 代码片段执行并收集结果&lt;/p&gt;

&lt;p&gt;高级监控我们使用 PhantomJS 打开页面后向页面注入像 jasmine, mocha 等类似的前端 JavaScript 测试框架，然后在页面执行对应的录入测试用例并返回结果&lt;/p&gt;

&lt;h4 id=&#34;规则队列生成器&#34;&gt;规则队列生成器&lt;/h4&gt;

&lt;p&gt;规则队列生成器会将采集的规则转化类成消息队列，然后交由长时持续处理器一次处理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么采用类消息队列的处理方式？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这和 PhantomJS 的性能是密不可分的，由多次实践发现，PhantomJS 并不能很好地进行并发处理，当并发过多，会导致 CPU 过载，从而导致机器宕机&lt;/p&gt;

&lt;p&gt;在本机环境下的虚拟机中进行并发测试，数据并不理想，极限基本在 ab -n 100 -c 50 左右。 所以为了防止并发导致的问题，就选择了使用类消息队列来避免因为并发过高导致的服务不可用&lt;/p&gt;

&lt;h4 id=&#34;类消息队列的实现&#34;&gt;类消息队列的实现&lt;/h4&gt;

&lt;p&gt;我们这里通过调用内部的分布式缓存系统生成类消息队列，队列的生成其实可以参考数据结构&amp;ndash;队列。最基本的模型就是在缓存中创建一个 KEY ，然后根据队列数据结构的模式进行数据的插入和读取&lt;/p&gt;

&lt;p&gt;当然，类消息队列的中间介质可根据你实际的条件来选择，你也可以使用本机内存实现。这可能会导致应用和类消息队列竞争内存&lt;/p&gt;

&lt;h4 id=&#34;长时持续处理器&#34;&gt;长时持续处理器&lt;/h4&gt;

&lt;p&gt;长时持续处理器是要功能就是消费规则队列生成器生成的类消息队列&lt;/p&gt;

&lt;h4 id=&#34;长时持续处理实现&#34;&gt;长时持续处理实现&lt;/h4&gt;

&lt;p&gt;在长时持续处理器的具体实现中，我们利用了 JavaScript 的 setInterval 方法来持续获取累消息队列的内容下发给规则转化器，然后转发给负载均衡调度器。之后再对返回的结果进行统一处理，比如邮件或者短信报警&lt;/p&gt;

&lt;h4 id=&#34;api&#34;&gt;API&lt;/h4&gt;

&lt;p&gt;PhantomJS 服务可以做为公共 API 提供给客户端进行测试需求的处理， API 通过 HTTP 方式调用。在 API 的处理上需要提供 HTTP 数据到规则和 PhantomJS 的转换。从而又演化出了 HTTP 数据到规则转换器&lt;/p&gt;

&lt;h4 id=&#34;phantomjs-服务&#34;&gt;PhantomJS 服务&lt;/h4&gt;

&lt;p&gt;PhantomJS 服务是指将 PhantomJS 结合 HTTP 服务和子进程进行服务化的处理&lt;/p&gt;

&lt;p&gt;首先、启动 HTTP 服务，然后将长时处理器下发的规则进行进一步转化，转化后启动子进程，HTTP 服务会监听子进程的处理结果，并在处理完毕之后返回&lt;/p&gt;

&lt;h3 id=&#34;报警系统&#34;&gt;报警系统&lt;/h3&gt;

&lt;p&gt;报警系统我们目前使用的是京东内部自己的统一监控平台 UMP，通过调用平台提供的一些 API 来实现报警邮件与短信通知&lt;/p&gt;

&lt;h4 id=&#34;如何根据报警定位到具体页面&#34;&gt;如何根据报警定位到具体页面？&lt;/h4&gt;

&lt;p&gt;用户通过监控管理系统录入规则后，监控系统会根据 UMP 规则针对用户录入的页面生成 UMP 使用的 key。当长时持续处理器发现 PhantomJS 服务返回的结果标示为异常后，就会使用 key 来进行日志记录&lt;/p&gt;

&lt;h4 id=&#34;何时出发报警&#34;&gt;何时出发报警？&lt;/h4&gt;

&lt;p&gt;报警主要分为了短信和邮件报警。邮件报警是在每条异常之后就会发给指定系统用户。短信则是根据异常次数来进行处理的，当异常次数过大，就会下发短信通知&lt;/p&gt;

&lt;h3 id=&#34;部署&#34;&gt;部署&lt;/h3&gt;

&lt;p&gt;对于系统部署可以分为两大块进行。因为机器资源数量有限，没有将所有部分都单独部署&lt;/p&gt;

&lt;p&gt;规则管理系统以及规则队列生成器和持续处理器整合部署在一台机器上，PhantomJS 服务部署在了其他的机器上。进程管理使用了著名的 NPM 模块 —— PM2&lt;/p&gt;

&lt;p&gt;PM2 是一个带有负载均衡功能的 NodeJS 应用的进程管理器。可充分利用 CPU，并保证进程稳定存活&lt;/p&gt;

&lt;p&gt;PM2 特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内建负载均衡（使用 Node cluster 集群模块）&lt;/li&gt;
&lt;li&gt;无缝重启类似 nginx reload&lt;/li&gt;
&lt;li&gt;具有 Ubuntu 和 CentOS 的开机启动脚本&lt;/li&gt;
&lt;li&gt;控制台检测&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过在目前部署任务中，并没有使用内建负载均衡的特性，没用通过集群的方式部署代理。仅使用了后台运行和无缝重启的特性&lt;/p&gt;

&lt;h2 id=&#34;总结与展望&#34;&gt;总结与展望&lt;/h2&gt;

&lt;p&gt;其实我们现在开发的这套监控系统并不复杂，只是合理的运用了一些现有的技术框架。抽象出来我们自己需要的一些功能。但却有效的达到了我们的预期功能，并且节省了很多之前需要人肉测试的时间成本。系统本身还有很多问题在待解决状态，比如报警系统的规则处理与阀值设定，JavaScript 报错的准确过滤机制等，这些问题我们都会逐个解决，并且未来的前端监控系统会成为一个平台，核心服务在后端爬取页面服务，应用端可以有多种形式，比如监控、测试工具等&lt;/p&gt;

&lt;p&gt;一些可以持续优化点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;监控系统虽然在应用层面进行了垂直划分，但是由于机器资源等限制，并没有进行单独功能的部署。这点可能会在后期的使用中进行优化&lt;/li&gt;
&lt;li&gt;PhantomJS 服务还需要进一步优化，以承载大并发，大处理量。提供稳定的服务&lt;/li&gt;
&lt;li&gt;报警由于依赖于公司内部的 UMP 系统，所以并不是特别灵活，后期可以考虑自己实现一套报警机制&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>京东单品页前端开发那些不得不说的事儿</title>
      <link>https://keelii.com/2016/07/31/something-have-to-say-with-JD-item/</link>
      <pubDate>Sun, 31 Jul 2016 10:48:57 +0800</pubDate>
      
      <guid>https://keelii.com/2016/07/31/something-have-to-say-with-JD-item/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;详情页也叫做单品页，域名以「item.jd.com/skuid.html」为格式的页面。是负责展示京东商品 SKU 的落地页。主要任务是展示和商品相关的信息，如：价格、促销、库存、推荐，从而引导用户进入购买流程。同时单品页有很多版本。一般分为两类。一类我们通常看到的「通用类目详情页」—— 所有类目都可以使用，一类是不经常看到的「垂直属性详情页」—— 一些有特殊属性的商品集合&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/6443/10/4580/19685/5bd9aa42E9e1ec871/780ffde00be9b417.jpg&#34; alt=&#34;item version&#34; /&gt;&lt;/p&gt;

&lt;p&gt;首先。由于详情页大量（sku上亿）、高并发（日 pv 约 5000 万）等特性，在很长的一段时间里，单品页面都是后端程序生成静态页面使用 CDN 来解决大量、高并发的问题&lt;/p&gt;

&lt;p&gt;其次。单品页涉及的「三方」系统特别多，比如：促销、库存、合约、秒杀、预售、推荐、IM、店铺、评价社区。而单品页的主要任务就是展示这些系统的信息，并且适当的处理他们之间的冲突关系，而这些系统的接口一般都使用 异步 Ajax 来完成，因为 其一 CDN 无法做到页面的动态化，其二 一些系统的信息对实时性要求特别高（价格、秒杀），即使使用后端动态渲染也很难做到无缓存 0 延迟&lt;/p&gt;

&lt;p&gt;基于上面两个原因，注定了单品页是一种重多系统业务逻辑展示型页面。重前端页面。我大概汇总了一下页面上异步接口，总共约有 30 个，页首屏的接口特别重要，接口之间几乎都有耦合关系&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img12.360buyimg.com/devfe/jfs/t1/8281/14/4115/69497/5bd9aa60E87106dd1/3d5858a0206a115b.jpg&#34;&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t1/8281/14/4115/69497/5bd9aa60E87106dd1/3d5858a0206a115b.jpg&#34; alt=&#34;item-async-service&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;前端的发展历程&#34;&gt;前端的发展历程&lt;/h2&gt;

&lt;h3 id=&#34;混沌时期&#34;&gt;混沌时期&lt;/h3&gt;

&lt;p&gt;混沌时期的单品页并没有前端开发的概念。核心的功能脚本只有三个：促销价格（promotion.js）、库存地区（iplocation.js）、其它逻辑（pshow.js）。这三个脚本分别是三个不同团队的同事负责维护，当时我刚进入京东的时候在 UED 部门，负责页面脚本整体的维护工作和 pshow的开发。那时候我自己维护的 pshow.js 脚本压缩后只有 80 kb，所有的代码都是过程式的，没有任何使用模式和代码技巧，JS 最多也只被用来做个判断渲染 DOM。那时候的前端工作内容只在 UI 层面，写样式和一些交互脚本&lt;/p&gt;

&lt;p&gt;这个阶段给我最深刻的感觉是单品页后端模板很少维护（后端架构是最老的 aspx 版本）。大多数的改动都要用 JavaScript 去动态渲染。因为后端页面是一个生成器生成的。如果页面后端模板有改动那么就需要全量的生成一次，过程可能需要几个小时&lt;/p&gt;

&lt;h3 id=&#34;初见端倪&#34;&gt;初见端倪&lt;/h3&gt;

&lt;p&gt;当我接手这个项目时刚好有一次大改版，就在这时候老大说页面上的脚本都要放在我们手里维护。然后就是一大波的重构、重写。基本上 pshow 被重写了大概 80% 其它的因为业务逻辑的问题并没有完全重写，只是做了些代码层面的优化&lt;/p&gt;

&lt;p&gt;有一个模板引擎叫 &lt;a href=&#34;http://code.google.com/p/trimpath/&#34;&gt;trimPath&lt;/a&gt;，知道这个的估计都算老前端的了。最早的客户端 JavaScript MVC 模式代表作品，只到现在还是使用。这个阶段像评价这种完全异步加载的模块特别适合使用模板引擎来减少维护的工作量。这个时候虽然页面上的代码并不都是我们写的，但基本上前端对页面的 JavaScript 有了控制权，接下来的事情就是寻找机会逐个优化&lt;/p&gt;

&lt;p&gt;这段时间是最痛苦的时候，维护的工作统一到前端。然后后端几乎没有变化，只是在一段时间将后台的架构从 aspx 过渡到了 java。本质上并没有什么改变。前端却做了比以前更多的事情，也是在这个时候我接手了大量的维护工作（包含全站公共库的维护）使得我意识到了一些自动化、工程化方面的重要性，后文会主要讲解，顺便说下，那时候前端自动化工具 Grunt 刚面世，但是我自己却用的是 &lt;a href=&#34;http://ant.apache.org/&#34;&gt;apache ant&lt;/a&gt;，不过不久就切换到了 Grunt 来构建项目&lt;/p&gt;

&lt;h3 id=&#34;拨云见日&#34;&gt;拨云见日&lt;/h3&gt;

&lt;p&gt;单品页不仅重系统逻辑，也重维护&lt;/p&gt;

&lt;p&gt;在这段时间里一方面有正常的维护类需求要做，一方面自己也不断的学习新知识为以后的改版做铺垫。不过就在这时单品页有历史意义的一次技改出现了 —— 单品页动态化技改。关于后端部分的改造细节可以去 &lt;a href=&#34;http://jinnianshilongnian.iteye.com/blog/2235572&#34;&gt;开涛的文章&lt;/a&gt; 了解&lt;/p&gt;

&lt;p&gt;总的来说这次的改版后很多数据直接从后端读取，不再从前端异步获取而且我们也做过一些异步加载的优化，多接口 combo 从统一服务吐出给前端使用。这时前端就不用再为异步接口的加载时苦脑了，只需要专注系统接口的逻辑&lt;/p&gt;

&lt;p&gt;随着这次技改，前端的代码也迎来了模块化的时代。我们把所有的前端代码都进行了模块化然后基于 SeaJS 重写，配合 Nginx concat 功能实现了本地模块化开发，线上服务端合并&lt;/p&gt;

&lt;h2 id=&#34;单品页前端模块的结构与划分&#34;&gt;单品页前端模块的结构与划分&lt;/h2&gt;

&lt;h3 id=&#34;概览&#34;&gt;概览&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://img30.360buyimg.com/devfe/jfs/t1/5384/14/13893/295474/5bd9aa81E87858c06/afbb4167b5339166.jpg&#34;&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t1/5384/14/13893/295474/5bd9aa81E87858c06/afbb4167b5339166.jpg&#34; alt=&#34;first-screen-normal-module&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上图可以看出，基本上最核心的模块都在首屏。每个模块都有单独的一/多个脚本。代码行数（LOC）由 230+ ~ 1200+ 不等。通常来说代码行数越多代码复杂性就越高，逻辑越复杂。很难想象「购买方式」这种只有一行属性选择功能的代码行数却 &lt;strong&gt;高达 1200 多行&lt;/strong&gt;。其主要原因就在于购买方式所在的系统和其它首屏核心系统（库存、促销、地址选择、白条）都有逻辑上的耦合&lt;/p&gt;

&lt;p&gt;看着不错，然而在一个前端工程师眼里至少应该是这样的（我只取了一些典型的模块，并不是全部）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://img20.360buyimg.com/devfe/jfs/t1/7252/24/4264/274354/5bd9aa96E7dc77552/e373aa42595c2369.jpg&#34;&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/7252/24/4264/274354/5bd9aa96E7dc77552/e373aa42595c2369.jpg&#34; alt=&#34;first-screen-in-fe-eye&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这就可以解释为什么有的时候只是加一个很小的东西我们都为考虑再三然后通过 AB 测试提取相关数据，最后后再进行决策。单品页的首屏可以说是寸土寸金&lt;/p&gt;

&lt;h3 id=&#34;按什么维度划分模块&#34;&gt;按什么维度划分模块&lt;/h3&gt;

&lt;p&gt;起初我按模块的属性划分，比如：核心、公共脚本、模块脚本。但用了一段时候以后发现这样划分在单品这种大型系统中并不科学，因为这样划分出来的代码只有划分的人知道是什么规则，其它人接手代码很难快速掌握代码架构，而且尤其在模块比较多的时候不方便维护&lt;/p&gt;

&lt;p&gt;后来我尝试完全以功能模块在页面上出现的位置维度划分。这样以来维护起来方便多了，需要修改某个模块代码只需要对照着图里面标识的模块信息就能轻易找到代码&lt;/p&gt;

&lt;h3 id=&#34;整体核心模块&#34;&gt;整体核心模块&lt;/h3&gt;

&lt;p&gt;我们按页面上的模块结构首屏划分出来这几个核心模块：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;curmb - 面包屑&lt;/li&gt;
&lt;li&gt;concat - 联系咨询相关店铺信息&lt;/li&gt;
&lt;li&gt;prom - 价格促销信息&lt;/li&gt;
&lt;li&gt;address - 地区库存选择，配送服务&lt;/li&gt;
&lt;li&gt;color - 颜色尺码&lt;/li&gt;
&lt;li&gt;buytype - 合约机购买方式&lt;/li&gt;
&lt;li&gt;suits - 套装购买&lt;/li&gt;
&lt;li&gt;jdservice - 增值服务&lt;/li&gt;
&lt;li&gt;baitiao - 白条支付&lt;/li&gt;
&lt;li&gt;buybtn - 购买按钮&lt;/li&gt;
&lt;li&gt;info - 地区提示信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;项目的整体树形结构是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img20.360buyimg.com/devfe/jfs/t1/7397/9/4122/26098/5bd9aaabEde2cd164/d18c6470430c847d.jpg&#34; alt=&#34;project-structure&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;模块内部结构&#34;&gt;模块内部结构&lt;/h3&gt;

&lt;p&gt;比如下面这个大图预览的功能，我全部放在一个文件夹里面维护，但是逻辑上的 JavaScript 模块是分离的，只是说文件夹（preview）就代表页面上的某一部分功能集合&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/6850/35/4456/47415/5bd9aab9Edfb82387/85571d5b35950d3c.jpg&#34; alt=&#34;module-structure&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意文件夹的命名有一定的规则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;模块脚本与样式名必须一样&lt;/li&gt;
&lt;li&gt;需要制作 sprite 的图片统一放在 module/i 目录下面，生成的 sprite 图片也在其中&lt;/li&gt;
&lt;li&gt;生成的 mixin 在模块根目录下，便于其它样式文件调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们再来看下自动生成生成的 __sprite.scss 是什么内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/* __sprite.scss 自动生成 */
@mixin sprite-arrow-next {
    width: 22px;
    height: 32px;
    background-image: url(i/__sprite.png);
    background-position: -0px -30px;
}

/* preview.scss 手动添加 */
@import &amp;quot;./__sprite&amp;quot;;
.sprite-arrow-next {
    @include sprite-arrow-next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意引用的 mixin 名称和我们需要手动添加的样式类名一致。当然也可以直接生成一个类名对应的样式，但是灵活性不好。比如 hover 的时候是另外一张图片就没法自动生成了&lt;/p&gt;

&lt;h2 id=&#34;前端技能树&#34;&gt;前端技能树&lt;/h2&gt;

&lt;h3 id=&#34;html&#34;&gt;HTML&lt;/h3&gt;

&lt;h4 id=&#34;dom-节点数&#34;&gt;DOM 节点数&lt;/h4&gt;

&lt;p&gt;与重业务逻辑的页面不同，重展示的页面一般具有很高的 DOM 节点数。比如京东首页，正常情况加载完页面一共有 3500 多个 DOM 节点，基本上全部用于展示商品信息、广告图和内容布局，页面上的三方异步服务也比较少。尤其像频道页基本上没有什么业务上的逻辑，全部是静态页面。这种页面的特点是更新换代频率高，一年两三次改版很正常，CMS 做模块化后两天换个皮肤都是没问题的。但是这种思路并不适合单品页。单品页更重业务逻辑，同时展示层 UI 逻辑也有很多关系&lt;/p&gt;

&lt;p&gt;我自己的经验是：页面上的 DOM 节点数绝对不能超过 5000 个，否则页面滚动的时候就会出现卡顿的情况，尤其是移动端&lt;/p&gt;

&lt;h4 id=&#34;同步渲染还是异步加载&#34;&gt;同步渲染还是异步加载&lt;/h4&gt;

&lt;p&gt;理论情况下最好做法是后端同步动态渲染页面，但是由于 Web 应用中很多功能都是用户行为驱动的。同步加载不可避免的消耗了后端服务资源。比如：非首屏模块（公共头尾、评价）、点击事件触发的 DOM 内容（异步 tab）&lt;/p&gt;

&lt;p&gt;所以我的经验是：能放到后端做判断渲染的 DOM 就尽量放在后端（尤其是首屏）。这样做的好处有四点好处&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;后端渲染页面相对稳定，不像前端 JavaScript 动态渲染 DOM，可能因为脚本报错或者不可用造成模块都无法展示&lt;/li&gt;
&lt;li&gt;可访问性、SEO 及用户体验也比较好。不会产生脚本的渲染抖动问题&lt;/li&gt;
&lt;li&gt;一定程度上减少了前端渲染页面的复杂性，减少前端代码复杂度&lt;/li&gt;
&lt;li&gt;逻辑统一到一个地方维护起来也方便，而且后端应该为业务逻辑负责，前端应该为展示UI 交互负责&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于异步渲染的模块来说，后端通常需要判断 &lt;strong&gt;「页面有什么元素」&lt;/strong&gt;，以及元素之间的依赖对应关系；而前端需要专注于 &lt;strong&gt;「元素应该怎么展示」&lt;/strong&gt;，UI 层面的交互以及模块与模块之前的逻辑关系&lt;/p&gt;

&lt;p&gt;其实更多的时候 异步是一种没有办法的办法，也就是说异步是其它方案都解决不了的情况下才考虑的&lt;/p&gt;

&lt;h4 id=&#34;外链静态资源&#34;&gt;外链静态资源&lt;/h4&gt;

&lt;p&gt;尽量使用外链 CSS 和 JavaScript 资源，一方面便于缓存，减少服务同步输出的资源浪费。IE 6 里面会有一些可怪的 bug，比如有内联样式 style 标签的页面 A 如果在另外一个页面 B 中的 link 标签中引用，那么这段 style 会在 B 页面也起作用&lt;/p&gt;

&lt;h4 id=&#34;使用双协议的-url&#34;&gt;使用双协议的 URL&lt;/h4&gt;

&lt;p&gt;使用 &lt;code&gt;//&lt;/code&gt; 来代替&lt;code&gt;http:&lt;/code&gt; 和 &lt;code&gt;https:&lt;/code&gt; 浏览器会自动适应两种协议的资源访问，兼容性较好。注意 IE 8 下使用脚本更新 src 为双协议时会出现 bug，建议使用 &lt;code&gt;location.protocol&lt;/code&gt; 来判断然后做兼容处理&lt;/p&gt;

&lt;h4 id=&#34;删除元素默认属性&#34;&gt;删除元素默认属性&lt;/h4&gt;

&lt;p&gt;比如 script 标签默认的 type 就是 &lt;code&gt;text/javascript&lt;/code&gt;，如果 script 里面的内容是 JavaScript 时可以不用写 type。另外如果要在页面里面插入一段不需要浏览器解析的 HTML 片段时可以将 type 写成 &lt;code&gt;text/x-template&lt;/code&gt;（任意不存在的 type） 用于放置模板文件，通常用来在脚本中获取其 innerHTML 而无任何负作用&lt;/p&gt;

&lt;h4 id=&#34;给脚本控制元素加上类钩子&#34;&gt;给脚本控制元素加上类钩子&lt;/h4&gt;

&lt;p&gt;在脚本中取页面元素使用 &lt;code&gt;J-&lt;/code&gt; 前缀类名，与普通样式类分离。这样做会生成很多冗余的类名，但却很好的降低了样式和脚本的耦合，并且在重构和脚本职位分开团队里会是一条最佳实践&lt;/p&gt;

&lt;h3 id=&#34;css&#34;&gt;CSS&lt;/h3&gt;

&lt;h4 id=&#34;样式分类&#34;&gt;样式分类&lt;/h4&gt;

&lt;p&gt;所有页面只共享一个 sass Mixin，里面包含了基础的 sass 语法糖、常用类（清浮动、页面整体颜色字体等）&lt;/p&gt;

&lt;p&gt;模块级的样式分为两类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;与脚本无关的公共样式，单独在模块文件夹中组织。比如：按钮、标签页。全部放在 common 模块中维护&lt;/li&gt;
&lt;li&gt;与脚本相关的模块级样式，与对应模块脚本放在一起，可以引用 common 中的公共样式，但不可以被其它模块引用&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;雪碧图&#34;&gt;雪碧图&lt;/h4&gt;

&lt;p&gt;关于雪碧图 我经验是：永远不要想把所有的图标拼合在一起。按模块而不是按页面去拼 sprite 更合理，更方便维护，然后配合构建工具自动接合生成样式文件才是最好的解决方案。当然如果你的页面比较简单，那这条规则并不适用。说到这个问题我就得把珍藏多年的图片拿出来 show 一把，用事实来说明为什么把所有图片都拼在一张图上就一定是对的&lt;/p&gt;

&lt;p&gt;早期由于年轻笃信将所有的 icon 拼在一张图上才是完美的（图 1）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t1/5086/32/14021/18074/5bd9aac5Ebc40c4af/49594049c31b25fc.jpg&#34; alt=&#34;first-sprite&#34; /&gt;&lt;/p&gt;

&lt;p&gt;后来维护起来实在不方便，就把按钮全部单独接合起来。注意，当时的按钮都是图片，设计方面要求的很严格。加入购物车按钮做的也非常漂亮（图 2）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img12.360buyimg.com/devfe/jfs/t1/2093/9/14007/27625/5bd9aad6E57d81cc9/86c3e1eeec27378b.jpg&#34; alt=&#34;button-sprite&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后这些都不是最典型的，下面这个 promise icon 才是 （图 3）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/756/9/14108/8098/5bd9aae4Eeacfb483/e40340bb0624153a.jpg&#34; alt=&#34;promise-sprite&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图里面可以看到，这个功能在第一个版本的时候只有 7 个 icon，后来不断增加，最多的时候达到 77 个。以至于当时每周都会添加两个的频率&lt;/p&gt;

&lt;p&gt;同时这个 icon 当时接合的时候技术上也有问题：不应该把文字也切到图片里面，主要原因是早期 icon 比较少加上外边框样式对齐的问题综合选择了直接使用图片&lt;/p&gt;

&lt;p&gt;后来我就觉得这样是不对的。然后通过和产品的沟通，说明我的考虑以及新的解决方案后得到了认同。结果就是对图片不进行拼合，后台上传经过审核的不带文字 icon，文字由接口输出，然后在产品上做了约定：icon 最多不能超过 4 个，代码里也做了相应限制。这样就能保证页面上的请求数不会太多同时方便系统维护，问题得到了解决&lt;/p&gt;

&lt;h4 id=&#34;适当使用-datauri&#34;&gt;适当使用 DataURI&lt;/h4&gt;

&lt;p&gt;这个在一些小图片场景方面特别适合，比如 1*1 的占位图、loading 图等，不过 IE 6 并不支持这种写法，需要的时候可以加上一些兼容写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.ELazy-loading {
    background: url(data:image/gif;base64,R0lGODlhKwAeAJEAAP///93d3Xq9VAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFFAAAACwDAA0AJQADAAACEpSPAhDtHxacqcr5Lm416f1hBQAh+QQJFAAAACwDAA0AJQADAAACFIyPAcLtDKKcMtn1Mt3RJpw53FYAACH5BAkUAAAALAMADQAlAAMAAAIUjI8BkL0CoxQtrYrenPjcrgDbVAAAOw==) center center no-repeat;
    *background-image: url(//misc.360buyimg.com/lib/skin/e/i/loading-jd.gif);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;关于兼容性&#34;&gt;关于兼容性&lt;/h4&gt;

&lt;p&gt;兼容性可以说是前端工程师在平常开发中花费很大量无意义工作的地方。关于兼容性我想说的是 &lt;strong&gt;如果你不愿意去说服周围的人放弃或者让他们意识到兼容性是个不可能完全解决的问题，那么你就得为那些低级浏览器给你带来的痛苦埋单&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实更好的办法是你和设计、产品沟通然后给出一种分级支持的方案。把每种浏览器定义一个级别。然后在开发功能的时候以「渐进增强」的方式。通常来讲我们的解决方案是在低级浏览器里面保证流程正常进行、模块可以使用，但忽略一些无关紧要的错位、不透明等问题，在高级浏览器里面需要对设计稿进行精确还原，适当的加上一些井上添花在细节。比如微小的动画、逻辑细节上的处理等&lt;/p&gt;

&lt;p&gt;举个例子吧，下面这个进度条表示预约的人数，它是接口异步加载完才展示的。如果加载完就立即设置进度条宽度会显得生硬无趣，但是如果加上一点动画效果的话就好多了。然而问题又来了，如果加上动画那么逻辑上这个进度条应该是一点点的增加，对应的人数也应该是逐个增加。于是我就做了个优化，让人数在这段时间内均匀的增加。这个细节并不是很容易被人发现，但是这种设计会让用户感觉很用心而且有意思&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t1/5613/35/13921/17298/5bd9ab70Efe5844f3/aefc91f515f3624b.gif&#34; alt=&#34;pingou&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/5921/29/14048/22753/5bd9ab91E234a6510/34f54c051c998885.png&#34; alt=&#34;javascript-exec-sequence&#34; /&gt;&lt;/p&gt;

&lt;p&gt;单品页的脚本加载/执行顺序：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;等待页面准备就绪（DOM Ready）&lt;/li&gt;
&lt;li&gt;准备就绪后加载入口脚本（main.js），脚本负责其它功能模块的调度，动态接合模块通过 seajs 的 &lt;code&gt;require.async&lt;/code&gt; 方法异步调用&lt;/li&gt;
&lt;li&gt;公共模块（common.js）负责加初始化全局变量并挂载到 pageConfig 命名空间&lt;/li&gt;
&lt;li&gt;动态模块数组，这个是后端通过程序判断处理生成的一个模块名列表。一般只包含首屏需要加载的模块&lt;/li&gt;
&lt;li&gt;后加载模块（lazyinit.js）初始化，这个脚本只做一些页面滚动才加载的模块事件绑定。当模块出现在视口内再使用 require.async 异步加载模块的资源及初始化&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;入口脚本&#34;&gt;入口脚本&lt;/h4&gt;

&lt;p&gt;大致代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
* 模块入口（1. 公共脚本 2. 首屏模块资源 3. 非首屏「后加载模块」）
*/
var entries = [];

// 页面公共脚本样式
entries.push(&#39;common&#39;);
// 页面使用到的首屏模块(后端开发根据页面不同配置需要调用的模块)
entries = entries.concat(config.modules);
// 非首屏「后加载模块」
entries.push(&#39;lazyinit&#39;);

for (var i = 0; i &amp;lt; entries.length; i++) {
    entries[i] = &#39;MOD_ROOT/&#39; + entries[i] + &#39;/&#39; + entries[i];
}

if (/debug=show_modules/.test(location.href)) console.log(entries);

require.async(entries, function() {
    var modules = Array.prototype.slice.call(arguments);
    var len = modules.length;

    for (var i = 0; i &amp;lt; len; i++) {
        var module = modules[i];

        if (module &amp;amp;&amp;amp; typeof module.init === &#39;function&#39;) {
            module.init(config);
        } else {
            console.warn(&#39;Module[%s] must be exports a init function.&#39;, entries[i]);
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意模块路径中的 &lt;code&gt;MOD_ROOT&lt;/code&gt; 是提前在页面定义好的一个 seajs path。目的是为了把前端版本号更新的控制权释放给后端，从而解决了前后端依赖上线不同步造成的缓存延迟问题，配置脚本中只有几个定义好的路径：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;seajs.config({
    paths: {
        &#39;MISC&#39; : &#39;//misc.360buyimg.com&#39;,
        &#39;MOD_ROOT&#39; : &#39;//static.360buyimg.com/item/default/1.0.12/components&#39;,
        &#39;PLG_ROOT&#39; : &#39;//static.360buyimg.com/item/default/1.0.12/components/common/plugins&#39;,
        &#39;JDF_UI&#39;   : &#39;//misc.360buyimg.com/jdf/1.0.0/ui&#39;,
        &#39;JDF_UNIT&#39; : &#39;//misc.360buyimg.com/jdf/1.0.0/unit&#39;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一点，在测试环境的页面中版本号（上面代码中的 1.0.12 是一个全量的版本号）是后端从 URL 上动态读取的（使用参数访问就可以命中对应版本 &lt;code&gt;item.jd.com/sku.html?version=1.0.12&lt;/code&gt;）。这样以来测试环境上就可以并行测试不同版本的需求，而且互不影响。当然如果不同版本的后端代码也有修改的话这样是不行的，因为后端代码也需要有个对应的版本号&lt;/p&gt;

&lt;p&gt;不过我们已经解决了这个问题。后端会在测试环境里 &lt;strong&gt;动态加载后端模板&lt;/strong&gt; 并且可以做到版本号与前端一致。这样以来配合 git 方便的分支策略就可以同时并行开发测试多个需求，不用单独配多个测试环境。什么？你还在使用 SVN！哦。那当我没说过&lt;/p&gt;

&lt;h4 id=&#34;事件处理模型&#34;&gt;事件处理模型&lt;/h4&gt;

&lt;p&gt;客户端的 JavaScript 代码基本上都是事件驱动的，代码的加载解析依赖于浏览器提供的 DOM 事件。比如 onload, mouseover, scroll 等&lt;/p&gt;

&lt;p&gt;事件驱动的的模型特别适用于异步编程，而 JavaScript 天生就是异步，所有的异步操作行为都最终会在一个回调函数（callback）中触发&lt;/p&gt;

&lt;p&gt;比如单品页中价格接口，加载完成后需要更新 DOM 元素来展示实时价格；地区选择接口加载完成后会更新配送信息、库存/商品状态等，伪代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/* onPriceReady 和 onAreaChange 可以认为都是一个 Ajax 异步函数调用
 * code 1 和 code 2 执行到的时间是不确定先后顺序的
 */
/* prom.js */
onPriceReady(function(price) {
    // code 1
    $(&#39;#price&#39;).html(price);
});

/* address.js */
onAreaChange(function(area) {
    // code 2
    $(&#39;#stock&#39;).html(area.stockInfo);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的两段代码分别在两个脚本中维护，因为他们的逻辑相对独立。早期并没有关联关系。后来需求有变，他们之间需要共享一些对方的数据（切换地区后需要重新获取价格数据并展示）。但是物理上又不能放在一起通过使用全局变量的方式共享，而且它们都是异步加载接口后才取到数据的，并不好确定谁先谁后（非要做到那就只能用全局变量双向判断）。所以这样并不能很好的解决问题，而且代码的耦合度会成倍增加&lt;/p&gt;

&lt;p&gt;这时候我们引入了一种设计模式来解决这种问题 —— &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85&#34;&gt;发布者/订阅者&lt;/a&gt;，我们把这种模式抽象成了自定义事件代码来解决这一问题。这段代码是由 YUI 核心开发者 &lt;a href=&#34;https://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/&#34;&gt;Nicholas C. Zakas&lt;/a&gt; 实现的。代码很简单，事件对象主要有两个方法 &lt;code&gt;addListener(type, listener)&lt;/code&gt; 和 &lt;code&gt;fire(event)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;于是我们重构了上面的伪代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/* prom.js */
// 在代码中注册一个地区变化事件，获取变化后的地区 id
// 然后重新请求价格接口并展示
Event.addListener(&#39;onAreaChange&#39;, function(data) {
    getAreaPrice(data.areaIds)
});

onPriceReady(function(price) {
    $(&#39;#price&#39;).html(price);

    Event.fire({
        type: &#39;onPriceReady&#39;,
        data: &#39;Any data you want&#39;
    })
});

/* address.js */
onAreaChange(function(area) {
    $(&#39;#stock&#39;).html(area.stockInfo);

    // 在地区变化后除了做自己该做的事情以外
    // 触发一个名为 onAreaChange 的事件，用来
    // 通知其它订阅者事件完成，并传递地区相关参数
    // 这个时候在 onAreaChange Ajax 回调函数
    // 中就只需要关心自己的逻辑，其它模块的耦合关系
    // 交给它们自己通过订阅事件来处理
    Event.fire({
        type: &#39;onAreaChange&#39;,
        data: area.ids
    })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的一点是，&lt;strong&gt;必须确保事件先注册后触发执行&lt;/strong&gt;，也就是说先 addListener， 再 fire&lt;/p&gt;

&lt;h4 id=&#34;一些典型的性能优化点&#34;&gt;一些典型的性能优化点&lt;/h4&gt;

&lt;p&gt;基本上客户端的 JavaScript 性能问题都来自于 DOM 查找和遍历，在用于的时候一定要小心，可能不经意的一个操作就会损失很多性能，尤其在低端浏览器中。顺便多说一点，现代的 JavaScript 解释器本身是很快的，语言层面的性能问题很少遇到。DOM 查找慢是因为 浏览器给 JavaScript 访问页面提供的一套 DOM API 本身慢&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;缓存 DOM 查找，同时 DOM 查找不要超过 2000 个，低级浏览器会卡顿&lt;/li&gt;
&lt;li&gt;不要使用链式调用 find，如：&lt;code&gt;find(&#39;li&#39;).find(&#39;a&#39;)&lt;/code&gt; 而是 &lt;code&gt;find(&#39;li a&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在切换元素显示状态的时候，如果元素很多。优先使用 &lt;code&gt;show()/hide()&lt;/code&gt; 方法，而不是 &lt;code&gt;css(&#39;display&#39;, &#39;block/none&#39;)&lt;/code&gt; 前者有缓存，后者会强制触发 reflow&lt;/li&gt;
&lt;li&gt;给节点添加 &lt;code&gt;data-xx&lt;/code&gt; 属性在存放一些数据，通过使用 jQuery 的 &lt;code&gt;data(&#39;xx&#39;)&lt;/code&gt; 方法取更高效，减少 DOM 属性访问&lt;/li&gt;
&lt;li&gt;高密度事件（scroll, mousemove）触发场景请使用节流方法&lt;/li&gt;
&lt;li&gt;使用事件代理，而不是直接绑定。如果不确定代码被调用次数，可以先解除绑定再绑定具有命名空间的事件处理函数&lt;/li&gt;
&lt;li&gt;尽量少用 DOM 动画，使用 CSS 3 动画代替&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;前端工程化&#34;&gt;前端工程化&lt;/h2&gt;

&lt;h3 id=&#34;原由&#34;&gt;原由&lt;/h3&gt;

&lt;p&gt;前端工程化其实并不是最近两年才有的概念。大约在 2013 年的时候 Grunt 问世的时候就已经有所涉及。这类打包工具主要的目的是自动化一些开发流程，我最早使用 Grunt 来构建代码的时候只解决了三个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;合并压缩优化样式脚本&lt;/li&gt;
&lt;li&gt;上线完自动备份&lt;/li&gt;
&lt;li&gt;单个文件打包到多目录（历史原因一个文件线上的路径有两种，需要传两个目录）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当时我还在组内做过一个分享，有兴趣的可以去围观一下 &lt;a href=&#34;https://speakerdeck.com/keelii/best-workflow-with-grunt&#34;&gt;Best Workflow With Grunt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其实这些工具出现的原因是：当时前端领域的各种基础设施很缺乏，而前端的工作内容又相对零散。工作时需要开很多的软件。再加上 JavaScript 语言本身也很弱，就连包管理这种基础的东西也没有内置，以至于模块化要通过一些第三方类库来实现，比如：RequireJS, SeaJS&lt;/p&gt;

&lt;p&gt;工具的重要性可以在我之前的一个分享中找到 &lt;a href=&#34;https://speakerdeck.com/keelii/qian-duan-kai-fa-gong-ju&#34;&gt;前端开发工具系列&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;现状&#34;&gt;现状&lt;/h3&gt;

&lt;p&gt;如今前端工程的生态环境由于 NodeJS 的出现已经变得很好了。你可以根据自己的需求选一个合适的直接用到项目里面。像 Grunt, Gulp, browserify, webpack 等。不过要明白这些工具的出现从另一方面证明了前端开发天生存在很多的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTML 从诞生到 HTML 5 之前几乎没有任何变化，DOM 性能天生缺失。所以才有了 Virtual DOM 这种东西&lt;/li&gt;
&lt;li&gt;CSS 只是一门描述型的语言，没有变量、逻辑控制、语句。所以才出现了 Sass, Less 这种预编译工具&lt;/li&gt;
&lt;li&gt;JavaScript 号称「高阶的（high-level）、动态的（dynamic）、弱类型的（untyped）解释型（interpreted）编程语言，适合面向对象（oop）和函数式的（functional）编程风格」的编程语言，但是语言本身有很多问题（ES 6 之前）。不适合大型项目的开发、没有一些高级特性的支持、同时被其它语言诟病的 callback 风格、单线程执行等。所以才出现了像 TypeScript, Babel 这种编译成 JavaScript 代码的语言&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些问题几乎都是历史性的原因和兼容性因素造成的。作为一名好的前端工程师要看清楚现状，然后按自己项目的需求去定制一些前端工程化的方案，而不是随波逐流。&lt;/p&gt;

&lt;h3 id=&#34;选择&#34;&gt;选择&lt;/h3&gt;

&lt;p&gt;其实现在自己开发一套前端工程化/自动化流程的成本已经很低了，你只需要学习一些 NodeJS 的知识，配合 NPM 包管理机制，随手就搞出一个构建工具出来。因为并不需要你去实现什么东西，所有的东西都有现成的包。脚本压缩有 UglifyJS，CSS 优化有 CSS-min，图片压缩优化有 PNG-quant 等等。你只需要想清楚自己要达到什么目的，解决什么问题就可以抄家伙自己写一套工作流出来&lt;/p&gt;

&lt;p&gt;我自己的经历也从 Grunt, GulpJS 到现在自造轮子。自己根据需求开发出来一套集成的打包工具，有兴趣的可以去围观一下 &lt;a href=&#34;https://github.com/keelii/wo&#34;&gt;Wooo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然你也可以不用任何打包工具，自己写一些 NPM Script 来完全定制化项目开发/测试/打包流程。我猜这也是为什么现在类似 Grunt 不再那么火，Gulp 迟迟没有发布 4.0 版本的原因。写一个构建工具的成本太低了，而且这种集成的工具很难满足差异的开发需求。君不知已有人意识到了这一点么&lt;a href=&#34;https://medium.freecodecamp.com/why-i-left-gulp-and-grunt-for-npm-scripts-3d6853dd22b8&#34;&gt;why-i-left-gulp-and-grunt-for-npm-scripts&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;程序-设计-产品&#34;&gt;程序、设计、产品&lt;/h2&gt;

&lt;p&gt;我始终认为程序、设计是为了产品服务的。好的产品是要重视设计的，好的（前端）工程师是要有一些审美素养&lt;/p&gt;

&lt;p&gt;其实很多时候技术解决方案都是要根据产品的定位来设计的，了解产品需求以后才能定制出真正合适的高效的解决方案。好比前面讲到的那个 sprite 案例，如果一开始就和产品讨论好方案后来也不可能有那种失控的情况发生。在产品形成/上线前期能发现问题比上线后发现问题更容易解决&lt;/p&gt;

&lt;p&gt;这部分内容和代码无关，就不多说了。然而早年我还有一次分享关于&lt;a href=&#34;https://speakerdeck.com/keelii/qian-duan-,gai-bian-front%5Bnil%5Dend-makes-change&#34;&gt;前端、改变&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;关于单品页的前端开发本篇文章只是冰山一角，还有很多没有提及，每个小东西都可以单独写一篇文章来分享。随后希望可以有更多的总结和分享&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>