<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Something</title>
    <link>https://keelii.github.io/tags/javascript/atom/index.xml</link>
    <description>Recent content on Something</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <atom:link href="https://keelii.github.io/tags/javascript/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>TrimPath 模板引擎使用指南</title>
      <link>https://keelii.github.io/2016/11/21/trimpath-template-engine/</link>
      <pubDate>Mon, 21 Nov 2016 12:39:49 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/11/21/trimpath-template-engine/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.summitdowntown.org/site_media/media/javascript/private/trimpath-template-docs/JavaScriptTemplates.html&#34;&gt;TrimPath&lt;/a&gt; 是一款轻量级的前端 JavaScript 模板引擎，语法类似 &lt;a href=&#34;http://freemarker.org/&#34;&gt;FreeMarker&lt;/a&gt;, &lt;a href=&#34;https://velocity.apache.org/&#34;&gt;Velocity&lt;/a&gt;，主要用于方便地渲染 json 数据
&lt;/p&gt;

&lt;h2 id=&#34;语法-syntax&#34;&gt;语法 Syntax&lt;/h2&gt;

&lt;h3 id=&#34;表达式-expressions&#34;&gt;表达式 Expressions&lt;/h3&gt;

&lt;p&gt;表达式和修饰符（其它模板语言中叫做过滤器 filter）中间用 &lt;code&gt;|&lt;/code&gt; 分割且 &lt;strong&gt;不能有空格&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${expr}
${expr|modifier}
${expr|modifier1:arg1,arg2|modifier2:arg1,arg2|...|modifierN:arg1,arg2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;语句-statements&#34;&gt;语句 Statements&lt;/h3&gt;

&lt;h4 id=&#34;控制流-control-flow&#34;&gt;控制流 Control Flow&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{if testExpr}
    {elseif testExpr}
    {else}
{/if}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;循环-loops&#34;&gt;循环 Loops&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{for varName in listExpr}
{/for}

{for varName in listExpr}
    ...循环主体...
{forelse}
    ...当 listExpr 是 null 或者 length 为 0 ...
{/for}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;变量声明-variable-declarations&#34;&gt;变量声明 Variable Declarations&lt;/h4&gt;

&lt;p&gt;变量声明语句用花括号 &lt;code&gt;{}&lt;/code&gt; 括起来，不需要关闭。类似 JavaScript 中的赋值语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{var varName}
{var varName = varInitExpr}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;宏声明-macro-declarations&#34;&gt;宏声明 Macro Declarations&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{macro macroName(arg1, arg2, ...argN)}
    ...macro 主体...
{/macro}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;cdata-部分-cdata-text-sections&#34;&gt;CDATA 部分 CDATA Text Sections&lt;/h4&gt;

&lt;p&gt;CDATA 部分用来告诉模板引擎不用做任何解析渲染，直接输出。比如展示一个模板字符串本身&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{cdata}
    ${customer.firstName} ${customer.lastName}
{/cdata}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;in-line-javascript&#34;&gt;In-line JavaScript&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;eval blocks&lt;/strong&gt; 用来执行 JavaScript 代码片段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{eval}
    ...模板渲染的时候执行的 JavaScript 代码...
{/eval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;minify blocks&lt;/strong&gt; 用来压缩内容中的换行符，比如压缩 HTML 属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;commentPanel&amp;quot; style=&amp;quot;{minify}
      display:none;
      margin: 1em;
      border: 1px solid #333;
      background: #eee;
      padding: 1em;
    {/minify}&amp;quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;修饰符-modifier&#34;&gt;修饰符 Modifier&lt;/h2&gt;

&lt;p&gt;修饰符用来处理上一个表达式的结果，并输出内容。类似于 Linux shell 中的 pipe 命名，可以串联&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${name|capitalize}
${name|default:&amp;quot;noname&amp;quot;|capitalize}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;内置修饰符&#34;&gt;内置修饰符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;capitalize&lt;/strong&gt; 返回大写内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;default:valueWhenNull&lt;/strong&gt; 如果内容为 null，返回 valueWhenNull&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;eat&lt;/strong&gt; 返回空内容，一般用于表达式求值后又不想展示输出的内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;escape&lt;/strong&gt; 转换 HTML 字符实体，比如： &amp;amp; 转换成 &amp;amp;amp;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;h&lt;/strong&gt; 和 escape 效果一样&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;自定义修饰符&#34;&gt;自定义修饰符&lt;/h3&gt;

&lt;p&gt;算定义修饰符可以持载到 contextObject 上的 &lt;code&gt;_MODIFIERS&lt;/code&gt; 属性上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Modifiers = { toFixed: function(n, num) { return n.toFixed(num) } }
var out = &#39;{var nu = 12}${nu|toFixed:2}&#39;.process({ _MODIFIERS: Modifiers });
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;宏-macro&#34;&gt;宏 Macro&lt;/h2&gt;

&lt;p&gt;macro 一般用来封装可复用 HTML 模板，类似函数的功能。对于每个模板来说 macro 是私用的。如果想公用 macro，可以保存 macro 引用到 contextObject 上。比如：在调用 process() 方法之前设置 &lt;code&gt;contextObject[&#39;exported&#39;] = {}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{macro link(href, name)}
    &amp;lt;a href=&amp;quot;${href}&amp;quot;&amp;gt;${name}&amp;lt;/a&amp;gt;
{/macro}

${link(&#39;http://google.com&#39;, &#39;google&#39;)}      =&amp;gt; &amp;lt;a href=&amp;quot;http://google.com&amp;quot;&amp;gt;google&amp;lt;/a&amp;gt;
${link(&#39;http://facebook.com&#39;, &#39;facebook&#39;)}  =&amp;gt; &amp;lt;a href=&amp;quot;http://facebook.com&amp;quot;&amp;gt;facebook&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var data = {
    name: &#39;iPhone 6 Plus&#39;,
    weight: 480,
    ram: &#39;16gb&#39;,
    networks: [
        &#39;移动（TD-LTE)&#39;,
        &#39;联通(TD-LTE)&#39;,
        &#39;电信(FDD-LTE)&#39;
    ]
}

data._MODIFIERS = {
    toFixed: function(n, num) {
        return n.toFixed(num)
    }
}

var template = &#39;\
名称: ${name}&amp;lt;br&amp;gt;\
重量：${weight|toFixed:2}&amp;lt;br&amp;gt;\
内存：${ram|capitalize}&amp;lt;br&amp;gt;\
网络：\
{for item in networks}\
  {if item_index!=0}|{/if}\
  ${item}\
{/for}&#39;;

template.process(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;名称: iPhone 6 Plus&amp;lt;br&amp;gt;
重量：480.00&amp;lt;br&amp;gt;
内存：16GB&amp;lt;br&amp;gt;
网络：
  移动（TD-LTE)
 | 联通(TD-LTE)
 | 电信(FDD-LTE)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>JavaScript 节流函数 throttle 详解</title>
      <link>https://keelii.github.io/2016/06/11/javascript-throttle/</link>
      <pubDate>Sat, 11 Jun 2016 06:52:57 +0800</pubDate>
      
      <guid>https://keelii.github.io/2016/06/11/javascript-throttle/</guid>
      <description>&lt;p&gt;在浏览器 DOM 事件里面，有一些事件会随着用户的操作不间断触发。比如：重新调整浏览器窗口大小（resize），浏览器页面滚动（scroll），鼠标移动（mousemove）。也就是说用户在触发这些浏览器操作的时候，如果脚本里面绑定了对应的事件处理方法，这个方法就不停的触发。&lt;/p&gt;

&lt;p&gt;
这并不是我们想要的，因为有的时候如果事件处理方法比较庞大，DOM 操作比如复杂，还不断的触发此类事件就会造成性能上的损失，导致用户体验下降（UI 反映慢、浏览器卡死等）。所以通常来讲我们会给相应事件添加延迟执行的逻辑。&lt;/p&gt;

&lt;p&gt;通常来说我们用下面的代码来实现这个功能：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var COUNT = 0;
function testFn() { console.log(COUNT++); }
// 浏览器resize的时候
// 1. 清除之前的计时器
// 2. 添加一个计时器让真正的函数testFn延后100毫秒触发
window.onresize = function () {
    var timer = null;
    clearTimeout(timer);

    timer = setTimeout(function() {
        testFn();
    }, 100);
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;细心的同学会发现上面的代码其实是错误的，这是新手会犯的一个问题：setTimeout 函数返回值应该保存在一个相对全局变量里面，否则每次 resize 的时候都会产生一个新的计时器，这样就达不到我们发的效果了&lt;/p&gt;

&lt;p&gt;于是我们修改了代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var timer = null;
window.onresize = function () {
    clearTimeout(timer);
    timer = setTimeout(function() {
        testFn();
    }, 100);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候代码就正常了，但是又多了一个新问题 —— 产生了一个全局变量 timer。这是我们不想见到的，如果这个页面还有别的功能也叫 timer 不同的代码之前就是产生冲突。为了解决这个问题我们要用 JavaScript 的一个语言特性：&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&#34;&gt;闭包&lt;/a&gt; closures 。相关知识读者可以去 MDN 中了解，改造后的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * 函数节流方法
 * @param Function fn 延时调用函数
 * @param Number delay 延迟多长时间
 * @return Function 延迟执行的方法
 */
var throttle = function (fn, delay) {
    var timer = null;

    return function () {
        clearTimeout(timer);
        timer = setTimeout(function() {
            fn();
        }, delay);
    }
};
window.onresize = throttle(testFn, 200, 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们用一个闭包函数（throttle节流）把 timer 放在内部并且返回延时处理函数，这样以来 timer 变量对外是不可见的，但是内部延时函数触发时还可以访问到 timer 变量。&lt;/p&gt;

&lt;p&gt;当然这种写法对于新手来说不好理解，我们可以变换一种写法来理解一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var throttle = function (fn, delay) {
    var timer = null;

    return function () {
        clearTimeout(timer);
        timer = setTimeout(function() {
            fn();
        }, delay);
    }
};

var f = throttle(testFn, 200);
window.onresize = function () {
    f();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里主要了解一点：throttle 被调用后返回的 function 才是真正的 onresize 触发时需要调用的函数&lt;/p&gt;

&lt;p&gt;现在看起来这个方法已经接近完美了，然而实际使用中并非如此。举个例子：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果用户 &lt;strong&gt;不断的&lt;/strong&gt; resize 浏览器窗口大小，这时延迟处理函数一次都不会执行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;于是我们又要添加一个功能：当用户触发 resize 的时候应该 &lt;strong&gt;在某段时间&lt;/strong&gt; 内至少触发一次，既然是在某段时间内，那么这个判断条件就可以取当前的时间毫秒数，每次函数调用把当前的时间和上一次调用时间相减，然后判断差值如果大于 &lt;strong&gt;某段时间&lt;/strong&gt; 就直接触发，否则还是走 timeout 的延迟逻辑。&lt;/p&gt;

&lt;p&gt;下面的代码里面需要指出的是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;previous 变量的作用和 timer 类似，都是记录上一次的标识，必须是相对的全局变量&lt;/li&gt;
&lt;li&gt;如果逻辑流程走的是“至少触发一次”的逻辑，那么函数调用完成需要把 previous 重置成当前时间，简单来说就是：相对于下一次的上一次其实就是当前&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * 函数节流方法
 * @param Function fn 延时调用函数
 * @param Number delay 延迟多长时间
 * @param Number atleast 至少多长时间触发一次
 * @return Function 延迟执行的方法
 */
var throttle = function (fn, delay, atleast) {
    var timer = null;
    var previous = null;

    return function () {
        var now = +new Date();

        if ( !previous ) previous = now;

        if ( now - previous &amp;gt; atleast ) {
            fn();
            // 重置上一次开始时间为本次结束时间
            previous = now;
        } else {
            clearTimeout(timer);
            timer = setTimeout(function() {
                fn();
            }, delay);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实践：&lt;/p&gt;

&lt;p&gt;我们模拟一个窗口 scroll 时节流的场景，也就是说当用户滚动页面向下的时候我们需要节流执行一些方法，比如：计算 DOM 位置等需要连续操作 DOM 元素的动作&lt;/p&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;throttle&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div style=&amp;quot;height:5000px&amp;quot;&amp;gt;
        &amp;lt;div id=&amp;quot;demo&amp;quot; style=&amp;quot;position:fixed;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
    var COUNT = 0, demo = document.getElementById(&#39;demo&#39;);
    function testFn() {demo.innerHTML += &#39;testFN 被调用了 &#39; + ++COUNT + &#39;次&amp;lt;br&amp;gt;&#39;;}

    var throttle = function (fn, delay, atleast) {
        var timer = null;
        var previous = null;

        return function () {
            var now = +new Date();

            if ( !previous ) previous = now;
            if ( atleast &amp;amp;&amp;amp; now - previous &amp;gt; atleast ) {
                fn();
                // 重置上一次开始时间为本次结束时间
                previous = now;
                clearTimeout(timer);
            } else {
                clearTimeout(timer);
                timer = setTimeout(function() {
                    fn();
                    previous = null;
                }, delay);
            }
        }
    };
    window.onscroll = throttle(testFn, 200);
    // window.onscroll = throttle(testFn, 500, 1000);
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们用两个 case 来测试效果，分别是添加至少触发 atleast 参数和不添加：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// case 1
window.onscroll = throttle(testFn, 200);
// case 2
window.onscroll = throttle(testFn, 200, 500);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;case 1&lt;/strong&gt; 的表现为：在页面滚动的过程（不能停止）中 testFN 不会被调用，直到停止的时候会调用一次，也就是说执行的是 throttle 里面 &lt;strong&gt;最后&lt;/strong&gt; 一个 setTimeout ，效果如图（查看原 gif 图）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/16030022/43a9b794-3220-11e6-9f41-554bb6876303.gif&#34; alt=&#34;case1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;case 2&lt;/strong&gt; 的表现为：在页面滚动的过程（不能停止）中 testFN 第一次会延迟 500ms 执行（来自至少延迟逻辑），后来至少每隔 500ms 执行一次，效果如图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/458894/16030023/43aa1d92-3220-11e6-9987-aa14f2bce83e.gif&#34; alt=&#34;case2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;至此为止，我们想要实现的效果已经基本完成。后续的一些辅助性优化读者可以自己琢磨，如：函数 this 指向，返回值保存等。&lt;/p&gt;

&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;测试代码 &lt;a href=&#34;http://jsbin.com/tanuxegija/edit&#34;&gt;http://jsbin.com/tanuxegija/edit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;完整版本代码 &lt;a href=&#34;http://jsbin.com/jigozuvuko&#34;&gt;http://jsbin.com/jigozuvuko&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Debounce VS throttle &lt;a href=&#34;https://github.com/dcorb/debounce-throttle&#34;&gt;https://github.com/dcorb/debounce-throttle&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
  </channel>
</rss>