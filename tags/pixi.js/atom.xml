<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>pixi.js on 臨池不輟</title>
    <link>https://keelii.com/tags/pixi.js/</link>
    <description>Recent content in pixi.js on 臨池不輟</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 17 Mar 2019 19:20:04 -0700</lastBuildDate>
    
        <atom:link href="https://keelii.com/tags/pixi.js/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用 Pixi.js 构建一个视差滚动器（第二篇）</title>
      <link>https://keelii.com/2019/03/17/building-a-parallax-scroller-with-pixijs-cn-2/</link>
      <pubDate>Sun, 17 Mar 2019 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2019/03/17/building-a-parallax-scroller-with-pixijs-cn-2/</guid>
      <description>

&lt;h2 id=&#34;翻译对照&#34;&gt;翻译对照&lt;/h2&gt;

&lt;p&gt;原文：
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5226&#34;&gt;PART 1&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5666&#34;&gt;PART 2&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=6496&#34;&gt;PART 3&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=7046&#34;&gt;PART 4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译文：
&lt;a href=&#34;https://keelii.com/2019/03/16/building-a-parallax-scroller-with-pixijs-cn-1/&#34;&gt;第一篇&lt;/a&gt;・
&lt;a href=&#34;https://keelii.com/2019/03/17/building-a-parallax-scroller-with-pixijs-cn-2/&#34;&gt;第二篇&lt;/a&gt;・
第三篇・
第四篇&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;关注 &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=chriscaleb&#34;&gt;@chriscaleb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个系列的教程已经更新到了 &lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PixiJS v4&lt;/a&gt; 版本。&lt;/p&gt;

&lt;p&gt;在这个系列教程中我们将探索如何构建一个类似 &lt;a href=&#34;http://www.adamatomic.com/canabalt/&#34;&gt;Canabalt&lt;/a&gt; 和 &lt;a href=&#34;https://chrome.google.com/webstore/detail/monster-dash/cknghehebaconkajgiobncfleofebcog?hl=en&#34;&gt;Monster Dash&lt;/a&gt; 的视差滚动地图游戏界面。第一篇介绍了 pixi.js 的渲染引擎并且涉及到了视差滚动的基础知识。现在我们将在上一篇的基础之上添加 &lt;strong&gt;视口&lt;/strong&gt; 的概念。&lt;/p&gt;

&lt;h3 id=&#34;你将学到什么&#34;&gt;你将学到什么…&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如何扩展 pixi.js 的 &lt;strong&gt;展示对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;JavaScript 中的面向对象基础（译者使用 ES 6 Class 重构了这个游戏 &lt;a href=&#34;https://github.com/keelii/parallax-scroller-cn&#34;&gt;源代码&lt;/a&gt;，看起来更直观）&lt;/li&gt;
&lt;li&gt;如何在你的滚动器中添加 &lt;strong&gt;视口&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;预备知识&#34;&gt;预备知识…&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;对面向对象有基本的概念&lt;/li&gt;
&lt;li&gt;pixi.js 基础&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你将以第一篇教程中的代码为基础，或者直接下载上篇教程中的 &lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5226&#34;&gt;源代码&lt;/a&gt;，另外整个教程的完全源代码也在 &lt;a href=&#34;https://github.com/ccaleb/pixi-parallax-scroller/tree/master/tutorial-2&#34;&gt;github&lt;/a&gt; 上可以找到。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yeahbutisitflash.com/pixi-parallax-scroller/tutorial-1/index.html&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/25206/13/10616/142679/5c887df7E7c1fa38a/eab39f5f7ab1cc6d.png&#34; alt=&#34;ps-tut1-screenshot1&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作为提示，点击上面的图片，将会加载当前版本的视差滚动，目前来说只有两个层，我们将添加每三个更复杂的层。与此同时，我们将通过添加视口的概念来添加第三层。我们还会执行一些重要代码重构，以便将滚动器封装在类中。&lt;/p&gt;

&lt;p&gt;虽然本教程非常针对那些对面向对象有基础概念的初学者级别，如这些概念让您感到不舒服，也不用担心，因为我仍然会为那些不熟悉这些枞的的人提供足够的指导。&lt;/p&gt;

&lt;h2 id=&#34;起步&#34;&gt;起步&lt;/h2&gt;

&lt;p&gt;如果你还没有看过第一篇教程，我建议你应该从那篇开始。&lt;/p&gt;

&lt;p&gt;还有一点值得提醒的是，为了能够测试你的代码，你需要开启一个本地的 web 服务器。如果你还没有做这一步，那么可能参考上一篇教程中的章节建立好自己的 web 服务器。&lt;/p&gt;

&lt;h2 id=&#34;扩展-pixi-js-的-展示对象&#34;&gt;扩展 pixi.js 的 &lt;strong&gt;展示对象&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;正如我们之前发现的，pixi.js 提供了几种可使用的 &lt;strong&gt;展示对象&lt;/strong&gt; 类型。如果你还记得的话，我们在使用 &lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt; 来满足我们的需求之前，先简单地使用了 &lt;code&gt;PIXI.Sprite&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这两个类共享许多公用的功能。例如，它们都为您提供位置（position），宽度（width），高度（height）和 alpha 属性。此外，两者都可以通过 &lt;code&gt;addChild()&lt;/code&gt; 方法添加到容器中。事实上，&lt;code&gt;PIXI.Container&lt;/code&gt; 类本身就是一个 &lt;strong&gt;展示对象&lt;/strong&gt;，它还提供了许多 Sprite 和 TilingSprite 类都能使用的属性。&lt;/p&gt;

&lt;p&gt;所有这些公用的功能都来自于 &lt;strong&gt;继承（inheritance）&lt;/strong&gt; 的魔力。它使得类可以继承和扩展功能到其它类上。为了让你能理解它，可以参考下面的示意图，它将为你展示 pixi.js 中提供的大多数展示对象&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/32241/35/6163/21482/5c8c93a6E0674998d/e778a3262a7f0f86.png&#34; alt=&#34;ps-tut2-screenshot1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从上面的示意图中，我们可以看出最基础的类型是 PIXI.DisplayObject 类，所有其它类都从它继承而来。这个类是将对象呈现到屏幕所必须需的元素。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当我说 &lt;strong&gt;展示对象&lt;/strong&gt; 时，并非指 &lt;code&gt;PIXI.DisplayObject&lt;/code&gt; 这个类。而当使用 &lt;code&gt;PIXI.DisplayObject&lt;/code&gt; 这个说法时，却表示所有继承自它的对象。本质上讲，当我使用 &lt;strong&gt;展示对象&lt;/strong&gt; 这一术语时，我指的是可以通过 pixi.js 呈现给屏幕的 &lt;strong&gt;任何对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下一层是 &lt;code&gt;PIXI.Container&lt;/code&gt;，它允许对象充当其他展示对象的 &lt;strong&gt;容器&lt;/strong&gt;。我们在第一个教程中使用的 &lt;code&gt;addChild()&lt;/code&gt; 方法是 &lt;code&gt;PIXI.Container&lt;/code&gt; 这个类提供的实例方法，也可以通过 &lt;code&gt;PIXI.Sprite&lt;/code&gt; 和 &lt;code&gt;PIXI.TilingSpite&lt;/code&gt; 继承获得。&lt;/p&gt;

&lt;p&gt;本质上讲，继承树中的每个类都是它继承的（父）类的 &lt;strong&gt;更特殊&lt;/strong&gt; 版本（译者：面向对象的 &lt;strong&gt;具体化&lt;/strong&gt; 与 &lt;strong&gt;泛化&lt;/strong&gt; 概念）。好的一点是我们可以使用继承来创建我们自己的自定义的展示对象。换而言之，我们可以为每个视差滚动器中的元素编写专用的类，并让 pixi.js 处理它们就像是处理其它展示对象一样。这给使我们封装代码更简单，代码也更多漂亮、整洁。&lt;/p&gt;

&lt;h3 id=&#34;制作远景层展示对象&#34;&gt;制作远景层展示对象&lt;/h3&gt;

&lt;p&gt;让我们开始制作远景层吧。&lt;/p&gt;

&lt;p&gt;打开index.html文件，在 &lt;code&gt;init()&lt;/code&gt; 函数中查找创建和设置图层的代码。这是你要找的东西：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);	
far = new PIXI.extras.TilingSprite(farTexture, 512, 256);
far.position.x = 0;
far.position.y = 0;
far.tilePosition.x = 0;
far.tilePosition.y = 0;
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理想的情况是，我们可以创建一个代表远景层的类，并把大部分实现细节隐藏在类中。因此，我们希望找到以下代码，而不是上面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new Far();
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码量大幅减少了吧？另外，我认为它比我们原来的尝试更具可读性。&lt;/p&gt;

&lt;p&gt;我们通过创建一个代表我们的滚动条远景层的名为 Far 的类来实现这一目标。在项目的根文件夹中创建一个新文件，并将其命名为 &lt;code&gt;Far.js&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;现在定义一个名为 Far 的函数，它将表示我们类的构造函数：&lt;/p&gt;

&lt;p&gt;（译者：原作者使用了 ES 5 和 prototype 来实现 JavaScript 中的继承，看起来可能没那么直观，可以参考我自己实现的 &lt;a href=&#34;https://github.com/keelii/parallax-scroller-cn&#34;&gt;ES 6 版&lt;/a&gt;的代码）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far(texture, width, height) {
  PIXI.extras.TilingSprite.call(this, texture, width, height);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在构造函数下面添加以下行，然后保存文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码继承了 &lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt; 类的功能。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;构造函数是一种特殊类型的函数，用于创建类实例。在 JavaScript 中，构造函数的名称也用于指定类的名称（译者：ES 6 中的类有专门的 construct 方法）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么为什么 Far 类继承自 &lt;code&gt;PIXI.TilingSprite&lt;/code&gt; 呢？好吧，如果你还记得第一个教程，我们使用 &lt;code&gt;TilingSprite&lt;/code&gt; 实例来表示每个视差层。因此，在更具体化的类中使用这些功能是有必要的。本质上讲，我们所说的是：Far 类是 &lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt; 的一个更特殊的版本。&lt;/p&gt;

&lt;p&gt;因为 Far 类继承自 &lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt;，所以我们要记得去初始化&lt;code&gt;TilingSprite&lt;/code&gt; 类的功能。这是通过从构造函数中调用 &lt;code&gt;TilingSprite&lt;/code&gt; 的构造函数来完成的。我高亮显示了以下代码行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far(texture, width, height) {
  PIXI.extras.TilingSprite.call(this, texture, width, height); // 这一行
}

Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做是因为我们希望 Far 类继承 &lt;code&gt;TilingSprite&lt;/code&gt; 的所有功能。由于 &lt;code&gt;TilingSprite&lt;/code&gt; 需要将三个参数传递给它的构造函数，我们需要确保我们自己的类也接受这些参数并使用它们初始化瓦片精灵。以下是高亮显示参数的类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 注意 texture, width, height 三个参数
function Far(texture, width, height) {
  PIXI.extras.TilingSprite.call(this, texture, width, height);
}

Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还有一些额外的功能可以添加 Far 类中，但实际上已经可以开始将它集成到 &lt;code&gt;index.html&lt;/code&gt; 页面中了。&lt;/p&gt;

&lt;h3 id=&#34;实例化你的远景-far-层类&#34;&gt;实例化你的远景（Far）层类&lt;/h3&gt;

&lt;p&gt;返回你的 &lt;code&gt;index.html&lt;/code&gt; 页面。&lt;/p&gt;

&lt;p&gt;要使用 Far 类，您需要引用它的源文件。在页面正文顶部附近添加以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body onload=&amp;quot;init();&amp;quot;&amp;gt;
  &amp;lt;div align=&amp;quot;center&amp;quot;&amp;gt;
    &amp;lt;canvas id=&amp;quot;game-canvas&amp;quot; width=&amp;quot;512&amp;quot; height=&amp;quot;384&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script src=&amp;quot;Far.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;!--这里--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在向下滚动并删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
far = new PIXI.extras.TilingSprite(farTexture, 512, 256);  // 删除此行
far.position.x = 0;
far.position.y = 0;
far.tilePosition.x = 0;
far.tilePosition.y = 0;
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
far = new Far(farTexture, 512, 256);  // 新行
far.position.x = 0;
far.position.y = 0;
far.tilePosition.x = 0;
far.tilePosition.y = 0;
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好吧，我承认。目前这似乎并没有太大的改进，但我们现在可以开始在 Far 类中直接隐藏更多代码，让我们继续吧。&lt;/p&gt;

&lt;h3 id=&#34;封装位置相关代码&#34;&gt;封装位置相关代码&lt;/h3&gt;

&lt;p&gt;在 &lt;code&gt;index.html&lt;/code&gt; 中，我们当前设置了 far 层的 &lt;code&gt;position&lt;/code&gt; 和 &lt;code&gt;tilePosition&lt;/code&gt; 属性。让我们删除它，并将其封装在我们的 Far 类中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
far = new Far(farTexture, 512, 256);
far.position.x = 0;  // 删除
far.position.y = 0;  // 删除
far.tilePosition.x = 0;  // 删除
far.tilePosition.y = 0;  // 删除
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存更改并打开 Far.js 文件。现在直接在类的构造函数中设置图层的位置和tilePosition 属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far(texture, width, height) {
  PIXI.extras.TilingSprite.call(this, texture, width, height);
	
  this.position.x = 0;
  this.position.y = 0;
  this.tilePosition.x = 0;
  this.tilePosition.y = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不熟悉面向对象的 JavaScript 或面向对象编程，那么你可能会好奇 &lt;code&gt;this&lt;/code&gt; 关键字在上面的代码中的用途是什么。基本上可以这么理解，它可以让你引用类的已创建实例。通过 &lt;code&gt;this&lt;/code&gt;，我们可以引用该实例的所有 &lt;strong&gt;属性&lt;/strong&gt; 和 &lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;因为 Far 类继承自 &lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt;，它还具有 &lt;code&gt;TilingSprite&lt;/code&gt; 的所有 &lt;strong&gt;属性&lt;/strong&gt; 和 &lt;strong&gt;方法&lt;/strong&gt;，包括 &lt;code&gt;position&lt;/code&gt; 和 &lt;code&gt;tilePosition&lt;/code&gt;。要访问这些属性，我们只需使用&lt;code&gt;this&lt;/code&gt; 关键字。这是再次设置图层 x 位置的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.position.x = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还应注意，&lt;code&gt;this&lt;/code&gt; 关键字还用于引用新添加到类中的属性或方法。&lt;/p&gt;

&lt;p&gt;现在保存更改并在浏览器中测试代码。一切都应按预期运行。另外，请查看 Chrome 的 JavaScript 控制台，确保没有错误。&lt;/p&gt;

&lt;h3 id=&#34;封装层的纹理&#34;&gt;封装层的纹理&lt;/h3&gt;

&lt;p&gt;好的，我们应该从哪里开始呢。如果你回顾一下 index.html 页面，你应该看到代码好像开始变得更加简洁了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);	
far = new Far(farTexture, 512, 256);
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但仍有改进的余地。毕竟，如果我们可以直接在 Far 类中隐藏我们的定位代码，那么为什么我们不能把纹理的逻辑也放在 Far 类中呢？&lt;/p&gt;

&lt;p&gt;切换到 &lt;code&gt;Far.js&lt;/code&gt; 文件并在构造函数的开头添加一行以创建图层的纹理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far(texture, width, height) {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;); // 添加
  PIXI.extras.TilingSprite.call(this, texture, width, height);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在显式地将纹理的宽度和高度传递给 &lt;code&gt;TilingSprite&lt;/code&gt; 的构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far(texture, width, height) {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
  PIXI.extras.TilingSprite.call(this, texture, 512, 256); // 512, 256
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们现在直接在类中处理纹理，因此实际上不需要将纹理，宽度和高度参数传递给构造函数。删除所有三个参数并保存您的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far(texture, width, height) { // 删除 texture, width, height
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你的构造函数现在应该是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far() {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
  PIXI.extras.TilingSprite.call(this, texture, 512, 256);

  this.position.x = 0;
  this.position.y = 0;
  this.tilePosition.x = 0;
  this.tilePosition.y = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;剩下要做的就是返回到你的 index.html 文件并删除我们之前创建的纹理并传递给 far的构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
far = new Far(farTexture, 512, 256);
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new Far();
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比以前简洁了，对吧？我们所有层的丑陋实现细节现在都安全地隐藏在 Far 类中。&lt;/p&gt;

&lt;p&gt;保存 index.html 和 Far.js ，然后在 Chrome 中测试最新版本的代码。&lt;/p&gt;

&lt;h3 id=&#34;同样的方法重构中间层&#34;&gt;同样的方法重构中间层&lt;/h3&gt;

&lt;p&gt;我花了一些时间引导你完成创建 Far类所需的步骤。该类继承自&lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt;，其行为与任何其他 pixi.js 展示对象相同。虽然我们尚未完成，但我们将暂时停止一下并应用我们学到的知识来创建一个代表视差滚动器中的中间层（Mid）的类。&lt;/p&gt;

&lt;p&gt;创建一个名为 &lt;code&gt;Mid.js&lt;/code&gt; 的新文件，并开始向其添加以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mid() {
}

Mid.prototype = Object.create(PIXI.extras.TilingSprite.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样在构造函数中，创建中间层的纹理并设置其定位属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mid() {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;);
  PIXI.extras.TilingSprite.call(this, texture, 512, 256);

  this.position.x = 0;
  this.position.y = 128;
  this.tilePosition.x = 0;
  this.tilePosition.y = 0;
}

Mid.prototype = Object.create(PIXI.extras.TilingSprite.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存 Mid.js 文件，然后转到 index.html 并引用 Mid 类的源文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Far.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Mid.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!--添加--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成后，向下滚动到 &lt;code&gt;init()&lt;/code&gt; 函数并删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new Far();
stage.addChild(far);

var midTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;); // 删除
mid = new PIXI.extras.TilingSprite(midTexture, 512, 256);// 删除
mid.position.x = 0;// 删除
mid.position.y = 128;// 删除
mid.tilePosition.x = 0;// 删除
mid.tilePosition.y = 0;// 删除
stage.addChild(mid);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用这一行代码替换它们：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new Far();
stage.addChild(far);

mid = new Mid(); // 此行
stage.addChild(mid);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存 Mid.js 文件并在浏览器中测试最新版本。像往常一样，在运行时检查是否有 JavaScript 错误，并确保滚动器仍然按预期执行。&lt;/p&gt;

&lt;h3 id=&#34;实现一个-update-方法&#34;&gt;实现一个 update() 方法&lt;/h3&gt;

&lt;p&gt;我们已经对代码库进行了大量的重构，但仍然有一些事情可以做。返回 index.html 文件，查看动画主更新逻辑。它应该如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.tilePosition.x -= 0.128;
  mid.tilePosition.x -= 0.64;

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;update 方法中的前两行通过更新其 tilePosition 属性来滚动我们的图层。但是，我们的代码目前存在一些问题：通过直接更改 &lt;code&gt;tilePosition&lt;/code&gt; 属性，我们将暴露 Mid 和 Far 类的内部 &lt;strong&gt;实现&lt;/strong&gt;（译者：类的外部不应该知道类的具体实现细节，只需要控制类的行为）。这违背了面向对象的封装原则。&lt;/p&gt;

&lt;p&gt;理想情况下，我们希望在类中隐藏具体细节。如果两个类只有一个实际为我们执行滚动的 &lt;code&gt;update()&lt;/code&gt; 方法，那么我们的代码会更易读。换句话说，对于我们的主循环来说，这样似乎更合适：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.update();
  mid.update();

  renderer.render(stage);

  requestAnimFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得庆幸的是，这样的改变是微不足道的。我们将向 Far 类和 Mid 类添加一个 &lt;code&gt;update()&lt;/code&gt; 方法，每个类都会一点点的滚动。&lt;/p&gt;

&lt;p&gt;从 Far 类开始，打开 Far.js 并向其添加以下方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);

Far.prototype.update = function() {
  this.tilePosition.x -= 0.128;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法（update）的主体应该看起来很熟悉。它只是将纹理的平铺位置移动 0.128 像素，这正是我们在 index.html 的主循环中所做的。&lt;/p&gt;

&lt;p&gt;好的，保存更改并向Mid.js添加类似的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Mid.prototype = Object.create(PIXI.extras.TilingSprite.prototype);

Mid.prototype.update = function() {
  this.tilePosition.x -= 0.64;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两个方法的唯一区别是 Mid 类中的 &lt;code&gt;update()&lt;/code&gt; 方法的滚动量更多。&lt;/p&gt;

&lt;p&gt;保存更改并返回 index.html。现在我们需要做的就是从主循环中调用每个层的 &lt;code&gt;update()&lt;/code&gt; 方法。删除以下两行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.tilePosition.x -= 0.128; // 删除
  mid.tilePosition.x -= 0.64; // 删除

  renderer.render(stage);

  requestAnimFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.update();
  mid.update();

  renderer.render(stage);

  requestAnimFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存更改并测试，保证 Chrome 中按预期正常运行。&lt;/p&gt;

&lt;h3 id=&#34;停下来思考一下&#34;&gt;停下来思考一下&lt;/h3&gt;

&lt;p&gt;虽然视差滚动器和以前一样表现正常，但我们实际上已对代码的整体架构进行了一些重大的更改。我们采用了更加面向对象的设计，利用继承创建了两个代表视差层的特殊展示对象。&lt;/p&gt;

&lt;p&gt;能够编写特殊的展示对象是一个强大的概念，在许多情况下都能派上用场。我们的 Far 类和 Mid 类都像 pixi.js 支持的任何其他展示对象一样。下图说明了我们的两个特殊类位于 Pixi 展示对象类的继承结构中的位置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/27384/39/11126/25797/5c8ca6b2E6fabfee4/0d138469e63570ba.png&#34; alt=&#34;ps-tut2-screenshot2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在继续之前，看看你的代码文件并确保我们迄今为止所做的一切都有意义。实际上并没有很多代码，但如果你是面向对象编程的新手，那么完全消化代码所表示的知识可能需要一些时间。&lt;/p&gt;

&lt;h2 id=&#34;建立滚动器-scroller-类&#34;&gt;建立滚动器（Scroller）类&lt;/h2&gt;

&lt;p&gt;本教程开头概述的目标之一是将我们的视差滚动器包装到一个类中。现在我们已经编写了 Far 类和 Mid 类，现在我们写一个滚动器类。&lt;/p&gt;

&lt;p&gt;这样的话我们就能够从 index.html 中删除 Mid 和 Far &lt;strong&gt;实例&lt;/strong&gt;，将它们封装在一个单独的对象中，以满足我们所有的滚动类需要实现的需求。&lt;/p&gt;

&lt;p&gt;让我们写一个能够实现我们想法的类。创建一个名为 Scroller.js 的新 JavaScript 文件，并通过向其添加以下代码来定义名为 Scroller 的类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Scroller(stage) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于这个类，有两点值得注意。首先，它的构造函数需要引用我们的舞台（Pixi.Container）。其次，它不会继承任何东西。&lt;/p&gt;

&lt;p&gt;与 Far 和 Mid 类不同，我们的 Scroller 类不是特殊的展示对象。相反，它将使用构造函数的 stage 参数添加我们的 远景层和中间层实例。（译者：Scroller 类只起到封装和控制作用，并不用继承任何 Pixi 中的类）&lt;/p&gt;

&lt;p&gt;让我们先在类中添加远景层的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Scroller(stage) {
  this.far = new Far();
  stage.addChild(this.far);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行代码创建了 Far 类的实例。请注意，我们将实例存储在名为 &lt;code&gt;far&lt;/code&gt; 的 &lt;code&gt;成员变量&lt;/code&gt; 中。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;成员变量&lt;/strong&gt; 是通过 this 关键字直接向类添加 &lt;strong&gt;属性&lt;/strong&gt; 来创建的。成员变量具有在类实例的整个生命周期中持久化可见的优点，这意味着类的任何其他方法也可以访问它。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第二行将远景层实例添加到舞台。&lt;/p&gt;

&lt;p&gt;现在让我们为中间层做同样的事情。将以下两行添加到构造函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Scroller(stage) {
  this.far = new Far();
  stage.addChild(this.far);

  this.mid = new Mid();
  stage.addChild(this.mid);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在 Scroller 类中有两个成员变量：&lt;code&gt;far&lt;/code&gt; 和 &lt;code&gt;mid&lt;/code&gt;。这是很有用，因为它允许我们从类中的任何其他方法中访问我们的视差层。这也很方便，因为我们确实需要添加一个额外的方法。它将用于更新两个层的位置。我们现在继续添加此方法（update）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Scroller(stage) {
  this.far = new Far();
  stage.addChild(this.far);

  this.mid = new Mid();
  stage.addChild(this.mid);
}

Scroller.prototype.update = function() {
  this.far.update();
  this.mid.update();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还记得我们为 Mid 和 Far 类编写了 &lt;code&gt;update()&lt;/code&gt; 方法吗？在我们的 Scroller 类自己的 &lt;code&gt;update()&lt;/code&gt; 方法需要做的就是调用这些更新方法。&lt;/p&gt;

&lt;h3 id=&#34;插入-scroller-类&#34;&gt;插入 Scroller 类&lt;/h3&gt;

&lt;p&gt;现在 Scroller 类可以表示我们的视差滚动器了，我们可以回到 index.html 页面并将其插入。&lt;/p&gt;

&lt;p&gt;打开 index.html 并引用 Scroller.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Far.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Mid.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Scroller.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在向下移动到 &lt;code&gt;init()&lt;/code&gt; 函数并删除以下代码行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {
  stage = new PIXI.Stage(0x66FF99);
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  far = new Far(); // 删除
  stage.addChild(far); // 删除

  mid = new Mid(); // 删除
  stage.addChild(mid); // 删除

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请记住，远景层和中间层现在都由 Scroller 类处理。因此，我们需要创建一个Scroller 实例来替换我们刚删除的行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {
  stage = new PIXI.Stage(0x66FF99);
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  scroller = new Scroller(stage); // 实例化 Scroller

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另请注意，我们将 stage 引用传递给 Scroller 类的构造函数。这样做非常重要，因为 Scroller 类需要这个引用才能将 远景层和中间层添加到 &lt;strong&gt;展示列表&lt;/strong&gt; 中。&lt;/p&gt;

&lt;p&gt;现在需要做的就是在主循环中调用 scroller 的 &lt;code&gt;update()&lt;/code&gt; 方法。首先，从主循环中删除以下两行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.update(); // 删除
  mid.update(); // 删除

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在添加以下行来更新滚动器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  scroller.update(); // 添加

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存更改并使用 Chrome 测试所有内容。一如既往地在 JavaScript 控制台中查找是否有错误，如果有，请仔细检查你的代码。&lt;/p&gt;

&lt;p&gt;我们已经成功地重新构建了视差滚动，以便所有内容都包含在一个类中。如果你查看 index.html，你会发现我们已经隐藏了我们上次在第一篇教程中写的所有实现代码。&lt;/p&gt;

&lt;h2 id=&#34;添加视口-viewport&#34;&gt;添加视口（viewport）&lt;/h2&gt;

&lt;p&gt;我们已经取得了巨大的进步，但还有一件事我们做。为了使我们的滚动条完整，需要添加 &lt;strong&gt;视口&lt;/strong&gt; 的概念。将视口视为一个查看游戏地图的窗口。&lt;/p&gt;

&lt;p&gt;你可能会问「我们不是已经有一个视口了吗？」是的，毕竟，当你在浏览器中运行代码时，我们只能看到在舞台边界内可以看到的内容。这是似乎就是一个视口了，但是我们还没有办法知道我们在游戏世界中 &lt;strong&gt;滚动了多远&lt;/strong&gt;（译者：需要实现视口是因为后续会涉及到地图的概念，地图中游戏场景是有长度、距离的概念的，这就方便我们实现一些特殊场景，比如落箱子，障碍物等。因为不引用视口的概念游戏将是无限循环滚动的。这会导致计算距离变得很复杂，而且无法将地图设计成一种具体的抽象）。另外，如果我们可以简单地跳到某个位置并确切地看到我们的图层应该如何看起来，那不是很好吗？一旦我们添加了视口的概念并提供了设置其当前位置的方法，那么一切都将成为可能。&lt;/p&gt;

&lt;h3 id=&#34;给-scroller-类添加-setviewportx-方法&#34;&gt;给 Scroller 类添加 setViewportX 方法&lt;/h3&gt;

&lt;p&gt;目前我们有一个 &lt;code&gt;update()&lt;/code&gt; 方法，我们用它来连续滚动我们的视差层。可以使用一个名为 &lt;code&gt;setViewportX()&lt;/code&gt; 的新方法替换它，我们可以用它来设置视口的水平位置。调用此方法将让我们随意定位我们的游戏地图。&lt;/p&gt;

&lt;p&gt;让我们从 Scroller 类开始。&lt;/p&gt;

&lt;p&gt;打开 Scroller.js 并删除现有的 &lt;code&gt;update()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Scroller(stage) {
  this.far = new Far();
  stage.addChild(this.far);

  this.mid = new Mid();
  stage.addChild(this.mid);
}

Scroller.prototype.update = function() { // 删除
  this.far.update();// 删除
  this.mid.update();// 删除
};// 删除
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们的 &lt;code&gt;setViewportX()&lt;/code&gt; 方法非常简单。它期望将一个数字作为方法的 viewportX 参数传递，然后将该值传递给我们的每个层。显然，我们的图层都需要实现自己的 &lt;code&gt;setViewportX()&lt;/code&gt; 方法。让我们继续吧，现在就去做吧。&lt;/p&gt;

&lt;h3 id=&#34;给-far-类添加-setviewportx-方法&#34;&gt;给 Far 类添加 setViewportX 方法&lt;/h3&gt;

&lt;p&gt;我们首先删除类中的现有 &lt;code&gt;update()&lt;/code&gt; 方法。打开 Far.js 并删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far() {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
  PIXI.extras.TilingSprite.call(this, texture, 512, 256);

  this.position.x = 0;
  this.position.y = 0;
  this.tilePosition.x = 0;
  this.tilePosition.y = 0;
}

Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);

Far.prototype.update = function() { // 删除
  this.tilePosition.x -= 0.128; // 删除
}; // 删除
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要能够跟踪视口的水平位置。为此，我们在类的构造函数中定义新的成员变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Far() {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
  PIXI.extras.TilingSprite.call(this, texture, 512, 256);

  this.position.x = 0;
  this.position.y = 0;
  this.tilePosition.x = 0;
  this.tilePosition.y = 0;

  this.viewportX = 0; // 新的成员变量
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再添加一个类的 &lt;strong&gt;静态常量&lt;/strong&gt;（&lt;code&gt;DELTA_X&lt;/code&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);

Far.DELTA_X = 0.128;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DELTA_X 常量的值看起来应该很熟悉。它是我们之前在每次调用 &lt;code&gt;update()&lt;/code&gt; 时移动图层的 tilePosition 的像素数。显然，使用常量会使我们的代码更具可读性和可维护性，这就是我们选择使用常量的原因。基本上，每当我们的视口移动一个单元时，我们将使用常量将远景层移动 0.128 像素。所以现在让我们编写一个 &lt;code&gt;setViewportX()&lt;/code&gt; 方法，添加以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Far.prototype = Object.create(PIXI.extras.TilingSprite.prototype);

Far.DELTA_X = 0.128;

Far.prototype.setViewportX = function(newViewportX) {
  var distanceTravelled = newViewportX - this.viewportX;
  this.viewportX = newViewportX;
  this.tilePosition.x -= (distanceTravelled * Far.DELTA_X);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码并不难理解。首先，我们计算自从上次调用 &lt;code&gt;setViewportX()&lt;/code&gt; 以来的滚动的距离。然后视口的新水平位置存储在我们的 &lt;code&gt;viewportX&lt;/code&gt; 成员变量中。最后，我们乘以 DELTA_X 常数，以确定将图层的瓦片移动了多远。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;应该注意，我们的 x 位置代表视口窗口的左侧。在其他实现中，x 位置代表视口的中心也很常见。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;保存最新版本的 &lt;code&gt;Far.js&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;现在我们需要对 &lt;code&gt;Mid&lt;/code&gt; 类进行相同的更改。&lt;/p&gt;

&lt;h3 id=&#34;给-mid-类添加-setviewportx-方法&#34;&gt;给 Mid 类添加 setViewportX 方法&lt;/h3&gt;

&lt;p&gt;Mid 类的代码几乎与 Far 类相同，所以我们能快速写出来。&lt;/p&gt;

&lt;p&gt;打开 Mid.js 并删除其 &lt;code&gt;update()&lt;/code&gt; 方法、并添加 &lt;code&gt;setViewportX&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mid() {
  var texture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;);
  PIXI.extras.TilingSprite.call(this, texture, 512, 256);

  this.position.x = 0;
  this.position.y = 128;
  this.tilePosition.x = 0;
  this.tilePosition.y = 0;

  this.viewportX = 0;
}

Mid.prototype = Object.create(PIXI.extras.TilingSprite.prototype);

Mid.DELTA_X = 0.64;

Mid.prototype.setViewportX = function(newViewportX) {
  var distanceTravelled = newViewportX - this.viewportX;
  this.viewportX = newViewportX;
  this.tilePosition.x -= (distanceTravelled * Mid.DELTA_X);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个类之间的唯一区别是 Mid 类的 DELTA_X 常量值为 &lt;code&gt;0.64&lt;/code&gt;，这是为了确保图层的滚动速度比 far 层快。保存更改。&lt;/p&gt;

&lt;h3 id=&#34;测试视口&#34;&gt;测试视口&lt;/h3&gt;

&lt;p&gt;我们应该测试视口并确保设置其位置反映在我们的视差层中。首先，我们需要打开 index.html 并删除 scrolller  的 &lt;code&gt;update()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  scroller.update(); // 删除

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存 index.html 文件并在浏览器中测试更改。你应该注意到你只能看见视差层，但都没有滚动。那是因为我们没有添加任何代码来真正更改视口的水平位置。目前它固定在默认的 x 位置 0。&lt;/p&gt;

&lt;p&gt;在我们添加代码之前，我们可以在 Chrome 的 JavaScript 控制台中测试一下我们的滚动条的 &lt;code&gt;setViewportX()&lt;/code&gt; 实际上是有效的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scroller.setViewportX(50); /// 控制台中调用
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;JavaScript 控制台可以访问程序中的任何全局变量。因此，我们可以通过全局 &lt;code&gt;scroller&lt;/code&gt; 变量访问滚动条并调用其 &lt;code&gt;setViewportX()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;您应该看到视差图层向左移动，这表示我们已成功重新定位了视口。&lt;/p&gt;

&lt;p&gt;尝试将视口移动到 x = 7000 的位置 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scroller.setViewportX(7000);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;滚动视口&#34;&gt;滚动视口&lt;/h3&gt;

&lt;p&gt;很明显，我们可以通过不断更新滚动器的视口位置来模拟游戏世界中的移动。我们可以在主循环中执行此操作，但是我们得够获取视口的当前水平位置。让我们继续为 &lt;code&gt;Scroller&lt;/code&gt; 类添加一个新方法。&lt;/p&gt;

&lt;h3 id=&#34;获取视口的位置&#34;&gt;获取视口的位置&lt;/h3&gt;

&lt;p&gt;目前来讲我们的 Scroller 类并没存储当前视口位置，我们需要一个成员变量来实现它。&lt;/p&gt;

&lt;p&gt;打开 Scroller.js 并在构造函数中定义以下成员变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Scroller(stage) {
  this.far = new Far();
  stage.addChild(this.far);

  this.mid = new Mid();
  stage.addChild(this.mid);

  this.viewportX = 0; // 水平滚动量
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并在 &lt;code&gt;setViewportX()&lt;/code&gt; 方法中更新 &lt;code&gt;viewportX&lt;/code&gt; 成员变量的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Scroller.prototype.setViewportX = function(viewportX) {
  this.viewportX = viewportX; // 更新
  this.far.setViewportX(viewportX);
  this.mid.setViewportX(viewportX);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成后，我们可以编写一个 &lt;code&gt;getViewportX()&lt;/code&gt; 方法，该方法将返回视口的当前位置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Scroller.prototype.setViewportX = function(viewportX) {
  this.viewportX = viewportX;
  this.far.setViewportX(viewportX);
  this.mid.setViewportX(viewportX);
};
// 新方法
Scroller.prototype.getViewportX = function() {
  return this.viewportX;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存你的代码。&lt;/p&gt;

&lt;h3 id=&#34;更新主循环&#34;&gt;更新主循环&lt;/h3&gt;

&lt;p&gt;现在要做的就是不断更新滚动器的视口位置。我们将在主循环中执行此操作。&lt;/p&gt;

&lt;p&gt;打开 index.html，只需添加以下两行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  var newViewportX = scroller.getViewportX() + 5; // 添加
  scroller.setViewportX(newViewportX); // 添加
            
  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行获取视口的 x 位置并将其增加 5 个单位。第二行采用新值并更新视口的当前 x 位置。从本质上讲，它会强制视口在每次调用主循环时滚动 5 个单位。&lt;/p&gt;

&lt;p&gt;保存代码并在 Chrome 中运行它。你应该会再一次看到视差层向外滚动。试试不同的滚动速度看。例如，将视口增加 15 个单位而不是 5 个单位。&lt;/p&gt;

&lt;h3 id=&#34;移动视口&#34;&gt;移动视口&lt;/h3&gt;

&lt;p&gt;让我们在 Scroller 类中再添加一个方法 &lt;code&gt;moveViewportXBy&lt;/code&gt;，可以将视口从其当前位置移动指定的距离。这将让主循环看起来更加简洁。&lt;/p&gt;

&lt;p&gt;在保存更改之前，打开 Scroller.js 并添加以下方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Scroller.prototype.getViewportX = function() {
  return this.viewportX;
};
// 添加新方法
Scroller.prototype.moveViewportXBy = function(units) {
  var newViewportX = this.viewportX + units;
  this.setViewportX(newViewportX);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就像我们之前做过的一样，这个新方法不难理解。它只是计算出视口的新位置然后调用类的 &lt;code&gt;setViewportX()&lt;/code&gt; 方法来实际设置视口位置。&lt;/p&gt;

&lt;p&gt;移回 index.html 并删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  var newViewportX = scroller.getViewportX() + 5; // 删除
  scroller.setViewportX(newViewportX); // 删除

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用 &lt;code&gt;moveViewportXBy()&lt;/code&gt; 方法的单行替换它们：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  scroller.moveViewportXBy(5); // 调用新的方法

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存更改并在 Web 浏览器中测试更改。&lt;/p&gt;

&lt;h2 id=&#34;回顾程序的主入口&#34;&gt;回顾程序的主入口&lt;/h2&gt;

&lt;p&gt;本系列教程的第二部分即将结束。在我们完成之前，让我们回顾下 index.html 并做最后一个重构。&lt;/p&gt;

&lt;p&gt;虽然我们已经完成了减少对全局变量的依赖的这样一项令人敬重的工作，但我们的 index.html 文件仍然有一些零散的全局变量。实际上，在大型应用程序中，将尽可能多的 JavaScript 与 HTML 页面分开也是一种很好的做法。虽然我们的 HTML 页面中没有多少 JavaScript，但我们可以做得更好。让我们把代码单独封装在一个与自己类名相同的文件中。这样，我们当前所依赖的全局变量将成为我们新类的成员变量。&lt;/p&gt;

&lt;p&gt;创建一个新文件并将其命名为 &lt;code&gt;Main.js&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;为类创建构造函数，并将HTML页面的 &lt;code&gt;init()&lt;/code&gt; 函数中的代码放入其中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Main() {
  this.stage = new PIXI.Container();
  this.renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  this.scroller = new Scroller(this.stage);

  requestAnimationFrame(this.update.bind(this));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面使用 &lt;code&gt;this&lt;/code&gt; 关键字。我们使用它来定义 &lt;code&gt;stage&lt;/code&gt;，&lt;code&gt;renderer&lt;/code&gt; 和 &lt;code&gt;scroller&lt;/code&gt; 作为成员变量。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 关键字也用于调用 JavaScript 函数 &lt;code&gt;requestAnimationFrame()&lt;/code&gt;。代码大概是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;requestAnimationFrame(this.update.bind(this));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用它来指定我们的类名为 &lt;code&gt;update()&lt;/code&gt; 的方法（我们仍然要写这个方法）将在下一次重绘时调用。另外，还调用另一个您可能不熟悉的名为 &lt;code&gt;bind()&lt;/code&gt; 的JavaScript 函数。它用来保证在调用 &lt;code&gt;update()&lt;/code&gt; 时它正确地访问到 Main 类的实例。如果不用 &lt;code&gt;bind()&lt;/code&gt;，&lt;code&gt;update()&lt;/code&gt; 方法将无法访问和使用任何 Main 类的成员变量。&lt;/p&gt;

&lt;p&gt;好吧，让我们实际编写我们的类的 &lt;code&gt;update()&lt;/code&gt; 方法。它将只包含我们原来 HTML 页面的 &lt;code&gt;update()&lt;/code&gt; 函数中的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main.prototype.update = function() {
  this.scroller.moveViewportXBy(Main.SCROLL_SPEED);
  this.renderer.render(this.stage);
  requestAnimationFrame(this.update.bind(this));
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再次使用了 &lt;code&gt;this&lt;/code&gt; 关键字，而且利用了JavaScript 的 &lt;code&gt;bind()&lt;/code&gt; 函数来确保我们的更新循环始终在正确的作用域下。&lt;/p&gt;

&lt;p&gt;另外，请注意上面的代码在调用 scrolller 的 &lt;code&gt;moveViewportXBy()&lt;/code&gt; 方法时使用了一个名为 &lt;code&gt;SCROLL_SPEED&lt;/code&gt; 的常量。以前我们刚刚传递了一个硬编码值。我们实际可以将该常量添加到 Main 类中做为静态常量。在构造函数后面直接添加以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  requestAnimationFrame(this.update.bind(this));
}

Main.SCROLL_SPEED = 5; // 添加

Main.prototype.update = function() {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好的，保存你的代码。&lt;/p&gt;

&lt;p&gt;现在让我们打开 index.html 并删除以前的老代码。&lt;/p&gt;

&lt;p&gt;删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 全部删除 --&amp;gt;
&amp;lt;script&amp;gt;
  function init() {
    stage = new PIXI.Container();
    renderer = PIXI.autoDetectRenderer(
      512,
      384,
      {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
    );

    scroller = new Scroller(stage);

    requestAnimationFrame(update);
  }

  function update() {
    scroller.moveViewportXBy(5);

    renderer.render(stage);

    requestAnimationFrame(update);
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用一个简单的实例化 Main 类的新 &lt;code&gt;init()&lt;/code&gt; 函数代替：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  function init() {
    main = new Main();
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，通过添加以下行来引用到类 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Far.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Mid.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Scroller.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- 添加 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存您的工作并测试仍在 Google Chrome 中运行的所有内容。&lt;/p&gt;

&lt;p&gt;我们已经成功地将所有内容都移到了一个主应用程序类中，而 index.html中只剩下几行 JavaScript 来解决所有问题。&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;哇哦！我们这一节涉及到了很多内容。虽然最终结果是相同的（我们仍然只有两个滚动视差层），但我希望你能看到重构代码的好处。现在一切都比干净了很多，我们有一个用于管理视差层的 Scroller 类。虽然这次我们的重点不是 pixi.js，但你至少应该体会到扩展 Pixi 展示对象类的好处。&lt;/p&gt;

&lt;h2 id=&#34;下集预告&#34;&gt;下集预告…&lt;/h2&gt;

&lt;p&gt;所有这些变化都处于理想的位置，可以在此基础上开发第三个更复杂的视差层了。这个图层将作为游戏世界的 地图，并将由一系列 &lt;strong&gt;精灵&lt;/strong&gt; 构建，而不是简单的重复纹理。我们将把目标放在 pixi.js 上，将涉及各种各样的好东西，包括精灵表（Spritesheet），纹理帧（texture frames）和对象池（object pooling）。&lt;/p&gt;

&lt;p&gt;记得 &lt;a href=&#34;https://github.com/ccaleb/pixi-parallax-scroller&#34;&gt;GitHub&lt;/a&gt; 上提供了本系列和本系列教程的源代码哦。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://keelii.com&#34;&gt;第三部分&lt;/a&gt; 见。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Pixi.js 构建一个视差滚动器（第一篇）</title>
      <link>https://keelii.com/2019/03/16/building-a-parallax-scroller-with-pixijs-cn-1/</link>
      <pubDate>Sat, 16 Mar 2019 19:20:04 -0700</pubDate>
      
      <guid>https://keelii.com/2019/03/16/building-a-parallax-scroller-with-pixijs-cn-1/</guid>
      <description>

&lt;h2 id=&#34;翻译对照&#34;&gt;翻译对照&lt;/h2&gt;

&lt;p&gt;原文：
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5226&#34;&gt;PART 1&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=5666&#34;&gt;PART 2&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=6496&#34;&gt;PART 3&lt;/a&gt;・
&lt;a href=&#34;http://www.yeahbutisitflash.com/?p=7046&#34;&gt;PART 4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译文：
&lt;a href=&#34;https://keelii.com/2019/03/16/building-a-parallax-scroller-with-pixijs-cn-1/&#34;&gt;第一篇&lt;/a&gt;・
&lt;a href=&#34;https://keelii.com/2019/03/17/building-a-parallax-scroller-with-pixijs-cn-2/&#34;&gt;第二篇&lt;/a&gt;・
第三篇・
第四篇&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;关注 &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=chriscaleb&#34;&gt;@chriscaleb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个系列的教程已经更新到了 &lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PixiJS v4&lt;/a&gt; 版本。&lt;/p&gt;

&lt;p&gt;曾经玩过 &lt;a href=&#34;http://www.adamatomic.com/canabalt/&#34;&gt;Canabalt&lt;/a&gt; 和 &lt;a href=&#34;https://chrome.google.com/webstore/detail/monster-dash/cknghehebaconkajgiobncfleofebcog?hl=en&#34;&gt;Monster Dash&lt;/a&gt;，好奇他们是如何构建一个滚动游戏地图的？在这个教程中我们将向「构建一个视差滚动器」迈出第一步，我们将使用 JavaScript 和 &lt;a href=&#34;http://www.pixijs.com/&#34;&gt;pixi.js&lt;/a&gt; 这个 2D 渲染引擎。&lt;/p&gt;

&lt;h3 id=&#34;你将学到什么&#34;&gt;你将学到什么…&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Pixi.js 的基础知识&lt;/li&gt;
&lt;li&gt;如何处理纹理（textures）和精灵（sprites）&lt;/li&gt;
&lt;li&gt;如何实现简单的视差滚动&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;预备知识&#34;&gt;预备知识…&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;了解 JavaScript 或者 ActionScript 的基础知识&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript 无处不在，由于浏览器的不断改善和大量的 JavaScript 库，我们真的开始看到 HTML5 游戏领域开发蓬勃发展。但是当有很多库可用的时候，选择合适的并非易事。&lt;/p&gt;

&lt;p&gt;这个系列的教程将向你介绍 JavaScript 游戏开发的基础，我们会聚焦到 pixijs。它是一个支持 WebGL 和 HTML5 Canvas 的渲染框架。教程最后你将完成如下的一个视差滚动地图程序：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yeahbutisitflash.com/pixi-parallax-scroller/final/index.html&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/25206/13/10616/142679/5c887df7E7c1fa38a/eab39f5f7ab1cc6d.png&#34; alt=&#34;ps-tut1-screenshot1&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;点击上面的链接启动最终版的程序，这就是你将要完成的。注意它包含了三个视差层：一个远景（far）层，一个中间（mid）层，一个前景（foreground）层。在第一篇教程中我们将集中精力构建远景层和中间层。当然为了做到这一点教程必须涉及 pixi.js 的基础，当然如果你还是个 JavaScript 新手，这会是个很好的开始学习 HTML5 游戏编程的地方。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yeahbutisitflash.com/pixi-parallax-scroller/tutorial-1/index.html&#34;&gt;&lt;img src=&#34;https://img10.360buyimg.com/devfe/jfs/t1/25206/13/10616/142679/5c887df7E7c1fa38a/eab39f5f7ab1cc6d.png&#34; alt=&#34;ps-tut1-screenshot1&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;开始之前，点击上面的链接预览下这篇教程中将做成的效果。你也可以从 github 上下载这个程序的 &lt;a href=&#34;https://github.com/ccaleb/pixi-parallax-scroller&#34;&gt;源代码&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;起步&#34;&gt;起步&lt;/h2&gt;

&lt;p&gt;为了完成编码，你需要一个代码编辑器，我将使用一个体验版的 sublime text，可以在 &lt;a href=&#34;www.sublimetext.com/2&#34;&gt;这里&lt;/a&gt; 下载到。&lt;/p&gt;

&lt;p&gt;还需要一个浏览器来测试你的程序。任何现代浏览器都可以，我将用 Google Chrome，开发过程中将会涉及到一些开始者工具的使用。如果你还没有安装 Chrome，可以去 &lt;a href=&#34;www.google.com/chrome&#34;&gt;这里&lt;/a&gt; 下载。&lt;/p&gt;

&lt;p&gt;为了测试你的程序，你还需要在你的开发机上安装一个 web 服务器。如果你用的是 Window，可以 &lt;a href=&#34;http://www.yeahbutisitflash.com/www.howtogeek.com/howto/windows-vista/how-to-install-iis-on-windows-vista&#34;&gt;安装 IIS&lt;/a&gt;，macOS 用户可以配置下系统默认的 &lt;a href=&#34;http://macdevcenter.com/pub/a/mac/2001/12/07/apache.html&#34;&gt;Apache&lt;/a&gt;，如果你的系统是 OS X Mountain Lion 配置 web 服务器可以会比较麻烦，可以参考这个 &lt;a href=&#34;http://reviews.cnet.com/8301-13727_7-57481978-263/how-to-enable-web-sharing-in-os-x-mountain-lion/&#34;&gt;教程&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你有自己托管的 web 服务器，就可以直接上传所以文件来测试，或者如果你有一个 &lt;a href=&#34;https://www.dropbox.com/&#34;&gt;Dropbox&lt;/a&gt; 账号，你可以通过 &lt;a href=&#34;http://droppages.com/&#34;&gt;DropPages&lt;/a&gt; 服务来托管你的文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;web 服务器建好后，创建一个目录 &lt;code&gt;parallax-scroller&lt;/code&gt; 如果你使用 Windows。你的 web 服务器根目录应该类似 &lt;code&gt;C:\inetpub\parallax-scroller&lt;/code&gt; 。如果你使用 OS X 则应该是 &lt;code&gt;/Users/your_user_name/Sites&lt;/code&gt;，&lt;code&gt;your_user_name&lt;/code&gt; 就是你电脑的用户名。&lt;/p&gt;

&lt;p&gt;最后，在教程中我们将使用几个图片素材，不用你自己去找，我已经为你打包好了一个 &lt;a href=&#34;http://www.yeahbutisitflash.com/pixi-parallax-scroller/tutorial-1/resources.zip&#34;&gt;zip 文件&lt;/a&gt;，下载并解压好你的 &lt;code&gt;parallax-scroller&lt;/code&gt; 目录。&lt;/p&gt;

&lt;p&gt;下面就是你的 &lt;code&gt;parallax-scroller&lt;/code&gt; 文件夹的样子（Windows）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img13.360buyimg.com/devfe/jfs/t1/10162/32/14136/48598/5c8884a8Ee6927d64/153a8f1b6f1b4e97.png&#34; alt=&#34;screenshot3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果你用的是 Mac OS X 则应该如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img30.360buyimg.com/devfe/jfs/t1/31876/28/5811/61642/5c8884ccE7e17d248/5c69f80f99e2cb1d.png&#34; alt=&#34;screenshot4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在我们已经准备好开始写代码了，启动 Sublime Text 2 或者你最喜欢的编辑器。&lt;/p&gt;

&lt;h2 id=&#34;创建画布&#34;&gt;创建画布&lt;/h2&gt;

&lt;p&gt;所有的 pixijs 项目都以一个 HTML 文件开始。在这里我们将创建一个 canvas 元素以及引入 pixi.js 库。canvas 元素表示HTML页面上将呈现滚动条的区域。&lt;/p&gt;

&lt;p&gt;在你的项目根目录 &lt;code&gt;parallax-scroller&lt;/code&gt; 下使用编辑器新建一个文件，命名为 &lt;code&gt;index.html&lt;/code&gt;，并写入下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Parallax Scrolling Demo&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在看起来还非常奇怪，我们的 HTML 页面只有一个 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 元素。&lt;/p&gt;

&lt;p&gt;现在让我们在页面上添加 HTML5 Canvas 元素，在 body 元素中添加如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;body&amp;gt;
  &amp;lt;div align=&amp;quot;center&amp;quot;&amp;gt;
    &amp;lt;canvas id=&amp;quot;game-canvas&amp;quot; width=&amp;quot;512&amp;quot; height=&amp;quot;384&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们指定了 canvas 宽度 512 像素，高度 384 像素。这就是 pixi.js 为库渲染游戏的地方。注意我们给 canvas 了一个 id 属性，值为 &lt;code&gt;game-canvas&lt;/code&gt; 这将使我们易于控制它，当 pixi.js 启动时也需要它&lt;/p&gt;

&lt;p&gt;现在启动你的 web 服务器，在 浏览器中打开类似 &lt;a href=&#34;http://localhost/parallax-scroller/index.html&#34;&gt;http://localhost/parallax-scroller/index.html&lt;/a&gt; 或者 &lt;a href=&#34;http://localhost/~**your_user_name**/parallax-scroller/index.html&#34;&gt;http://localhost/~**your_user_name**/parallax-scroller/index.html&lt;/a&gt; 的链接&lt;/p&gt;

&lt;p&gt;你会发现并没有什么东西，我们来给 canvas 加点样式（style 标签）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Endless Runner Game Demo&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      body { background-color: #000000; }
      canvas { background-color: #222222; }
    &amp;lt;/style&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存并刷新，你将会看见一个水平居中的灰色区域出现在页面上。&lt;/p&gt;

&lt;h2 id=&#34;引入-pixi-js-类库&#34;&gt;引入 pixi.js 类库&lt;/h2&gt;

&lt;p&gt;在 &lt;/body&gt; 标签前面加入引用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
  &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pixi.js 库文件托管在 CDN 上，URL 上的 &lt;code&gt;4.0.0&lt;/code&gt; 表示库的版本号，你可以替换成其它的发行版。&lt;/p&gt;

&lt;h2 id=&#34;添加程序的入口&#34;&gt;添加程序的入口&lt;/h2&gt;

&lt;p&gt;给 body 元素添加 &lt;code&gt;onload=&amp;quot;init();&lt;/code&gt; 表示页面加载完成时调用 init 方法。我们在 script 标签中添加一个 init 方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body onload=&amp;quot;init();&amp;quot;&amp;gt;
  &amp;lt;div align=&amp;quot;center&amp;quot;&amp;gt;
    &amp;lt;canvas id=&amp;quot;game-canvas&amp;quot; width=&amp;quot;512&amp;quot; height=&amp;quot;384&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;script src=&amp;quot;pixi.js-master/bin/pixi.dev.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script&amp;gt;
    function init() {
      console.log(&amp;quot;init() successfully called.&amp;quot;);
    }
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开 Chrome Console，Windows 下按 &lt;code&gt;F12&lt;/code&gt;，macOS 下按 &lt;code&gt;Cmd + Opt + i&lt;/code&gt;。正常的话控制台就会有下面的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; init() successfully called.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在这个 init 方法做的事情还很少，最终它将做为入口负责你程序的调用。&lt;/p&gt;

&lt;h2 id=&#34;初始化-pixi-js&#34;&gt;初始化 pixi.js&lt;/h2&gt;

&lt;p&gt;我们在 init 方法中需要做下面两件事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建你的舞台（stage）&lt;/li&gt;
&lt;li&gt;选择并实例化一个渲染器（renderer）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们先来创建一个舞台对象，如果你是个 Flash 开发者，你可能会对舞台的概念比较熟悉了。基本上舞台就是你游戏的图形内容呈现的地方。另一方面，渲染器控制舞台并且把游戏绘制到你的 HTML 页面中的 canvas 元素上，这样你的做的东西才最终呈现给了用户。&lt;/p&gt;

&lt;p&gt;我们来创建一个舞台对象并将它关联到一个名字叫做 &lt;code&gt;stage&lt;/code&gt; 的全局变量上。并且删除之前的 log 语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {
  console.log(&amp;quot;init() successfully called.&amp;quot;);
  stage = new PIXI.Container();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pixi.js 的 API 包含了一些类和函数，并且被保存在 &lt;code&gt;PIXI&lt;/code&gt; 模块命名空间下面。PIXI.Container 类用来表示一些 &lt;strong&gt;展示对象&lt;/strong&gt;（display object） 的集合，同样也可以表示舞台这个根展示对象。&lt;/p&gt;

&lt;p&gt;现在我们已经创建好了一个舞台，我们还需要一个渲染器。Pixi.js 支持两种渲染器：WebGL 和 HTML5 Canvas。你可以通过 &lt;code&gt;PIXI.WebGLRenderer&lt;/code&gt; 或者 &lt;code&gt;PIXI.CanvasRenderer&lt;/code&gt; 来分别创建它们各自的实例。然而，更好的做法是让 Pixi 为你判断浏览器自动检测并使用正确的渲染器。Pixi 默认会尝试使用 WebGL，如果不支持则回滚到  canvas。我们调用用 Pixi 的 &lt;code&gt;PIXI.autoDetectRenderer()&lt;/code&gt; 函数来自动帮我们选择合适的渲染器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {		
  stage = new PIXI.Container();
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;autoDetectRenderer()&lt;/code&gt; 函数需要传入渲染舞台上 cavnas 的宽度和高度，以及 cavnas 元素的引用，它返回 &lt;code&gt;PIXI.WebGLRenderer&lt;/code&gt; 或 &lt;code&gt;PIXI.CanvasRenderer&lt;/code&gt; 的实例，我们将其保存在名为 &lt;code&gt;renderer&lt;/code&gt; 的全局变量中。&lt;/p&gt;

&lt;p&gt;在上面的代码中，我们通过一个包含 &lt;code&gt;view&lt;/code&gt; 属性的 JavaScript 对象来传递给 &lt;code&gt;autoDetectRenderer&lt;/code&gt; 方法，表示 canvas 元素的引用。我们传递这个对象做为函数的第三个参数而不是直接传 canvas 对象的引用。&lt;/p&gt;

&lt;p&gt;我们使用了硬编码的方式指定了宽，高，实际上可以直接通过 canvas 元素取得这两个值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var width = document.getElementById(&amp;quot;game-canvas&amp;quot;).width;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;渲染&#34;&gt;渲染&lt;/h2&gt;

&lt;p&gt;为了能看到舞台上的内容，你得指导你的渲染器把舞台上的内容真正的绘制到 canvas 上。可以通过调用 renderer 的 render 方法，并传入舞台对象的引用来做到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {		
  stage = new PIXI.Container();
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );
  renderer.render(stage);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将成功的把舞台渲染到浏览器中。当然我们还没有给舞台上添加任何东西，所以你还看不出来&lt;/p&gt;

&lt;h2 id=&#34;为你的展示列表-display-list-添加内容&#34;&gt;为你的展示列表（display list）添加内容&lt;/h2&gt;

&lt;p&gt;现在你的舞台已经建成，让我们继续往上面添加一些实际的东西。毕竟我们不想一直只到一个黑色的窗口。&lt;/p&gt;

&lt;p&gt;舞台上的东西被添加到一个 &lt;strong&gt;树型结构&lt;/strong&gt; 的展示列表中。你的舞台扮演着这些展示列表的根元素的角色，同时展示列表也会有栈顺序的问题，这意味着有的对象展示在别的对象上面，这由他们被设计的索引深度决定。&lt;/p&gt;

&lt;p&gt;有很多种类的 &lt;strong&gt;展示对象（display object）&lt;/strong&gt; 可以被添加到 &lt;strong&gt;展示列表&lt;/strong&gt; 中，最常见的是 &lt;code&gt;PIXI.Sprite&lt;/code&gt;，它可以添加图片素材。&lt;/p&gt;

&lt;p&gt;由于这个教程是关于创建视差滚动背景的，让我们来添加一个表示远景层的图片。 我们将以添加一行代码来加载 &lt;code&gt;bg-far.png&lt;/code&gt; 文件，这个文件在 resources 目录中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {		
  stage = new PIXI.Container();
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);

  renderer.render(stage);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图片素材被加载并保存为纹理（textures），这个纹理可以随后被符加到一个或者多个精灵上面。在上面的代码中我们调用了静态 &lt;code&gt;PIXI.Texture.fromImage()&lt;/code&gt; 方法来创建一个&lt;code&gt;PIXI.Texture&lt;/code&gt; 实例并将 &lt;code&gt;bg-far.png&lt;/code&gt; 文件加载到其中。为了方便使用，我们将纹理引用赋值给名为 &lt;code&gt;farTexture&lt;/code&gt; 的局部变量。&lt;/p&gt;

&lt;p&gt;现在让我们创建一个精灵并将纹理附加到它上面。并将精灵定位在舞台的左上角：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {		
  stage = new PIXI.Container();
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
  far = new PIXI.Sprite(farTexture);
  far.position.x = 0;
  far.position.y = 0;

  renderer.render(stage);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;PIXI.Sprite&lt;/code&gt; 类用于创建精灵。它的构造函数将接收一个纹理的引用参数。我们使用了一个名为 far 的全局变量，并将新创建的 sprite 实例存储在其中。&lt;/p&gt;

&lt;p&gt;聪明的你可能已经发现我们是如何使用 position 属性将精灵的 x 和 y 坐标设置到舞台的左上角的。舞台的坐标从左到右，从上到下，这意味着舞台的左上角位置为（0,0），右下角为（512,384）。&lt;/p&gt;

&lt;p&gt;精灵有一个轴心点（pivot），它们可以来回旋转。轴心点也可以用来定位精灵。精灵的默认轴心点设置为左上角（0,0）。这就是为什么当我们的精灵定位在舞台的左上角时，我们将其位置设置为（0,0）。（译者：如果你将轴心点设置到正中央，那位置是（0,0）的精灵就会展示不全）&lt;/p&gt;

&lt;p&gt;最后一步是将精灵添加到舞台上。这是使用 &lt;code&gt;PIXI.Stage&lt;/code&gt; 类的（实例方法） &lt;code&gt;addChild()&lt;/code&gt; 方法完成的。来看看怎么做吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
  far = new PIXI.Sprite(farTexture);
  far.position.x = 0;
  far.position.y = 0;
  stage.addChild(far);

  renderer.render(stage);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好的，保存你的代码并刷新浏览器。你可能已经满坏期望能看到背景图，但实际上可能看不到。为什么呢？在素材纹理被加载完成之前就渲染它可能并不能有任何效果。因为纹理加载是需要一小段时间的。&lt;/p&gt;

&lt;p&gt;我们可以通过简单地等一段时间，然后再次调用 render 方法来解决这个问题。通过 Chrome 的控制台执行下面的代码即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;renderer.render(stage);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;由于我们之前声明的 &lt;code&gt;renderer&lt;/code&gt; 是全局变量，所以你能在 console 中直接使用它。console 中可以使用任何 JavaScript 中声明的全局变量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;恭喜你！现在应该看到紧贴在屏幕顶部的背景图层了。&lt;/p&gt;

&lt;p&gt;现在让我们继续添舞台上的中间层：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
far = new PIXI.Sprite(farTexture);
far.position.x = 0;
far.position.y = 0;
stage.addChild(far);

var midTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;);
mid = new PIXI.Sprite(midTexture);
mid.position.x = 0;
mid.position.y = 128;
stage.addChild(mid);

renderer.render(stage);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存代码并刷新浏览器。你需要再次手动在 Chrome 控制台中调用渲染方法才能看到两个层：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;renderer.render(stage);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为中间层是在远景层 &lt;strong&gt;之后&lt;/strong&gt; 加入的，所以它离我们更进，或者说有更高的层深度。也就是说每次调用 addChild() 方法添加的展示对象都会在上一次添加的对象之上。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我们在这一节的教程中将只会聚焦到远景层和中间层的展示，后面的几节中，我们会实现更复杂的前景层&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;主循环&#34;&gt;主循环&lt;/h2&gt;

&lt;p&gt;现在我们有两个背景图层，我想我们可以尝试实现一些视差滚动，并且还可以找到一种渲染内容的方法，而不用从 JavaScript 控制台中手动执行。&lt;/p&gt;

&lt;p&gt;为了避免疑惑，让我们快速解释下究竟是什么视差滚动。这是一种用于视频游戏的滚动技术，其中背景层在屏幕上移动的速度比前景层慢。这样做会在2D游戏中产生一种幻觉，并让玩家更有沉浸感（更真实）。&lt;/p&gt;

&lt;p&gt;根据上面这些信息，我们可以将它应用于我们的两个精灵层，来生成一个水平视差滚动器，我们将背景层移动到屏幕上的速度比中间层慢一点。为了能让每个层都滚动，我们将创建一个主循环，我们可以不断改变每个层的位置。为了实现这一点，我们将使用 &lt;code&gt;requestAnimationFrame()&lt;/code&gt; 的帮助，这是一个 JavaScript 函数，它能决定浏览器的最佳帧速率，然后在下一次重绘 canvas/stage 时调用指定的函数。我们还将使用这个主循环来 &lt;strong&gt;不断地&lt;/strong&gt; 呈现我们的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var midTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;);
mid = new PIXI.Sprite(midTexture);
mid.position.x = 0;
mid.position.y = 128;
stage.addChild(mid);

renderer.render(stage);

requestAnimationFrame(update);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码，我们指定了一个 update 函数，如果你想连续调用 &lt;code&gt;requestAnimationFrame()&lt;/code&gt; ，这将使得你的 update 方法每秒调用 60 次。或者通常称为每秒 60 帧（FPS）。&lt;/p&gt;

&lt;p&gt;我们还没有 update 函数，但是在实现它之前，先删除渲染方法的调用，因为主循环中会处理这个逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var midTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;);
mid = new PIXI.Sprite(midTexture);
mid.position.x = 0;
mid.position.y = 128;
stage.addChild(mid);

renderer.render(stage); // 删除它

requestAnimationFrame(update);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好吧，让我们来编写主循环并让它稍微改变两个层的位置，然后渲染舞台的内容，这样我们就可以看到每个帧重绘的差异。在 &lt;code&gt;init()&lt;/code&gt; 函数之后直接添加 &lt;code&gt;update()&lt;/code&gt; 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.position.x -= 0.128;
  mid.position.x -= 0.64;

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前两行代码更新了远景层和中间层精灵的水平位置。请注意，我们将远层向左移动0.128 像素，而我们将中间层向左移动 0.64 像素。要向左移动某些东西，我们得使用负值，而正值则会将其移动到右侧。另外请注意，我们将精灵移动了 &lt;strong&gt;小数&lt;/strong&gt; 像素。 Pixi 的渲染器可以存储它们并使用子像素来处理它们位置。当你想要非常缓慢地在屏幕上轻推东西时，这是理想的选择。&lt;/p&gt;

&lt;p&gt;在循环结束时，我们再次调用 &lt;code&gt;requestAnimationFrame()&lt;/code&gt; 函数，以确保在下次再次绘制画布时自动再次调用 &lt;code&gt;update()&lt;/code&gt;。正是它确保了我们的主循环被连续调用，从而能确保我们的视差层在屏幕上稳定移动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img14.360buyimg.com/devfe/jfs/t1/25862/18/10942/84129/5c8b2631E9323cbf6/487b26b72c59b787.png&#34; alt=&#34;ps-tut1-screenshot5&#34; /&gt;&lt;/p&gt;

&lt;p&gt;保存代码并刷新浏览器看看它长什么样子。你应该看到两个图层自动呈现在屏幕上。此外，当两个图层都在移动时，中间层实际上比远景层更快地移动，从而为场景提供深度感。但是你也应该发现有一个明显问题：当每个精灵移出屏幕的左侧时，它会向右边留下一个间隙。换句话说，两个图层的图形都没有循环，以给出连续滚动的错觉。还好，有一个解决方案。&lt;/p&gt;

&lt;h2 id=&#34;使用瓦片-平铺-精灵&#34;&gt;使用瓦片（平铺）精灵&lt;/h2&gt;

&lt;p&gt;到目前为止，我们已经学会使用 &lt;code&gt;PIXI.Sprite&lt;/code&gt; 类来表示展示列表中的对象。然而，pixi.js 还提供了几个其他 &lt;strong&gt;展示对象&lt;/strong&gt; 以满足不同的需求。&lt;/p&gt;

&lt;p&gt;如果你细心的观察一下 bg-far.png 和 bg-mid.png 的话，你应该注意到这两个图像都设计成可以水平平铺的（译：平铺就好比瓦片）。检查每个图像的左右边缘。你可以发现，最右边的边缘完美地匹配连接到最左边的边缘。换句话说，两个图像都被设计成无缝循环的。&lt;/p&gt;

&lt;p&gt;因此，如果有一种方法可以简单地移动每个精灵的纹理以给出他们正在移动的错觉，而不是物理地移动我们的远景层和中间层精灵的位置，这不是很好吗？值得庆幸的是 pixi.js 提供了 PIXI.extras.TilingSprite 类，它就是用来做这个的。&lt;/p&gt;

&lt;p&gt;所以，让我们对代码进行一些调整，来使用瓦片精灵。我们首先关注远景层。继续从建立函数中删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);
far = new PIXI.Sprite(farTexture); // 删除它
far.position.x = 0;
far.position.y = 0;
stage.addChild(far);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new PIXI.extras.TilingSprite(farTexture, 512, 256);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后设置他们的位置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far.tilePosition.x = 0;
far.tilePosition.y = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在继续之前，让我们讨论 TilingSprite 类的构造函数及它的 tilePosition 属性。&lt;/p&gt;

&lt;p&gt;和 Sprite 类的单个参数比较，您会注意到 TilingSprite 类的构造函数需要 3 个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new PIXI.extras.TilingSprite(farTexture, 512, 256);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的第一个参数与之前相同：纹理的引用。第二个和第三个参数分别表示瓦片精灵的宽度和高度。通常，将这两个参数设置为 &lt;strong&gt;纹理&lt;/strong&gt; 的宽度和高度，比如 &lt;code&gt;bg-far.png&lt;/code&gt; 为 512 x 256 像素。&lt;/p&gt;

&lt;p&gt;我们又一次的硬编码的传入了两个宽高参数，可以通过下面的方法改善：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far = new PIXI.extras.TilingSprite(
  farTexture,
  farTexture.baseTexture.width,
  farTexture.baseTexture.height
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还利用了平铺精灵的 tilePosition 属性，该属性用于偏移精灵纹理的位置。换句话说，通过调整偏移量，就可以水平或垂直地移动纹理，并使纹理环绕。本质上，你可以模拟滚动而无需实际更改精灵的位置。&lt;/p&gt;

&lt;p&gt;我们将精灵的 tilePosition 属性默认设置为（0,0），这意味着远景层的外观在初始化的状态下没有变化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;far.tilePosition.x = 0;
far.tilePosition.y = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;剩下要做的就是通过不断更新精灵的 tilePosition 属性的水平偏移来模拟滚动。为此，我们将对 &lt;code&gt;update()&lt;/code&gt; 函数进行更改。首先删除以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.position.x -= 0.128; // 删除它
  mid.position.x -= 0.64;

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换成下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.tilePosition.x -= 0.128;
  mid.position.x -= 0.64;

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在保存 index.html 并再次刷新浏览器。你将看到远景层无缝滚动并一直重复着，这和我们的预期结果的一样。&lt;/p&gt;

&lt;p&gt;好的，让我们继续为中间层做出相同的修改。以下是进行更改后 &lt;code&gt;init()&lt;/code&gt; 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function init() {
  stage = new PIXI.Container();
  renderer = PIXI.autoDetectRenderer(
    512,
    384,
    {view:document.getElementById(&amp;quot;game-canvas&amp;quot;)}
  );

  var farTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-far.png&amp;quot;);	
  far = new PIXI.extras.TilingSprite(farTexture, 512, 256);
  far.position.x = 0;
  far.position.y = 0;
  far.tilePosition.x = 0;
  far.tilePosition.y = 0;
  stage.addChild(far);

  var midTexture = PIXI.Texture.fromImage(&amp;quot;resources/bg-mid.png&amp;quot;);
  mid = new PIXI.extras.TilingSprite(midTexture, 512, 256);
  mid.position.x = 0;
  mid.position.y = 128;
  mid.tilePosition.x = 0;
  mid.tilePosition.y = 0;
  stage.addChild(mid);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在继续对 &lt;code&gt;update()&lt;/code&gt; 函数进行以下重构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function update() {
  far.tilePosition.x -= 0.128;
  mid.tilePosition.x -= 0.64;

  renderer.render(stage);

  requestAnimationFrame(update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存并测试你的代码。这次你应该看到两个图层完全地滚动，同时环绕屏幕的左右边界。&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;我们已经介绍了pixi.js 的一些基础知识，并了解了 &lt;code&gt;PIXI.extras.TilingSprite&lt;/code&gt; 如何用于创建无限滚动图层的。我们还看到了如何使用 &lt;code&gt;addChild()&lt;/code&gt; 将瓦片精灵堆叠在一起以产生真实的视差滚动。&lt;/p&gt;

&lt;p&gt;我建议你继续尝试使用 Pixi 并查看它的文档和代码示例。两者都可以在 PixiJS &lt;a href=&#34;http://www.pixijs.com/&#34;&gt;官方网站&lt;/a&gt; 上找到。&lt;/p&gt;

&lt;h2 id=&#34;下集预告&#34;&gt;下集预告…&lt;/h2&gt;

&lt;p&gt;虽然我们有一个水平视差滚动器并且能运行起来，但它仍然有点简单。下次我们将介绍 &lt;strong&gt;视口&lt;/strong&gt; 和 &lt;strong&gt;世界&lt;/strong&gt; 位置的概念，如果你想最终将你的卷轴添加到游戏中，这两个都很重要。它还将使我们处于添加前景层的良好位置，这将代表一个简单的平台游戏地图。&lt;/p&gt;

&lt;p&gt;我们将花很多时间来重构现有的代码库。我们将采用更加面向对象的架构，摆脱目前对全局变量的依赖。在下一个教程结束时，所有滚动功能都将整齐地包含在一个类中。&lt;/p&gt;

&lt;p&gt;我希望这个教程能帮助到你，也希望下次能在 &lt;strong&gt;第二部分&lt;/strong&gt; 中见到你。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>